/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./node_modules/mocha-loader/index.js!./test/index.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/babel-loader/lib/index.js!./test/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/babel-loader/lib!./test/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/***/ }),

/***/ "./node_modules/mocha-loader/index.js!./test/index.js":
/*!***************************************************!*\
  !*** ./node_modules/mocha-loader!./test/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/mocha-loader/web.js */ "./node_modules/mocha-loader/web.js");
if(typeof window !== 'undefined' && window.initMochaPhantomJS) { window.initMochaPhantomJS(); }
mocha.setup({"ui":"bdd"});
__webpack_require__(/*! !./node_modules/babel-loader/lib!./test/index.js */ "./node_modules/babel-loader/lib/index.js!./test/index.js")
__webpack_require__(/*! !./node_modules/mocha-loader/start.js */ "./node_modules/mocha-loader/start.js");
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!******************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \******************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__(/*! ../mocha-loader/node_modules/css-loader/lib/css-base.js */ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js")(false);
// imports


// module
exports.push([module.i, "@charset \"utf-8\";\n\nbody {\n  margin:0;\n}\n\n#mocha {\n  font: 20px/1.5 \"Helvetica Neue\", Helvetica, Arial, sans-serif;\n  margin: 60px 50px;\n}\n\n#mocha ul,\n#mocha li {\n  margin: 0;\n  padding: 0;\n}\n\n#mocha ul {\n  list-style: none;\n}\n\n#mocha h1,\n#mocha h2 {\n  margin: 0;\n}\n\n#mocha h1 {\n  margin-top: 15px;\n  font-size: 1em;\n  font-weight: 200;\n}\n\n#mocha h1 a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha h1 a:hover {\n  text-decoration: underline;\n}\n\n#mocha .suite .suite h1 {\n  margin-top: 0;\n  font-size: .8em;\n}\n\n#mocha .hidden {\n  display: none;\n}\n\n#mocha h2 {\n  font-size: 12px;\n  font-weight: normal;\n  cursor: pointer;\n}\n\n#mocha .suite {\n  margin-left: 15px;\n}\n\n#mocha .test {\n  margin-left: 15px;\n  overflow: hidden;\n}\n\n#mocha .test.pending:hover h2::after {\n  content: '(pending)';\n  font-family: arial, sans-serif;\n}\n\n#mocha .test.pass.medium .duration {\n  background: #c09853;\n}\n\n#mocha .test.pass.slow .duration {\n  background: #b94a48;\n}\n\n#mocha .test.pass::before {\n  content: '\\2713';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #00d6b2;\n}\n\n#mocha .test.pass .duration {\n  font-size: 9px;\n  margin-left: 5px;\n  padding: 2px 5px;\n  color: #fff;\n  -webkit-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -moz-box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  box-shadow: inset 0 1px 1px rgba(0,0,0,.2);\n  -webkit-border-radius: 5px;\n  -moz-border-radius: 5px;\n  -ms-border-radius: 5px;\n  -o-border-radius: 5px;\n  border-radius: 5px;\n}\n\n#mocha .test.pass.fast .duration {\n  display: none;\n}\n\n#mocha .test.pending {\n  color: #0b97c4;\n}\n\n#mocha .test.pending::before {\n  content: '\\25E6';\n  color: #0b97c4;\n}\n\n#mocha .test.fail {\n  color: #c00;\n}\n\n#mocha .test.fail pre {\n  color: black;\n}\n\n#mocha .test.fail::before {\n  content: '\\2716';\n  font-size: 12px;\n  display: block;\n  float: left;\n  margin-right: 5px;\n  color: #c00;\n}\n\n#mocha .test pre.error {\n  color: #c00;\n  max-height: 300px;\n  overflow: auto;\n}\n\n#mocha .test .html-error {\n  overflow: auto;\n  color: black;\n  line-height: 1.5;\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  max-height: 300px;\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test .html-error pre.error {\n  border: none;\n  -webkit-border-radius: 0;\n  -moz-border-radius: 0;\n  border-radius: 0;\n  -webkit-box-shadow: 0;\n  -moz-box-shadow: 0;\n  box-shadow: 0;\n  padding: 0;\n  margin: 0;\n  margin-top: 18px;\n  max-height: none;\n}\n\n/**\n * (1): approximate for browsers not supporting calc\n * (2): 42 = 2*15 + 2*10 + 2*1 (padding + margin + border)\n *      ^^ seriously\n */\n#mocha .test pre {\n  display: block;\n  float: left;\n  clear: left;\n  font: 12px/1.5 monaco, monospace;\n  margin: 5px;\n  padding: 15px;\n  border: 1px solid #eee;\n  max-width: 85%; /*(1)*/\n  max-width: -webkit-calc(100% - 42px);\n  max-width: -moz-calc(100% - 42px);\n  max-width: calc(100% - 42px); /*(2)*/\n  word-wrap: break-word;\n  border-bottom-color: #ddd;\n  -webkit-box-shadow: 0 1px 3px #eee;\n  -moz-box-shadow: 0 1px 3px #eee;\n  box-shadow: 0 1px 3px #eee;\n  -webkit-border-radius: 3px;\n  -moz-border-radius: 3px;\n  border-radius: 3px;\n}\n\n#mocha .test h2 {\n  position: relative;\n}\n\n#mocha .test a.replay {\n  position: absolute;\n  top: 3px;\n  right: 0;\n  text-decoration: none;\n  vertical-align: middle;\n  display: block;\n  width: 15px;\n  height: 15px;\n  line-height: 15px;\n  text-align: center;\n  background: #eee;\n  font-size: 15px;\n  -webkit-border-radius: 15px;\n  -moz-border-radius: 15px;\n  border-radius: 15px;\n  -webkit-transition:opacity 200ms;\n  -moz-transition:opacity 200ms;\n  -o-transition:opacity 200ms;\n  transition: opacity 200ms;\n  opacity: 0.3;\n  color: #888;\n}\n\n#mocha .test:hover a.replay {\n  opacity: 1;\n}\n\n#mocha-report.pass .test.fail {\n  display: none;\n}\n\n#mocha-report.fail .test.pass {\n  display: none;\n}\n\n#mocha-report.pending .test.pass,\n#mocha-report.pending .test.fail {\n  display: none;\n}\n#mocha-report.pending .test.pass.pending {\n  display: block;\n}\n\n#mocha-error {\n  color: #c00;\n  font-size: 1.5em;\n  font-weight: 100;\n  letter-spacing: 1px;\n}\n\n#mocha-stats {\n  position: fixed;\n  top: 15px;\n  right: 10px;\n  font-size: 12px;\n  margin: 0;\n  color: #888;\n  z-index: 1;\n}\n\n#mocha-stats .progress {\n  float: right;\n  padding-top: 0;\n\n  /**\n   * Set safe initial values, so mochas .progress does not inherit these\n   * properties from Bootstrap .progress (which causes .progress height to\n   * equal line height set in Bootstrap).\n   */\n  height: auto;\n  -webkit-box-shadow: none;\n  -moz-box-shadow: none;\n  box-shadow: none;\n  background-color: initial;\n}\n\n#mocha-stats em {\n  color: black;\n}\n\n#mocha-stats a {\n  text-decoration: none;\n  color: inherit;\n}\n\n#mocha-stats a:hover {\n  border-bottom: 1px solid #eee;\n}\n\n#mocha-stats li {\n  display: inline-block;\n  margin: 0 5px;\n  list-style: none;\n  padding-top: 11px;\n}\n\n#mocha-stats canvas {\n  width: 40px;\n  height: 40px;\n}\n\n#mocha code .comment { color: #ddd; }\n#mocha code .init { color: #2f6fad; }\n#mocha code .string { color: #5890ad; }\n#mocha code .keyword { color: #8a6343; }\n#mocha code .number { color: #2f6fad; }\n\n@media screen and (max-device-width: 480px) {\n  #mocha {\n    margin: 60px 0px;\n  }\n\n  #mocha #stats {\n    position: absolute;\n  }\n}\n", ""]);

// exports


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js":
/*!***************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/css-loader/lib/css-base.js ***!
  \***************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function(useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if(item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function(modules, mediaQuery) {
		if(typeof modules === "string")
			modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for(var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if(typeof id === "number")
				alreadyImportedModules[id] = true;
		}
		for(i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if(typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if(mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if(mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */'
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css":
/*!************************************************************************************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader!./node_modules/mocha-loader/node_modules/css-loader!./node_modules/mocha/mocha.css ***!
  \************************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__(/*! !../mocha-loader/node_modules/css-loader!./mocha.css */ "./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {"hmr":true}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__(/*! ../mocha-loader/node_modules/style-loader/lib/addStyles.js */ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {}

/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js":
/*!******************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/addStyles.js ***!
  \******************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			var styleTarget = fn.call(this, selector);
			// Special case to return head of iframe instead of iframe itself
			if (styleTarget instanceof window.HTMLIFrameElement) {
				try {
					// This will throw an exception if access to iframe is blocked
					// due to cross-origin restrictions
					styleTarget = styleTarget.contentDocument.head;
				} catch(e) {
					styleTarget = null;
				}
			}
			memo[selector] = styleTarget;
		}
		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__(/*! ./urls */ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton && typeof options.singleton !== "boolean") options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else if (typeof options.insertAt === "object" && options.insertAt.before) {
		var nextSibling = getElement(options.insertInto + " " + options.insertAt.before);
		target.insertBefore(style, nextSibling);
	} else {
		throw new Error("[Style Loader]\n\n Invalid value for parameter 'insertAt' ('options.insertAt') found.\n Must be 'top', 'bottom', or Object.\n (https://github.com/webpack-contrib/style-loader#insertat)\n");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js":
/*!*************************************************************************!*\
  !*** ./node_modules/mocha-loader/node_modules/style-loader/lib/urls.js ***!
  \*************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
  // get current location
  var location = typeof window !== "undefined" && window.location;

  if (!location) {
    throw new Error("fixUrls requires window.location");
  }

	// blank or null?
	if (!css || typeof css !== "string") {
	  return css;
  }

  var baseUrl = location.protocol + "//" + location.host;
  var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
	This regular expression is just a way to recursively match brackets within
	a string.

	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
	   (  = Start a capturing group
	     (?:  = Start a non-capturing group
	         [^)(]  = Match anything that isn't a parentheses
	         |  = OR
	         \(  = Match a start parentheses
	             (?:  = Start another non-capturing groups
	                 [^)(]+  = Match anything that isn't a parentheses
	                 |  = OR
	                 \(  = Match a start parentheses
	                     [^)(]*  = Match anything that isn't a parentheses
	                 \)  = Match a end parentheses
	             )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
	 \)  = Match a close parens

	 /gi  = Get all matches, not the first.  Be case insensitive.
	 */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function(fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl
			.trim()
			.replace(/^"(.*)"$/, function(o, $1){ return $1; })
			.replace(/^'(.*)'$/, function(o, $1){ return $1; });

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
		  return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
		  	//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};


/***/ }),

/***/ "./node_modules/mocha-loader/start.js":
/*!********************************************!*\
  !*** ./node_modules/mocha-loader/start.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {process.nextTick(function() {
	delete __webpack_require__.c[module.i];
	if(typeof window !== "undefined" && window.mochaPhantomJS)
		mochaPhantomJS.run();
	else
		mocha.run();
});

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../process/browser.js */ "./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/mocha-loader/web.js":
/*!******************************************!*\
  !*** ./node_modules/mocha-loader/web.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

if (! document.getElementById("mocha")) { document.write("<div id=\"mocha\"></div>"); }

__webpack_require__(/*! style-loader!css-loader!mocha/mocha.css */ "./node_modules/mocha-loader/node_modules/style-loader/index.js!./node_modules/mocha-loader/node_modules/css-loader/index.js!./node_modules/mocha/mocha.css");
__webpack_require__(/*! script-loader!mocha/mocha.js */ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js");


/***/ }),

/***/ "./node_modules/process/browser.js":
/*!*****************************************!*\
  !*** ./node_modules/process/browser.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js":
/*!***************************************************************!*\
  !*** ./node_modules/raw-loader!./node_modules/mocha/mocha.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = "(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/* eslint no-unused-vars: off */\n/* eslint-env commonjs */\n\n/**\n * Shim process.stdout.\n */\n\nprocess.stdout = require('browser-stdout')({level: false});\n\nvar Mocha = require('./lib/mocha');\n\n/**\n * Create a Mocha instance.\n *\n * @return {undefined}\n */\n\nvar mocha = new Mocha({ reporter: 'html' });\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n\nvar uncaughtExceptionHandlers = [];\n\nvar originalOnerrorHandler = global.onerror;\n\n/**\n * Remove uncaughtException listener.\n * Revert to original onerror handler if previously defined.\n */\n\nprocess.removeListener = function (e, fn) {\n  if (e === 'uncaughtException') {\n    if (originalOnerrorHandler) {\n      global.onerror = originalOnerrorHandler;\n    } else {\n      global.onerror = function () {};\n    }\n    var i = uncaughtExceptionHandlers.indexOf(fn);\n    if (i !== -1) {\n      uncaughtExceptionHandlers.splice(i, 1);\n    }\n  }\n};\n\n/**\n * Implements uncaughtException listener.\n */\n\nprocess.on = function (e, fn) {\n  if (e === 'uncaughtException') {\n    global.onerror = function (err, url, line) {\n      fn(new Error(err + ' (' + url + ':' + line + ')'));\n      return !mocha.allowUncaught;\n    };\n    uncaughtExceptionHandlers.push(fn);\n  }\n};\n\n// The BDD UI is registered by default, but no UI will be functional in the\n// browser without an explicit call to the overridden `mocha.ui` (see below).\n// Ensure that this default UI does not expose its methods to the global scope.\nmocha.suite.removeAllListeners('pre-require');\n\nvar immediateQueue = [];\nvar immediateTimeout;\n\nfunction timeslice () {\n  var immediateStart = new Date().getTime();\n  while (immediateQueue.length && (new Date().getTime() - immediateStart) < 100) {\n    immediateQueue.shift()();\n  }\n  if (immediateQueue.length) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  } else {\n    immediateTimeout = null;\n  }\n}\n\n/**\n * High-performance override of Runner.immediately.\n */\n\nMocha.Runner.immediately = function (callback) {\n  immediateQueue.push(callback);\n  if (!immediateTimeout) {\n    immediateTimeout = setTimeout(timeslice, 0);\n  }\n};\n\n/**\n * Function to allow assertion libraries to throw errors directly into mocha.\n * This is useful when running tests in a browser because window.onerror will\n * only receive the 'message' attribute of the Error.\n */\nmocha.throwError = function (err) {\n  uncaughtExceptionHandlers.forEach(function (fn) {\n    fn(err);\n  });\n  throw err;\n};\n\n/**\n * Override ui to ensure that the ui functions are initialized.\n * Normally this would happen in Mocha.prototype.loadFiles.\n */\n\nmocha.ui = function (ui) {\n  Mocha.prototype.ui.call(this, ui);\n  this.suite.emit('pre-require', global, null, this);\n  return this;\n};\n\n/**\n * Setup mocha with the given setting options.\n */\n\nmocha.setup = function (opts) {\n  if (typeof opts === 'string') {\n    opts = { ui: opts };\n  }\n  for (var opt in opts) {\n    if (opts.hasOwnProperty(opt)) {\n      this[opt](opts[opt]);\n    }\n  }\n  return this;\n};\n\n/**\n * Run mocha, returning the Runner.\n */\n\nmocha.run = function (fn) {\n  var options = mocha.options;\n  mocha.globals('location');\n\n  var query = Mocha.utils.parseQuery(global.location.search || '');\n  if (query.grep) {\n    mocha.grep(query.grep);\n  }\n  if (query.fgrep) {\n    mocha.fgrep(query.fgrep);\n  }\n  if (query.invert) {\n    mocha.invert();\n  }\n\n  return Mocha.prototype.run.call(mocha, function (err) {\n    // The DOM Document is not available in Web Workers.\n    var document = global.document;\n    if (document && document.getElementById('mocha') && options.noHighlighting !== true) {\n      Mocha.utils.highlightTags('code');\n    }\n    if (fn) {\n      fn(err);\n    }\n  });\n};\n\n/**\n * Expose the process shim.\n * https://github.com/mochajs/mocha/pull/916\n */\n\nMocha.process = process;\n\n/**\n * Expose mocha.\n */\n\nglobal.Mocha = Mocha;\nglobal.mocha = mocha;\n\n// this allows test/acceptance/required-tokens.js to pass; thus,\n// you can now do `const describe = require('mocha').describe` in a\n// browser context (assuming browserification).  should fix #880\nmodule.exports = global;\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./lib/mocha\":13,\"_process\":56,\"browser-stdout\":39}],2:[function(require,module,exports){\n'use strict';\n\n// just stub out growl\n\nmodule.exports = require('../utils').noop;\n\n},{\"../utils\":36}],3:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Progress`.\n */\n\nmodule.exports = Progress;\n\n/**\n * Initialize a new `Progress` indicator.\n */\nfunction Progress () {\n  this.percent = 0;\n  this.size(0);\n  this.fontSize(11);\n  this.font('helvetica, arial, sans-serif');\n}\n\n/**\n * Set progress size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.size = function (size) {\n  this._size = size;\n  return this;\n};\n\n/**\n * Set text to `text`.\n *\n * @api public\n * @param {string} text\n * @return {Progress} Progress instance.\n */\nProgress.prototype.text = function (text) {\n  this._text = text;\n  return this;\n};\n\n/**\n * Set font size to `size`.\n *\n * @api public\n * @param {number} size\n * @return {Progress} Progress instance.\n */\nProgress.prototype.fontSize = function (size) {\n  this._fontSize = size;\n  return this;\n};\n\n/**\n * Set font to `family`.\n *\n * @param {string} family\n * @return {Progress} Progress instance.\n */\nProgress.prototype.font = function (family) {\n  this._font = family;\n  return this;\n};\n\n/**\n * Update percentage to `n`.\n *\n * @param {number} n\n * @return {Progress} Progress instance.\n */\nProgress.prototype.update = function (n) {\n  this.percent = n;\n  return this;\n};\n\n/**\n * Draw on `ctx`.\n *\n * @param {CanvasRenderingContext2d} ctx\n * @return {Progress} Progress instance.\n */\nProgress.prototype.draw = function (ctx) {\n  try {\n    var percent = Math.min(this.percent, 100);\n    var size = this._size;\n    var half = size / 2;\n    var x = half;\n    var y = half;\n    var rad = half - 1;\n    var fontSize = this._fontSize;\n\n    ctx.font = fontSize + 'px ' + this._font;\n\n    var angle = Math.PI * 2 * (percent / 100);\n    ctx.clearRect(0, 0, size, size);\n\n    // outer circle\n    ctx.strokeStyle = '#9f9f9f';\n    ctx.beginPath();\n    ctx.arc(x, y, rad, 0, angle, false);\n    ctx.stroke();\n\n    // inner circle\n    ctx.strokeStyle = '#eee';\n    ctx.beginPath();\n    ctx.arc(x, y, rad - 1, 0, angle, true);\n    ctx.stroke();\n\n    // text\n    var text = this._text || (percent | 0) + '%';\n    var w = ctx.measureText(text).width;\n\n    ctx.fillText(text, x - w / 2 + 1, y + fontSize / 2 - 1);\n  } catch (err) {\n    // don't fail if we can't render progress\n  }\n  return this;\n};\n\n},{}],4:[function(require,module,exports){\n(function (global){\n'use strict';\n\nexports.isatty = function isatty () {\n  return true;\n};\n\nexports.getWindowSize = function getWindowSize () {\n  if ('innerHeight' in global) {\n    return [global.innerHeight, global.innerWidth];\n  }\n  // In a Web Worker, the DOM Window is not available.\n  return [640, 480];\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],5:[function(require,module,exports){\n'use strict';\n/**\n * @module Context\n */\n/**\n * Expose `Context`.\n */\n\nmodule.exports = Context;\n\n/**\n * Initialize a new `Context`.\n *\n * @api private\n */\nfunction Context () {}\n\n/**\n * Set or get the context `Runnable` to `runnable`.\n *\n * @api private\n * @param {Runnable} runnable\n * @return {Context} context\n */\nContext.prototype.runnable = function (runnable) {\n  if (!arguments.length) {\n    return this._runnable;\n  }\n  this.test = this._runnable = runnable;\n  return this;\n};\n\n/**\n * Set or get test timeout `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().timeout();\n  }\n  this.runnable().timeout(ms);\n  return this;\n};\n\n/**\n * Set test timeout `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Context} self\n */\nContext.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this.runnable().enableTimeouts();\n  }\n  this.runnable().enableTimeouts(enabled);\n  return this;\n};\n\n/**\n * Set or get test slowness threshold `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {Context} self\n */\nContext.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this.runnable().slow();\n  }\n  this.runnable().slow(ms);\n  return this;\n};\n\n/**\n * Mark a test as skipped.\n *\n * @api private\n * @throws Pending\n */\nContext.prototype.skip = function () {\n  this.runnable().skip();\n};\n\n/**\n * Set or get a number of allowed retries on failed tests\n *\n * @api private\n * @param {number} n\n * @return {Context} self\n */\nContext.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this.runnable().retries();\n  }\n  this.runnable().retries(n);\n  return this;\n};\n\n},{}],6:[function(require,module,exports){\n'use strict';\n/**\n * @module Hook\n *\n */\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar inherits = require('./utils').inherits;\n\n/**\n * Expose `Hook`.\n */\n\nmodule.exports = Hook;\n\n/**\n * Initialize a new `Hook` with the given `title` and callback `fn`. Derived from\n * `Runnable`.\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n * @api private\n */\nfunction Hook (title, fn) {\n  Runnable.call(this, title, fn);\n  this.type = 'hook';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\ninherits(Hook, Runnable);\n\n/**\n * Get or set the test `err`.\n *\n * @memberof Mocha.Hook\n * @public\n * @param {Error} err\n * @return {Error}\n * @api public\n */\nHook.prototype.error = function (err) {\n  if (!arguments.length) {\n    err = this._error;\n    this._error = null;\n    return err;\n  }\n\n  this._error = err;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],7:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * BDD-style interface:\n *\n *      describe('Array', function() {\n *        describe('#indexOf()', function() {\n *          it('should return -1 when not present', function() {\n *            // ...\n *          });\n *\n *          it('should return the index when present', function() {\n *            // ...\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`\n     * and callback `fn` containing nested suites\n     * and/or tests.\n     */\n\n    context.describe = context.context = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending describe.\n     */\n\n    context.xdescribe = context.xcontext = context.describe.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive suite.\n     */\n\n    context.describe.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.it = context.specify = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.it.only = function (title, fn) {\n      return common.test.only(mocha, context.it(title, fn));\n    };\n\n    /**\n     * Pending test case.\n     */\n\n    context.xit = context.xspecify = context.it.skip = function (title) {\n      return context.it(title);\n    };\n\n    /**\n     * Number of attempts to retry.\n     */\n    context.it.retries = function (n) {\n      context.retries(n);\n    };\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],8:[function(require,module,exports){\n'use strict';\n\nvar Suite = require('../suite');\n\n/**\n * Functions common to more than one interface.\n *\n * @param {Suite[]} suites\n * @param {Context} context\n * @param {Mocha} mocha\n * @return {Object} An object containing common functions.\n */\nmodule.exports = function (suites, context, mocha) {\n  return {\n    /**\n     * This is only present if flag --delay is passed into Mocha. It triggers\n     * root suite execution.\n     *\n     * @param {Suite} suite The root suite.\n     * @return {Function} A function which runs the root suite\n     */\n    runWithSuite: function runWithSuite (suite) {\n      return function run () {\n        suite.run();\n      };\n    },\n\n    /**\n     * Execute before running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    before: function (name, fn) {\n      suites[0].beforeAll(name, fn);\n    },\n\n    /**\n     * Execute after running tests.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    after: function (name, fn) {\n      suites[0].afterAll(name, fn);\n    },\n\n    /**\n     * Execute before each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    beforeEach: function (name, fn) {\n      suites[0].beforeEach(name, fn);\n    },\n\n    /**\n     * Execute after each test case.\n     *\n     * @param {string} name\n     * @param {Function} fn\n     */\n    afterEach: function (name, fn) {\n      suites[0].afterEach(name, fn);\n    },\n\n    suite: {\n      /**\n       * Create an exclusive Suite; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      only: function only (opts) {\n        opts.isOnly = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Create a Suite, but skip it; convenience function\n       * See docstring for create() below.\n       *\n       * @param {Object} opts\n       * @returns {Suite}\n       */\n      skip: function skip (opts) {\n        opts.pending = true;\n        return this.create(opts);\n      },\n\n      /**\n       * Creates a suite.\n       * @param {Object} opts Options\n       * @param {string} opts.title Title of Suite\n       * @param {Function} [opts.fn] Suite Function (not always applicable)\n       * @param {boolean} [opts.pending] Is Suite pending?\n       * @param {string} [opts.file] Filepath where this Suite resides\n       * @param {boolean} [opts.isOnly] Is Suite exclusive?\n       * @returns {Suite}\n       */\n      create: function create (opts) {\n        var suite = Suite.create(suites[0], opts.title);\n        suite.pending = Boolean(opts.pending);\n        suite.file = opts.file;\n        suites.unshift(suite);\n        if (opts.isOnly) {\n          suite.parent._onlySuites = suite.parent._onlySuites.concat(suite);\n        }\n        if (typeof opts.fn === 'function') {\n          opts.fn.call(suite);\n          suites.shift();\n        } else if (typeof opts.fn === 'undefined' && !suite.pending) {\n          throw new Error('Suite \"' + suite.fullTitle() + '\" was defined but no callback was supplied. Supply a callback or explicitly skip the suite.');\n        } else if (!opts.fn && suite.pending) {\n          suites.shift();\n        }\n\n        return suite;\n      }\n    },\n\n    test: {\n\n      /**\n       * Exclusive test-case.\n       *\n       * @param {Object} mocha\n       * @param {Function} test\n       * @returns {*}\n       */\n      only: function (mocha, test) {\n        test.parent._onlyTests = test.parent._onlyTests.concat(test);\n        return test;\n      },\n\n      /**\n       * Pending test case.\n       *\n       * @param {string} title\n       */\n      skip: function (title) {\n        context.test(title);\n      },\n\n      /**\n       * Number of retry attempts\n       *\n       * @param {number} n\n       */\n      retries: function (n) {\n        context.retries(n);\n      }\n    }\n  };\n};\n\n},{\"../suite\":34}],9:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Suite = require('../suite');\nvar Test = require('../test');\n\n/**\n * Exports-style (as Node.js module) interface:\n *\n *     exports.Array = {\n *       '#indexOf()': {\n *         'should return -1 when the value is not present': function() {\n *\n *         },\n *\n *         'should return the correct index when the value is present': function() {\n *\n *         }\n *       }\n *     };\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('require', visit);\n\n  function visit (obj, file) {\n    var suite;\n    for (var key in obj) {\n      if (typeof obj[key] === 'function') {\n        var fn = obj[key];\n        switch (key) {\n          case 'before':\n            suites[0].beforeAll(fn);\n            break;\n          case 'after':\n            suites[0].afterAll(fn);\n            break;\n          case 'beforeEach':\n            suites[0].beforeEach(fn);\n            break;\n          case 'afterEach':\n            suites[0].afterEach(fn);\n            break;\n          default:\n            var test = new Test(key, fn);\n            test.file = file;\n            suites[0].addTest(test);\n        }\n      } else {\n        suite = Suite.create(suites[0], key);\n        suites.unshift(suite);\n        visit(obj[key], file);\n        suites.shift();\n      }\n    }\n  }\n};\n\n},{\"../suite\":34,\"../test\":35}],10:[function(require,module,exports){\n'use strict';\n\nexports.bdd = require('./bdd');\nexports.tdd = require('./tdd');\nexports.qunit = require('./qunit');\nexports.exports = require('./exports');\n\n},{\"./bdd\":7,\"./exports\":9,\"./qunit\":11,\"./tdd\":12}],11:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * QUnit-style interface:\n *\n *     suite('Array');\n *\n *     test('#length', function() {\n *       var arr = [1,2,3];\n *       ok(arr.length == 3);\n *     });\n *\n *     test('#indexOf()', function() {\n *       var arr = [1,2,3];\n *       ok(arr.indexOf(1) == 0);\n *       ok(arr.indexOf(2) == 1);\n *       ok(arr.indexOf(3) == 2);\n *     });\n *\n *     suite('String');\n *\n *     test('#length', function() {\n *       ok('foo'.length == 3);\n *     });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.before = common.before;\n    context.after = common.after;\n    context.beforeEach = common.beforeEach;\n    context.afterEach = common.afterEach;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n    /**\n     * Describe a \"suite\" with the given `title`.\n     */\n\n    context.suite = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Exclusive Suite.\n     */\n\n    context.suite.only = function (title) {\n      if (suites.length > 1) {\n        suites.shift();\n      }\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: false\n      });\n    };\n\n    /**\n     * Describe a specification or test-case\n     * with the given `title` and callback `fn`\n     * acting as a thunk.\n     */\n\n    context.test = function (title, fn) {\n      var test = new Test(title, fn);\n      test.file = file;\n      suites[0].addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],12:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Test = require('../test');\n\n/**\n * TDD-style interface:\n *\n *      suite('Array', function() {\n *        suite('#indexOf()', function() {\n *          suiteSetup(function() {\n *\n *          });\n *\n *          test('should return -1 when not present', function() {\n *\n *          });\n *\n *          test('should return the index when present', function() {\n *\n *          });\n *\n *          suiteTeardown(function() {\n *\n *          });\n *        });\n *      });\n *\n * @param {Suite} suite Root suite.\n */\nmodule.exports = function (suite) {\n  var suites = [suite];\n\n  suite.on('pre-require', function (context, file, mocha) {\n    var common = require('./common')(suites, context, mocha);\n\n    context.setup = common.beforeEach;\n    context.teardown = common.afterEach;\n    context.suiteSetup = common.before;\n    context.suiteTeardown = common.after;\n    context.run = mocha.options.delay && common.runWithSuite(suite);\n\n    /**\n     * Describe a \"suite\" with the given `title` and callback `fn` containing\n     * nested suites and/or tests.\n     */\n    context.suite = function (title, fn) {\n      return common.suite.create({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Pending suite.\n     */\n    context.suite.skip = function (title, fn) {\n      return common.suite.skip({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n    context.suite.only = function (title, fn) {\n      return common.suite.only({\n        title: title,\n        file: file,\n        fn: fn\n      });\n    };\n\n    /**\n     * Describe a specification or test-case with the given `title` and\n     * callback `fn` acting as a thunk.\n     */\n    context.test = function (title, fn) {\n      var suite = suites[0];\n      if (suite.isPending()) {\n        fn = null;\n      }\n      var test = new Test(title, fn);\n      test.file = file;\n      suite.addTest(test);\n      return test;\n    };\n\n    /**\n     * Exclusive test-case.\n     */\n\n    context.test.only = function (title, fn) {\n      return common.test.only(mocha, context.test(title, fn));\n    };\n\n    context.test.skip = common.test.skip;\n    context.test.retries = common.test.retries;\n  });\n};\n\n},{\"../test\":35,\"./common\":8}],13:[function(require,module,exports){\n(function (process,global,__dirname){\n'use strict';\n\n/*!\n * mocha\n * Copyright(c) 2011 TJ Holowaychuk <tj@vision-media.ca>\n * MIT Licensed\n */\n/**\n * @namespace Mocha\n * @module Mocha\n */\n/**\n * Module dependencies.\n */\n\nvar escapeRe = require('escape-string-regexp');\nvar path = require('path');\nvar reporters = require('./reporters');\nvar utils = require('./utils');\n\n/**\n * Expose `Mocha`.\n */\n\nexports = module.exports = Mocha;\n\n/**\n * To require local UIs and reporters when running in node.\n */\n\nif (!process.browser) {\n  var cwd = process.cwd();\n  module.paths.push(cwd, path.join(cwd, 'node_modules'));\n}\n\n/**\n * Expose internals.\n */\n\n/**\n * @public\n * @class utils\n * @memberof Mocha\n */\nexports.utils = utils;\nexports.interfaces = require('./interfaces');\n/**\n *\n * @memberof Mocha\n * @public\n */\nexports.reporters = reporters;\nexports.Runnable = require('./runnable');\nexports.Context = require('./context');\n/**\n *\n * @memberof Mocha\n */\nexports.Runner = require('./runner');\nexports.Suite = require('./suite');\nexports.Hook = require('./hook');\nexports.Test = require('./test');\n\n/**\n * Return image `name` path.\n *\n * @api private\n * @param {string} name\n * @return {string}\n */\nfunction image (name) {\n  return path.join(__dirname, '../images', name + '.png');\n}\n\n/**\n * Set up mocha with `options`.\n *\n * Options:\n *\n *   - `ui` name \"bdd\", \"tdd\", \"exports\" etc\n *   - `reporter` reporter instance, defaults to `mocha.reporters.spec`\n *   - `globals` array of accepted globals\n *   - `timeout` timeout in milliseconds\n *   - `retries` number of times to retry failed tests\n *   - `bail` bail on the first test failure\n *   - `slow` milliseconds to wait before considering a test slow\n *   - `ignoreLeaks` ignore global leaks\n *   - `fullTrace` display the full stack-trace on failing\n *   - `grep` string or regexp to filter tests with\n *\n * @public\n * @class Mocha\n * @param {Object} options\n * @api public\n */\nfunction Mocha (options) {\n  options = options || {};\n  this.files = [];\n  this.options = options;\n  if (options.grep) {\n    this.grep(new RegExp(options.grep));\n  }\n  if (options.fgrep) {\n    this.fgrep(options.fgrep);\n  }\n  this.suite = new exports.Suite('', new exports.Context());\n  this.ui(options.ui);\n  this.bail(options.bail);\n  this.reporter(options.reporter, options.reporterOptions);\n  if (typeof options.timeout !== 'undefined' && options.timeout !== null) {\n    this.timeout(options.timeout);\n  }\n  if (typeof options.retries !== 'undefined' && options.retries !== null) {\n    this.retries(options.retries);\n  }\n  this.useColors(options.useColors);\n  if (options.enableTimeouts !== null) {\n    this.enableTimeouts(options.enableTimeouts);\n  }\n  if (options.slow) {\n    this.slow(options.slow);\n  }\n}\n\n/**\n * Enable or disable bailing on the first failure.\n *\n * @public\n * @api public\n * @param {boolean} [bail]\n */\nMocha.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    bail = true;\n  }\n  this.suite.bail(bail);\n  return this;\n};\n\n/**\n * Add test `file`.\n *\n * @public\n * @api public\n * @param {string} file\n */\nMocha.prototype.addFile = function (file) {\n  this.files.push(file);\n  return this;\n};\n\n/**\n * Set reporter to `reporter`, defaults to \"spec\".\n *\n * @public\n * @param {String|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n * @api public\n * @param {string|Function} reporter name or constructor\n * @param {Object} reporterOptions optional options\n */\nMocha.prototype.reporter = function (reporter, reporterOptions) {\n  if (typeof reporter === 'function') {\n    this._reporter = reporter;\n  } else {\n    reporter = reporter || 'spec';\n    var _reporter;\n    // Try to load a built-in reporter.\n    if (reporters[reporter]) {\n      _reporter = reporters[reporter];\n    }\n    // Try to load reporters from process.cwd() and node_modules\n    if (!_reporter) {\n      try {\n        _reporter = require(reporter);\n      } catch (err) {\n        if (err.message.indexOf('Cannot find module') !== -1) {\n          // Try to load reporters from a path (absolute or relative)\n          try {\n            _reporter = require(path.resolve(process.cwd(), reporter));\n          } catch (_err) {\n            err.message.indexOf('Cannot find module') !== -1 ? console.warn('\"' + reporter + '\" reporter not found')\n              : console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n          }\n        } else {\n          console.warn('\"' + reporter + '\" reporter blew up with error:\\n' + err.stack);\n        }\n      }\n    }\n    if (!_reporter && reporter === 'teamcity') {\n      console.warn('The Teamcity reporter was moved to a package named ' +\n        'mocha-teamcity-reporter ' +\n        '(https://npmjs.org/package/mocha-teamcity-reporter).');\n    }\n    if (!_reporter) {\n      throw new Error('invalid reporter \"' + reporter + '\"');\n    }\n    this._reporter = _reporter;\n  }\n  this.options.reporterOptions = reporterOptions;\n  return this;\n};\n\n/**\n * Set test UI `name`, defaults to \"bdd\".\n * @public\n * @api public\n * @param {string} bdd\n */\nMocha.prototype.ui = function (name) {\n  name = name || 'bdd';\n  this._ui = exports.interfaces[name];\n  if (!this._ui) {\n    try {\n      this._ui = require(name);\n    } catch (err) {\n      throw new Error('invalid interface \"' + name + '\"');\n    }\n  }\n  this._ui = this._ui(this.suite);\n\n  this.suite.on('pre-require', function (context) {\n    exports.afterEach = context.afterEach || context.teardown;\n    exports.after = context.after || context.suiteTeardown;\n    exports.beforeEach = context.beforeEach || context.setup;\n    exports.before = context.before || context.suiteSetup;\n    exports.describe = context.describe || context.suite;\n    exports.it = context.it || context.test;\n    exports.xit = context.xit || context.test.skip;\n    exports.setup = context.setup || context.beforeEach;\n    exports.suiteSetup = context.suiteSetup || context.before;\n    exports.suiteTeardown = context.suiteTeardown || context.after;\n    exports.suite = context.suite || context.describe;\n    exports.teardown = context.teardown || context.afterEach;\n    exports.test = context.test || context.it;\n    exports.run = context.run;\n  });\n\n  return this;\n};\n\n/**\n * Load registered files.\n *\n * @api private\n */\nMocha.prototype.loadFiles = function (fn) {\n  var self = this;\n  var suite = this.suite;\n  this.files.forEach(function (file) {\n    file = path.resolve(file);\n    suite.emit('pre-require', global, file, self);\n    suite.emit('require', require(file), file, self);\n    suite.emit('post-require', global, file, self);\n  });\n  fn && fn();\n};\n\n/**\n * Enable growl support.\n *\n * @api private\n */\nMocha.prototype._growl = function (runner, reporter) {\n  var notify = require('growl');\n\n  runner.on('end', function () {\n    var stats = reporter.stats;\n    if (stats.failures) {\n      var msg = stats.failures + ' of ' + runner.total + ' tests failed';\n      notify(msg, { name: 'mocha', title: 'Failed', image: image('error') });\n    } else {\n      notify(stats.passes + ' tests passed in ' + stats.duration + 'ms', {\n        name: 'mocha',\n        title: 'Passed',\n        image: image('ok')\n      });\n    }\n  });\n};\n\n/**\n * Escape string and add it to grep as a regexp.\n *\n * @public\n * @api public\n * @param str\n * @returns {Mocha}\n */\nMocha.prototype.fgrep = function (str) {\n  return this.grep(new RegExp(escapeRe(str)));\n};\n\n/**\n * Add regexp to grep, if `re` is a string it is escaped.\n *\n * @public\n * @param {RegExp|String} re\n * @return {Mocha}\n * @api public\n * @param {RegExp|string} re\n * @return {Mocha}\n */\nMocha.prototype.grep = function (re) {\n  if (utils.isString(re)) {\n    // extract args if it's regex-like, i.e: [string, pattern, flag]\n    var arg = re.match(/^\\/(.*)\\/(g|i|)$|.*/);\n    this.options.grep = new RegExp(arg[1] || arg[0], arg[2]);\n  } else {\n    this.options.grep = re;\n  }\n  return this;\n};\n/**\n * Invert `.grep()` matches.\n *\n * @public\n * @return {Mocha}\n * @api public\n */\nMocha.prototype.invert = function () {\n  this.options.invert = true;\n  return this;\n};\n\n/**\n * Ignore global leaks.\n *\n * @public\n * @param {Boolean} ignore\n * @return {Mocha}\n * @api public\n * @param {boolean} ignore\n * @return {Mocha}\n */\nMocha.prototype.ignoreLeaks = function (ignore) {\n  this.options.ignoreLeaks = Boolean(ignore);\n  return this;\n};\n\n/**\n * Enable global leak checking.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.checkLeaks = function () {\n  this.options.ignoreLeaks = false;\n  return this;\n};\n\n/**\n * Display long stack-trace on failing\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.fullTrace = function () {\n  this.options.fullStackTrace = true;\n  return this;\n};\n\n/**\n * Enable growl support.\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.growl = function () {\n  this.options.growl = true;\n  return this;\n};\n\n/**\n * Ignore `globals` array or string.\n *\n * @param {Array|String} globals\n * @return {Mocha}\n * @api public\n * @public\n * @param {Array|string} globals\n * @return {Mocha}\n */\nMocha.prototype.globals = function (globals) {\n  this.options.globals = (this.options.globals || []).concat(globals);\n  return this;\n};\n\n/**\n * Emit color output.\n *\n * @param {Boolean} colors\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} colors\n * @return {Mocha}\n */\nMocha.prototype.useColors = function (colors) {\n  if (colors !== undefined) {\n    this.options.useColors = colors;\n  }\n  return this;\n};\n\n/**\n * Use inline diffs rather than +/-.\n *\n * @param {Boolean} inlineDiffs\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} inlineDiffs\n * @return {Mocha}\n */\nMocha.prototype.useInlineDiffs = function (inlineDiffs) {\n  this.options.useInlineDiffs = inlineDiffs !== undefined && inlineDiffs;\n  return this;\n};\n\n/**\n * Do not show diffs at all.\n *\n * @param {Boolean} hideDiff\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} hideDiff\n * @return {Mocha}\n */\nMocha.prototype.hideDiff = function (hideDiff) {\n  this.options.hideDiff = hideDiff !== undefined && hideDiff;\n  return this;\n};\n\n/**\n * Set the timeout in milliseconds.\n *\n * @param {Number} timeout\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} timeout\n * @return {Mocha}\n */\nMocha.prototype.timeout = function (timeout) {\n  this.suite.timeout(timeout);\n  return this;\n};\n\n/**\n * Set the number of times to retry failed tests.\n *\n * @param {Number} retry times\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.retries = function (n) {\n  this.suite.retries(n);\n  return this;\n};\n\n/**\n * Set slowness threshold in milliseconds.\n *\n * @param {Number} slow\n * @return {Mocha}\n * @api public\n * @public\n * @param {number} slow\n * @return {Mocha}\n */\nMocha.prototype.slow = function (slow) {\n  this.suite.slow(slow);\n  return this;\n};\n\n/**\n * Enable timeouts.\n *\n * @param {Boolean} enabled\n * @return {Mocha}\n * @api public\n * @public\n * @param {boolean} enabled\n * @return {Mocha}\n */\nMocha.prototype.enableTimeouts = function (enabled) {\n  this.suite.enableTimeouts(arguments.length && enabled !== undefined ? enabled : true);\n  return this;\n};\n\n/**\n * Makes all tests async (accepting a callback)\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.asyncOnly = function () {\n  this.options.asyncOnly = true;\n  return this;\n};\n\n/**\n * Disable syntax highlighting (in browser).\n *\n * @api public\n * @public\n */\nMocha.prototype.noHighlighting = function () {\n  this.options.noHighlighting = true;\n  return this;\n};\n\n/**\n * Enable uncaught errors to propagate (in browser).\n *\n * @return {Mocha}\n * @api public\n * @public\n */\nMocha.prototype.allowUncaught = function () {\n  this.options.allowUncaught = true;\n  return this;\n};\n\n/**\n * Delay root suite execution.\n * @returns {Mocha}\n */\nMocha.prototype.delay = function delay () {\n  this.options.delay = true;\n  return this;\n};\n\n/**\n * Tests marked only fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidOnly = function () {\n  this.options.forbidOnly = true;\n  return this;\n};\n\n/**\n * Pending tests and tests marked skip fail the suite\n * @returns {Mocha}\n */\nMocha.prototype.forbidPending = function () {\n  this.options.forbidPending = true;\n  return this;\n};\n\n/**\n * Run tests and invoke `fn()` when complete.\n *\n * Note that `loadFiles` relies on Node's `require` to execute\n * the test interface functions and will be subject to the\n * cache - if the files are already in the `require` cache,\n * they will effectively be skipped. Therefore, to run tests\n * multiple times or to run tests in files that are already\n * in the `require` cache, make sure to clear them from the\n * cache first in whichever manner best suits your needs.\n *\n * @api public\n * @public\n * @param {Function} fn\n * @return {Runner}\n */\nMocha.prototype.run = function (fn) {\n  if (this.files.length) {\n    this.loadFiles();\n  }\n  var suite = this.suite;\n  var options = this.options;\n  options.files = this.files;\n  var runner = new exports.Runner(suite, options.delay);\n  var reporter = new this._reporter(runner, options);\n  runner.ignoreLeaks = options.ignoreLeaks !== false;\n  runner.fullStackTrace = options.fullStackTrace;\n  runner.asyncOnly = options.asyncOnly;\n  runner.allowUncaught = options.allowUncaught;\n  runner.forbidOnly = options.forbidOnly;\n  runner.forbidPending = options.forbidPending;\n  if (options.grep) {\n    runner.grep(options.grep, options.invert);\n  }\n  if (options.globals) {\n    runner.globals(options.globals);\n  }\n  if (options.growl) {\n    this._growl(runner, reporter);\n  }\n  if (options.useColors !== undefined) {\n    exports.reporters.Base.useColors = options.useColors;\n  }\n  exports.reporters.Base.inlineDiffs = options.useInlineDiffs;\n  exports.reporters.Base.hideDiff = options.hideDiff;\n\n  function done (failures) {\n    if (reporter.done) {\n      reporter.done(failures, fn);\n    } else {\n      fn && fn(failures);\n    }\n  }\n\n  return runner.run(done);\n};\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {},\"/lib\")\n},{\"./context\":5,\"./hook\":6,\"./interfaces\":10,\"./reporters\":20,\"./runnable\":32,\"./runner\":33,\"./suite\":34,\"./test\":35,\"./utils\":36,\"_process\":56,\"escape-string-regexp\":46,\"growl\":2,\"path\":40}],14:[function(require,module,exports){\n'use strict';\n/**\n * @module milliseconds\n */\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {string|number} val\n * @return {string|number}\n */\nmodule.exports = function (val) {\n  if (typeof val === 'string') {\n    return parse(val);\n  }\n  return format(val);\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @api private\n * @param {string} str\n * @return {number}\n */\nfunction parse (str) {\n  var match = (/^((?:\\d+)?\\.?\\d+) *(ms|seconds?|s|minutes?|m|hours?|h|days?|d|years?|y)?$/i).exec(str);\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 's':\n      return n * s;\n    case 'ms':\n      return n;\n    default:\n      // No default case\n  }\n}\n\n/**\n * Format for `ms`.\n *\n * @api private\n * @param {number} ms\n * @return {string}\n */\nfunction format (ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n},{}],15:[function(require,module,exports){\n'use strict';\n\n/**\n * Expose `Pending`.\n */\n\nmodule.exports = Pending;\n\n/**\n * Initialize a new `Pending` error with the given message.\n *\n * @param {string} message\n */\nfunction Pending (message) {\n  this.message = message;\n}\n\n},{}],16:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module Base\n */\n/**\n * Module dependencies.\n */\n\nvar tty = require('tty');\nvar diff = require('diff');\nvar ms = require('../ms');\nvar utils = require('../utils');\nvar supportsColor = process.browser ? null : require('supports-color');\n\n/**\n * Expose `Base`.\n */\n\nexports = module.exports = Base;\n\n/**\n * Save timer references to avoid Sinon interfering.\n * See: https://github.com/mochajs/mocha/issues/237\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Check if both stdio streams are associated with a tty.\n */\n\nvar isatty = tty.isatty(1) && tty.isatty(2);\n\n/**\n * Enable coloring by default, except in the browser interface.\n */\n\nexports.useColors = !process.browser && (supportsColor || (process.env.MOCHA_COLORS !== undefined));\n\n/**\n * Inline diffs instead of +/-\n */\n\nexports.inlineDiffs = false;\n\n/**\n * Default color map.\n */\n\nexports.colors = {\n  pass: 90,\n  fail: 31,\n  'bright pass': 92,\n  'bright fail': 91,\n  'bright yellow': 93,\n  pending: 36,\n  suite: 0,\n  'error title': 0,\n  'error message': 31,\n  'error stack': 90,\n  checkmark: 32,\n  fast: 90,\n  medium: 33,\n  slow: 31,\n  green: 32,\n  light: 90,\n  'diff gutter': 90,\n  'diff added': 32,\n  'diff removed': 31\n};\n\n/**\n * Default symbol map.\n */\n\nexports.symbols = {\n  ok: '',\n  err: '',\n  dot: '',\n  comma: ',',\n  bang: '!'\n};\n\n// With node.js on Windows: use symbols available in terminal default fonts\nif (process.platform === 'win32') {\n  exports.symbols.ok = '\\u221A';\n  exports.symbols.err = '\\u00D7';\n  exports.symbols.dot = '.';\n}\n\n/**\n * Color `str` with the given `type`,\n * allowing colors to be disabled,\n * as well as user-defined color\n * schemes.\n *\n * @param {string} type\n * @param {string} str\n * @return {string}\n * @api private\n */\nvar color = exports.color = function (type, str) {\n  if (!exports.useColors) {\n    return String(str);\n  }\n  return '\\u001b[' + exports.colors[type] + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Expose term window size, with some defaults for when stderr is not a tty.\n */\n\nexports.window = {\n  width: 75\n};\n\nif (isatty) {\n  exports.window.width = process.stdout.getWindowSize\n    ? process.stdout.getWindowSize(1)[0]\n    : tty.getWindowSize()[1];\n}\n\n/**\n * Expose some basic cursor interactions that are common among reporters.\n */\n\nexports.cursor = {\n  hide: function () {\n    isatty && process.stdout.write('\\u001b[?25l');\n  },\n\n  show: function () {\n    isatty && process.stdout.write('\\u001b[?25h');\n  },\n\n  deleteLine: function () {\n    isatty && process.stdout.write('\\u001b[2K');\n  },\n\n  beginningOfLine: function () {\n    isatty && process.stdout.write('\\u001b[0G');\n  },\n\n  CR: function () {\n    if (isatty) {\n      exports.cursor.deleteLine();\n      exports.cursor.beginningOfLine();\n    } else {\n      process.stdout.write('\\r');\n    }\n  }\n};\n\nfunction showDiff (err) {\n  return err && err.showDiff !== false && sameType(err.actual, err.expected) && err.expected !== undefined;\n}\n\nfunction stringifyDiffObjs (err) {\n  if (!utils.isString(err.actual) || !utils.isString(err.expected)) {\n    err.actual = utils.stringify(err.actual);\n    err.expected = utils.stringify(err.expected);\n  }\n}\n\n/**\n * Returns a diff between 2 strings with coloured ANSI output.\n *\n * The diff will be either inline or unified dependant on the value\n * of `Base.inlineDiff`.\n *\n * @param {string} actual\n * @param {string} expected\n * @return {string} Diff\n */\nvar generateDiff = exports.generateDiff = function (actual, expected) {\n  return exports.inlineDiffs\n    ? inlineDiff(actual, expected)\n    : unifiedDiff(actual, expected);\n};\n\n/**\n * Output the given `failures` as a list.\n *\n * @public\n * @memberof Mocha.reporters.Base\n * @variation 1\n * @param {Array} failures\n * @api public\n */\n\nexports.list = function (failures) {\n  console.log();\n  failures.forEach(function (test, i) {\n    // format\n    var fmt = color('error title', '  %s) %s:\\n') +\n      color('error message', '     %s') +\n      color('error stack', '\\n%s\\n');\n\n    // msg\n    var msg;\n    var err = test.err;\n    var message;\n    if (err.message && typeof err.message.toString === 'function') {\n      message = err.message + '';\n    } else if (typeof err.inspect === 'function') {\n      message = err.inspect() + '';\n    } else {\n      message = '';\n    }\n    var stack = err.stack || message;\n    var index = message ? stack.indexOf(message) : -1;\n\n    if (index === -1) {\n      msg = message;\n    } else {\n      index += message.length;\n      msg = stack.slice(0, index);\n      // remove msg from stack\n      stack = stack.slice(index + 1);\n    }\n\n    // uncaught\n    if (err.uncaught) {\n      msg = 'Uncaught ' + msg;\n    }\n    // explicitly show diff\n    if (!exports.hideDiff && showDiff(err)) {\n      stringifyDiffObjs(err);\n      fmt = color('error title', '  %s) %s:\\n%s') + color('error stack', '\\n%s\\n');\n      var match = message.match(/^([^:]+): expected/);\n      msg = '\\n      ' + color('error message', match ? match[1] : msg);\n\n      msg += generateDiff(err.actual, err.expected);\n    }\n\n    // indent stack trace\n    stack = stack.replace(/^/gm, '  ');\n\n    // indented test title\n    var testTitle = '';\n    test.titlePath().forEach(function (str, index) {\n      if (index !== 0) {\n        testTitle += '\\n     ';\n      }\n      for (var i = 0; i < index; i++) {\n        testTitle += '  ';\n      }\n      testTitle += str;\n    });\n\n    console.log(fmt, (i + 1), testTitle, msg, stack);\n  });\n};\n\n/**\n * Initialize a new `Base` reporter.\n *\n * All other reporters generally\n * inherit from this reporter, providing\n * stats such as test duration, number\n * of tests passed / failed etc.\n *\n * @memberof Mocha.reporters\n * @public\n * @class\n * @param {Runner} runner\n * @api public\n */\n\nfunction Base (runner) {\n  var stats = this.stats = { suites: 0, tests: 0, passes: 0, pending: 0, failures: 0 };\n  var failures = this.failures = [];\n\n  if (!runner) {\n    return;\n  }\n  this.runner = runner;\n\n  runner.stats = stats;\n\n  runner.on('start', function () {\n    stats.start = new Date();\n  });\n\n  runner.on('suite', function (suite) {\n    stats.suites = stats.suites || 0;\n    suite.root || stats.suites++;\n  });\n\n  runner.on('test end', function () {\n    stats.tests = stats.tests || 0;\n    stats.tests++;\n  });\n\n  runner.on('pass', function (test) {\n    stats.passes = stats.passes || 0;\n\n    if (test.duration > test.slow()) {\n      test.speed = 'slow';\n    } else if (test.duration > test.slow() / 2) {\n      test.speed = 'medium';\n    } else {\n      test.speed = 'fast';\n    }\n\n    stats.passes++;\n  });\n\n  runner.on('fail', function (test, err) {\n    stats.failures = stats.failures || 0;\n    stats.failures++;\n    if (showDiff(err)) {\n      stringifyDiffObjs(err);\n    }\n    test.err = err;\n    failures.push(test);\n  });\n\n  runner.once('end', function () {\n    stats.end = new Date();\n    stats.duration = stats.end - stats.start;\n  });\n\n  runner.on('pending', function () {\n    stats.pending++;\n  });\n}\n\n/**\n * Output common epilogue used by many of\n * the bundled reporters.\n *\n * @memberof Mocha.reporters.Base\n * @public\n * @api public\n */\nBase.prototype.epilogue = function () {\n  var stats = this.stats;\n  var fmt;\n\n  console.log();\n\n  // passes\n  fmt = color('bright pass', ' ') +\n    color('green', ' %d passing') +\n    color('light', ' (%s)');\n\n  console.log(fmt,\n    stats.passes || 0,\n    ms(stats.duration));\n\n  // pending\n  if (stats.pending) {\n    fmt = color('pending', ' ') +\n      color('pending', ' %d pending');\n\n    console.log(fmt, stats.pending);\n  }\n\n  // failures\n  if (stats.failures) {\n    fmt = color('fail', '  %d failing');\n\n    console.log(fmt, stats.failures);\n\n    Base.list(this.failures);\n    console.log();\n  }\n\n  console.log();\n};\n\n/**\n * Pad the given `str` to `len`.\n *\n * @api private\n * @param {string} str\n * @param {string} len\n * @return {string}\n */\nfunction pad (str, len) {\n  str = String(str);\n  return Array(len - str.length + 1).join(' ') + str;\n}\n\n/**\n * Returns an inline diff between 2 strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} Diff\n */\nfunction inlineDiff (actual, expected) {\n  var msg = errorDiff(actual, expected);\n\n  // linenos\n  var lines = msg.split('\\n');\n  if (lines.length > 4) {\n    var width = String(lines.length).length;\n    msg = lines.map(function (str, i) {\n      return pad(++i, width) + ' |' + ' ' + str;\n    }).join('\\n');\n  }\n\n  // legend\n  msg = '\\n' +\n    color('diff removed', 'actual') +\n    ' ' +\n    color('diff added', 'expected') +\n    '\\n\\n' +\n    msg +\n    '\\n';\n\n  // indent\n  msg = msg.replace(/^/gm, '      ');\n  return msg;\n}\n\n/**\n * Returns a unified diff between two strings with coloured ANSI output.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} The diff.\n */\nfunction unifiedDiff (actual, expected) {\n  var indent = '      ';\n  function cleanUp (line) {\n    if (line[0] === '+') {\n      return indent + colorLines('diff added', line);\n    }\n    if (line[0] === '-') {\n      return indent + colorLines('diff removed', line);\n    }\n    if (line.match(/@@/)) {\n      return '--';\n    }\n    if (line.match(/\\\\ No newline/)) {\n      return null;\n    }\n    return indent + line;\n  }\n  function notBlank (line) {\n    return typeof line !== 'undefined' && line !== null;\n  }\n  var msg = diff.createPatch('string', actual, expected);\n  var lines = msg.split('\\n').splice(5);\n  return '\\n      ' +\n    colorLines('diff added', '+ expected') + ' ' +\n    colorLines('diff removed', '- actual') +\n    '\\n\\n' +\n    lines.map(cleanUp).filter(notBlank).join('\\n');\n}\n\n/**\n * Return a character diff for `err`.\n *\n * @api private\n * @param {String} actual\n * @param {String} expected\n * @return {string} the diff\n */\nfunction errorDiff (actual, expected) {\n  return diff.diffWordsWithSpace(actual, expected).map(function (str) {\n    if (str.added) {\n      return colorLines('diff added', str.value);\n    }\n    if (str.removed) {\n      return colorLines('diff removed', str.value);\n    }\n    return str.value;\n  }).join('');\n}\n\n/**\n * Color lines for `str`, using the color `name`.\n *\n * @api private\n * @param {string} name\n * @param {string} str\n * @return {string}\n */\nfunction colorLines (name, str) {\n  return str.split('\\n').map(function (str) {\n    return color(name, str);\n  }).join('\\n');\n}\n\n/**\n * Object#toString reference.\n */\nvar objToString = Object.prototype.toString;\n\n/**\n * Check that a / b have the same type.\n *\n * @api private\n * @param {Object} a\n * @param {Object} b\n * @return {boolean}\n */\nfunction sameType (a, b) {\n  return objToString.call(a) === objToString.call(b);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../ms\":14,\"../utils\":36,\"_process\":56,\"diff\":45,\"supports-color\":40,\"tty\":4}],17:[function(require,module,exports){\n'use strict';\n/**\n * @module Doc\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Expose `Doc`.\n */\n\nexports = module.exports = Doc;\n\n/**\n * Initialize a new `Doc` reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends {Base}\n * @public\n * @param {Runner} runner\n * @api public\n */\nfunction Doc (runner) {\n  Base.call(this, runner);\n\n  var indents = 2;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    ++indents;\n    console.log('%s<section class=\"suite\">', indent());\n    ++indents;\n    console.log('%s<h1>%s</h1>', indent(), utils.escape(suite.title));\n    console.log('%s<dl>', indent());\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      return;\n    }\n    console.log('%s</dl>', indent());\n    --indents;\n    console.log('%s</section>', indent());\n    --indents;\n  });\n\n  runner.on('pass', function (test) {\n    console.log('%s  <dt>%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd><pre><code>%s</code></pre></dd>', indent(), code);\n  });\n\n  runner.on('fail', function (test, err) {\n    console.log('%s  <dt class=\"error\">%s</dt>', indent(), utils.escape(test.title));\n    var code = utils.escape(utils.clean(test.body));\n    console.log('%s  <dd class=\"error\"><pre><code>%s</code></pre></dd>', indent(), code);\n    console.log('%s  <dd class=\"error\">%s</dd>', indent(), utils.escape(err));\n  });\n}\n\n},{\"../utils\":36,\"./base\":16}],18:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Dot\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = Dot;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @public\n * @api public\n * @param {Runner} runner\n */\nfunction Dot (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var n = -1;\n\n  runner.on('start', function () {\n    process.stdout.write('\\n');\n  });\n\n  runner.on('pending', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('pending', Base.symbols.comma));\n  });\n\n  runner.on('pass', function (test) {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    if (test.speed === 'slow') {\n      process.stdout.write(color('bright yellow', Base.symbols.dot));\n    } else {\n      process.stdout.write(color(test.speed, Base.symbols.dot));\n    }\n  });\n\n  runner.on('fail', function () {\n    if (++n % width === 0) {\n      process.stdout.write('\\n  ');\n    }\n    process.stdout.write(color('fail', Base.symbols.bang));\n  });\n\n  runner.once('end', function () {\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Dot, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],19:[function(require,module,exports){\n(function (global){\n'use strict';\n\n/* eslint-env browser */\n/**\n * @module HTML\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar Progress = require('../browser/progress');\nvar escapeRe = require('escape-string-regexp');\nvar escape = utils.escape;\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `HTML`.\n */\n\nexports = module.exports = HTML;\n\n/**\n * Stats template.\n */\n\nvar statsTemplate = '<ul id=\"mocha-stats\">' +\n  '<li class=\"progress\"><canvas width=\"40\" height=\"40\"></canvas></li>' +\n  '<li class=\"passes\"><a href=\"javascript:void(0);\">passes:</a> <em>0</em></li>' +\n  '<li class=\"failures\"><a href=\"javascript:void(0);\">failures:</a> <em>0</em></li>' +\n  '<li class=\"duration\">duration: <em>0</em>s</li>' +\n  '</ul>';\n\nvar playIcon = '&#x2023;';\n\n/**\n * Initialize a new `HTML` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction HTML (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var stats = this.stats;\n  var stat = fragment(statsTemplate);\n  var items = stat.getElementsByTagName('li');\n  var passes = items[1].getElementsByTagName('em')[0];\n  var passesLink = items[1].getElementsByTagName('a')[0];\n  var failures = items[2].getElementsByTagName('em')[0];\n  var failuresLink = items[2].getElementsByTagName('a')[0];\n  var duration = items[3].getElementsByTagName('em')[0];\n  var canvas = stat.getElementsByTagName('canvas')[0];\n  var report = fragment('<ul id=\"mocha-report\"></ul>');\n  var stack = [report];\n  var progress;\n  var ctx;\n  var root = document.getElementById('mocha');\n\n  if (canvas.getContext) {\n    var ratio = window.devicePixelRatio || 1;\n    canvas.style.width = canvas.width;\n    canvas.style.height = canvas.height;\n    canvas.width *= ratio;\n    canvas.height *= ratio;\n    ctx = canvas.getContext('2d');\n    ctx.scale(ratio, ratio);\n    progress = new Progress();\n  }\n\n  if (!root) {\n    return error('#mocha div missing, add it to your document');\n  }\n\n  // pass toggle\n  on(passesLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/pass/).test(report.className) ? '' : ' pass';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test pass');\n    }\n  });\n\n  // failure toggle\n  on(failuresLink, 'click', function (evt) {\n    evt.preventDefault();\n    unhide();\n    var name = (/fail/).test(report.className) ? '' : ' fail';\n    report.className = report.className.replace(/fail|pass/g, '') + name;\n    if (report.className.trim()) {\n      hideSuitesWithout('test fail');\n    }\n  });\n\n  root.appendChild(stat);\n  root.appendChild(report);\n\n  if (progress) {\n    progress.size(40);\n  }\n\n  runner.on('suite', function (suite) {\n    if (suite.root) {\n      return;\n    }\n\n    // suite\n    var url = self.suiteURL(suite);\n    var el = fragment('<li class=\"suite\"><h1><a href=\"%s\">%s</a></h1></li>', url, escape(suite.title));\n\n    // container\n    stack[0].appendChild(el);\n    stack.unshift(document.createElement('ul'));\n    el.appendChild(stack[0]);\n  });\n\n  runner.on('suite end', function (suite) {\n    if (suite.root) {\n      updateStats();\n      return;\n    }\n    stack.shift();\n  });\n\n  runner.on('pass', function (test) {\n    var url = self.testURL(test);\n    var markup = '<li class=\"test pass %e\"><h2>%e<span class=\"duration\">%ems</span> ' +\n      '<a href=\"%s\" class=\"replay\">' + playIcon + '</a></h2></li>';\n    var el = fragment(markup, test.speed, test.title, test.duration, url);\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('fail', function (test) {\n    var el = fragment('<li class=\"test fail\"><h2>%e <a href=\"%e\" class=\"replay\">' + playIcon + '</a></h2></li>',\n      test.title, self.testURL(test));\n    var stackString; // Note: Includes leading newline\n    var message = test.err.toString();\n\n    // <=IE7 stringifies to [Object Error]. Since it can be overloaded, we\n    // check for the result of the stringifying.\n    if (message === '[object Error]') {\n      message = test.err.message;\n    }\n\n    if (test.err.stack) {\n      var indexOfMessage = test.err.stack.indexOf(test.err.message);\n      if (indexOfMessage === -1) {\n        stackString = test.err.stack;\n      } else {\n        stackString = test.err.stack.substr(test.err.message.length + indexOfMessage);\n      }\n    } else if (test.err.sourceURL && test.err.line !== undefined) {\n      // Safari doesn't give you a stack. Let's at least provide a source line.\n      stackString = '\\n(' + test.err.sourceURL + ':' + test.err.line + ')';\n    }\n\n    stackString = stackString || '';\n\n    if (test.err.htmlMessage && stackString) {\n      el.appendChild(fragment('<div class=\"html-error\">%s\\n<pre class=\"error\">%e</pre></div>',\n        test.err.htmlMessage, stackString));\n    } else if (test.err.htmlMessage) {\n      el.appendChild(fragment('<div class=\"html-error\">%s</div>', test.err.htmlMessage));\n    } else {\n      el.appendChild(fragment('<pre class=\"error\">%e%e</pre>', message, stackString));\n    }\n\n    self.addCodeToggle(el, test.body);\n    appendToStack(el);\n    updateStats();\n  });\n\n  runner.on('pending', function (test) {\n    var el = fragment('<li class=\"test pass pending\"><h2>%e</h2></li>', test.title);\n    appendToStack(el);\n    updateStats();\n  });\n\n  function appendToStack (el) {\n    // Don't call .appendChild if #mocha-report was already .shift()'ed off the stack.\n    if (stack[0]) {\n      stack[0].appendChild(el);\n    }\n  }\n\n  function updateStats () {\n    // TODO: add to stats\n    var percent = stats.tests / runner.total * 100 | 0;\n    if (progress) {\n      progress.update(percent).draw(ctx);\n    }\n\n    // update stats\n    var ms = new Date() - stats.start;\n    text(passes, stats.passes);\n    text(failures, stats.failures);\n    text(duration, (ms / 1000).toFixed(2));\n  }\n}\n\n/**\n * Makes a URL, preserving querystring (\"search\") parameters.\n *\n * @param {string} s\n * @return {string} A new URL.\n */\nfunction makeUrl (s) {\n  var search = window.location.search;\n\n  // Remove previous grep query parameter if present\n  if (search) {\n    search = search.replace(/[?&]grep=[^&\\s]*/g, '').replace(/^&/, '?');\n  }\n\n  return window.location.pathname + (search ? search + '&' : '?') + 'grep=' + encodeURIComponent(escapeRe(s));\n}\n\n/**\n * Provide suite URL.\n *\n * @param {Object} [suite]\n */\nHTML.prototype.suiteURL = function (suite) {\n  return makeUrl(suite.fullTitle());\n};\n\n/**\n * Provide test URL.\n *\n * @param {Object} [test]\n */\nHTML.prototype.testURL = function (test) {\n  return makeUrl(test.fullTitle());\n};\n\n/**\n * Adds code toggle functionality for the provided test's list element.\n *\n * @param {HTMLLIElement} el\n * @param {string} contents\n */\nHTML.prototype.addCodeToggle = function (el, contents) {\n  var h2 = el.getElementsByTagName('h2')[0];\n\n  on(h2, 'click', function () {\n    pre.style.display = pre.style.display === 'none' ? 'block' : 'none';\n  });\n\n  var pre = fragment('<pre><code>%e</code></pre>', utils.clean(contents));\n  el.appendChild(pre);\n  pre.style.display = 'none';\n};\n\n/**\n * Display error `msg`.\n *\n * @param {string} msg\n */\nfunction error (msg) {\n  document.body.appendChild(fragment('<div id=\"mocha-error\">%s</div>', msg));\n}\n\n/**\n * Return a DOM fragment from `html`.\n *\n * @param {string} html\n */\nfunction fragment (html) {\n  var args = arguments;\n  var div = document.createElement('div');\n  var i = 1;\n\n  div.innerHTML = html.replace(/%([se])/g, function (_, type) {\n    switch (type) {\n      case 's': return String(args[i++]);\n      case 'e': return escape(args[i++]);\n      // no default\n    }\n  });\n\n  return div.firstChild;\n}\n\n/**\n * Check for suites that do not have elements\n * with `classname`, and hide them.\n *\n * @param {text} classname\n */\nfunction hideSuitesWithout (classname) {\n  var suites = document.getElementsByClassName('suite');\n  for (var i = 0; i < suites.length; i++) {\n    var els = suites[i].getElementsByClassName(classname);\n    if (!els.length) {\n      suites[i].className += ' hidden';\n    }\n  }\n}\n\n/**\n * Unhide .hidden suites.\n */\nfunction unhide () {\n  var els = document.getElementsByClassName('suite hidden');\n  for (var i = 0; i < els.length; ++i) {\n    els[i].className = els[i].className.replace('suite hidden', 'suite');\n  }\n}\n\n/**\n * Set an element's text contents.\n *\n * @param {HTMLElement} el\n * @param {string} contents\n */\nfunction text (el, contents) {\n  if (el.textContent) {\n    el.textContent = contents;\n  } else {\n    el.innerText = contents;\n  }\n}\n\n/**\n * Listen on `event` with callback `fn`.\n */\nfunction on (el, event, fn) {\n  if (el.addEventListener) {\n    el.addEventListener(event, fn, false);\n  } else {\n    el.attachEvent('on' + event, fn);\n  }\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../browser/progress\":3,\"../utils\":36,\"./base\":16,\"escape-string-regexp\":46}],20:[function(require,module,exports){\n'use strict';\n\n// Alias exports to a their normalized format Mocha#reporter to prevent a need\n// for dynamic (try/catch) requires, which Browserify doesn't handle.\nexports.Base = exports.base = require('./base');\nexports.Dot = exports.dot = require('./dot');\nexports.Doc = exports.doc = require('./doc');\nexports.TAP = exports.tap = require('./tap');\nexports.JSON = exports.json = require('./json');\nexports.HTML = exports.html = require('./html');\nexports.List = exports.list = require('./list');\nexports.Min = exports.min = require('./min');\nexports.Spec = exports.spec = require('./spec');\nexports.Nyan = exports.nyan = require('./nyan');\nexports.XUnit = exports.xunit = require('./xunit');\nexports.Markdown = exports.markdown = require('./markdown');\nexports.Progress = exports.progress = require('./progress');\nexports.Landing = exports.landing = require('./landing');\nexports.JSONStream = exports['json-stream'] = require('./json-stream');\n\n},{\"./base\":16,\"./doc\":17,\"./dot\":18,\"./html\":19,\"./json\":22,\"./json-stream\":21,\"./landing\":23,\"./list\":24,\"./markdown\":25,\"./min\":26,\"./nyan\":27,\"./progress\":28,\"./spec\":29,\"./tap\":30,\"./xunit\":31}],21:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSONStream\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `JSONStream` test reporter.\n *\n * @public\n * @name JSONStream\n * @class JSONStream\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var total = runner.total;\n\n  runner.on('start', function () {\n    console.log(JSON.stringify(['start', { total: total }]));\n  });\n\n  runner.on('pass', function (test) {\n    console.log(JSON.stringify(['pass', clean(test)]));\n  });\n\n  runner.on('fail', function (test, err) {\n    test = clean(test);\n    test.err = err.message;\n    test.stack = err.stack || null;\n    console.log(JSON.stringify(['fail', test]));\n  });\n\n  runner.once('end', function () {\n    process.stdout.write(JSON.stringify(['end', self.stats]));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry()\n  };\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],22:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module JSON\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `JSON`.\n */\n\nexports = module.exports = JSONReporter;\n\n/**\n * Initialize a new `JSON` reporter.\n *\n * @public\n * @class JSON\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction JSONReporter (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var tests = [];\n  var pending = [];\n  var failures = [];\n  var passes = [];\n\n  runner.on('test end', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    passes.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    failures.push(test);\n  });\n\n  runner.on('pending', function (test) {\n    pending.push(test);\n  });\n\n  runner.once('end', function () {\n    var obj = {\n      stats: self.stats,\n      tests: tests.map(clean),\n      pending: pending.map(clean),\n      failures: failures.map(clean),\n      passes: passes.map(clean)\n    };\n\n    runner.testResults = obj;\n\n    process.stdout.write(JSON.stringify(obj, null, 2));\n  });\n}\n\n/**\n * Return a plain-object representation of `test`\n * free of cyclic properties etc.\n *\n * @api private\n * @param {Object} test\n * @return {Object}\n */\nfunction clean (test) {\n  var err = test.err || {};\n  if (err instanceof Error) {\n    err = errorJSON(err);\n  }\n\n  return {\n    title: test.title,\n    fullTitle: test.fullTitle(),\n    duration: test.duration,\n    currentRetry: test.currentRetry(),\n    err: cleanCycles(err)\n  };\n}\n\n/**\n * Replaces any circular references inside `obj` with '[object Object]'\n *\n * @api private\n * @param {Object} obj\n * @return {Object}\n */\nfunction cleanCycles (obj) {\n  var cache = [];\n  return JSON.parse(JSON.stringify(obj, function (key, value) {\n    if (typeof value === 'object' && value !== null) {\n      if (cache.indexOf(value) !== -1) {\n        // Instead of going in a circle, we'll print [object Object]\n        return '' + value;\n      }\n      cache.push(value);\n    }\n\n    return value;\n  }));\n}\n\n/**\n * Transform an Error object into a JSON object.\n *\n * @api private\n * @param {Error} err\n * @return {Object}\n */\nfunction errorJSON (err) {\n  var res = {};\n  Object.getOwnPropertyNames(err).forEach(function (key) {\n    res[key] = err[key];\n  }, err);\n  return res;\n}\n\n}).call(this,require('_process'))\n},{\"./base\":16,\"_process\":56}],23:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Landing\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar cursor = Base.cursor;\nvar color = Base.color;\n\n/**\n * Expose `Landing`.\n */\n\nexports = module.exports = Landing;\n\n/**\n * Airplane color.\n */\n\nBase.colors.plane = 0;\n\n/**\n * Airplane crash color.\n */\n\nBase.colors['plane crash'] = 31;\n\n/**\n * Runway color.\n */\n\nBase.colors.runway = 90;\n\n/**\n * Initialize a new `Landing` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Landing (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var total = runner.total;\n  var stream = process.stdout;\n  var plane = color('plane', '');\n  var crashed = -1;\n  var n = 0;\n\n  function runway () {\n    var buf = Array(width).join('-');\n    return '  ' + color('runway', buf);\n  }\n\n  runner.on('start', function () {\n    stream.write('\\n\\n\\n  ');\n    cursor.hide();\n  });\n\n  runner.on('test end', function (test) {\n    // check if the plane crashed\n    var col = crashed === -1 ? width * ++n / total | 0 : crashed;\n\n    // show the crash\n    if (test.state === 'failed') {\n      plane = color('plane crash', '');\n      crashed = col;\n    }\n\n    // render landing strip\n    stream.write('\\u001b[' + (width + 1) + 'D\\u001b[2A');\n    stream.write(runway());\n    stream.write('\\n  ');\n    stream.write(color('runway', Array(col).join('')));\n    stream.write(plane);\n    stream.write(color('runway', Array(width - col).join('') + '\\n'));\n    stream.write(runway());\n    stream.write('\\u001b[0m');\n  });\n\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Landing, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],24:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module List\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `List`.\n */\n\nexports = module.exports = List;\n\n/**\n * Initialize a new `List` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction List (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var n = 0;\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('test', function (test) {\n    process.stdout.write(color('pass', '    ' + test.fullTitle() + ': '));\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = color('checkmark', '  -') +\n      color('pending', ' %s');\n    console.log(fmt, test.fullTitle());\n  });\n\n  runner.on('pass', function (test) {\n    var fmt = color('checkmark', '  ' + Base.symbols.ok) +\n      color('pass', ' %s: ') +\n      color(test.speed, '%dms');\n    cursor.CR();\n    console.log(fmt, test.fullTitle(), test.duration);\n  });\n\n  runner.on('fail', function (test) {\n    cursor.CR();\n    console.log(color('fail', '  %d) %s'), ++n, test.fullTitle());\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(List, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],25:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Markdown\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\n\n/**\n * Constants\n */\n\nvar SUITE_PREFIX = '$';\n\n/**\n * Expose `Markdown`.\n */\n\nexports = module.exports = Markdown;\n\n/**\n * Initialize a new `Markdown` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Markdown (runner) {\n  Base.call(this, runner);\n\n  var level = 0;\n  var buf = '';\n\n  function title (str) {\n    return Array(level).join('#') + ' ' + str;\n  }\n\n  function mapTOC (suite, obj) {\n    var ret = obj;\n    var key = SUITE_PREFIX + suite.title;\n\n    obj = obj[key] = obj[key] || { suite: suite };\n    suite.suites.forEach(function (suite) {\n      mapTOC(suite, obj);\n    });\n\n    return ret;\n  }\n\n  function stringifyTOC (obj, level) {\n    ++level;\n    var buf = '';\n    var link;\n    for (var key in obj) {\n      if (key === 'suite') {\n        continue;\n      }\n      if (key !== SUITE_PREFIX) {\n        link = ' - [' + key.substring(1) + ']';\n        link += '(#' + utils.slug(obj[key].suite.fullTitle()) + ')\\n';\n        buf += Array(level).join('  ') + link;\n      }\n      buf += stringifyTOC(obj[key], level);\n    }\n    return buf;\n  }\n\n  function generateTOC (suite) {\n    var obj = mapTOC(suite, {});\n    return stringifyTOC(obj, 0);\n  }\n\n  generateTOC(runner.suite);\n\n  runner.on('suite', function (suite) {\n    ++level;\n    var slug = utils.slug(suite.fullTitle());\n    buf += '<a name=\"' + slug + '\"></a>' + '\\n';\n    buf += title(suite.title) + '\\n';\n  });\n\n  runner.on('suite end', function () {\n    --level;\n  });\n\n  runner.on('pass', function (test) {\n    var code = utils.clean(test.body);\n    buf += test.title + '.\\n';\n    buf += '\\n```js\\n';\n    buf += code + '\\n';\n    buf += '```\\n\\n';\n  });\n\n  runner.once('end', function () {\n    process.stdout.write('# TOC\\n');\n    process.stdout.write(generateTOC(runner.suite));\n    process.stdout.write(buf);\n  });\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],26:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Min\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Min`.\n */\n\nexports = module.exports = Min;\n\n/**\n * Initialize a new `Min` minimal test reporter (best used with --watch).\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Min (runner) {\n  Base.call(this, runner);\n\n  runner.on('start', function () {\n    // clear screen\n    process.stdout.write('\\u001b[2J');\n    // set cursor position\n    process.stdout.write('\\u001b[1;3H');\n  });\n\n  runner.once('end', this.epilogue.bind(this));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Min, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],27:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Nyan\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\n\n/**\n * Expose `Dot`.\n */\n\nexports = module.exports = NyanCat;\n\n/**\n * Initialize a new `Dot` matrix test reporter.\n *\n * @param {Runner} runner\n * @api public\n * @public\n * @class Nyan\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n */\n\nfunction NyanCat (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.75 | 0;\n  var nyanCatWidth = this.nyanCatWidth = 11;\n\n  this.colorIndex = 0;\n  this.numberOfLines = 4;\n  this.rainbowColors = self.generateColors();\n  this.scoreboardWidth = 5;\n  this.tick = 0;\n  this.trajectories = [[], [], [], []];\n  this.trajectoryWidthMax = (width - nyanCatWidth);\n\n  runner.on('start', function () {\n    Base.cursor.hide();\n    self.draw();\n  });\n\n  runner.on('pending', function () {\n    self.draw();\n  });\n\n  runner.on('pass', function () {\n    self.draw();\n  });\n\n  runner.on('fail', function () {\n    self.draw();\n  });\n\n  runner.once('end', function () {\n    Base.cursor.show();\n    for (var i = 0; i < self.numberOfLines; i++) {\n      write('\\n');\n    }\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(NyanCat, Base);\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\n\nNyanCat.prototype.draw = function () {\n  this.appendRainbow();\n  this.drawScoreboard();\n  this.drawRainbow();\n  this.drawNyanCat();\n  this.tick = !this.tick;\n};\n\n/**\n * Draw the \"scoreboard\" showing the number\n * of passes, failures and pending tests.\n *\n * @api private\n */\n\nNyanCat.prototype.drawScoreboard = function () {\n  var stats = this.stats;\n\n  function draw (type, n) {\n    write(' ');\n    write(Base.color(type, n));\n    write('\\n');\n  }\n\n  draw('green', stats.passes);\n  draw('fail', stats.failures);\n  draw('pending', stats.pending);\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Append the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.appendRainbow = function () {\n  var segment = this.tick ? '_' : '-';\n  var rainbowified = this.rainbowify(segment);\n\n  for (var index = 0; index < this.numberOfLines; index++) {\n    var trajectory = this.trajectories[index];\n    if (trajectory.length >= this.trajectoryWidthMax) {\n      trajectory.shift();\n    }\n    trajectory.push(rainbowified);\n  }\n};\n\n/**\n * Draw the rainbow.\n *\n * @api private\n */\n\nNyanCat.prototype.drawRainbow = function () {\n  var self = this;\n\n  this.trajectories.forEach(function (line) {\n    write('\\u001b[' + self.scoreboardWidth + 'C');\n    write(line.join(''));\n    write('\\n');\n  });\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw the nyan cat\n *\n * @api private\n */\nNyanCat.prototype.drawNyanCat = function () {\n  var self = this;\n  var startWidth = this.scoreboardWidth + this.trajectories[0].length;\n  var dist = '\\u001b[' + startWidth + 'C';\n  var padding = '';\n\n  write(dist);\n  write('_,------,');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '  ' : '   ';\n  write('_|' + padding + '/\\\\_/\\\\ ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? '_' : '__';\n  var tail = self.tick ? '~' : '^';\n  write(tail + '|' + padding + this.face() + ' ');\n  write('\\n');\n\n  write(dist);\n  padding = self.tick ? ' ' : '  ';\n  write(padding + '\"\"  \"\" ');\n  write('\\n');\n\n  this.cursorUp(this.numberOfLines);\n};\n\n/**\n * Draw nyan cat face.\n *\n * @api private\n * @return {string}\n */\n\nNyanCat.prototype.face = function () {\n  var stats = this.stats;\n  if (stats.failures) {\n    return '( x .x)';\n  } else if (stats.pending) {\n    return '( o .o)';\n  } else if (stats.passes) {\n    return '( ^ .^)';\n  }\n  return '( - .-)';\n};\n\n/**\n * Move cursor up `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorUp = function (n) {\n  write('\\u001b[' + n + 'A');\n};\n\n/**\n * Move cursor down `n`.\n *\n * @api private\n * @param {number} n\n */\n\nNyanCat.prototype.cursorDown = function (n) {\n  write('\\u001b[' + n + 'B');\n};\n\n/**\n * Generate rainbow colors.\n *\n * @api private\n * @return {Array}\n */\nNyanCat.prototype.generateColors = function () {\n  var colors = [];\n\n  for (var i = 0; i < (6 * 7); i++) {\n    var pi3 = Math.floor(Math.PI / 3);\n    var n = (i * (1.0 / 6));\n    var r = Math.floor(3 * Math.sin(n) + 3);\n    var g = Math.floor(3 * Math.sin(n + 2 * pi3) + 3);\n    var b = Math.floor(3 * Math.sin(n + 4 * pi3) + 3);\n    colors.push(36 * r + 6 * g + b + 16);\n  }\n\n  return colors;\n};\n\n/**\n * Apply rainbow to the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nNyanCat.prototype.rainbowify = function (str) {\n  if (!Base.useColors) {\n    return str;\n  }\n  var color = this.rainbowColors[this.colorIndex % this.rainbowColors.length];\n  this.colorIndex += 1;\n  return '\\u001b[38;5;' + color + 'm' + str + '\\u001b[0m';\n};\n\n/**\n * Stdout helper.\n *\n * @param {string} string A message to write to stdout.\n */\nfunction write (string) {\n  process.stdout.write(string);\n}\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],28:[function(require,module,exports){\n(function (process){\n'use strict';\n/**\n * @module Progress\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\nvar cursor = Base.cursor;\n\n/**\n * Expose `Progress`.\n */\n\nexports = module.exports = Progress;\n\n/**\n * General progress bar color.\n */\n\nBase.colors.progress = 90;\n\n/**\n * Initialize a new `Progress` bar test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n * @param {Object} options\n */\nfunction Progress (runner, options) {\n  Base.call(this, runner);\n\n  var self = this;\n  var width = Base.window.width * 0.50 | 0;\n  var total = runner.total;\n  var complete = 0;\n  var lastN = -1;\n\n  // default chars\n  options = options || {};\n  var reporterOptions = options.reporterOptions || {};\n\n  options.open = reporterOptions.open || '[';\n  options.complete = reporterOptions.complete || '';\n  options.incomplete = reporterOptions.incomplete || Base.symbols.dot;\n  options.close = reporterOptions.close || ']';\n  options.verbose = reporterOptions.verbose || false;\n\n  // tests started\n  runner.on('start', function () {\n    console.log();\n    cursor.hide();\n  });\n\n  // tests complete\n  runner.on('test end', function () {\n    complete++;\n\n    var percent = complete / total;\n    var n = width * percent | 0;\n    var i = width - n;\n\n    if (n === lastN && !options.verbose) {\n      // Don't re-render the line if it hasn't changed\n      return;\n    }\n    lastN = n;\n\n    cursor.CR();\n    process.stdout.write('\\u001b[J');\n    process.stdout.write(color('progress', '  ' + options.open));\n    process.stdout.write(Array(n).join(options.complete));\n    process.stdout.write(Array(i).join(options.incomplete));\n    process.stdout.write(color('progress', options.close));\n    if (options.verbose) {\n      process.stdout.write(color('progress', ' ' + complete + ' of ' + total));\n    }\n  });\n\n  // tests are complete, output some stats\n  // and the failures if any\n  runner.once('end', function () {\n    cursor.show();\n    console.log();\n    self.epilogue();\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Progress, Base);\n\n}).call(this,require('_process'))\n},{\"../utils\":36,\"./base\":16,\"_process\":56}],29:[function(require,module,exports){\n'use strict';\n/**\n * @module Spec\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar inherits = require('../utils').inherits;\nvar color = Base.color;\n\n/**\n * Expose `Spec`.\n */\n\nexports = module.exports = Spec;\n\n/**\n * Initialize a new `Spec` test reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction Spec (runner) {\n  Base.call(this, runner);\n\n  var self = this;\n  var indents = 0;\n  var n = 0;\n\n  function indent () {\n    return Array(indents).join('  ');\n  }\n\n  runner.on('start', function () {\n    console.log();\n  });\n\n  runner.on('suite', function (suite) {\n    ++indents;\n    console.log(color('suite', '%s%s'), indent(), suite.title);\n  });\n\n  runner.on('suite end', function () {\n    --indents;\n    if (indents === 1) {\n      console.log();\n    }\n  });\n\n  runner.on('pending', function (test) {\n    var fmt = indent() + color('pending', '  - %s');\n    console.log(fmt, test.title);\n  });\n\n  runner.on('pass', function (test) {\n    var fmt;\n    if (test.speed === 'fast') {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s');\n      console.log(fmt, test.title);\n    } else {\n      fmt = indent() +\n        color('checkmark', '  ' + Base.symbols.ok) +\n        color('pass', ' %s') +\n        color(test.speed, ' (%dms)');\n      console.log(fmt, test.title, test.duration);\n    }\n  });\n\n  runner.on('fail', function (test) {\n    console.log(indent() + color('fail', '  %d) %s'), ++n, test.title);\n  });\n\n  runner.once('end', self.epilogue.bind(self));\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(Spec, Base);\n\n},{\"../utils\":36,\"./base\":16}],30:[function(require,module,exports){\n'use strict';\n/**\n * @module TAP\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\n\n/**\n * Expose `TAP`.\n */\n\nexports = module.exports = TAP;\n\n/**\n * Initialize a new `TAP` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction TAP (runner) {\n  Base.call(this, runner);\n\n  var n = 1;\n  var passes = 0;\n  var failures = 0;\n\n  runner.on('start', function () {\n    var total = runner.grepTotal(runner.suite);\n    console.log('%d..%d', 1, total);\n  });\n\n  runner.on('test end', function () {\n    ++n;\n  });\n\n  runner.on('pending', function (test) {\n    console.log('ok %d %s # SKIP -', n, title(test));\n  });\n\n  runner.on('pass', function (test) {\n    passes++;\n    console.log('ok %d %s', n, title(test));\n  });\n\n  runner.on('fail', function (test, err) {\n    failures++;\n    console.log('not ok %d %s', n, title(test));\n    if (err.stack) {\n      console.log(err.stack.replace(/^/gm, '  '));\n    }\n  });\n\n  runner.once('end', function () {\n    console.log('# tests ' + (passes + failures));\n    console.log('# pass ' + passes);\n    console.log('# fail ' + failures);\n  });\n}\n\n/**\n * Return a TAP-safe title of `test`\n *\n * @api private\n * @param {Object} test\n * @return {String}\n */\nfunction title (test) {\n  return test.fullTitle().replace(/#/g, '');\n}\n\n},{\"./base\":16}],31:[function(require,module,exports){\n(function (process,global){\n'use strict';\n/**\n * @module XUnit\n */\n/**\n * Module dependencies.\n */\n\nvar Base = require('./base');\nvar utils = require('../utils');\nvar inherits = utils.inherits;\nvar fs = require('fs');\nvar escape = utils.escape;\nvar mkdirp = require('mkdirp');\nvar path = require('path');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Expose `XUnit`.\n */\n\nexports = module.exports = XUnit;\n\n/**\n * Initialize a new `XUnit` reporter.\n *\n * @public\n * @class\n * @memberof Mocha.reporters\n * @extends Mocha.reporters.Base\n * @api public\n * @param {Runner} runner\n */\nfunction XUnit (runner, options) {\n  Base.call(this, runner);\n\n  var stats = this.stats;\n  var tests = [];\n  var self = this;\n\n  // the name of the test suite, as it will appear in the resulting XML file\n  var suiteName;\n\n  // the default name of the test suite if none is provided\n  var DEFAULT_SUITE_NAME = 'Mocha Tests';\n\n  if (options && options.reporterOptions) {\n    if (options.reporterOptions.output) {\n      if (!fs.createWriteStream) {\n        throw new Error('file output not supported in browser');\n      }\n\n      mkdirp.sync(path.dirname(options.reporterOptions.output));\n      self.fileStream = fs.createWriteStream(options.reporterOptions.output);\n    }\n\n    // get the suite name from the reporter options (if provided)\n    suiteName = options.reporterOptions.suiteName;\n  }\n\n  // fall back to the default suite name\n  suiteName = suiteName || DEFAULT_SUITE_NAME;\n\n  runner.on('pending', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('pass', function (test) {\n    tests.push(test);\n  });\n\n  runner.on('fail', function (test) {\n    tests.push(test);\n  });\n\n  runner.once('end', function () {\n    self.write(tag('testsuite', {\n      name: suiteName,\n      tests: stats.tests,\n      failures: stats.failures,\n      errors: stats.failures,\n      skipped: stats.tests - stats.failures - stats.passes,\n      timestamp: (new Date()).toUTCString(),\n      time: (stats.duration / 1000) || 0\n    }, false));\n\n    tests.forEach(function (t) {\n      self.test(t);\n    });\n\n    self.write('</testsuite>');\n  });\n}\n\n/**\n * Inherit from `Base.prototype`.\n */\ninherits(XUnit, Base);\n\n/**\n * Override done to close the stream (if it's a file).\n *\n * @param failures\n * @param {Function} fn\n */\nXUnit.prototype.done = function (failures, fn) {\n  if (this.fileStream) {\n    this.fileStream.end(function () {\n      fn(failures);\n    });\n  } else {\n    fn(failures);\n  }\n};\n\n/**\n * Write out the given line.\n *\n * @param {string} line\n */\nXUnit.prototype.write = function (line) {\n  if (this.fileStream) {\n    this.fileStream.write(line + '\\n');\n  } else if (typeof process === 'object' && process.stdout) {\n    process.stdout.write(line + '\\n');\n  } else {\n    console.log(line);\n  }\n};\n\n/**\n * Output tag for the given `test.`\n *\n * @param {Test} test\n */\nXUnit.prototype.test = function (test) {\n  var attrs = {\n    classname: test.parent.fullTitle(),\n    name: test.title,\n    time: (test.duration / 1000) || 0\n  };\n\n  if (test.state === 'failed') {\n    var err = test.err;\n    this.write(tag('testcase', attrs, false, tag('failure', {}, false, escape(err.message) + '\\n' + escape(err.stack))));\n  } else if (test.isPending()) {\n    this.write(tag('testcase', attrs, false, tag('skipped', {}, true)));\n  } else {\n    this.write(tag('testcase', attrs, true));\n  }\n};\n\n/**\n * HTML tag helper.\n *\n * @param name\n * @param attrs\n * @param close\n * @param content\n * @return {string}\n */\nfunction tag (name, attrs, close, content) {\n  var end = close ? '/>' : '>';\n  var pairs = [];\n  var tag;\n\n  for (var key in attrs) {\n    if (Object.prototype.hasOwnProperty.call(attrs, key)) {\n      pairs.push(key + '=\"' + escape(attrs[key]) + '\"');\n    }\n  }\n\n  tag = '<' + name + (pairs.length ? ' ' + pairs.join(' ') : '') + end;\n  if (content) {\n    tag += content + '</' + name + end;\n  }\n  return tag;\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"../utils\":36,\"./base\":16,\"_process\":56,\"fs\":40,\"mkdirp\":53,\"path\":40}],32:[function(require,module,exports){\n(function (global){\n'use strict';\n/**\n * @module Runnable\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar debug = require('debug')('mocha:runnable');\nvar milliseconds = require('./ms');\nvar utils = require('./utils');\n\n/**\n * Save timer references to avoid Sinon interfering (see GH-237).\n */\n\n/* eslint-disable no-unused-vars, no-native-reassign */\nvar Date = global.Date;\nvar setTimeout = global.setTimeout;\nvar setInterval = global.setInterval;\nvar clearTimeout = global.clearTimeout;\nvar clearInterval = global.clearInterval;\n/* eslint-enable no-unused-vars, no-native-reassign */\n\n/**\n * Object#toString().\n */\n\nvar toString = Object.prototype.toString;\n\n/**\n * Expose `Runnable`.\n */\n\nmodule.exports = Runnable;\n\n/**\n * Initialize a new `Runnable` with the given `title` and callback `fn`.  Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {String} title\n * @param {Function} fn\n */\nfunction Runnable (title, fn) {\n  this.title = title;\n  this.fn = fn;\n  this.body = (fn || '').toString();\n  this.async = fn && fn.length;\n  this.sync = !this.async;\n  this._timeout = 2000;\n  this._slow = 75;\n  this._enableTimeouts = true;\n  this.timedOut = false;\n  this._retries = -1;\n  this._currentRetry = 0;\n  this.pending = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\nutils.inherits(Runnable, EventEmitter);\n\n/**\n * Set & get timeout `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  // see #1652 for reasoning\n  if (ms === 0 || ms > Math.pow(2, 31)) {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = ms;\n  if (this.timer) {\n    this.resetTimeout();\n  }\n  return this;\n};\n\n/**\n * Set or get slow `ms`.\n *\n * @api private\n * @param {number|string} ms\n * @return {Runnable|number} ms or Runnable instance.\n */\nRunnable.prototype.slow = function (ms) {\n  if (!arguments.length || typeof ms === 'undefined') {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set and get whether timeout is `enabled`.\n *\n * @api private\n * @param {boolean} enabled\n * @return {Runnable|boolean} enabled or Runnable instance.\n */\nRunnable.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Halt and mark as pending.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n */\nRunnable.prototype.skip = function () {\n  throw new Pending('sync skip');\n};\n\n/**\n * Check if this runnable or its parent suite is marked as pending.\n *\n * @api private\n */\nRunnable.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Return `true` if this Runnable has failed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isFailed = function () {\n  return !this.isPending() && this.state === 'failed';\n};\n\n/**\n * Return `true` if this Runnable has passed.\n * @return {boolean}\n * @private\n */\nRunnable.prototype.isPassed = function () {\n  return !this.isPending() && this.state === 'passed';\n};\n\n/**\n * Set or get number of retries.\n *\n * @api private\n */\nRunnable.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  this._retries = n;\n};\n\n/**\n * Set or get current retry\n *\n * @api private\n */\nRunnable.prototype.currentRetry = function (n) {\n  if (!arguments.length) {\n    return this._currentRetry;\n  }\n  this._currentRetry = n;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by concatenating the parent's title path with the title.\n *\n * @memberof Mocha.Runnable\n * @public\n * @api public\n * @return {string}\n */\nRunnable.prototype.titlePath = function () {\n  return this.parent.titlePath().concat([this.title]);\n};\n\n/**\n * Clear the timeout.\n *\n * @api private\n */\nRunnable.prototype.clearTimeout = function () {\n  clearTimeout(this.timer);\n};\n\n/**\n * Inspect the runnable void of private properties.\n *\n * @api private\n * @return {string}\n */\nRunnable.prototype.inspect = function () {\n  return JSON.stringify(this, function (key, val) {\n    if (key[0] === '_') {\n      return;\n    }\n    if (key === 'parent') {\n      return '#<Suite>';\n    }\n    if (key === 'ctx') {\n      return '#<Context>';\n    }\n    return val;\n  }, 2);\n};\n\n/**\n * Reset the timeout.\n *\n * @api private\n */\nRunnable.prototype.resetTimeout = function () {\n  var self = this;\n  var ms = this.timeout() || 1e9;\n\n  if (!this._enableTimeouts) {\n    return;\n  }\n  this.clearTimeout();\n  this.timer = setTimeout(function () {\n    if (!self._enableTimeouts) {\n      return;\n    }\n    self.callback(self._timeoutError(ms));\n    self.timedOut = true;\n  }, ms);\n};\n\n/**\n * Set or get a list of whitelisted globals for this test run.\n *\n * @api private\n * @param {string[]} globals\n */\nRunnable.prototype.globals = function (globals) {\n  if (!arguments.length) {\n    return this._allowedGlobals;\n  }\n  this._allowedGlobals = globals;\n};\n\n/**\n * Run the test and invoke `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunnable.prototype.run = function (fn) {\n  var self = this;\n  var start = new Date();\n  var ctx = this.ctx;\n  var finished;\n  var emitted;\n\n  // Sometimes the ctx exists, but it is not runnable\n  if (ctx && ctx.runnable) {\n    ctx.runnable(this);\n  }\n\n  // called multiple times\n  function multiple (err) {\n    if (emitted) {\n      return;\n    }\n    emitted = true;\n    var msg = 'done() called multiple times';\n    if (err && err.message) {\n      err.message += \" (and Mocha's \" + msg + ')';\n      self.emit('error', err);\n    } else {\n      self.emit('error', new Error(msg));\n    }\n  }\n\n  // finished\n  function done (err) {\n    var ms = self.timeout();\n    if (self.timedOut) {\n      return;\n    }\n\n    if (finished) {\n      return multiple(err);\n    }\n\n    self.clearTimeout();\n    self.duration = new Date() - start;\n    finished = true;\n    if (!err && self.duration > ms && self._enableTimeouts) {\n      err = self._timeoutError(ms);\n    }\n    fn(err);\n  }\n\n  // for .resetTimeout()\n  this.callback = done;\n\n  // explicit async with `done` argument\n  if (this.async) {\n    this.resetTimeout();\n\n    // allows skip() to be used in an explicit async context\n    this.skip = function asyncSkip () {\n      done(new Pending('async skip call'));\n      // halt execution.  the Runnable will be marked pending\n      // by the previous call, and the uncaught handler will ignore\n      // the failure.\n      throw new Pending('async skip; aborting execution');\n    };\n\n    if (this.allowUncaught) {\n      return callFnAsync(this.fn);\n    }\n    try {\n      callFnAsync(this.fn);\n    } catch (err) {\n      emitted = true;\n      done(utils.getError(err));\n    }\n    return;\n  }\n\n  if (this.allowUncaught) {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n    return;\n  }\n\n  // sync or promise-returning\n  try {\n    if (this.isPending()) {\n      done();\n    } else {\n      callFn(this.fn);\n    }\n  } catch (err) {\n    emitted = true;\n    done(utils.getError(err));\n  }\n\n  function callFn (fn) {\n    var result = fn.call(ctx);\n    if (result && typeof result.then === 'function') {\n      self.resetTimeout();\n      result\n        .then(function () {\n          done();\n          // Return null so libraries like bluebird do not warn about\n          // subsequently constructed Promises.\n          return null;\n        },\n        function (reason) {\n          done(reason || new Error('Promise rejected with no or falsy reason'));\n        });\n    } else {\n      if (self.asyncOnly) {\n        return done(new Error('--async-only option in use without declaring `done()` or returning a promise'));\n      }\n\n      done();\n    }\n  }\n\n  function callFnAsync (fn) {\n    var result = fn.call(ctx, function (err) {\n      if (err instanceof Error || toString.call(err) === '[object Error]') {\n        return done(err);\n      }\n      if (err) {\n        if (Object.prototype.toString.call(err) === '[object Object]') {\n          return done(new Error('done() invoked with non-Error: ' +\n            JSON.stringify(err)));\n        }\n        return done(new Error('done() invoked with non-Error: ' + err));\n      }\n      if (result && utils.isPromise(result)) {\n        return done(new Error('Resolution method is overspecified. Specify a callback *or* return a Promise; not both.'));\n      }\n\n      done();\n    });\n  }\n};\n\n/**\n * Instantiates a \"timeout\" error\n *\n * @param {number} ms - Timeout (in milliseconds)\n * @returns {Error} a \"timeout\" error\n * @private\n */\nRunnable.prototype._timeoutError = function (ms) {\n  var msg = 'Timeout of ' + ms + 'ms exceeded. For async tests and hooks, ensure \"done()\" is called; if returning a Promise, ensure it resolves.';\n  if (this.file) {\n    msg += ' (' + this.file + ')';\n  }\n  return new Error(msg);\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./ms\":14,\"./pending\":15,\"./utils\":36,\"debug\":43,\"events\":47}],33:[function(require,module,exports){\n(function (process,global){\n'use strict';\n\n/**\n * @module Runner\n */\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Pending = require('./pending');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:runner');\nvar Runnable = require('./runnable');\nvar stackFilter = utils.stackTraceFilter();\nvar stringify = utils.stringify;\nvar type = utils.type;\nvar undefinedError = utils.undefinedError;\n\n/**\n * Non-enumerable globals.\n */\n\nvar globals = [\n  'setTimeout',\n  'clearTimeout',\n  'setInterval',\n  'clearInterval',\n  'XMLHttpRequest',\n  'Date',\n  'setImmediate',\n  'clearImmediate'\n];\n\n/**\n * Expose `Runner`.\n */\n\nmodule.exports = Runner;\n\n/**\n * Initialize a `Runner` for the given `suite`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * Events:\n *\n *   - `start`  execution started\n *   - `end`  execution complete\n *   - `suite`  (suite) test suite execution started\n *   - `suite end`  (suite) all tests (and sub-suites) have finished\n *   - `test`  (test) test execution started\n *   - `test end`  (test) test completed\n *   - `hook`  (hook) hook execution started\n *   - `hook end`  (hook) hook complete\n *   - `pass`  (test) test passed\n *   - `fail`  (test, err) test failed\n *   - `pending`  (test) test pending\n *\n * @memberof Mocha\n * @public\n * @class\n * @api public\n * @param {Suite} [suite] Root suite\n * @param {boolean} [delay] Whether or not to delay execution of root suite\n * until ready.\n */\nfunction Runner (suite, delay) {\n  var self = this;\n  this._globals = [];\n  this._abort = false;\n  this._delay = delay;\n  this.suite = suite;\n  this.started = false;\n  this.total = suite.total();\n  this.failures = 0;\n  this.on('test end', function (test) {\n    self.checkGlobals(test);\n  });\n  this.on('hook end', function (hook) {\n    self.checkGlobals(hook);\n  });\n  this._defaultGrep = /.*/;\n  this.grep(this._defaultGrep);\n  this.globals(this.globalProps().concat(extraGlobals()));\n}\n\n/**\n * Wrapper for setImmediate, process.nextTick, or browser polyfill.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.immediately = global.setImmediate || process.nextTick;\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Runner, EventEmitter);\n\n/**\n * Run tests with full titles matching `re`. Updates runner.total\n * with number of tests matched.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {RegExp} re\n * @param {boolean} invert\n * @return {Runner} Runner instance.\n */\nRunner.prototype.grep = function (re, invert) {\n  debug('grep %s', re);\n  this._grep = re;\n  this._invert = invert;\n  this.total = this.grepTotal(this.suite);\n  return this;\n};\n\n/**\n * Returns the number of tests matching the grep search for the\n * given suite.\n *\n * @memberof Mocha.Runner\n * @api public\n * @public\n * @param {Suite} suite\n * @return {number}\n */\nRunner.prototype.grepTotal = function (suite) {\n  var self = this;\n  var total = 0;\n\n  suite.eachTest(function (test) {\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (match) {\n      total++;\n    }\n  });\n\n  return total;\n};\n\n/**\n * Return a list of global properties.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.globalProps = function () {\n  var props = Object.keys(global);\n\n  // non-enumerables\n  for (var i = 0; i < globals.length; ++i) {\n    if (~props.indexOf(globals[i])) {\n      continue;\n    }\n    props.push(globals[i]);\n  }\n\n  return props;\n};\n\n/**\n * Allow the given `arr` of globals.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Array} arr\n * @return {Runner} Runner instance.\n */\nRunner.prototype.globals = function (arr) {\n  if (!arguments.length) {\n    return this._globals;\n  }\n  debug('globals %j', arr);\n  this._globals = this._globals.concat(arr);\n  return this;\n};\n\n/**\n * Check for global variable leaks.\n *\n * @api private\n */\nRunner.prototype.checkGlobals = function (test) {\n  if (this.ignoreLeaks) {\n    return;\n  }\n  var ok = this._globals;\n\n  var globals = this.globalProps();\n  var leaks;\n\n  if (test) {\n    ok = ok.concat(test._allowedGlobals || []);\n  }\n\n  if (this.prevGlobalsLength === globals.length) {\n    return;\n  }\n  this.prevGlobalsLength = globals.length;\n\n  leaks = filterLeaks(ok, globals);\n  this._globals = this._globals.concat(leaks);\n\n  if (leaks.length > 1) {\n    this.fail(test, new Error('global leaks detected: ' + leaks.join(', ') + ''));\n  } else if (leaks.length) {\n    this.fail(test, new Error('global leak detected: ' + leaks[0]));\n  }\n};\n\n/**\n * Fail the given `test`.\n *\n * @api private\n * @param {Test} test\n * @param {Error} err\n */\nRunner.prototype.fail = function (test, err) {\n  if (test.isPending()) {\n    return;\n  }\n\n  ++this.failures;\n  test.state = 'failed';\n\n  if (!(err instanceof Error || (err && typeof err.message === 'string'))) {\n    err = new Error('the ' + type(err) + ' ' + stringify(err) + ' was thrown, throw an Error :)');\n  }\n\n  try {\n    err.stack = (this.fullStackTrace || !err.stack)\n      ? err.stack\n      : stackFilter(err.stack);\n  } catch (ignored) {\n    // some environments do not take kindly to monkeying with the stack\n  }\n\n  this.emit('fail', test, err);\n};\n\n/**\n * Fail the given `hook` with `err`.\n *\n * Hook failures work in the following pattern:\n * - If bail, then exit\n * - Failed `before` hook skips all tests in a suite and subsuites,\n *   but jumps to corresponding `after` hook\n * - Failed `before each` hook skips remaining tests in a\n *   suite and jumps to corresponding `after each` hook,\n *   which is run only once\n * - Failed `after` hook does not alter\n *   execution order\n * - Failed `after each` hook skips remaining tests in a\n *   suite and subsuites, but executes other `after each`\n *   hooks\n *\n * @api private\n * @param {Hook} hook\n * @param {Error} err\n */\nRunner.prototype.failHook = function (hook, err) {\n  if (hook.ctx && hook.ctx.currentTest) {\n    hook.originalTitle = hook.originalTitle || hook.title;\n    hook.title = hook.originalTitle + ' for \"' + hook.ctx.currentTest.title + '\"';\n  }\n\n  if (this.suite.bail()) {\n    this.emit('end');\n  }\n  this.fail(hook, err);\n};\n\n/**\n * Run hook `name` callbacks and then invoke `fn()`.\n *\n * @api private\n * @param {string} name\n * @param {Function} fn\n */\n\nRunner.prototype.hook = function (name, fn) {\n  var suite = this.suite;\n  var hooks = suite['_' + name];\n  var self = this;\n\n  function next (i) {\n    var hook = hooks[i];\n    if (!hook) {\n      return fn();\n    }\n    self.currentRunnable = hook;\n\n    hook.ctx.currentTest = self.test;\n\n    self.emit('hook', hook);\n\n    if (!hook.listeners('error').length) {\n      hook.on('error', function (err) {\n        self.failHook(hook, err);\n      });\n    }\n\n    hook.run(function (err) {\n      var testError = hook.error();\n      if (testError) {\n        self.fail(self.test, testError);\n      }\n      if (err) {\n        if (err instanceof Pending) {\n          if (name === 'beforeEach' || name === 'afterEach') {\n            self.test.pending = true;\n          } else {\n            suite.tests.forEach(function (test) {\n              test.pending = true;\n            });\n            // a pending hook won't be executed twice.\n            hook.pending = true;\n          }\n        } else {\n          self.failHook(hook, err);\n\n          // stop executing hooks, notify callee of hook err\n          return fn(err);\n        }\n      }\n      self.emit('hook end', hook);\n      delete hook.ctx.currentTest;\n      next(++i);\n    });\n  }\n\n  Runner.immediately(function () {\n    next(0);\n  });\n};\n\n/**\n * Run hook `name` for the given array of `suites`\n * in order, and callback `fn(err, errSuite)`.\n *\n * @api private\n * @param {string} name\n * @param {Array} suites\n * @param {Function} fn\n */\nRunner.prototype.hooks = function (name, suites, fn) {\n  var self = this;\n  var orig = this.suite;\n\n  function next (suite) {\n    self.suite = suite;\n\n    if (!suite) {\n      self.suite = orig;\n      return fn();\n    }\n\n    self.hook(name, function (err) {\n      if (err) {\n        var errSuite = self.suite;\n        self.suite = orig;\n        return fn(err, errSuite);\n      }\n\n      next(suites.pop());\n    });\n  }\n\n  next(suites.pop());\n};\n\n/**\n * Run hooks from the top level down.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookUp = function (name, fn) {\n  var suites = [this.suite].concat(this.parents()).reverse();\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Run hooks from the bottom up.\n *\n * @param {String} name\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.hookDown = function (name, fn) {\n  var suites = [this.suite].concat(this.parents());\n  this.hooks(name, suites, fn);\n};\n\n/**\n * Return an array of parent Suites from\n * closest to furthest.\n *\n * @return {Array}\n * @api private\n */\nRunner.prototype.parents = function () {\n  var suite = this.suite;\n  var suites = [];\n  while (suite.parent) {\n    suite = suite.parent;\n    suites.push(suite);\n  }\n  return suites;\n};\n\n/**\n * Run the current test and callback `fn(err)`.\n *\n * @param {Function} fn\n * @api private\n */\nRunner.prototype.runTest = function (fn) {\n  var self = this;\n  var test = this.test;\n\n  if (!test) {\n    return;\n  }\n  if (this.forbidOnly && hasOnly(this.parents().reverse()[0] || this.suite)) {\n    fn(new Error('`.only` forbidden'));\n    return;\n  }\n  if (this.asyncOnly) {\n    test.asyncOnly = true;\n  }\n  test.on('error', function (err) {\n    self.fail(test, err);\n  });\n  if (this.allowUncaught) {\n    test.allowUncaught = true;\n    return test.run(fn);\n  }\n  try {\n    test.run(fn);\n  } catch (err) {\n    fn(err);\n  }\n};\n\n/**\n * Run tests in the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runTests = function (suite, fn) {\n  var self = this;\n  var tests = suite.tests.slice();\n  var test;\n\n  function hookErr (_, errSuite, after) {\n    // before/after Each hook for errSuite failed:\n    var orig = self.suite;\n\n    // for failed 'after each' hook start from errSuite parent,\n    // otherwise start from errSuite itself\n    self.suite = after ? errSuite.parent : errSuite;\n\n    if (self.suite) {\n      // call hookUp afterEach\n      self.hookUp('afterEach', function (err2, errSuite2) {\n        self.suite = orig;\n        // some hooks may fail even now\n        if (err2) {\n          return hookErr(err2, errSuite2, true);\n        }\n        // report error suite\n        fn(errSuite);\n      });\n    } else {\n      // there is no need calling other 'after each' hooks\n      self.suite = orig;\n      fn(errSuite);\n    }\n  }\n\n  function next (err, errSuite) {\n    // if we bail after first err\n    if (self.failures && suite._bail) {\n      return fn();\n    }\n\n    if (self._abort) {\n      return fn();\n    }\n\n    if (err) {\n      return hookErr(err, errSuite, true);\n    }\n\n    // next test\n    test = tests.shift();\n\n    // all done\n    if (!test) {\n      return fn();\n    }\n\n    // grep\n    var match = self._grep.test(test.fullTitle());\n    if (self._invert) {\n      match = !match;\n    }\n    if (!match) {\n      // Run immediately only if we have defined a grep. When we\n      // define a grep  It can cause maximum callstack error if\n      // the grep is doing a large recursive loop by neglecting\n      // all tests. The run immediately function also comes with\n      // a performance cost. So we don't want to run immediately\n      // if we run the whole test suite, because running the whole\n      // test suite don't do any immediate recursive loops. Thus,\n      // allowing a JS runtime to breathe.\n      if (self._grep !== self._defaultGrep) {\n        Runner.immediately(next);\n      } else {\n        next();\n      }\n      return;\n    }\n\n    if (test.isPending()) {\n      if (self.forbidPending) {\n        test.isPending = alwaysFalse;\n        self.fail(test, new Error('Pending test forbidden'));\n        delete test.isPending;\n      } else {\n        self.emit('pending', test);\n      }\n      self.emit('test end', test);\n      return next();\n    }\n\n    // execute test and hook(s)\n    self.emit('test', self.test = test);\n    self.hookDown('beforeEach', function (err, errSuite) {\n      if (test.isPending()) {\n        if (self.forbidPending) {\n          test.isPending = alwaysFalse;\n          self.fail(test, new Error('Pending test forbidden'));\n          delete test.isPending;\n        } else {\n          self.emit('pending', test);\n        }\n        self.emit('test end', test);\n        return next();\n      }\n      if (err) {\n        return hookErr(err, errSuite, false);\n      }\n      self.currentRunnable = self.test;\n      self.runTest(function (err) {\n        test = self.test;\n        if (err) {\n          var retry = test.currentRetry();\n          if (err instanceof Pending && self.forbidPending) {\n            self.fail(test, new Error('Pending test forbidden'));\n          } else if (err instanceof Pending) {\n            test.pending = true;\n            self.emit('pending', test);\n          } else if (retry < test.retries()) {\n            var clonedTest = test.clone();\n            clonedTest.currentRetry(retry + 1);\n            tests.unshift(clonedTest);\n\n            // Early return + hook trigger so that it doesn't\n            // increment the count wrong\n            return self.hookUp('afterEach', next);\n          } else {\n            self.fail(test, err);\n          }\n          self.emit('test end', test);\n\n          if (err instanceof Pending) {\n            return next();\n          }\n\n          return self.hookUp('afterEach', next);\n        }\n\n        test.state = 'passed';\n        self.emit('pass', test);\n        self.emit('test end', test);\n        self.hookUp('afterEach', next);\n      });\n    });\n  }\n\n  this.next = next;\n  this.hookErr = hookErr;\n  next();\n};\n\nfunction alwaysFalse () {\n  return false;\n}\n\n/**\n * Run the given `suite` and invoke the callback `fn()` when complete.\n *\n * @api private\n * @param {Suite} suite\n * @param {Function} fn\n */\nRunner.prototype.runSuite = function (suite, fn) {\n  var i = 0;\n  var self = this;\n  var total = this.grepTotal(suite);\n  var afterAllHookCalled = false;\n\n  debug('run suite %s', suite.fullTitle());\n\n  if (!total || (self.failures && suite._bail)) {\n    return fn();\n  }\n\n  this.emit('suite', this.suite = suite);\n\n  function next (errSuite) {\n    if (errSuite) {\n      // current suite failed on a hook from errSuite\n      if (errSuite === suite) {\n        // if errSuite is current suite\n        // continue to the next sibling suite\n        return done();\n      }\n      // errSuite is among the parents of current suite\n      // stop execution of errSuite and all sub-suites\n      return done(errSuite);\n    }\n\n    if (self._abort) {\n      return done();\n    }\n\n    var curr = suite.suites[i++];\n    if (!curr) {\n      return done();\n    }\n\n    // Avoid grep neglecting large number of tests causing a\n    // huge recursive loop and thus a maximum call stack error.\n    // See comment in `this.runTests()` for more information.\n    if (self._grep !== self._defaultGrep) {\n      Runner.immediately(function () {\n        self.runSuite(curr, next);\n      });\n    } else {\n      self.runSuite(curr, next);\n    }\n  }\n\n  function done (errSuite) {\n    self.suite = suite;\n    self.nextSuite = next;\n\n    if (afterAllHookCalled) {\n      fn(errSuite);\n    } else {\n      // mark that the afterAll block has been called once\n      // and so can be skipped if there is an error in it.\n      afterAllHookCalled = true;\n\n      // remove reference to test\n      delete self.test;\n\n      self.hook('afterAll', function () {\n        self.emit('suite end', suite);\n        fn(errSuite);\n      });\n    }\n  }\n\n  this.nextSuite = next;\n\n  this.hook('beforeAll', function (err) {\n    if (err) {\n      return done();\n    }\n    self.runTests(suite, next);\n  });\n};\n\n/**\n * Handle uncaught exceptions.\n *\n * @param {Error} err\n * @api private\n */\nRunner.prototype.uncaught = function (err) {\n  if (err) {\n    debug('uncaught exception %s', err === (function () {\n      return this;\n    }.call(err)) ? (err.message || err) : err);\n  } else {\n    debug('uncaught undefined exception');\n    err = undefinedError();\n  }\n  err.uncaught = true;\n\n  var runnable = this.currentRunnable;\n\n  if (!runnable) {\n    runnable = new Runnable('Uncaught error outside test suite');\n    runnable.parent = this.suite;\n\n    if (this.started) {\n      this.fail(runnable, err);\n    } else {\n      // Can't recover from this failure\n      this.emit('start');\n      this.fail(runnable, err);\n      this.emit('end');\n    }\n\n    return;\n  }\n\n  runnable.clearTimeout();\n\n  // Ignore errors if already failed or pending\n  // See #3226\n  if (runnable.isFailed() || runnable.isPending()) {\n    return;\n  }\n  // we cannot recover gracefully if a Runnable has already passed\n  // then fails asynchronously\n  var alreadyPassed = runnable.isPassed();\n  // this will change the state to \"failed\" regardless of the current value\n  this.fail(runnable, err);\n  if (!alreadyPassed) {\n    // recover from test\n    if (runnable.type === 'test') {\n      this.emit('test end', runnable);\n      this.hookUp('afterEach', this.next);\n      return;\n    }\n\n    // recover from hooks\n    var errSuite = this.suite;\n    // if hook failure is in afterEach block\n    if (runnable.fullTitle().indexOf('after each') > -1) {\n      return this.hookErr(err, errSuite, true);\n    }\n    // if hook failure is in beforeEach block\n    if (runnable.fullTitle().indexOf('before each') > -1) {\n      return this.hookErr(err, errSuite, false);\n    }\n    // if hook failure is in after or before blocks\n    return this.nextSuite(errSuite);\n  }\n\n  // bail\n  this.emit('end');\n};\n\n/**\n * Cleans up the references to all the deferred functions\n * (before/after/beforeEach/afterEach) and tests of a Suite.\n * These must be deleted otherwise a memory leak can happen,\n * as those functions may reference variables from closures,\n * thus those variables can never be garbage collected as long\n * as the deferred functions exist.\n *\n * @param {Suite} suite\n */\nfunction cleanSuiteReferences (suite) {\n  function cleanArrReferences (arr) {\n    for (var i = 0; i < arr.length; i++) {\n      delete arr[i].fn;\n    }\n  }\n\n  if (Array.isArray(suite._beforeAll)) {\n    cleanArrReferences(suite._beforeAll);\n  }\n\n  if (Array.isArray(suite._beforeEach)) {\n    cleanArrReferences(suite._beforeEach);\n  }\n\n  if (Array.isArray(suite._afterAll)) {\n    cleanArrReferences(suite._afterAll);\n  }\n\n  if (Array.isArray(suite._afterEach)) {\n    cleanArrReferences(suite._afterEach);\n  }\n\n  for (var i = 0; i < suite.tests.length; i++) {\n    delete suite.tests[i].fn;\n  }\n}\n\n/**\n * Run the root suite and invoke `fn(failures)`\n * on completion.\n *\n * @api public\n * @public\n * @memberof Mocha.Runner\n * @param {Function} fn\n * @return {Runner} Runner instance.\n */\nRunner.prototype.run = function (fn) {\n  var self = this;\n  var rootSuite = this.suite;\n\n  fn = fn || function () {};\n\n  function uncaught (err) {\n    self.uncaught(err);\n  }\n\n  function start () {\n    // If there is an `only` filter\n    if (hasOnly(rootSuite)) {\n      filterOnly(rootSuite);\n    }\n    self.started = true;\n    self.emit('start');\n    self.runSuite(rootSuite, function () {\n      debug('finished running');\n      self.emit('end');\n    });\n  }\n\n  debug('start');\n\n  // references cleanup to avoid memory leaks\n  this.on('suite end', cleanSuiteReferences);\n\n  // callback\n  this.on('end', function () {\n    debug('end');\n    process.removeListener('uncaughtException', uncaught);\n    fn(self.failures);\n  });\n\n  // uncaught exception\n  process.on('uncaughtException', uncaught);\n\n  if (this._delay) {\n    // for reporters, I guess.\n    // might be nice to debounce some dots while we wait.\n    this.emit('waiting', rootSuite);\n    rootSuite.once('run', start);\n  } else {\n    start();\n  }\n\n  return this;\n};\n\n/**\n * Cleanly abort execution.\n *\n * @memberof Mocha.Runner\n * @public\n * @api public\n * @return {Runner} Runner instance.\n */\nRunner.prototype.abort = function () {\n  debug('aborting');\n  this._abort = true;\n\n  return this;\n};\n\n/**\n * Filter suites based on `isOnly` logic.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction filterOnly (suite) {\n  if (suite._onlyTests.length) {\n    // If the suite contains `only` tests, run those and ignore any nested suites.\n    suite.tests = suite._onlyTests;\n    suite.suites = [];\n  } else {\n    // Otherwise, do not run any of the tests in this suite.\n    suite.tests = [];\n    suite._onlySuites.forEach(function (onlySuite) {\n      // If there are other `only` tests/suites nested in the current `only` suite, then filter that `only` suite.\n      // Otherwise, all of the tests on this `only` suite should be run, so don't filter it.\n      if (hasOnly(onlySuite)) {\n        filterOnly(onlySuite);\n      }\n    });\n    // Run the `only` suites, as well as any other suites that have `only` tests/suites as descendants.\n    suite.suites = suite.suites.filter(function (childSuite) {\n      return suite._onlySuites.indexOf(childSuite) !== -1 || filterOnly(childSuite);\n    });\n  }\n  // Keep the suite only if there is something to run\n  return suite.tests.length || suite.suites.length;\n}\n\n/**\n * Determines whether a suite has an `only` test or suite as a descendant.\n *\n * @param {Array} suite\n * @returns {Boolean}\n * @api private\n */\nfunction hasOnly (suite) {\n  return suite._onlyTests.length || suite._onlySuites.length || suite.suites.some(hasOnly);\n}\n\n/**\n * Filter leaks with the given globals flagged as `ok`.\n *\n * @api private\n * @param {Array} ok\n * @param {Array} globals\n * @return {Array}\n */\nfunction filterLeaks (ok, globals) {\n  return globals.filter(function (key) {\n    // Firefox and Chrome exposes iframes as index inside the window object\n    if (/^\\d+/.test(key)) {\n      return false;\n    }\n\n    // in firefox\n    // if runner runs in an iframe, this iframe's window.getInterface method\n    // not init at first it is assigned in some seconds\n    if (global.navigator && (/^getInterface/).test(key)) {\n      return false;\n    }\n\n    // an iframe could be approached by window[iframeIndex]\n    // in ie6,7,8 and opera, iframeIndex is enumerable, this could cause leak\n    if (global.navigator && (/^\\d+/).test(key)) {\n      return false;\n    }\n\n    // Opera and IE expose global variables for HTML element IDs (issue #243)\n    if (/^mocha-/.test(key)) {\n      return false;\n    }\n\n    var matched = ok.filter(function (ok) {\n      if (~ok.indexOf('*')) {\n        return key.indexOf(ok.split('*')[0]) === 0;\n      }\n      return key === ok;\n    });\n    return !matched.length && (!global.navigator || key !== 'onerror');\n  });\n}\n\n/**\n * Array of globals dependent on the environment.\n *\n * @return {Array}\n * @api private\n */\nfunction extraGlobals () {\n  if (typeof process === 'object' && typeof process.version === 'string') {\n    var parts = process.version.split('.');\n    var nodeVersion = parts.reduce(function (a, v) {\n      return a << 8 | v;\n    });\n\n    // 'errno' was renamed to process._errno in v0.9.11.\n\n    if (nodeVersion < 0x00090B) {\n      return ['errno'];\n    }\n  }\n\n  return [];\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./pending\":15,\"./runnable\":32,\"./utils\":36,\"_process\":56,\"debug\":43,\"events\":47}],34:[function(require,module,exports){\n'use strict';\n/**\n * @module Suite\n */\n\n/**\n * Module dependencies.\n */\nvar EventEmitter = require('events').EventEmitter;\nvar Hook = require('./hook');\nvar utils = require('./utils');\nvar inherits = utils.inherits;\nvar debug = require('debug')('mocha:suite');\nvar milliseconds = require('./ms');\n\n/**\n * Expose `Suite`.\n */\n\nexports = module.exports = Suite;\n\n/**\n * Create a new `Suite` with the given `title` and parent `Suite`. When a suite\n * with the same title is already present, that suite is returned to provide\n * nicer reporter and more flexible meta-testing.\n *\n * @memberof Mocha\n * @public\n * @api public\n * @param {Suite} parent\n * @param {string} title\n * @return {Suite}\n */\nexports.create = function (parent, title) {\n  var suite = new Suite(title, parent.ctx);\n  suite.parent = parent;\n  title = suite.fullTitle();\n  parent.addSuite(suite);\n  return suite;\n};\n\n/**\n * Initialize a new `Suite` with the given `title` and `ctx`. Derived from [EventEmitter](https://nodejs.org/api/events.html#events_class_eventemitter)\n *\n * @memberof Mocha\n * @public\n * @class\n * @param {string} title\n * @param {Context} parentContext\n */\nfunction Suite (title, parentContext) {\n  if (!utils.isString(title)) {\n    throw new Error('Suite `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  this.title = title;\n  function Context () {}\n  Context.prototype = parentContext;\n  this.ctx = new Context();\n  this.suites = [];\n  this.tests = [];\n  this.pending = false;\n  this._beforeEach = [];\n  this._beforeAll = [];\n  this._afterEach = [];\n  this._afterAll = [];\n  this.root = !title;\n  this._timeout = 2000;\n  this._enableTimeouts = true;\n  this._slow = 75;\n  this._bail = false;\n  this._retries = -1;\n  this._onlyTests = [];\n  this._onlySuites = [];\n  this.delayed = false;\n}\n\n/**\n * Inherit from `EventEmitter.prototype`.\n */\ninherits(Suite, EventEmitter);\n\n/**\n * Return a clone of this `Suite`.\n *\n * @api private\n * @return {Suite}\n */\nSuite.prototype.clone = function () {\n  var suite = new Suite(this.title);\n  debug('clone');\n  suite.ctx = this.ctx;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  return suite;\n};\n\n/**\n * Set or get timeout `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.timeout = function (ms) {\n  if (!arguments.length) {\n    return this._timeout;\n  }\n  if (ms.toString() === '0') {\n    this._enableTimeouts = false;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('timeout %d', ms);\n  this._timeout = parseInt(ms, 10);\n  return this;\n};\n\n/**\n * Set or get number of times to retry a failed test.\n *\n * @api private\n * @param {number|string} n\n * @return {Suite|number} for chaining\n */\nSuite.prototype.retries = function (n) {\n  if (!arguments.length) {\n    return this._retries;\n  }\n  debug('retries %d', n);\n  this._retries = parseInt(n, 10) || 0;\n  return this;\n};\n\n/**\n  * Set or get timeout to `enabled`.\n  *\n  * @api private\n  * @param {boolean} enabled\n  * @return {Suite|boolean} self or enabled\n  */\nSuite.prototype.enableTimeouts = function (enabled) {\n  if (!arguments.length) {\n    return this._enableTimeouts;\n  }\n  debug('enableTimeouts %s', enabled);\n  this._enableTimeouts = enabled;\n  return this;\n};\n\n/**\n * Set or get slow `ms` or short-hand such as \"2s\".\n *\n * @api private\n * @param {number|string} ms\n * @return {Suite|number} for chaining\n */\nSuite.prototype.slow = function (ms) {\n  if (!arguments.length) {\n    return this._slow;\n  }\n  if (typeof ms === 'string') {\n    ms = milliseconds(ms);\n  }\n  debug('slow %d', ms);\n  this._slow = ms;\n  return this;\n};\n\n/**\n * Set or get whether to bail after first error.\n *\n * @api private\n * @param {boolean} bail\n * @return {Suite|number} for chaining\n */\nSuite.prototype.bail = function (bail) {\n  if (!arguments.length) {\n    return this._bail;\n  }\n  debug('bail %s', bail);\n  this._bail = bail;\n  return this;\n};\n\n/**\n * Check if this suite or its parent suite is marked as pending.\n *\n * @api private\n */\nSuite.prototype.isPending = function () {\n  return this.pending || (this.parent && this.parent.isPending());\n};\n\n/**\n * Generic hook-creator.\n * @private\n * @param {string} title - Title of hook\n * @param {Function} fn - Hook callback\n * @returns {Hook} A new hook\n */\nSuite.prototype._createHook = function (title, fn) {\n  var hook = new Hook(title, fn);\n  hook.parent = this;\n  hook.timeout(this.timeout());\n  hook.retries(this.retries());\n  hook.enableTimeouts(this.enableTimeouts());\n  hook.slow(this.slow());\n  hook.ctx = this.ctx;\n  hook.file = this.file;\n  return hook;\n};\n\n/**\n * Run `fn(test[, done])` before running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeAll.push(hook);\n  this.emit('beforeAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after running tests.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterAll = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after all\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterAll.push(hook);\n  this.emit('afterAll', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` before each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.beforeEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"before each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._beforeEach.push(hook);\n  this.emit('beforeEach', hook);\n  return this;\n};\n\n/**\n * Run `fn(test[, done])` after each test case.\n *\n * @api private\n * @param {string} title\n * @param {Function} fn\n * @return {Suite} for chaining\n */\nSuite.prototype.afterEach = function (title, fn) {\n  if (this.isPending()) {\n    return this;\n  }\n  if (typeof title === 'function') {\n    fn = title;\n    title = fn.name;\n  }\n  title = '\"after each\" hook' + (title ? ': ' + title : '');\n\n  var hook = this._createHook(title, fn);\n  this._afterEach.push(hook);\n  this.emit('afterEach', hook);\n  return this;\n};\n\n/**\n * Add a test `suite`.\n *\n * @api private\n * @param {Suite} suite\n * @return {Suite} for chaining\n */\nSuite.prototype.addSuite = function (suite) {\n  suite.parent = this;\n  suite.timeout(this.timeout());\n  suite.retries(this.retries());\n  suite.enableTimeouts(this.enableTimeouts());\n  suite.slow(this.slow());\n  suite.bail(this.bail());\n  this.suites.push(suite);\n  this.emit('suite', suite);\n  return this;\n};\n\n/**\n * Add a `test` to this suite.\n *\n * @api private\n * @param {Test} test\n * @return {Suite} for chaining\n */\nSuite.prototype.addTest = function (test) {\n  test.parent = this;\n  test.timeout(this.timeout());\n  test.retries(this.retries());\n  test.enableTimeouts(this.enableTimeouts());\n  test.slow(this.slow());\n  test.ctx = this.ctx;\n  this.tests.push(test);\n  this.emit('test', test);\n  return this;\n};\n\n/**\n * Return the full title generated by recursively concatenating the parent's\n * full title.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.fullTitle = function () {\n  return this.titlePath().join(' ');\n};\n\n/**\n * Return the title path generated by recursively concatenating the parent's\n * title path.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {string}\n */\nSuite.prototype.titlePath = function () {\n  var result = [];\n  if (this.parent) {\n    result = result.concat(this.parent.titlePath());\n  }\n  if (!this.root) {\n    result.push(this.title);\n  }\n  return result;\n};\n\n/**\n * Return the total number of tests.\n *\n * @memberof Mocha.Suite\n * @public\n * @api public\n * @return {number}\n */\nSuite.prototype.total = function () {\n  return this.suites.reduce(function (sum, suite) {\n    return sum + suite.total();\n  }, 0) + this.tests.length;\n};\n\n/**\n * Iterates through each suite recursively to find all tests. Applies a\n * function in the format `fn(test)`.\n *\n * @api private\n * @param {Function} fn\n * @return {Suite}\n */\nSuite.prototype.eachTest = function (fn) {\n  this.tests.forEach(fn);\n  this.suites.forEach(function (suite) {\n    suite.eachTest(fn);\n  });\n  return this;\n};\n\n/**\n * This will run the root suite if we happen to be running in delayed mode.\n */\nSuite.prototype.run = function run () {\n  if (this.root) {\n    this.emit('run');\n  }\n};\n\n},{\"./hook\":6,\"./ms\":14,\"./utils\":36,\"debug\":43,\"events\":47}],35:[function(require,module,exports){\n'use strict';\n\n/**\n * Module dependencies.\n */\n\nvar Runnable = require('./runnable');\nvar utils = require('./utils');\nvar isString = utils.isString;\n\n/**\n * Expose `Test`.\n */\n\nmodule.exports = Test;\n\n/**\n * Initialize a new `Test` with the given `title` and callback `fn`.\n *\n * @api private\n * @param {String} title\n * @param {Function} fn\n */\nfunction Test (title, fn) {\n  if (!isString(title)) {\n    throw new Error('Test `title` should be a \"string\" but \"' + typeof title + '\" was given instead.');\n  }\n  Runnable.call(this, title, fn);\n  this.pending = !fn;\n  this.type = 'test';\n}\n\n/**\n * Inherit from `Runnable.prototype`.\n */\nutils.inherits(Test, Runnable);\n\nTest.prototype.clone = function () {\n  var test = new Test(this.title, this.fn);\n  test.timeout(this.timeout());\n  test.slow(this.slow());\n  test.enableTimeouts(this.enableTimeouts());\n  test.retries(this.retries());\n  test.currentRetry(this.currentRetry());\n  test.globals(this.globals());\n  test.parent = this.parent;\n  test.file = this.file;\n  test.ctx = this.ctx;\n  return test;\n};\n\n},{\"./runnable\":32,\"./utils\":36}],36:[function(require,module,exports){\n(function (process,Buffer){\n'use strict';\n\n/**\n * @module\n */\n\n/**\n * Module dependencies.\n */\n\nvar debug = require('debug')('mocha:watch');\nvar fs = require('fs');\nvar glob = require('glob');\nvar path = require('path');\nvar join = path.join;\nvar he = require('he');\n\n/**\n * Ignored directories.\n */\n\nvar ignore = ['node_modules', '.git'];\n\nexports.inherits = require('util').inherits;\n\n/**\n * Escape special characters in the given string of html.\n *\n * @api private\n * @param  {string} html\n * @return {string}\n */\nexports.escape = function (html) {\n  return he.encode(String(html), { useNamedReferences: false });\n};\n\n/**\n * Test if the given obj is type of string.\n *\n * @api private\n * @param {Object} obj\n * @return {boolean}\n */\nexports.isString = function (obj) {\n  return typeof obj === 'string';\n};\n\n/**\n * Watch the given `files` for changes\n * and invoke `fn(file)` on modification.\n *\n * @api private\n * @param {Array} files\n * @param {Function} fn\n */\nexports.watch = function (files, fn) {\n  var options = { interval: 100 };\n  files.forEach(function (file) {\n    debug('file %s', file);\n    fs.watchFile(file, options, function (curr, prev) {\n      if (prev.mtime < curr.mtime) {\n        fn(file);\n      }\n    });\n  });\n};\n\n/**\n * Ignored files.\n *\n * @api private\n * @param {string} path\n * @return {boolean}\n */\nfunction ignored (path) {\n  return !~ignore.indexOf(path);\n}\n\n/**\n * Lookup files in the given `dir`.\n *\n * @api private\n * @param {string} dir\n * @param {string[]} [ext=['.js']]\n * @param {Array} [ret=[]]\n * @return {Array}\n */\nexports.files = function (dir, ext, ret) {\n  ret = ret || [];\n  ext = ext || ['js'];\n\n  var re = new RegExp('\\\\.(' + ext.join('|') + ')$');\n\n  fs.readdirSync(dir)\n    .filter(ignored)\n    .forEach(function (path) {\n      path = join(dir, path);\n      if (fs.lstatSync(path).isDirectory()) {\n        exports.files(path, ext, ret);\n      } else if (path.match(re)) {\n        ret.push(path);\n      }\n    });\n\n  return ret;\n};\n\n/**\n * Compute a slug from the given `str`.\n *\n * @api private\n * @param {string} str\n * @return {string}\n */\nexports.slug = function (str) {\n  return str\n    .toLowerCase()\n    .replace(/ +/g, '-')\n    .replace(/[^-\\w]/g, '');\n};\n\n/**\n * Strip the function definition from `str`, and re-indent for pre whitespace.\n *\n * @param {string} str\n * @return {string}\n */\nexports.clean = function (str) {\n  str = str\n    .replace(/\\r\\n?|[\\n\\u2028\\u2029]/g, '\\n').replace(/^\\uFEFF/, '')\n    // (traditional)->  space/name     parameters    body     (lambda)-> parameters       body   multi-statement/single          keep body content\n    .replace(/^function(?:\\s*|\\s+[^(]*)\\([^)]*\\)\\s*\\{((?:.|\\n)*?)\\s*\\}$|^\\([^)]*\\)\\s*=>\\s*(?:\\{((?:.|\\n)*?)\\s*\\}|((?:.|\\n)*))$/, '$1$2$3');\n\n  var spaces = str.match(/^\\n?( *)/)[1].length;\n  var tabs = str.match(/^\\n?(\\t*)/)[1].length;\n  var re = new RegExp('^\\n?' + (tabs ? '\\t' : ' ') + '{' + (tabs || spaces) + '}', 'gm');\n\n  str = str.replace(re, '');\n\n  return str.trim();\n};\n\n/**\n * Parse the given `qs`.\n *\n * @api private\n * @param {string} qs\n * @return {Object}\n */\nexports.parseQuery = function (qs) {\n  return qs.replace('?', '').split('&').reduce(function (obj, pair) {\n    var i = pair.indexOf('=');\n    var key = pair.slice(0, i);\n    var val = pair.slice(++i);\n\n    // Due to how the URLSearchParams API treats spaces\n    obj[key] = decodeURIComponent(val.replace(/\\+/g, '%20'));\n\n    return obj;\n  }, {});\n};\n\n/**\n * Highlight the given string of `js`.\n *\n * @api private\n * @param {string} js\n * @return {string}\n */\nfunction highlight (js) {\n  return js\n    .replace(/</g, '&lt;')\n    .replace(/>/g, '&gt;')\n    .replace(/\\/\\/(.*)/gm, '<span class=\"comment\">//$1</span>')\n    .replace(/('.*?')/gm, '<span class=\"string\">$1</span>')\n    .replace(/(\\d+\\.\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/(\\d+)/gm, '<span class=\"number\">$1</span>')\n    .replace(/\\bnew[ \\t]+(\\w+)/gm, '<span class=\"keyword\">new</span> <span class=\"init\">$1</span>')\n    .replace(/\\b(function|new|throw|return|var|if|else)\\b/gm, '<span class=\"keyword\">$1</span>');\n}\n\n/**\n * Highlight the contents of tag `name`.\n *\n * @api private\n * @param {string} name\n */\nexports.highlightTags = function (name) {\n  var code = document.getElementById('mocha').getElementsByTagName(name);\n  for (var i = 0, len = code.length; i < len; ++i) {\n    code[i].innerHTML = highlight(code[i].innerHTML);\n  }\n};\n\n/**\n * If a value could have properties, and has none, this function is called,\n * which returns a string representation of the empty value.\n *\n * Functions w/ no properties return `'[Function]'`\n * Arrays w/ length === 0 return `'[]'`\n * Objects w/ no properties return `'{}'`\n * All else: return result of `value.toString()`\n *\n * @api private\n * @param {*} value The value to inspect.\n * @param {string} typeHint The type of the value\n * @returns {string}\n */\nfunction emptyRepresentation (value, typeHint) {\n  switch (typeHint) {\n    case 'function':\n      return '[Function]';\n    case 'object':\n      return '{}';\n    case 'array':\n      return '[]';\n    default:\n      return value.toString();\n  }\n}\n\n/**\n * Takes some variable and asks `Object.prototype.toString()` what it thinks it\n * is.\n *\n * @api private\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString\n * @param {*} value The value to test.\n * @returns {string} Computed type\n * @example\n * type({}) // 'object'\n * type([]) // 'array'\n * type(1) // 'number'\n * type(false) // 'boolean'\n * type(Infinity) // 'number'\n * type(null) // 'null'\n * type(new Date()) // 'date'\n * type(/foo/) // 'regexp'\n * type('type') // 'string'\n * type(global) // 'global'\n * type(new String('foo') // 'object'\n */\nvar type = exports.type = function type (value) {\n  if (value === undefined) {\n    return 'undefined';\n  } else if (value === null) {\n    return 'null';\n  } else if (Buffer.isBuffer(value)) {\n    return 'buffer';\n  }\n  return Object.prototype.toString.call(value)\n    .replace(/^\\[.+\\s(.+?)]$/, '$1')\n    .toLowerCase();\n};\n\n/**\n * Stringify `value`. Different behavior depending on type of value:\n *\n * - If `value` is undefined or null, return `'[undefined]'` or `'[null]'`, respectively.\n * - If `value` is not an object, function or array, return result of `value.toString()` wrapped in double-quotes.\n * - If `value` is an *empty* object, function, or array, return result of function\n *   {@link emptyRepresentation}.\n * - If `value` has properties, call {@link exports.canonicalize} on it, then return result of\n *   JSON.stringify().\n *\n * @api private\n * @see exports.type\n * @param {*} value\n * @return {string}\n */\nexports.stringify = function (value) {\n  var typeHint = type(value);\n\n  if (!~['object', 'array', 'function'].indexOf(typeHint)) {\n    if (typeHint === 'buffer') {\n      var json = Buffer.prototype.toJSON.call(value);\n      // Based on the toJSON result\n      return jsonStringify(json.data && json.type ? json.data : json, 2)\n        .replace(/,(\\n|$)/g, '$1');\n    }\n\n    // IE7/IE8 has a bizarre String constructor; needs to be coerced\n    // into an array and back to obj.\n    if (typeHint === 'string' && typeof value === 'object') {\n      value = value.split('').reduce(function (acc, char, idx) {\n        acc[idx] = char;\n        return acc;\n      }, {});\n      typeHint = 'object';\n    } else {\n      return jsonStringify(value);\n    }\n  }\n\n  for (var prop in value) {\n    if (Object.prototype.hasOwnProperty.call(value, prop)) {\n      return jsonStringify(exports.canonicalize(value, null, typeHint), 2).replace(/,(\\n|$)/g, '$1');\n    }\n  }\n\n  return emptyRepresentation(value, typeHint);\n};\n\n/**\n * like JSON.stringify but more sense.\n *\n * @api private\n * @param {Object}  object\n * @param {number=} spaces\n * @param {number=} depth\n * @returns {*}\n */\nfunction jsonStringify (object, spaces, depth) {\n  if (typeof spaces === 'undefined') {\n    // primitive types\n    return _stringify(object);\n  }\n\n  depth = depth || 1;\n  var space = spaces * depth;\n  var str = Array.isArray(object) ? '[' : '{';\n  var end = Array.isArray(object) ? ']' : '}';\n  var length = typeof object.length === 'number' ? object.length : Object.keys(object).length;\n  // `.repeat()` polyfill\n  function repeat (s, n) {\n    return new Array(n).join(s);\n  }\n\n  function _stringify (val) {\n    switch (type(val)) {\n      case 'null':\n      case 'undefined':\n        val = '[' + val + ']';\n        break;\n      case 'array':\n      case 'object':\n        val = jsonStringify(val, spaces, depth + 1);\n        break;\n      case 'boolean':\n      case 'regexp':\n      case 'symbol':\n      case 'number':\n        val = val === 0 && (1 / val) === -Infinity // `-0`\n          ? '-0'\n          : val.toString();\n        break;\n      case 'date':\n        var sDate = isNaN(val.getTime()) ? val.toString() : val.toISOString();\n        val = '[Date: ' + sDate + ']';\n        break;\n      case 'buffer':\n        var json = val.toJSON();\n        // Based on the toJSON result\n        json = json.data && json.type ? json.data : json;\n        val = '[Buffer: ' + jsonStringify(json, 2, depth + 1) + ']';\n        break;\n      default:\n        val = (val === '[Function]' || val === '[Circular]')\n          ? val\n          : JSON.stringify(val); // string\n    }\n    return val;\n  }\n\n  for (var i in object) {\n    if (!Object.prototype.hasOwnProperty.call(object, i)) {\n      continue; // not my business\n    }\n    --length;\n    str += '\\n ' + repeat(' ', space) +\n      (Array.isArray(object) ? '' : '\"' + i + '\": ') + // key\n      _stringify(object[i]) + // value\n      (length ? ',' : ''); // comma\n  }\n\n  return str +\n    // [], {}\n    (str.length !== 1 ? '\\n' + repeat(' ', --space) + end : end);\n}\n\n/**\n * Return a new Thing that has the keys in sorted order. Recursive.\n *\n * If the Thing...\n * - has already been seen, return string `'[Circular]'`\n * - is `undefined`, return string `'[undefined]'`\n * - is `null`, return value `null`\n * - is some other primitive, return the value\n * - is not a primitive or an `Array`, `Object`, or `Function`, return the value of the Thing's `toString()` method\n * - is a non-empty `Array`, `Object`, or `Function`, return the result of calling this function again.\n * - is an empty `Array`, `Object`, or `Function`, return the result of calling `emptyRepresentation()`\n *\n * @api private\n * @see {@link exports.stringify}\n * @param {*} value Thing to inspect.  May or may not have properties.\n * @param {Array} [stack=[]] Stack of seen values\n * @param {string} [typeHint] Type hint\n * @return {(Object|Array|Function|string|undefined)}\n */\nexports.canonicalize = function canonicalize (value, stack, typeHint) {\n  var canonicalizedObj;\n  /* eslint-disable no-unused-vars */\n  var prop;\n  /* eslint-enable no-unused-vars */\n  typeHint = typeHint || type(value);\n  function withStack (value, fn) {\n    stack.push(value);\n    fn();\n    stack.pop();\n  }\n\n  stack = stack || [];\n\n  if (stack.indexOf(value) !== -1) {\n    return '[Circular]';\n  }\n\n  switch (typeHint) {\n    case 'undefined':\n    case 'buffer':\n    case 'null':\n      canonicalizedObj = value;\n      break;\n    case 'array':\n      withStack(value, function () {\n        canonicalizedObj = value.map(function (item) {\n          return exports.canonicalize(item, stack);\n        });\n      });\n      break;\n    case 'function':\n      /* eslint-disable guard-for-in */\n      for (prop in value) {\n        canonicalizedObj = {};\n        break;\n      }\n      /* eslint-enable guard-for-in */\n      if (!canonicalizedObj) {\n        canonicalizedObj = emptyRepresentation(value, typeHint);\n        break;\n      }\n    /* falls through */\n    case 'object':\n      canonicalizedObj = canonicalizedObj || {};\n      withStack(value, function () {\n        Object.keys(value).sort().forEach(function (key) {\n          canonicalizedObj[key] = exports.canonicalize(value[key], stack);\n        });\n      });\n      break;\n    case 'date':\n    case 'number':\n    case 'regexp':\n    case 'boolean':\n    case 'symbol':\n      canonicalizedObj = value;\n      break;\n    default:\n      canonicalizedObj = value + '';\n  }\n\n  return canonicalizedObj;\n};\n\n/**\n * Lookup file names at the given `path`.\n *\n * @memberof Mocha.utils\n * @public\n * @api public\n * @param {string} filepath Base path to start searching from.\n * @param {string[]} extensions File extensions to look for.\n * @param {boolean} recursive Whether or not to recurse into subdirectories.\n * @return {string[]} An array of paths.\n */\nexports.lookupFiles = function lookupFiles (filepath, extensions, recursive) {\n  var files = [];\n\n  if (!fs.existsSync(filepath)) {\n    if (fs.existsSync(filepath + '.js')) {\n      filepath += '.js';\n    } else {\n      files = glob.sync(filepath);\n      if (!files.length) {\n        throw new Error(\"cannot resolve path (or pattern) '\" + filepath + \"'\");\n      }\n      return files;\n    }\n  }\n\n  try {\n    var stat = fs.statSync(filepath);\n    if (stat.isFile()) {\n      return filepath;\n    }\n  } catch (err) {\n    // ignore error\n    return;\n  }\n\n  fs.readdirSync(filepath).forEach(function (file) {\n    file = path.join(filepath, file);\n    try {\n      var stat = fs.statSync(file);\n      if (stat.isDirectory()) {\n        if (recursive) {\n          files = files.concat(lookupFiles(file, extensions, recursive));\n        }\n        return;\n      }\n    } catch (err) {\n      // ignore error\n      return;\n    }\n    var re = new RegExp('\\\\.(?:' + extensions.join('|') + ')$');\n    if (!stat.isFile() || !re.test(file) || path.basename(file)[0] === '.') {\n      return;\n    }\n    files.push(file);\n  });\n\n  return files;\n};\n\n/**\n * Generate an undefined error with a message warning the user.\n *\n * @return {Error}\n */\n\nexports.undefinedError = function () {\n  return new Error('Caught undefined error, did you throw without specifying what?');\n};\n\n/**\n * Generate an undefined error if `err` is not defined.\n *\n * @param {Error} err\n * @return {Error}\n */\n\nexports.getError = function (err) {\n  return err || exports.undefinedError();\n};\n\n/**\n * @summary\n * This Filter based on `mocha-clean` module.(see: `github.com/rstacruz/mocha-clean`)\n * @description\n * When invoking this function you get a filter function that get the Error.stack as an input,\n * and return a prettify output.\n * (i.e: strip Mocha and internal node functions from stack trace).\n * @returns {Function}\n */\nexports.stackTraceFilter = function () {\n  // TODO: Replace with `process.browser`\n  var is = typeof document === 'undefined' ? { node: true } : { browser: true };\n  var slash = path.sep;\n  var cwd;\n  if (is.node) {\n    cwd = process.cwd() + slash;\n  } else {\n    cwd = (typeof location === 'undefined'\n      ? window.location\n      : location).href.replace(/\\/[^/]*$/, '/');\n    slash = '/';\n  }\n\n  function isMochaInternal (line) {\n    return (~line.indexOf('node_modules' + slash + 'mocha' + slash)) ||\n      (~line.indexOf('node_modules' + slash + 'mocha.js')) ||\n      (~line.indexOf('bower_components' + slash + 'mocha.js')) ||\n      (~line.indexOf(slash + 'mocha.js'));\n  }\n\n  function isNodeInternal (line) {\n    return (~line.indexOf('(timers.js:')) ||\n      (~line.indexOf('(events.js:')) ||\n      (~line.indexOf('(node.js:')) ||\n      (~line.indexOf('(module.js:')) ||\n      (~line.indexOf('GeneratorFunctionPrototype.next (native)')) ||\n      false;\n  }\n\n  return function (stack) {\n    stack = stack.split('\\n');\n\n    stack = stack.reduce(function (list, line) {\n      if (isMochaInternal(line)) {\n        return list;\n      }\n\n      if (is.node && isNodeInternal(line)) {\n        return list;\n      }\n\n      // Clean up cwd(absolute)\n      if (/\\(?.+:\\d+:\\d+\\)?$/.test(line)) {\n        line = line.replace('(' + cwd, '(');\n      }\n\n      list.push(line);\n      return list;\n    }, []);\n\n    return stack.join('\\n');\n  };\n};\n\n/**\n * Crude, but effective.\n * @api\n * @param {*} value\n * @returns {boolean} Whether or not `value` is a Promise\n */\nexports.isPromise = function isPromise (value) {\n  return typeof value === 'object' && typeof value.then === 'function';\n};\n\n/**\n * It's a noop.\n * @api\n */\nexports.noop = function () {};\n\n}).call(this,require('_process'),require(\"buffer\").Buffer)\n},{\"_process\":56,\"buffer\":41,\"debug\":43,\"fs\":40,\"glob\":40,\"he\":48,\"path\":40,\"util\":76}],37:[function(require,module,exports){\n'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction placeHoldersCount (b64) {\n  var len = b64.length\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // the number of equal signs (place holders)\n  // if there are two placeholders, than the two characters before it\n  // represent one byte\n  // if there is only one, then the three characters before it represent 2 bytes\n  // this is just a cheap hack to not do indexOf twice\n  return b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0\n}\n\nfunction byteLength (b64) {\n  // base64 is 4/3 + up to two characters of the original data\n  return (b64.length * 3 / 4) - placeHoldersCount(b64)\n}\n\nfunction toByteArray (b64) {\n  var i, l, tmp, placeHolders, arr\n  var len = b64.length\n  placeHolders = placeHoldersCount(b64)\n\n  arr = new Arr((len * 3 / 4) - placeHolders)\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  l = placeHolders > 0 ? len - 4 : len\n\n  var L = 0\n\n  for (i = 0; i < l; i += 4) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 18) | (revLookup[b64.charCodeAt(i + 1)] << 12) | (revLookup[b64.charCodeAt(i + 2)] << 6) | revLookup[b64.charCodeAt(i + 3)]\n    arr[L++] = (tmp >> 16) & 0xFF\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  if (placeHolders === 2) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 2) | (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[L++] = tmp & 0xFF\n  } else if (placeHolders === 1) {\n    tmp = (revLookup[b64.charCodeAt(i)] << 10) | (revLookup[b64.charCodeAt(i + 1)] << 4) | (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[L++] = (tmp >> 8) & 0xFF\n    arr[L++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + (uint8[i + 2])\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var output = ''\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    output += lookup[tmp >> 2]\n    output += lookup[(tmp << 4) & 0x3F]\n    output += '=='\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + (uint8[len - 1])\n    output += lookup[tmp >> 10]\n    output += lookup[(tmp >> 4) & 0x3F]\n    output += lookup[(tmp << 2) & 0x3F]\n    output += '='\n  }\n\n  parts.push(output)\n\n  return parts.join('')\n}\n\n},{}],38:[function(require,module,exports){\n\n},{}],39:[function(require,module,exports){\n(function (process){\nvar WritableStream = require('stream').Writable\nvar inherits = require('util').inherits\n\nmodule.exports = BrowserStdout\n\n\ninherits(BrowserStdout, WritableStream)\n\nfunction BrowserStdout(opts) {\n  if (!(this instanceof BrowserStdout)) return new BrowserStdout(opts)\n\n  opts = opts || {}\n  WritableStream.call(this, opts)\n  this.label = (opts.label !== undefined) ? opts.label : 'stdout'\n}\n\nBrowserStdout.prototype._write = function(chunks, encoding, cb) {\n  var output = chunks.toString ? chunks.toString() : chunks\n  if (this.label === false) {\n    console.log(output)\n  } else {\n    console.log(this.label+':', output)\n  }\n  process.nextTick(cb)\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"stream\":71,\"util\":76}],40:[function(require,module,exports){\narguments[4][38][0].apply(exports,arguments)\n},{\"dup\":38}],41:[function(require,module,exports){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\nvar K_MAX_LENGTH = 0x7fffffff\nexports.kMaxLength = K_MAX_LENGTH\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Print warning and recommend using `buffer` v4.x which has an Object\n *               implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * We report that the browser does not support typed arrays if the are not subclassable\n * using __proto__. Firefox 4-29 lacks support for adding new properties to `Uint8Array`\n * (See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438). IE 10 lacks support\n * for __proto__ and has a buggy typed array implementation.\n */\nBuffer.TYPED_ARRAY_SUPPORT = typedArraySupport()\n\nif (!Buffer.TYPED_ARRAY_SUPPORT && typeof console !== 'undefined' &&\n    typeof console.error === 'function') {\n  console.error(\n    'This browser lacks typed array (Uint8Array) support which is required by ' +\n    '`buffer` v5.x. Use `buffer` v4.x if you require old browser support.'\n  )\n}\n\nfunction typedArraySupport () {\n  // Can typed array instances can be augmented?\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42\n  } catch (e) {\n    return false\n  }\n}\n\nfunction createBuffer (length) {\n  if (length > K_MAX_LENGTH) {\n    throw new RangeError('Invalid typed array length')\n  }\n  // Return an augmented `Uint8Array` instance\n  var buf = new Uint8Array(length)\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(arg)\n  }\n  return from(arg, encodingOrOffset, length)\n}\n\n// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\nif (typeof Symbol !== 'undefined' && Symbol.species &&\n    Buffer[Symbol.species] === Buffer) {\n  Object.defineProperty(Buffer, Symbol.species, {\n    value: null,\n    configurable: true,\n    enumerable: false,\n    writable: false\n  })\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\nfunction from (value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (isArrayBuffer(value)) {\n    return fromArrayBuffer(value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(value, encodingOrOffset)\n  }\n\n  return fromObject(value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(value, encodingOrOffset, length)\n}\n\n// Note: Change prototype *after* Buffer.from is defined to workaround Chrome bug:\n// https://github.com/feross/buffer/pull/148\nBuffer.prototype.__proto__ = Uint8Array.prototype\nBuffer.__proto__ = Uint8Array\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(size).fill(fill, encoding)\n      : createBuffer(size).fill(fill)\n  }\n  return createBuffer(size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(size, fill, encoding)\n}\n\nfunction allocUnsafe (size) {\n  assertSize(size)\n  return createBuffer(size < 0 ? 0 : checked(size) | 0)\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(size)\n}\n\nfunction fromString (string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  var buf = createBuffer(length)\n\n  var actual = buf.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    buf = buf.slice(0, actual)\n  }\n\n  return buf\n}\n\nfunction fromArrayLike (array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  var buf = createBuffer(length)\n  for (var i = 0; i < length; i += 1) {\n    buf[i] = array[i] & 255\n  }\n  return buf\n}\n\nfunction fromArrayBuffer (array, byteOffset, length) {\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  var buf\n  if (byteOffset === undefined && length === undefined) {\n    buf = new Uint8Array(array)\n  } else if (length === undefined) {\n    buf = new Uint8Array(array, byteOffset)\n  } else {\n    buf = new Uint8Array(array, byteOffset, length)\n  }\n\n  // Return an augmented `Uint8Array` instance\n  buf.__proto__ = Buffer.prototype\n  return buf\n}\n\nfunction fromObject (obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    var buf = createBuffer(len)\n\n    if (buf.length === 0) {\n      return buf\n    }\n\n    obj.copy(buf, 0, 0, len)\n    return buf\n  }\n\n  if (obj) {\n    if (isArrayBufferView(obj) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || numberIsNaN(obj.length)) {\n        return createBuffer(0)\n      }\n      return fromArrayLike(obj)\n    }\n\n    if (obj.type === 'Buffer' && Array.isArray(obj.data)) {\n      return fromArrayLike(obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < K_MAX_LENGTH` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= K_MAX_LENGTH) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + K_MAX_LENGTH.toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return b != null && b._isBuffer === true\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!Array.isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (isArrayBufferView(string) || isArrayBuffer(string)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// This property is used by `Buffer.isBuffer` (and the `is-buffer` npm package)\n// to detect a Buffer instance. It's not possible to use `instanceof Buffer`\n// reliably in a browserify context because there could be multiple different\n// copies of the 'buffer' package in use. This method works even for Buffer\n// instances that were created from another copy of the `buffer` package.\n// See: https://github.com/feross/buffer/issues/154\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (numberIsNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (numberIsNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset >>> 0\n    if (isFinite(length)) {\n      length = length >>> 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + (bytes[i + 1] * 256))\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf = this.subarray(start, end)\n  // Return an augmented `Uint8Array` instance\n  newBuf.__proto__ = Buffer.prototype\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  offset = offset >>> 0\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  byteLength = byteLength >>> 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset + 3] = (value >>> 24)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 1] = (value >>> 8)\n  this[offset] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    var limit = Math.pow(2, (8 * byteLength) - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  this[offset] = (value >>> 8)\n  this[offset + 1] = (value & 0xff)\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  this[offset] = (value & 0xff)\n  this[offset + 1] = (value >>> 8)\n  this[offset + 2] = (value >>> 16)\n  this[offset + 3] = (value >>> 24)\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  this[offset] = (value >>> 24)\n  this[offset + 1] = (value >>> 16)\n  this[offset + 2] = (value >>> 8)\n  this[offset + 3] = (value & 0xff)\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  value = +value\n  offset = offset >>> 0\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : new Buffer(val, encoding)\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = str.trim().replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\n// ArrayBuffers from another context (i.e. an iframe) do not pass the `instanceof` check\n// but they should be treated as valid. See: https://github.com/feross/buffer/issues/166\nfunction isArrayBuffer (obj) {\n  return obj instanceof ArrayBuffer ||\n    (obj != null && obj.constructor != null && obj.constructor.name === 'ArrayBuffer' &&\n      typeof obj.byteLength === 'number')\n}\n\n// Node 0.10 supports `ArrayBuffer` but lacks `ArrayBuffer.isView`\nfunction isArrayBufferView (obj) {\n  return (typeof ArrayBuffer.isView === 'function') && ArrayBuffer.isView(obj)\n}\n\nfunction numberIsNaN (obj) {\n  return obj !== obj // eslint-disable-line no-self-compare\n}\n\n},{\"base64-js\":37,\"ieee754\":49}],42:[function(require,module,exports){\n(function (Buffer){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\n\nfunction isArray(arg) {\n  if (Array.isArray) {\n    return Array.isArray(arg);\n  }\n  return objectToString(arg) === '[object Array]';\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = Buffer.isBuffer;\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n}).call(this,{\"isBuffer\":require(\"../../is-buffer/index.js\")})\n},{\"../../is-buffer/index.js\":51}],43:[function(require,module,exports){\n(function (process){\n/**\n * This is the web browser implementation of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = require('./debug');\nexports.log = log;\nexports.formatArgs = formatArgs;\nexports.save = save;\nexports.load = load;\nexports.useColors = useColors;\nexports.storage = 'undefined' != typeof chrome\n               && 'undefined' != typeof chrome.storage\n                  ? chrome.storage.local\n                  : localstorage();\n\n/**\n * Colors.\n */\n\nexports.colors = [\n  '#0000CC', '#0000FF', '#0033CC', '#0033FF', '#0066CC', '#0066FF', '#0099CC',\n  '#0099FF', '#00CC00', '#00CC33', '#00CC66', '#00CC99', '#00CCCC', '#00CCFF',\n  '#3300CC', '#3300FF', '#3333CC', '#3333FF', '#3366CC', '#3366FF', '#3399CC',\n  '#3399FF', '#33CC00', '#33CC33', '#33CC66', '#33CC99', '#33CCCC', '#33CCFF',\n  '#6600CC', '#6600FF', '#6633CC', '#6633FF', '#66CC00', '#66CC33', '#9900CC',\n  '#9900FF', '#9933CC', '#9933FF', '#99CC00', '#99CC33', '#CC0000', '#CC0033',\n  '#CC0066', '#CC0099', '#CC00CC', '#CC00FF', '#CC3300', '#CC3333', '#CC3366',\n  '#CC3399', '#CC33CC', '#CC33FF', '#CC6600', '#CC6633', '#CC9900', '#CC9933',\n  '#CCCC00', '#CCCC33', '#FF0000', '#FF0033', '#FF0066', '#FF0099', '#FF00CC',\n  '#FF00FF', '#FF3300', '#FF3333', '#FF3366', '#FF3399', '#FF33CC', '#FF33FF',\n  '#FF6600', '#FF6633', '#FF9900', '#FF9933', '#FFCC00', '#FFCC33'\n];\n\n/**\n * Currently only WebKit-based Web Inspectors, Firefox >= v31,\n * and the Firebug extension (any Firefox version) are known\n * to support \"%c\" CSS customizations.\n *\n * TODO: add a `localStorage` variable to explicitly enable/disable colors\n */\n\nfunction useColors() {\n  // NB: In an Electron preload script, document will be defined but not fully\n  // initialized. Since we know we're in Chrome, we'll just detect this case\n  // explicitly\n  if (typeof window !== 'undefined' && window.process && window.process.type === 'renderer') {\n    return true;\n  }\n\n  // Internet Explorer and Edge do not support colors.\n  if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\\/(\\d+)/)) {\n    return false;\n  }\n\n  // is webkit? http://stackoverflow.com/a/16459606/376773\n  // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632\n  return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||\n    // is firebug? http://stackoverflow.com/a/398120/376773\n    (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||\n    // is firefox >= v31?\n    // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\\/(\\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||\n    // double check webkit in userAgent just in case we are in a worker\n    (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\\/(\\d+)/));\n}\n\n/**\n * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.\n */\n\nexports.formatters.j = function(v) {\n  try {\n    return JSON.stringify(v);\n  } catch (err) {\n    return '[UnexpectedJSONParseError]: ' + err.message;\n  }\n};\n\n\n/**\n * Colorize log arguments if enabled.\n *\n * @api public\n */\n\nfunction formatArgs(args) {\n  var useColors = this.useColors;\n\n  args[0] = (useColors ? '%c' : '')\n    + this.namespace\n    + (useColors ? ' %c' : ' ')\n    + args[0]\n    + (useColors ? '%c ' : ' ')\n    + '+' + exports.humanize(this.diff);\n\n  if (!useColors) return;\n\n  var c = 'color: ' + this.color;\n  args.splice(1, 0, c, 'color: inherit')\n\n  // the final \"%c\" is somewhat tricky, because there could be other\n  // arguments passed either before or after the %c, so we need to\n  // figure out the correct index to insert the CSS into\n  var index = 0;\n  var lastC = 0;\n  args[0].replace(/%[a-zA-Z%]/g, function(match) {\n    if ('%%' === match) return;\n    index++;\n    if ('%c' === match) {\n      // we only are interested in the *last* %c\n      // (the user may have provided their own)\n      lastC = index;\n    }\n  });\n\n  args.splice(lastC, 0, c);\n}\n\n/**\n * Invokes `console.log()` when available.\n * No-op when `console.log` is not a \"function\".\n *\n * @api public\n */\n\nfunction log() {\n  // this hackery is required for IE8/9, where\n  // the `console.log` function doesn't have 'apply'\n  return 'object' === typeof console\n    && console.log\n    && Function.prototype.apply.call(console.log, console, arguments);\n}\n\n/**\n * Save `namespaces`.\n *\n * @param {String} namespaces\n * @api private\n */\n\nfunction save(namespaces) {\n  try {\n    if (null == namespaces) {\n      exports.storage.removeItem('debug');\n    } else {\n      exports.storage.debug = namespaces;\n    }\n  } catch(e) {}\n}\n\n/**\n * Load `namespaces`.\n *\n * @return {String} returns the previously persisted debug modes\n * @api private\n */\n\nfunction load() {\n  var r;\n  try {\n    r = exports.storage.debug;\n  } catch(e) {}\n\n  // If debug isn't set in LS, and we're in Electron, try to load $DEBUG\n  if (!r && typeof process !== 'undefined' && 'env' in process) {\n    r = process.env.DEBUG;\n  }\n\n  return r;\n}\n\n/**\n * Enable namespaces listed in `localStorage.debug` initially.\n */\n\nexports.enable(load());\n\n/**\n * Localstorage attempts to return the localstorage.\n *\n * This is necessary because safari throws\n * when a user disables cookies/localstorage\n * and you attempt to access it.\n *\n * @return {LocalStorage}\n * @api private\n */\n\nfunction localstorage() {\n  try {\n    return window.localStorage;\n  } catch (e) {}\n}\n\n}).call(this,require('_process'))\n},{\"./debug\":44,\"_process\":56}],44:[function(require,module,exports){\n\n/**\n * This is the common logic for both the Node.js and web browser\n * implementations of `debug()`.\n *\n * Expose `debug()` as the module.\n */\n\nexports = module.exports = createDebug.debug = createDebug['default'] = createDebug;\nexports.coerce = coerce;\nexports.disable = disable;\nexports.enable = enable;\nexports.enabled = enabled;\nexports.humanize = require('ms');\n\n/**\n * Active `debug` instances.\n */\nexports.instances = [];\n\n/**\n * The currently active debug mode names, and names to skip.\n */\n\nexports.names = [];\nexports.skips = [];\n\n/**\n * Map of special \"%n\" handling functions, for the debug \"format\" argument.\n *\n * Valid key names are a single, lower or upper-case letter, i.e. \"n\" and \"N\".\n */\n\nexports.formatters = {};\n\n/**\n * Select a color.\n * @param {String} namespace\n * @return {Number}\n * @api private\n */\n\nfunction selectColor(namespace) {\n  var hash = 0, i;\n\n  for (i in namespace) {\n    hash  = ((hash << 5) - hash) + namespace.charCodeAt(i);\n    hash |= 0; // Convert to 32bit integer\n  }\n\n  return exports.colors[Math.abs(hash) % exports.colors.length];\n}\n\n/**\n * Create a debugger with the given `namespace`.\n *\n * @param {String} namespace\n * @return {Function}\n * @api public\n */\n\nfunction createDebug(namespace) {\n\n  var prevTime;\n\n  function debug() {\n    // disabled?\n    if (!debug.enabled) return;\n\n    var self = debug;\n\n    // set `diff` timestamp\n    var curr = +new Date();\n    var ms = curr - (prevTime || curr);\n    self.diff = ms;\n    self.prev = prevTime;\n    self.curr = curr;\n    prevTime = curr;\n\n    // turn the `arguments` into a proper Array\n    var args = new Array(arguments.length);\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i];\n    }\n\n    args[0] = exports.coerce(args[0]);\n\n    if ('string' !== typeof args[0]) {\n      // anything else let's inspect with %O\n      args.unshift('%O');\n    }\n\n    // apply any `formatters` transformations\n    var index = 0;\n    args[0] = args[0].replace(/%([a-zA-Z%])/g, function(match, format) {\n      // if we encounter an escaped % then don't increase the array index\n      if (match === '%%') return match;\n      index++;\n      var formatter = exports.formatters[format];\n      if ('function' === typeof formatter) {\n        var val = args[index];\n        match = formatter.call(self, val);\n\n        // now we need to remove `args[index]` since it's inlined in the `format`\n        args.splice(index, 1);\n        index--;\n      }\n      return match;\n    });\n\n    // apply env-specific formatting (colors, etc.)\n    exports.formatArgs.call(self, args);\n\n    var logFn = debug.log || exports.log || console.log.bind(console);\n    logFn.apply(self, args);\n  }\n\n  debug.namespace = namespace;\n  debug.enabled = exports.enabled(namespace);\n  debug.useColors = exports.useColors();\n  debug.color = selectColor(namespace);\n  debug.destroy = destroy;\n\n  // env-specific initialization logic for debug instances\n  if ('function' === typeof exports.init) {\n    exports.init(debug);\n  }\n\n  exports.instances.push(debug);\n\n  return debug;\n}\n\nfunction destroy () {\n  var index = exports.instances.indexOf(this);\n  if (index !== -1) {\n    exports.instances.splice(index, 1);\n    return true;\n  } else {\n    return false;\n  }\n}\n\n/**\n * Enables a debug mode by namespaces. This can include modes\n * separated by a colon and wildcards.\n *\n * @param {String} namespaces\n * @api public\n */\n\nfunction enable(namespaces) {\n  exports.save(namespaces);\n\n  exports.names = [];\n  exports.skips = [];\n\n  var i;\n  var split = (typeof namespaces === 'string' ? namespaces : '').split(/[\\s,]+/);\n  var len = split.length;\n\n  for (i = 0; i < len; i++) {\n    if (!split[i]) continue; // ignore empty strings\n    namespaces = split[i].replace(/\\*/g, '.*?');\n    if (namespaces[0] === '-') {\n      exports.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));\n    } else {\n      exports.names.push(new RegExp('^' + namespaces + '$'));\n    }\n  }\n\n  for (i = 0; i < exports.instances.length; i++) {\n    var instance = exports.instances[i];\n    instance.enabled = exports.enabled(instance.namespace);\n  }\n}\n\n/**\n * Disable debug output.\n *\n * @api public\n */\n\nfunction disable() {\n  exports.enable('');\n}\n\n/**\n * Returns true if the given mode name is enabled, false otherwise.\n *\n * @param {String} name\n * @return {Boolean}\n * @api public\n */\n\nfunction enabled(name) {\n  if (name[name.length - 1] === '*') {\n    return true;\n  }\n  var i, len;\n  for (i = 0, len = exports.skips.length; i < len; i++) {\n    if (exports.skips[i].test(name)) {\n      return false;\n    }\n  }\n  for (i = 0, len = exports.names.length; i < len; i++) {\n    if (exports.names[i].test(name)) {\n      return true;\n    }\n  }\n  return false;\n}\n\n/**\n * Coerce `val`.\n *\n * @param {Mixed} val\n * @return {Mixed}\n * @api private\n */\n\nfunction coerce(val) {\n  if (val instanceof Error) return val.stack || val.message;\n  return val;\n}\n\n},{\"ms\":54}],45:[function(require,module,exports){\n/*!\n\n diff v3.5.0\n\nSoftware License Agreement (BSD License)\n\nCopyright (c) 2009-2015, Kevin Decker <kpdecker@gmail.com>\n\nAll rights reserved.\n\nRedistribution and use of this software in source and binary forms, with or without modification,\nare permitted provided that the following conditions are met:\n\n* Redistributions of source code must retain the above\n  copyright notice, this list of conditions and the\n  following disclaimer.\n\n* Redistributions in binary form must reproduce the above\n  copyright notice, this list of conditions and the\n  following disclaimer in the documentation and/or other\n  materials provided with the distribution.\n\n* Neither the name of Kevin Decker nor the names of its\n  contributors may be used to endorse or promote products\n  derived from this software without specific prior\n  written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND ANY EXPRESS OR\nIMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\nFITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR\nCONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL\nDAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,\nDATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER\nIN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT\nOF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n@license\n*/\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(false)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"JsDiff\"] = factory();\n\telse\n\t\troot[\"JsDiff\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n\n\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.canonicalize = exports.convertChangesToXML = exports.convertChangesToDMP = exports.merge = exports.parsePatch = exports.applyPatches = exports.applyPatch = exports.createPatch = exports.createTwoFilesPatch = exports.structuredPatch = exports.diffArrays = exports.diffJson = exports.diffCss = exports.diffSentences = exports.diffTrimmedLines = exports.diffLines = exports.diffWordsWithSpace = exports.diffWords = exports.diffChars = exports.Diff = undefined;\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_character = __webpack_require__(2) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_word = __webpack_require__(3) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_sentence = __webpack_require__(6) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_css = __webpack_require__(7) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_json = __webpack_require__(8) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(9) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_apply = __webpack_require__(10) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_merge = __webpack_require__(13) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_dmp = __webpack_require__(16) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_xml = __webpack_require__(17) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/* See LICENSE file for terms of use */\n\n\t/*\n\t * Text diff implementation.\n\t *\n\t * This library supports the following APIS:\n\t * JsDiff.diffChars: Character by character diff\n\t * JsDiff.diffWords: Word (as defined by \\b regex) diff which ignores whitespace\n\t * JsDiff.diffLines: Line based diff\n\t *\n\t * JsDiff.diffCss: Diff targeted at CSS content\n\t *\n\t * These methods are based on the implementation proposed in\n\t * \"An O(ND) Difference Algorithm and its Variations\" (Myers, 1986).\n\t * http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.4.6927\n\t */\n\texports. /*istanbul ignore end*/Diff = _base2['default'];\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffChars = _character.diffChars;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWords = _word.diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = _word.diffWordsWithSpace;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffLines = _line.diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = _line.diffTrimmedLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffSentences = _sentence.diffSentences;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffCss = _css.diffCss;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffJson = _json.diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffArrays = _array.diffArrays;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/structuredPatch = _create.structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = _create.createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = _create.createPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatch = _apply.applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = _apply.applyPatches;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/parsePatch = _parse.parsePatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = _merge.merge;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToDMP = _dmp.convertChangesToDMP;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/convertChangesToXML = _xml.convertChangesToXML;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = _json.canonicalize;\n\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports['default'] = /*istanbul ignore end*/Diff;\n\tfunction Diff() {}\n\n\tDiff.prototype = {\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/diff: function diff(oldString, newString) {\n\t    /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t    var callback = options.callback;\n\t    if (typeof options === 'function') {\n\t      callback = options;\n\t      options = {};\n\t    }\n\t    this.options = options;\n\n\t    var self = this;\n\n\t    function done(value) {\n\t      if (callback) {\n\t        setTimeout(function () {\n\t          callback(undefined, value);\n\t        }, 0);\n\t        return true;\n\t      } else {\n\t        return value;\n\t      }\n\t    }\n\n\t    // Allow subclasses to massage the input prior to running\n\t    oldString = this.castInput(oldString);\n\t    newString = this.castInput(newString);\n\n\t    oldString = this.removeEmpty(this.tokenize(oldString));\n\t    newString = this.removeEmpty(this.tokenize(newString));\n\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length;\n\t    var editLength = 1;\n\t    var maxEditLength = newLen + oldLen;\n\t    var bestPath = [{ newPos: -1, components: [] }];\n\n\t    // Seed editLength = 0, i.e. the content starts with the same values\n\t    var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);\n\t    if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {\n\t      // Identity per the equality and tokenizer\n\t      return done([{ value: this.join(newString), count: newString.length }]);\n\t    }\n\n\t    // Main worker method. checks all permutations of a given edit length for acceptance.\n\t    function execEditLength() {\n\t      for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {\n\t        var basePath = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t        var addPath = bestPath[diagonalPath - 1],\n\t            removePath = bestPath[diagonalPath + 1],\n\t            _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;\n\t        if (addPath) {\n\t          // No one else is going to attempt to use this value, clear it\n\t          bestPath[diagonalPath - 1] = undefined;\n\t        }\n\n\t        var canAdd = addPath && addPath.newPos + 1 < newLen,\n\t            canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;\n\t        if (!canAdd && !canRemove) {\n\t          // If this path is a terminal then prune\n\t          bestPath[diagonalPath] = undefined;\n\t          continue;\n\t        }\n\n\t        // Select the diagonal that we want to branch from. We select the prior\n\t        // path whose position in the new string is the farthest from the origin\n\t        // and does not pass the bounds of the diff graph\n\t        if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {\n\t          basePath = clonePath(removePath);\n\t          self.pushComponent(basePath.components, undefined, true);\n\t        } else {\n\t          basePath = addPath; // No need to clone, we've pulled it from the list\n\t          basePath.newPos++;\n\t          self.pushComponent(basePath.components, true, undefined);\n\t        }\n\n\t        _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath);\n\n\t        // If we have hit the end of both strings, then we are done\n\t        if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {\n\t          return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));\n\t        } else {\n\t          // Otherwise track this path as a potential candidate and continue.\n\t          bestPath[diagonalPath] = basePath;\n\t        }\n\t      }\n\n\t      editLength++;\n\t    }\n\n\t    // Performs the length of edit iteration. Is a bit fugly as this has to support the\n\t    // sync and async mode which is never fun. Loops over execEditLength until a value\n\t    // is produced.\n\t    if (callback) {\n\t      (function exec() {\n\t        setTimeout(function () {\n\t          // This should not happen, but we want to be safe.\n\t          /* istanbul ignore next */\n\t          if (editLength > maxEditLength) {\n\t            return callback();\n\t          }\n\n\t          if (!execEditLength()) {\n\t            exec();\n\t          }\n\t        }, 0);\n\t      })();\n\t    } else {\n\t      while (editLength <= maxEditLength) {\n\t        var ret = execEditLength();\n\t        if (ret) {\n\t          return ret;\n\t        }\n\t      }\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/pushComponent: function pushComponent(components, added, removed) {\n\t    var last = components[components.length - 1];\n\t    if (last && last.added === added && last.removed === removed) {\n\t      // We need to clone here as the component clone operation is just\n\t      // as shallow array clone\n\t      components[components.length - 1] = { count: last.count + 1, added: added, removed: removed };\n\t    } else {\n\t      components.push({ count: 1, added: added, removed: removed });\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {\n\t    var newLen = newString.length,\n\t        oldLen = oldString.length,\n\t        newPos = basePath.newPos,\n\t        oldPos = newPos - diagonalPath,\n\t        commonCount = 0;\n\t    while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {\n\t      newPos++;\n\t      oldPos++;\n\t      commonCount++;\n\t    }\n\n\t    if (commonCount) {\n\t      basePath.components.push({ count: commonCount });\n\t    }\n\n\t    basePath.newPos = newPos;\n\t    return oldPos;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/equals: function equals(left, right) {\n\t    if (this.options.comparator) {\n\t      return this.options.comparator(left, right);\n\t    } else {\n\t      return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();\n\t    }\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/removeEmpty: function removeEmpty(array) {\n\t    var ret = [];\n\t    for (var i = 0; i < array.length; i++) {\n\t      if (array[i]) {\n\t        ret.push(array[i]);\n\t      }\n\t    }\n\t    return ret;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/castInput: function castInput(value) {\n\t    return value;\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/tokenize: function tokenize(value) {\n\t    return value.split('');\n\t  },\n\t  /*istanbul ignore start*/ /*istanbul ignore end*/join: function join(chars) {\n\t    return chars.join('');\n\t  }\n\t};\n\n\tfunction buildValues(diff, components, newString, oldString, useLongestToken) {\n\t  var componentPos = 0,\n\t      componentLen = components.length,\n\t      newPos = 0,\n\t      oldPos = 0;\n\n\t  for (; componentPos < componentLen; componentPos++) {\n\t    var component = components[componentPos];\n\t    if (!component.removed) {\n\t      if (!component.added && useLongestToken) {\n\t        var value = newString.slice(newPos, newPos + component.count);\n\t        value = value.map(function (value, i) {\n\t          var oldValue = oldString[oldPos + i];\n\t          return oldValue.length > value.length ? oldValue : value;\n\t        });\n\n\t        component.value = diff.join(value);\n\t      } else {\n\t        component.value = diff.join(newString.slice(newPos, newPos + component.count));\n\t      }\n\t      newPos += component.count;\n\n\t      // Common case\n\t      if (!component.added) {\n\t        oldPos += component.count;\n\t      }\n\t    } else {\n\t      component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));\n\t      oldPos += component.count;\n\n\t      // Reverse add and remove so removes are output first to match common convention\n\t      // The diffing algorithm is tied to add then remove output and this is the simplest\n\t      // route to get the desired output with minimal overhead.\n\t      if (componentPos && components[componentPos - 1].added) {\n\t        var tmp = components[componentPos - 1];\n\t        components[componentPos - 1] = components[componentPos];\n\t        components[componentPos] = tmp;\n\t      }\n\t    }\n\t  }\n\n\t  // Special case handle for when one terminal is ignored (i.e. whitespace).\n\t  // For this case we merge the terminal into the prior string and drop the change.\n\t  // This is only available for string mode.\n\t  var lastComponent = components[componentLen - 1];\n\t  if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {\n\t    components[componentLen - 2].value += lastComponent.value;\n\t    components.pop();\n\t  }\n\n\t  return components;\n\t}\n\n\tfunction clonePath(path) {\n\t  return { newPos: path.newPos, components: path.components.slice(0) };\n\t}\n\n\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.characterDiff = undefined;\n\texports. /*istanbul ignore end*/diffChars = diffChars;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var characterDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/characterDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tfunction diffChars(oldStr, newStr, options) {\n\t  return characterDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.wordDiff = undefined;\n\texports. /*istanbul ignore end*/diffWords = diffWords;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffWordsWithSpace = diffWordsWithSpace;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/ // Based on https://en.wikipedia.org/wiki/Latin_script_in_Unicode\n\t//\n\t// Ranges and exceptions:\n\t// Latin-1 Supplement, 008000FF\n\t//  - U+00D7   Multiplication sign\n\t//  - U+00F7   Division sign\n\t// Latin Extended-A, 0100017F\n\t// Latin Extended-B, 0180024F\n\t// IPA Extensions, 025002AF\n\t// Spacing Modifier Letters, 02B002FF\n\t//  - U+02C7   &#711;  Caron\n\t//  - U+02D8   &#728;  Breve\n\t//  - U+02D9   &#729;  Dot Above\n\t//  - U+02DA   &#730;  Ring Above\n\t//  - U+02DB   &#731;  Ogonek\n\t//  - U+02DC   &#732;  Small Tilde\n\t//  - U+02DD   &#733;  Double Acute Accent\n\t// Latin Extended Additional, 1E001EFF\n\tvar extendedWordChars = /^[A-Za-z\\xC0-\\u02C6\\u02C8-\\u02D7\\u02DE-\\u02FF\\u1E00-\\u1EFF]+$/;\n\n\tvar reWhitespace = /\\S/;\n\n\tvar wordDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/wordDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\twordDiff.equals = function (left, right) {\n\t  if (this.options.ignoreCase) {\n\t    left = left.toLowerCase();\n\t    right = right.toLowerCase();\n\t  }\n\t  return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);\n\t};\n\twordDiff.tokenize = function (value) {\n\t  var tokens = value.split(/(\\s+|\\b)/);\n\n\t  // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.\n\t  for (var i = 0; i < tokens.length - 1; i++) {\n\t    // If we have an empty string in the next field and we have only word chars before and after, merge\n\t    if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {\n\t      tokens[i] += tokens[i + 2];\n\t      tokens.splice(i + 1, 2);\n\t      i--;\n\t    }\n\t  }\n\n\t  return tokens;\n\t};\n\n\tfunction diffWords(oldStr, newStr, options) {\n\t  options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(options, { ignoreWhitespace: true });\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\tfunction diffWordsWithSpace(oldStr, newStr, options) {\n\t  return wordDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/generateOptions = generateOptions;\n\tfunction generateOptions(options, defaults) {\n\t  if (typeof options === 'function') {\n\t    defaults.callback = options;\n\t  } else if (options) {\n\t    for (var name in options) {\n\t      /* istanbul ignore else */\n\t      if (options.hasOwnProperty(name)) {\n\t        defaults[name] = options[name];\n\t      }\n\t    }\n\t  }\n\t  return defaults;\n\t}\n\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.lineDiff = undefined;\n\texports. /*istanbul ignore end*/diffLines = diffLines;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/diffTrimmedLines = diffTrimmedLines;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_params = __webpack_require__(4) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var lineDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/lineDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tlineDiff.tokenize = function (value) {\n\t  var retLines = [],\n\t      linesAndNewlines = value.split(/(\\n|\\r\\n)/);\n\n\t  // Ignore the final empty token that occurs if the string ends with a new line\n\t  if (!linesAndNewlines[linesAndNewlines.length - 1]) {\n\t    linesAndNewlines.pop();\n\t  }\n\n\t  // Merge the content and line separators into single tokens\n\t  for (var i = 0; i < linesAndNewlines.length; i++) {\n\t    var line = linesAndNewlines[i];\n\n\t    if (i % 2 && !this.options.newlineIsToken) {\n\t      retLines[retLines.length - 1] += line;\n\t    } else {\n\t      if (this.options.ignoreWhitespace) {\n\t        line = line.trim();\n\t      }\n\t      retLines.push(line);\n\t    }\n\t  }\n\n\t  return retLines;\n\t};\n\n\tfunction diffLines(oldStr, newStr, callback) {\n\t  return lineDiff.diff(oldStr, newStr, callback);\n\t}\n\tfunction diffTrimmedLines(oldStr, newStr, callback) {\n\t  var options = /*istanbul ignore start*/(0, _params.generateOptions) /*istanbul ignore end*/(callback, { ignoreWhitespace: true });\n\t  return lineDiff.diff(oldStr, newStr, options);\n\t}\n\n\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.sentenceDiff = undefined;\n\texports. /*istanbul ignore end*/diffSentences = diffSentences;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var sentenceDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/sentenceDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tsentenceDiff.tokenize = function (value) {\n\t  return value.split(/(\\S.+?[.!?])(?=\\s+|$)/);\n\t};\n\n\tfunction diffSentences(oldStr, newStr, callback) {\n\t  return sentenceDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.cssDiff = undefined;\n\texports. /*istanbul ignore end*/diffCss = diffCss;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var cssDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/cssDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tcssDiff.tokenize = function (value) {\n\t  return value.split(/([{}:;,]|\\s+)/);\n\t};\n\n\tfunction diffCss(oldStr, newStr, callback) {\n\t  return cssDiff.diff(oldStr, newStr, callback);\n\t}\n\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.jsonDiff = undefined;\n\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\n\texports. /*istanbul ignore end*/diffJson = diffJson;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/canonicalize = canonicalize;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\t/*istanbul ignore end*/var /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var objectPrototypeToString = Object.prototype.toString;\n\n\tvar jsonDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/jsonDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\t// Discriminate between two lines of pretty-printed, serialized JSON where one of them has a\n\t// dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:\n\tjsonDiff.useLongestToken = true;\n\n\tjsonDiff.tokenize = /*istanbul ignore start*/_line.lineDiff /*istanbul ignore end*/.tokenize;\n\tjsonDiff.castInput = function (value) {\n\t  /*istanbul ignore start*/var _options = /*istanbul ignore end*/this.options,\n\t      undefinedReplacement = _options.undefinedReplacement,\n\t      _options$stringifyRep = _options.stringifyReplacer,\n\t      stringifyReplacer = _options$stringifyRep === undefined ? function (k, v) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/typeof v === 'undefined' ? undefinedReplacement : v\n\t    );\n\t  } : _options$stringifyRep;\n\n\n\t  return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');\n\t};\n\tjsonDiff.equals = function (left, right) {\n\t  return (/*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/.prototype.equals.call(jsonDiff, left.replace(/,([\\r\\n])/g, '$1'), right.replace(/,([\\r\\n])/g, '$1'))\n\t  );\n\t};\n\n\tfunction diffJson(oldObj, newObj, options) {\n\t  return jsonDiff.diff(oldObj, newObj, options);\n\t}\n\n\t// This function handles the presence of circular references by bailing out when encountering an\n\t// object that is already on the \"stack\" of items being processed. Accepts an optional replacer\n\tfunction canonicalize(obj, stack, replacementStack, replacer, key) {\n\t  stack = stack || [];\n\t  replacementStack = replacementStack || [];\n\n\t  if (replacer) {\n\t    obj = replacer(key, obj);\n\t  }\n\n\t  var i = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  for (i = 0; i < stack.length; i += 1) {\n\t    if (stack[i] === obj) {\n\t      return replacementStack[i];\n\t    }\n\t  }\n\n\t  var canonicalizedObj = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  if ('[object Array]' === objectPrototypeToString.call(obj)) {\n\t    stack.push(obj);\n\t    canonicalizedObj = new Array(obj.length);\n\t    replacementStack.push(canonicalizedObj);\n\t    for (i = 0; i < obj.length; i += 1) {\n\t      canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t    return canonicalizedObj;\n\t  }\n\n\t  if (obj && obj.toJSON) {\n\t    obj = obj.toJSON();\n\t  }\n\n\t  if ( /*istanbul ignore start*/(typeof /*istanbul ignore end*/obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object' && obj !== null) {\n\t    stack.push(obj);\n\t    canonicalizedObj = {};\n\t    replacementStack.push(canonicalizedObj);\n\t    var sortedKeys = [],\n\t        _key = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t    for (_key in obj) {\n\t      /* istanbul ignore else */\n\t      if (obj.hasOwnProperty(_key)) {\n\t        sortedKeys.push(_key);\n\t      }\n\t    }\n\t    sortedKeys.sort();\n\t    for (i = 0; i < sortedKeys.length; i += 1) {\n\t      _key = sortedKeys[i];\n\t      canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);\n\t    }\n\t    stack.pop();\n\t    replacementStack.pop();\n\t  } else {\n\t    canonicalizedObj = obj;\n\t  }\n\t  return canonicalizedObj;\n\t}\n\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports.arrayDiff = undefined;\n\texports. /*istanbul ignore end*/diffArrays = diffArrays;\n\n\tvar /*istanbul ignore start*/_base = __webpack_require__(1) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _base2 = _interopRequireDefault(_base);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/var arrayDiff = /*istanbul ignore start*/exports. /*istanbul ignore end*/arrayDiff = new /*istanbul ignore start*/_base2['default'] /*istanbul ignore end*/();\n\tarrayDiff.tokenize = function (value) {\n\t  return value.slice();\n\t};\n\tarrayDiff.join = arrayDiff.removeEmpty = function (value) {\n\t  return value;\n\t};\n\n\tfunction diffArrays(oldArr, newArr, callback) {\n\t  return arrayDiff.diff(oldArr, newArr, callback);\n\t}\n\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/applyPatch = applyPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/applyPatches = applyPatches;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_distanceIterator = __webpack_require__(12) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/var _distanceIterator2 = _interopRequireDefault(_distanceIterator);\n\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }\n\n\t/*istanbul ignore end*/function applyPatch(source, uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  if (Array.isArray(uniDiff)) {\n\t    if (uniDiff.length > 1) {\n\t      throw new Error('applyPatch only works with a single input.');\n\t    }\n\n\t    uniDiff = uniDiff[0];\n\t  }\n\n\t  // Apply the diff to the input\n\t  var lines = source.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = source.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      hunks = uniDiff.hunks,\n\t      compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) /*istanbul ignore start*/{\n\t    return (/*istanbul ignore end*/line === patchContent\n\t    );\n\t  },\n\t      errorCount = 0,\n\t      fuzzFactor = options.fuzzFactor || 0,\n\t      minLine = 0,\n\t      offset = 0,\n\t      removeEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      addEOFNL = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\n\t  /**\n\t   * Checks if the hunk exactly fits on the provided location\n\t   */\n\t  function hunkFits(hunk, toPos) {\n\t    for (var j = 0; j < hunk.lines.length; j++) {\n\t      var line = hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line;\n\n\t      if (operation === ' ' || operation === '-') {\n\t        // Context sanity check\n\t        if (!compareLine(toPos + 1, lines[toPos], operation, content)) {\n\t          errorCount++;\n\n\t          if (errorCount > fuzzFactor) {\n\t            return false;\n\t          }\n\t        }\n\t        toPos++;\n\t      }\n\t    }\n\n\t    return true;\n\t  }\n\n\t  // Search best fit offsets for each hunk based on the previous ones\n\t  for (var i = 0; i < hunks.length; i++) {\n\t    var hunk = hunks[i],\n\t        maxLine = lines.length - hunk.oldLines,\n\t        localOffset = 0,\n\t        toPos = offset + hunk.oldStart - 1;\n\n\t    var iterator = /*istanbul ignore start*/(0, _distanceIterator2['default']) /*istanbul ignore end*/(toPos, minLine, maxLine);\n\n\t    for (; localOffset !== undefined; localOffset = iterator()) {\n\t      if (hunkFits(hunk, toPos + localOffset)) {\n\t        hunk.offset = offset += localOffset;\n\t        break;\n\t      }\n\t    }\n\n\t    if (localOffset === undefined) {\n\t      return false;\n\t    }\n\n\t    // Set lower text limit to end of the current hunk, so next ones don't try\n\t    // to fit over already patched text\n\t    minLine = hunk.offset + hunk.oldStart + hunk.oldLines;\n\t  }\n\n\t  // Apply patch hunks\n\t  var diffOffset = 0;\n\t  for (var _i = 0; _i < hunks.length; _i++) {\n\t    var _hunk = hunks[_i],\n\t        _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;\n\t    diffOffset += _hunk.newLines - _hunk.oldLines;\n\n\t    if (_toPos < 0) {\n\t      // Creating a new file\n\t      _toPos = 0;\n\t    }\n\n\t    for (var j = 0; j < _hunk.lines.length; j++) {\n\t      var line = _hunk.lines[j],\n\t          operation = line.length > 0 ? line[0] : ' ',\n\t          content = line.length > 0 ? line.substr(1) : line,\n\t          delimiter = _hunk.linedelimiters[j];\n\n\t      if (operation === ' ') {\n\t        _toPos++;\n\t      } else if (operation === '-') {\n\t        lines.splice(_toPos, 1);\n\t        delimiters.splice(_toPos, 1);\n\t        /* istanbul ignore else */\n\t      } else if (operation === '+') {\n\t        lines.splice(_toPos, 0, content);\n\t        delimiters.splice(_toPos, 0, delimiter);\n\t        _toPos++;\n\t      } else if (operation === '\\\\') {\n\t        var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;\n\t        if (previousOperation === '+') {\n\t          removeEOFNL = true;\n\t        } else if (previousOperation === '-') {\n\t          addEOFNL = true;\n\t        }\n\t      }\n\t    }\n\t  }\n\n\t  // Handle EOFNL insertion/removal\n\t  if (removeEOFNL) {\n\t    while (!lines[lines.length - 1]) {\n\t      lines.pop();\n\t      delimiters.pop();\n\t    }\n\t  } else if (addEOFNL) {\n\t    lines.push('');\n\t    delimiters.push('\\n');\n\t  }\n\t  for (var _k = 0; _k < lines.length - 1; _k++) {\n\t    lines[_k] = lines[_k] + delimiters[_k];\n\t  }\n\t  return lines.join('');\n\t}\n\n\t// Wrapper that supports multiple file patches via callbacks.\n\tfunction applyPatches(uniDiff, options) {\n\t  if (typeof uniDiff === 'string') {\n\t    uniDiff = /*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(uniDiff);\n\t  }\n\n\t  var currentIndex = 0;\n\t  function processIndex() {\n\t    var index = uniDiff[currentIndex++];\n\t    if (!index) {\n\t      return options.complete();\n\t    }\n\n\t    options.loadFile(index, function (err, data) {\n\t      if (err) {\n\t        return options.complete(err);\n\t      }\n\n\t      var updatedContent = applyPatch(data, index, options);\n\t      options.patched(index, updatedContent, function (err) {\n\t        if (err) {\n\t          return options.complete(err);\n\t        }\n\n\t        processIndex();\n\t      });\n\t    });\n\t  }\n\t  processIndex();\n\t}\n\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/parsePatch = parsePatch;\n\tfunction parsePatch(uniDiff) {\n\t  /*istanbul ignore start*/var /*istanbul ignore end*/options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n\t  var diffstr = uniDiff.split(/\\r\\n|[\\n\\v\\f\\r\\x85]/),\n\t      delimiters = uniDiff.match(/\\r\\n|[\\n\\v\\f\\r\\x85]/g) || [],\n\t      list = [],\n\t      i = 0;\n\n\t  function parseIndex() {\n\t    var index = {};\n\t    list.push(index);\n\n\t    // Parse diff metadata\n\t    while (i < diffstr.length) {\n\t      var line = diffstr[i];\n\n\t      // File header found, end parsing diff metadata\n\t      if (/^(\\-\\-\\-|\\+\\+\\+|@@)\\s/.test(line)) {\n\t        break;\n\t      }\n\n\t      // Diff index\n\t      var header = /^(?:Index:|diff(?: -r \\w+)+)\\s+(.+?)\\s*$/.exec(line);\n\t      if (header) {\n\t        index.index = header[1];\n\t      }\n\n\t      i++;\n\t    }\n\n\t    // Parse file headers if they are defined. Unified diff requires them, but\n\t    // there's no technical issues to have an isolated hunk without file header\n\t    parseFileHeader(index);\n\t    parseFileHeader(index);\n\n\t    // Parse hunks\n\t    index.hunks = [];\n\n\t    while (i < diffstr.length) {\n\t      var _line = diffstr[i];\n\n\t      if (/^(Index:|diff|\\-\\-\\-|\\+\\+\\+)\\s/.test(_line)) {\n\t        break;\n\t      } else if (/^@@/.test(_line)) {\n\t        index.hunks.push(parseHunk());\n\t      } else if (_line && options.strict) {\n\t        // Ignore unexpected content unless in strict mode\n\t        throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));\n\t      } else {\n\t        i++;\n\t      }\n\t    }\n\t  }\n\n\t  // Parses the --- and +++ headers, if none are found, no lines\n\t  // are consumed.\n\t  function parseFileHeader(index) {\n\t    var fileHeader = /^(---|\\+\\+\\+)\\s+(.*)$/.exec(diffstr[i]);\n\t    if (fileHeader) {\n\t      var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';\n\t      var data = fileHeader[2].split('\\t', 2);\n\t      var fileName = data[0].replace(/\\\\\\\\/g, '\\\\');\n\t      if (/^\".*\"$/.test(fileName)) {\n\t        fileName = fileName.substr(1, fileName.length - 2);\n\t      }\n\t      index[keyPrefix + 'FileName'] = fileName;\n\t      index[keyPrefix + 'Header'] = (data[1] || '').trim();\n\n\t      i++;\n\t    }\n\t  }\n\n\t  // Parses a hunk\n\t  // This assumes that we are at the start of a hunk.\n\t  function parseHunk() {\n\t    var chunkHeaderIndex = i,\n\t        chunkHeaderLine = diffstr[i++],\n\t        chunkHeader = chunkHeaderLine.split(/@@ -(\\d+)(?:,(\\d+))? \\+(\\d+)(?:,(\\d+))? @@/);\n\n\t    var hunk = {\n\t      oldStart: +chunkHeader[1],\n\t      oldLines: +chunkHeader[2] || 1,\n\t      newStart: +chunkHeader[3],\n\t      newLines: +chunkHeader[4] || 1,\n\t      lines: [],\n\t      linedelimiters: []\n\t    };\n\n\t    var addCount = 0,\n\t        removeCount = 0;\n\t    for (; i < diffstr.length; i++) {\n\t      // Lines starting with '---' could be mistaken for the \"remove line\" operation\n\t      // But they could be the header for the next file. Therefore prune such cases out.\n\t      if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {\n\t        break;\n\t      }\n\t      var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];\n\n\t      if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\\\') {\n\t        hunk.lines.push(diffstr[i]);\n\t        hunk.linedelimiters.push(delimiters[i] || '\\n');\n\n\t        if (operation === '+') {\n\t          addCount++;\n\t        } else if (operation === '-') {\n\t          removeCount++;\n\t        } else if (operation === ' ') {\n\t          addCount++;\n\t          removeCount++;\n\t        }\n\t      } else {\n\t        break;\n\t      }\n\t    }\n\n\t    // Handle the empty block count case\n\t    if (!addCount && hunk.newLines === 1) {\n\t      hunk.newLines = 0;\n\t    }\n\t    if (!removeCount && hunk.oldLines === 1) {\n\t      hunk.oldLines = 0;\n\t    }\n\n\t    // Perform optional sanity checking\n\t    if (options.strict) {\n\t      if (addCount !== hunk.newLines) {\n\t        throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t      if (removeCount !== hunk.oldLines) {\n\t        throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));\n\t      }\n\t    }\n\n\t    return hunk;\n\t  }\n\n\t  while (i < diffstr.length) {\n\t    parseIndex();\n\t  }\n\n\t  return list;\n\t}\n\n\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\n\texports[\"default\"] = /*istanbul ignore end*/function (start, minLine, maxLine) {\n\t  var wantForward = true,\n\t      backwardExhausted = false,\n\t      forwardExhausted = false,\n\t      localOffset = 1;\n\n\t  return function iterator() {\n\t    if (wantForward && !forwardExhausted) {\n\t      if (backwardExhausted) {\n\t        localOffset++;\n\t      } else {\n\t        wantForward = false;\n\t      }\n\n\t      // Check if trying to fit beyond text length, and if not, check it fits\n\t      // after offset location (or desired location on first iteration)\n\t      if (start + localOffset <= maxLine) {\n\t        return localOffset;\n\t      }\n\n\t      forwardExhausted = true;\n\t    }\n\n\t    if (!backwardExhausted) {\n\t      if (!forwardExhausted) {\n\t        wantForward = true;\n\t      }\n\n\t      // Check if trying to fit before text beginning, and if not, check it fits\n\t      // before offset location\n\t      if (minLine <= start - localOffset) {\n\t        return -localOffset++;\n\t      }\n\n\t      backwardExhausted = true;\n\t      return iterator();\n\t    }\n\n\t    // We tried to fit hunk before text beginning and beyond text length, then\n\t    // hunk can't fit on the text. Return undefined\n\t  };\n\t};\n\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/calcLineCount = calcLineCount;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/merge = merge;\n\n\tvar /*istanbul ignore start*/_create = __webpack_require__(14) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_parse = __webpack_require__(11) /*istanbul ignore end*/;\n\n\tvar /*istanbul ignore start*/_array = __webpack_require__(15) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function calcLineCount(hunk) {\n\t  /*istanbul ignore start*/var _calcOldNewLineCount = /*istanbul ignore end*/calcOldNewLineCount(hunk.lines),\n\t      oldLines = _calcOldNewLineCount.oldLines,\n\t      newLines = _calcOldNewLineCount.newLines;\n\n\t  if (oldLines !== undefined) {\n\t    hunk.oldLines = oldLines;\n\t  } else {\n\t    delete hunk.oldLines;\n\t  }\n\n\t  if (newLines !== undefined) {\n\t    hunk.newLines = newLines;\n\t  } else {\n\t    delete hunk.newLines;\n\t  }\n\t}\n\n\tfunction merge(mine, theirs, base) {\n\t  mine = loadPatch(mine, base);\n\t  theirs = loadPatch(theirs, base);\n\n\t  var ret = {};\n\n\t  // For index we just let it pass through as it doesn't have any necessary meaning.\n\t  // Leaving sanity checks on this to the API consumer that may know more about the\n\t  // meaning in their own context.\n\t  if (mine.index || theirs.index) {\n\t    ret.index = mine.index || theirs.index;\n\t  }\n\n\t  if (mine.newFileName || theirs.newFileName) {\n\t    if (!fileNameChanged(mine)) {\n\t      // No header or no change in ours, use theirs (and ours if theirs does not exist)\n\t      ret.oldFileName = theirs.oldFileName || mine.oldFileName;\n\t      ret.newFileName = theirs.newFileName || mine.newFileName;\n\t      ret.oldHeader = theirs.oldHeader || mine.oldHeader;\n\t      ret.newHeader = theirs.newHeader || mine.newHeader;\n\t    } else if (!fileNameChanged(theirs)) {\n\t      // No header or no change in theirs, use ours\n\t      ret.oldFileName = mine.oldFileName;\n\t      ret.newFileName = mine.newFileName;\n\t      ret.oldHeader = mine.oldHeader;\n\t      ret.newHeader = mine.newHeader;\n\t    } else {\n\t      // Both changed... figure it out\n\t      ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);\n\t      ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);\n\t      ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);\n\t      ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);\n\t    }\n\t  }\n\n\t  ret.hunks = [];\n\n\t  var mineIndex = 0,\n\t      theirsIndex = 0,\n\t      mineOffset = 0,\n\t      theirsOffset = 0;\n\n\t  while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {\n\t    var mineCurrent = mine.hunks[mineIndex] || { oldStart: Infinity },\n\t        theirsCurrent = theirs.hunks[theirsIndex] || { oldStart: Infinity };\n\n\t    if (hunkBefore(mineCurrent, theirsCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(mineCurrent, mineOffset));\n\t      mineIndex++;\n\t      theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;\n\t    } else if (hunkBefore(theirsCurrent, mineCurrent)) {\n\t      // This patch does not overlap with any of the others, yay.\n\t      ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));\n\t      theirsIndex++;\n\t      mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;\n\t    } else {\n\t      // Overlap, merge as best we can\n\t      var mergedHunk = {\n\t        oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),\n\t        oldLines: 0,\n\t        newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),\n\t        newLines: 0,\n\t        lines: []\n\t      };\n\t      mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);\n\t      theirsIndex++;\n\t      mineIndex++;\n\n\t      ret.hunks.push(mergedHunk);\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\n\tfunction loadPatch(param, base) {\n\t  if (typeof param === 'string') {\n\t    if (/^@@/m.test(param) || /^Index:/m.test(param)) {\n\t      return (/*istanbul ignore start*/(0, _parse.parsePatch) /*istanbul ignore end*/(param)[0]\n\t      );\n\t    }\n\n\t    if (!base) {\n\t      throw new Error('Must provide a base reference or pass in a patch');\n\t    }\n\t    return (/*istanbul ignore start*/(0, _create.structuredPatch) /*istanbul ignore end*/(undefined, undefined, base, param)\n\t    );\n\t  }\n\n\t  return param;\n\t}\n\n\tfunction fileNameChanged(patch) {\n\t  return patch.newFileName && patch.newFileName !== patch.oldFileName;\n\t}\n\n\tfunction selectField(index, mine, theirs) {\n\t  if (mine === theirs) {\n\t    return mine;\n\t  } else {\n\t    index.conflict = true;\n\t    return { mine: mine, theirs: theirs };\n\t  }\n\t}\n\n\tfunction hunkBefore(test, check) {\n\t  return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;\n\t}\n\n\tfunction cloneHunk(hunk, offset) {\n\t  return {\n\t    oldStart: hunk.oldStart, oldLines: hunk.oldLines,\n\t    newStart: hunk.newStart + offset, newLines: hunk.newLines,\n\t    lines: hunk.lines\n\t  };\n\t}\n\n\tfunction mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {\n\t  // This will generally result in a conflicted hunk, but there are cases where the context\n\t  // is the only overlap where we can successfully merge the content here.\n\t  var mine = { offset: mineOffset, lines: mineLines, index: 0 },\n\t      their = { offset: theirOffset, lines: theirLines, index: 0 };\n\n\t  // Handle any leading content\n\t  insertLeading(hunk, mine, their);\n\t  insertLeading(hunk, their, mine);\n\n\t  // Now in the overlap content. Scan through and select the best changes from each.\n\t  while (mine.index < mine.lines.length && their.index < their.lines.length) {\n\t    var mineCurrent = mine.lines[mine.index],\n\t        theirCurrent = their.lines[their.index];\n\n\t    if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {\n\t      // Both modified ...\n\t      mutualChange(hunk, mine, their);\n\t    } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines;\n\n\t      /*istanbul ignore end*/ // Mine inserted\n\t      /*istanbul ignore start*/(_hunk$lines = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(mine)));\n\t    } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {\n\t      /*istanbul ignore start*/var _hunk$lines2;\n\n\t      /*istanbul ignore end*/ // Theirs inserted\n\t      /*istanbul ignore start*/(_hunk$lines2 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/collectChange(their)));\n\t    } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {\n\t      // Mine removed or edited\n\t      removal(hunk, mine, their);\n\t    } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {\n\t      // Their removed or edited\n\t      removal(hunk, their, mine, true);\n\t    } else if (mineCurrent === theirCurrent) {\n\t      // Context identity\n\t      hunk.lines.push(mineCurrent);\n\t      mine.index++;\n\t      their.index++;\n\t    } else {\n\t      // Context mismatch\n\t      conflict(hunk, collectChange(mine), collectChange(their));\n\t    }\n\t  }\n\n\t  // Now push anything that may be remaining\n\t  insertTrailing(hunk, mine);\n\t  insertTrailing(hunk, their);\n\n\t  calcLineCount(hunk);\n\t}\n\n\tfunction mutualChange(hunk, mine, their) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectChange(their);\n\n\t  if (allRemoves(myChanges) && allRemoves(theirChanges)) {\n\t    // Special case for remove changes that are supersets of one another\n\t    if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines3;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines3 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t      return;\n\t    } else if ( /*istanbul ignore start*/(0, _array.arrayStartsWith) /*istanbul ignore end*/(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {\n\t      /*istanbul ignore start*/var _hunk$lines4;\n\n\t      /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines4 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines4 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges));\n\t      return;\n\t    }\n\t  } else if ( /*istanbul ignore start*/(0, _array.arrayEqual) /*istanbul ignore end*/(myChanges, theirChanges)) {\n\t    /*istanbul ignore start*/var _hunk$lines5;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines5 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines5 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/myChanges));\n\t    return;\n\t  }\n\n\t  conflict(hunk, myChanges, theirChanges);\n\t}\n\n\tfunction removal(hunk, mine, their, swap) {\n\t  var myChanges = collectChange(mine),\n\t      theirChanges = collectContext(their, myChanges);\n\t  if (theirChanges.merged) {\n\t    /*istanbul ignore start*/var _hunk$lines6;\n\n\t    /*istanbul ignore end*/ /*istanbul ignore start*/(_hunk$lines6 = /*istanbul ignore end*/hunk.lines).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_hunk$lines6 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/theirChanges.merged));\n\t  } else {\n\t    conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);\n\t  }\n\t}\n\n\tfunction conflict(hunk, mine, their) {\n\t  hunk.conflict = true;\n\t  hunk.lines.push({\n\t    conflict: true,\n\t    mine: mine,\n\t    theirs: their\n\t  });\n\t}\n\n\tfunction insertLeading(hunk, insert, their) {\n\t  while (insert.offset < their.offset && insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t    insert.offset++;\n\t  }\n\t}\n\tfunction insertTrailing(hunk, insert) {\n\t  while (insert.index < insert.lines.length) {\n\t    var line = insert.lines[insert.index++];\n\t    hunk.lines.push(line);\n\t  }\n\t}\n\n\tfunction collectChange(state) {\n\t  var ret = [],\n\t      operation = state.lines[state.index][0];\n\t  while (state.index < state.lines.length) {\n\t    var line = state.lines[state.index];\n\n\t    // Group additions that are immediately after subtractions and treat them as one \"atomic\" modify change.\n\t    if (operation === '-' && line[0] === '+') {\n\t      operation = '+';\n\t    }\n\n\t    if (operation === line[0]) {\n\t      ret.push(line);\n\t      state.index++;\n\t    } else {\n\t      break;\n\t    }\n\t  }\n\n\t  return ret;\n\t}\n\tfunction collectContext(state, matchChanges) {\n\t  var changes = [],\n\t      merged = [],\n\t      matchIndex = 0,\n\t      contextChanges = false,\n\t      conflicted = false;\n\t  while (matchIndex < matchChanges.length && state.index < state.lines.length) {\n\t    var change = state.lines[state.index],\n\t        match = matchChanges[matchIndex];\n\n\t    // Once we've hit our add, then we are done\n\t    if (match[0] === '+') {\n\t      break;\n\t    }\n\n\t    contextChanges = contextChanges || change[0] !== ' ';\n\n\t    merged.push(match);\n\t    matchIndex++;\n\n\t    // Consume any additions in the other block as a conflict to attempt\n\t    // to pull in the remaining context after this\n\t    if (change[0] === '+') {\n\t      conflicted = true;\n\n\t      while (change[0] === '+') {\n\t        changes.push(change);\n\t        change = state.lines[++state.index];\n\t      }\n\t    }\n\n\t    if (match.substr(1) === change.substr(1)) {\n\t      changes.push(change);\n\t      state.index++;\n\t    } else {\n\t      conflicted = true;\n\t    }\n\t  }\n\n\t  if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {\n\t    conflicted = true;\n\t  }\n\n\t  if (conflicted) {\n\t    return changes;\n\t  }\n\n\t  while (matchIndex < matchChanges.length) {\n\t    merged.push(matchChanges[matchIndex++]);\n\t  }\n\n\t  return {\n\t    merged: merged,\n\t    changes: changes\n\t  };\n\t}\n\n\tfunction allRemoves(changes) {\n\t  return changes.reduce(function (prev, change) {\n\t    return prev && change[0] === '-';\n\t  }, true);\n\t}\n\tfunction skipRemoveSuperset(state, removeChanges, delta) {\n\t  for (var i = 0; i < delta; i++) {\n\t    var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);\n\t    if (state.lines[state.index + i] !== ' ' + changeContent) {\n\t      return false;\n\t    }\n\t  }\n\n\t  state.index += delta;\n\t  return true;\n\t}\n\n\tfunction calcOldNewLineCount(lines) {\n\t  var oldLines = 0;\n\t  var newLines = 0;\n\n\t  lines.forEach(function (line) {\n\t    if (typeof line !== 'string') {\n\t      var myCount = calcOldNewLineCount(line.mine);\n\t      var theirCount = calcOldNewLineCount(line.theirs);\n\n\t      if (oldLines !== undefined) {\n\t        if (myCount.oldLines === theirCount.oldLines) {\n\t          oldLines += myCount.oldLines;\n\t        } else {\n\t          oldLines = undefined;\n\t        }\n\t      }\n\n\t      if (newLines !== undefined) {\n\t        if (myCount.newLines === theirCount.newLines) {\n\t          newLines += myCount.newLines;\n\t        } else {\n\t          newLines = undefined;\n\t        }\n\t      }\n\t    } else {\n\t      if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {\n\t        newLines++;\n\t      }\n\t      if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {\n\t        oldLines++;\n\t      }\n\t    }\n\t  });\n\n\t  return { oldLines: oldLines, newLines: newLines };\n\t}\n\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/structuredPatch = structuredPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createTwoFilesPatch = createTwoFilesPatch;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/createPatch = createPatch;\n\n\tvar /*istanbul ignore start*/_line = __webpack_require__(5) /*istanbul ignore end*/;\n\n\t/*istanbul ignore start*/function _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\n\n\t/*istanbul ignore end*/function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  if (!options) {\n\t    options = {};\n\t  }\n\t  if (typeof options.context === 'undefined') {\n\t    options.context = 4;\n\t  }\n\n\t  var diff = /*istanbul ignore start*/(0, _line.diffLines) /*istanbul ignore end*/(oldStr, newStr, options);\n\t  diff.push({ value: '', lines: [] }); // Append an empty value to make cleanup easier\n\n\t  function contextLines(lines) {\n\t    return lines.map(function (entry) {\n\t      return ' ' + entry;\n\t    });\n\t  }\n\n\t  var hunks = [];\n\t  var oldRangeStart = 0,\n\t      newRangeStart = 0,\n\t      curRange = [],\n\t      oldLine = 1,\n\t      newLine = 1;\n\n\t  /*istanbul ignore start*/var _loop = function _loop( /*istanbul ignore end*/i) {\n\t    var current = diff[i],\n\t        lines = current.lines || current.value.replace(/\\n$/, '').split('\\n');\n\t    current.lines = lines;\n\n\t    if (current.added || current.removed) {\n\t      /*istanbul ignore start*/var _curRange;\n\n\t      /*istanbul ignore end*/ // If we have previous context, start with that\n\t      if (!oldRangeStart) {\n\t        var prev = diff[i - 1];\n\t        oldRangeStart = oldLine;\n\t        newRangeStart = newLine;\n\n\t        if (prev) {\n\t          curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];\n\t          oldRangeStart -= curRange.length;\n\t          newRangeStart -= curRange.length;\n\t        }\n\t      }\n\n\t      // Output our changes\n\t      /*istanbul ignore start*/(_curRange = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/lines.map(function (entry) {\n\t        return (current.added ? '+' : '-') + entry;\n\t      })));\n\n\t      // Track the updated file position\n\t      if (current.added) {\n\t        newLine += lines.length;\n\t      } else {\n\t        oldLine += lines.length;\n\t      }\n\t    } else {\n\t      // Identical context lines. Track line changes\n\t      if (oldRangeStart) {\n\t        // Close out any changes that have been output (or join overlapping)\n\t        if (lines.length <= options.context * 2 && i < diff.length - 2) {\n\t          /*istanbul ignore start*/var _curRange2;\n\n\t          /*istanbul ignore end*/ // Overlapping\n\t          /*istanbul ignore start*/(_curRange2 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange2 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines)));\n\t        } else {\n\t          /*istanbul ignore start*/var _curRange3;\n\n\t          /*istanbul ignore end*/ // end the range and output\n\t          var contextSize = Math.min(lines.length, options.context);\n\t          /*istanbul ignore start*/(_curRange3 = /*istanbul ignore end*/curRange).push. /*istanbul ignore start*/apply /*istanbul ignore end*/( /*istanbul ignore start*/_curRange3 /*istanbul ignore end*/, /*istanbul ignore start*/_toConsumableArray( /*istanbul ignore end*/contextLines(lines.slice(0, contextSize))));\n\n\t          var hunk = {\n\t            oldStart: oldRangeStart,\n\t            oldLines: oldLine - oldRangeStart + contextSize,\n\t            newStart: newRangeStart,\n\t            newLines: newLine - newRangeStart + contextSize,\n\t            lines: curRange\n\t          };\n\t          if (i >= diff.length - 2 && lines.length <= options.context) {\n\t            // EOF is inside this hunk\n\t            var oldEOFNewline = /\\n$/.test(oldStr);\n\t            var newEOFNewline = /\\n$/.test(newStr);\n\t            if (lines.length == 0 && !oldEOFNewline) {\n\t              // special case: old has no eol and no trailing context; no-nl can end up before adds\n\t              curRange.splice(hunk.oldLines, 0, '\\\\ No newline at end of file');\n\t            } else if (!oldEOFNewline || !newEOFNewline) {\n\t              curRange.push('\\\\ No newline at end of file');\n\t            }\n\t          }\n\t          hunks.push(hunk);\n\n\t          oldRangeStart = 0;\n\t          newRangeStart = 0;\n\t          curRange = [];\n\t        }\n\t      }\n\t      oldLine += lines.length;\n\t      newLine += lines.length;\n\t    }\n\t  };\n\n\t  for (var i = 0; i < diff.length; i++) {\n\t    /*istanbul ignore start*/_loop( /*istanbul ignore end*/i);\n\t  }\n\n\t  return {\n\t    oldFileName: oldFileName, newFileName: newFileName,\n\t    oldHeader: oldHeader, newHeader: newHeader,\n\t    hunks: hunks\n\t  };\n\t}\n\n\tfunction createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);\n\n\t  var ret = [];\n\t  if (oldFileName == newFileName) {\n\t    ret.push('Index: ' + oldFileName);\n\t  }\n\t  ret.push('===================================================================');\n\t  ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\\t' + diff.oldHeader));\n\t  ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\\t' + diff.newHeader));\n\n\t  for (var i = 0; i < diff.hunks.length; i++) {\n\t    var hunk = diff.hunks[i];\n\t    ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');\n\t    ret.push.apply(ret, hunk.lines);\n\t  }\n\n\t  return ret.join('\\n') + '\\n';\n\t}\n\n\tfunction createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {\n\t  return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);\n\t}\n\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/arrayEqual = arrayEqual;\n\t/*istanbul ignore start*/exports. /*istanbul ignore end*/arrayStartsWith = arrayStartsWith;\n\tfunction arrayEqual(a, b) {\n\t  if (a.length !== b.length) {\n\t    return false;\n\t  }\n\n\t  return arrayStartsWith(a, b);\n\t}\n\n\tfunction arrayStartsWith(array, start) {\n\t  if (start.length > array.length) {\n\t    return false;\n\t  }\n\n\t  for (var i = 0; i < start.length; i++) {\n\t    if (start[i] !== array[i]) {\n\t      return false;\n\t    }\n\t  }\n\n\t  return true;\n\t}\n\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/\"use strict\";\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToDMP = convertChangesToDMP;\n\t// See: http://code.google.com/p/google-diff-match-patch/wiki/API\n\tfunction convertChangesToDMP(changes) {\n\t  var ret = [],\n\t      change = /*istanbul ignore start*/void 0 /*istanbul ignore end*/,\n\t      operation = /*istanbul ignore start*/void 0 /*istanbul ignore end*/;\n\t  for (var i = 0; i < changes.length; i++) {\n\t    change = changes[i];\n\t    if (change.added) {\n\t      operation = 1;\n\t    } else if (change.removed) {\n\t      operation = -1;\n\t    } else {\n\t      operation = 0;\n\t    }\n\n\t    ret.push([operation, change.value]);\n\t  }\n\t  return ret;\n\t}\n\n\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports) {\n\n\t/*istanbul ignore start*/'use strict';\n\n\texports.__esModule = true;\n\texports. /*istanbul ignore end*/convertChangesToXML = convertChangesToXML;\n\tfunction convertChangesToXML(changes) {\n\t  var ret = [];\n\t  for (var i = 0; i < changes.length; i++) {\n\t    var change = changes[i];\n\t    if (change.added) {\n\t      ret.push('<ins>');\n\t    } else if (change.removed) {\n\t      ret.push('<del>');\n\t    }\n\n\t    ret.push(escapeHTML(change.value));\n\n\t    if (change.added) {\n\t      ret.push('</ins>');\n\t    } else if (change.removed) {\n\t      ret.push('</del>');\n\t    }\n\t  }\n\t  return ret.join('');\n\t}\n\n\tfunction escapeHTML(s) {\n\t  var n = s;\n\t  n = n.replace(/&/g, '&amp;');\n\t  n = n.replace(/</g, '&lt;');\n\t  n = n.replace(/>/g, '&gt;');\n\t  n = n.replace(/\"/g, '&quot;');\n\n\t  return n;\n\t}\n\n\n\n/***/ })\n/******/ ])\n});\n;\n},{}],46:[function(require,module,exports){\n'use strict';\n\nvar matchOperatorsRe = /[|\\\\{}()[\\]^$+*?.]/g;\n\nmodule.exports = function (str) {\n\tif (typeof str !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\treturn str.replace(matchOperatorsRe, '\\\\$&');\n};\n\n},{}],47:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nfunction EventEmitter() {\n  this._events = this._events || {};\n  this._maxListeners = this._maxListeners || undefined;\n}\nmodule.exports = EventEmitter;\n\n// Backwards-compat with node 0.10.x\nEventEmitter.EventEmitter = EventEmitter;\n\nEventEmitter.prototype._events = undefined;\nEventEmitter.prototype._maxListeners = undefined;\n\n// By default EventEmitters will print a warning if more than 10 listeners are\n// added to it. This is a useful default which helps finding memory leaks.\nEventEmitter.defaultMaxListeners = 10;\n\n// Obviously not all Emitters should be limited to 10. This function allows\n// that to be increased. Set to zero for unlimited.\nEventEmitter.prototype.setMaxListeners = function(n) {\n  if (!isNumber(n) || n < 0 || isNaN(n))\n    throw TypeError('n must be a positive number');\n  this._maxListeners = n;\n  return this;\n};\n\nEventEmitter.prototype.emit = function(type) {\n  var er, handler, len, args, i, listeners;\n\n  if (!this._events)\n    this._events = {};\n\n  // If there is no 'error' event listener then throw.\n  if (type === 'error') {\n    if (!this._events.error ||\n        (isObject(this._events.error) && !this._events.error.length)) {\n      er = arguments[1];\n      if (er instanceof Error) {\n        throw er; // Unhandled 'error' event\n      } else {\n        // At least give some kind of context to the user\n        var err = new Error('Uncaught, unspecified \"error\" event. (' + er + ')');\n        err.context = er;\n        throw err;\n      }\n    }\n  }\n\n  handler = this._events[type];\n\n  if (isUndefined(handler))\n    return false;\n\n  if (isFunction(handler)) {\n    switch (arguments.length) {\n      // fast cases\n      case 1:\n        handler.call(this);\n        break;\n      case 2:\n        handler.call(this, arguments[1]);\n        break;\n      case 3:\n        handler.call(this, arguments[1], arguments[2]);\n        break;\n      // slower\n      default:\n        args = Array.prototype.slice.call(arguments, 1);\n        handler.apply(this, args);\n    }\n  } else if (isObject(handler)) {\n    args = Array.prototype.slice.call(arguments, 1);\n    listeners = handler.slice();\n    len = listeners.length;\n    for (i = 0; i < len; i++)\n      listeners[i].apply(this, args);\n  }\n\n  return true;\n};\n\nEventEmitter.prototype.addListener = function(type, listener) {\n  var m;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events)\n    this._events = {};\n\n  // To avoid recursion in the case that type === \"newListener\"! Before\n  // adding it to the listeners, first emit \"newListener\".\n  if (this._events.newListener)\n    this.emit('newListener', type,\n              isFunction(listener.listener) ?\n              listener.listener : listener);\n\n  if (!this._events[type])\n    // Optimize the case of one listener. Don't need the extra array object.\n    this._events[type] = listener;\n  else if (isObject(this._events[type]))\n    // If we've already got an array, just append.\n    this._events[type].push(listener);\n  else\n    // Adding the second element, need to change to array.\n    this._events[type] = [this._events[type], listener];\n\n  // Check for listener leak\n  if (isObject(this._events[type]) && !this._events[type].warned) {\n    if (!isUndefined(this._maxListeners)) {\n      m = this._maxListeners;\n    } else {\n      m = EventEmitter.defaultMaxListeners;\n    }\n\n    if (m && m > 0 && this._events[type].length > m) {\n      this._events[type].warned = true;\n      console.error('(node) warning: possible EventEmitter memory ' +\n                    'leak detected. %d listeners added. ' +\n                    'Use emitter.setMaxListeners() to increase limit.',\n                    this._events[type].length);\n      if (typeof console.trace === 'function') {\n        // not supported in IE 10\n        console.trace();\n      }\n    }\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.on = EventEmitter.prototype.addListener;\n\nEventEmitter.prototype.once = function(type, listener) {\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  var fired = false;\n\n  function g() {\n    this.removeListener(type, g);\n\n    if (!fired) {\n      fired = true;\n      listener.apply(this, arguments);\n    }\n  }\n\n  g.listener = listener;\n  this.on(type, g);\n\n  return this;\n};\n\n// emits a 'removeListener' event iff the listener was removed\nEventEmitter.prototype.removeListener = function(type, listener) {\n  var list, position, length, i;\n\n  if (!isFunction(listener))\n    throw TypeError('listener must be a function');\n\n  if (!this._events || !this._events[type])\n    return this;\n\n  list = this._events[type];\n  length = list.length;\n  position = -1;\n\n  if (list === listener ||\n      (isFunction(list.listener) && list.listener === listener)) {\n    delete this._events[type];\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n\n  } else if (isObject(list)) {\n    for (i = length; i-- > 0;) {\n      if (list[i] === listener ||\n          (list[i].listener && list[i].listener === listener)) {\n        position = i;\n        break;\n      }\n    }\n\n    if (position < 0)\n      return this;\n\n    if (list.length === 1) {\n      list.length = 0;\n      delete this._events[type];\n    } else {\n      list.splice(position, 1);\n    }\n\n    if (this._events.removeListener)\n      this.emit('removeListener', type, listener);\n  }\n\n  return this;\n};\n\nEventEmitter.prototype.removeAllListeners = function(type) {\n  var key, listeners;\n\n  if (!this._events)\n    return this;\n\n  // not listening for removeListener, no need to emit\n  if (!this._events.removeListener) {\n    if (arguments.length === 0)\n      this._events = {};\n    else if (this._events[type])\n      delete this._events[type];\n    return this;\n  }\n\n  // emit removeListener for all listeners on all events\n  if (arguments.length === 0) {\n    for (key in this._events) {\n      if (key === 'removeListener') continue;\n      this.removeAllListeners(key);\n    }\n    this.removeAllListeners('removeListener');\n    this._events = {};\n    return this;\n  }\n\n  listeners = this._events[type];\n\n  if (isFunction(listeners)) {\n    this.removeListener(type, listeners);\n  } else if (listeners) {\n    // LIFO order\n    while (listeners.length)\n      this.removeListener(type, listeners[listeners.length - 1]);\n  }\n  delete this._events[type];\n\n  return this;\n};\n\nEventEmitter.prototype.listeners = function(type) {\n  var ret;\n  if (!this._events || !this._events[type])\n    ret = [];\n  else if (isFunction(this._events[type]))\n    ret = [this._events[type]];\n  else\n    ret = this._events[type].slice();\n  return ret;\n};\n\nEventEmitter.prototype.listenerCount = function(type) {\n  if (this._events) {\n    var evlistener = this._events[type];\n\n    if (isFunction(evlistener))\n      return 1;\n    else if (evlistener)\n      return evlistener.length;\n  }\n  return 0;\n};\n\nEventEmitter.listenerCount = function(emitter, type) {\n  return emitter.listenerCount(type);\n};\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\n\n},{}],48:[function(require,module,exports){\n(function (global){\n/*! https://mths.be/he v1.1.1 by @mathias | MIT license */\n;(function(root) {\n\n\t// Detect free variables `exports`.\n\tvar freeExports = typeof exports == 'object' && exports;\n\n\t// Detect free variable `module`.\n\tvar freeModule = typeof module == 'object' && module &&\n\t\tmodule.exports == freeExports && module;\n\n\t// Detect free variable `global`, from Node.js or Browserified code,\n\t// and use it as `root`.\n\tvar freeGlobal = typeof global == 'object' && global;\n\tif (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal) {\n\t\troot = freeGlobal;\n\t}\n\n\t/*--------------------------------------------------------------------------*/\n\n\t// All astral symbols.\n\tvar regexAstralSymbols = /[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]/g;\n\t// All ASCII symbols (not just printable ASCII) except those listed in the\n\t// first column of the overrides table.\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides\n\tvar regexAsciiWhitelist = /[\\x01-\\x7F]/g;\n\t// All BMP symbols that are not ASCII newlines, printable ASCII symbols, or\n\t// code points listed in the first column of the overrides table on\n\t// https://html.spec.whatwg.org/multipage/syntax.html#table-charref-overrides.\n\tvar regexBmpWhitelist = /[\\x01-\\t\\x0B\\f\\x0E-\\x1F\\x7F\\x81\\x8D\\x8F\\x90\\x9D\\xA0-\\uFFFF]/g;\n\n\tvar regexEncodeNonAscii = /<\\u20D2|=\\u20E5|>\\u20D2|\\u205F\\u200A|\\u219D\\u0338|\\u2202\\u0338|\\u2220\\u20D2|\\u2229\\uFE00|\\u222A\\uFE00|\\u223C\\u20D2|\\u223D\\u0331|\\u223E\\u0333|\\u2242\\u0338|\\u224B\\u0338|\\u224D\\u20D2|\\u224E\\u0338|\\u224F\\u0338|\\u2250\\u0338|\\u2261\\u20E5|\\u2264\\u20D2|\\u2265\\u20D2|\\u2266\\u0338|\\u2267\\u0338|\\u2268\\uFE00|\\u2269\\uFE00|\\u226A\\u0338|\\u226A\\u20D2|\\u226B\\u0338|\\u226B\\u20D2|\\u227F\\u0338|\\u2282\\u20D2|\\u2283\\u20D2|\\u228A\\uFE00|\\u228B\\uFE00|\\u228F\\u0338|\\u2290\\u0338|\\u2293\\uFE00|\\u2294\\uFE00|\\u22B4\\u20D2|\\u22B5\\u20D2|\\u22D8\\u0338|\\u22D9\\u0338|\\u22DA\\uFE00|\\u22DB\\uFE00|\\u22F5\\u0338|\\u22F9\\u0338|\\u2933\\u0338|\\u29CF\\u0338|\\u29D0\\u0338|\\u2A6D\\u0338|\\u2A70\\u0338|\\u2A7D\\u0338|\\u2A7E\\u0338|\\u2AA1\\u0338|\\u2AA2\\u0338|\\u2AAC\\uFE00|\\u2AAD\\uFE00|\\u2AAF\\u0338|\\u2AB0\\u0338|\\u2AC5\\u0338|\\u2AC6\\u0338|\\u2ACB\\uFE00|\\u2ACC\\uFE00|\\u2AFD\\u20E5|[\\xA0-\\u0113\\u0116-\\u0122\\u0124-\\u012B\\u012E-\\u014D\\u0150-\\u017E\\u0192\\u01B5\\u01F5\\u0237\\u02C6\\u02C7\\u02D8-\\u02DD\\u0311\\u0391-\\u03A1\\u03A3-\\u03A9\\u03B1-\\u03C9\\u03D1\\u03D2\\u03D5\\u03D6\\u03DC\\u03DD\\u03F0\\u03F1\\u03F5\\u03F6\\u0401-\\u040C\\u040E-\\u044F\\u0451-\\u045C\\u045E\\u045F\\u2002-\\u2005\\u2007-\\u2010\\u2013-\\u2016\\u2018-\\u201A\\u201C-\\u201E\\u2020-\\u2022\\u2025\\u2026\\u2030-\\u2035\\u2039\\u203A\\u203E\\u2041\\u2043\\u2044\\u204F\\u2057\\u205F-\\u2063\\u20AC\\u20DB\\u20DC\\u2102\\u2105\\u210A-\\u2113\\u2115-\\u211E\\u2122\\u2124\\u2127-\\u2129\\u212C\\u212D\\u212F-\\u2131\\u2133-\\u2138\\u2145-\\u2148\\u2153-\\u215E\\u2190-\\u219B\\u219D-\\u21A7\\u21A9-\\u21AE\\u21B0-\\u21B3\\u21B5-\\u21B7\\u21BA-\\u21DB\\u21DD\\u21E4\\u21E5\\u21F5\\u21FD-\\u2205\\u2207-\\u2209\\u220B\\u220C\\u220F-\\u2214\\u2216-\\u2218\\u221A\\u221D-\\u2238\\u223A-\\u2257\\u2259\\u225A\\u225C\\u225F-\\u2262\\u2264-\\u228B\\u228D-\\u229B\\u229D-\\u22A5\\u22A7-\\u22B0\\u22B2-\\u22BB\\u22BD-\\u22DB\\u22DE-\\u22E3\\u22E6-\\u22F7\\u22F9-\\u22FE\\u2305\\u2306\\u2308-\\u2310\\u2312\\u2313\\u2315\\u2316\\u231C-\\u231F\\u2322\\u2323\\u232D\\u232E\\u2336\\u233D\\u233F\\u237C\\u23B0\\u23B1\\u23B4-\\u23B6\\u23DC-\\u23DF\\u23E2\\u23E7\\u2423\\u24C8\\u2500\\u2502\\u250C\\u2510\\u2514\\u2518\\u251C\\u2524\\u252C\\u2534\\u253C\\u2550-\\u256C\\u2580\\u2584\\u2588\\u2591-\\u2593\\u25A1\\u25AA\\u25AB\\u25AD\\u25AE\\u25B1\\u25B3-\\u25B5\\u25B8\\u25B9\\u25BD-\\u25BF\\u25C2\\u25C3\\u25CA\\u25CB\\u25EC\\u25EF\\u25F8-\\u25FC\\u2605\\u2606\\u260E\\u2640\\u2642\\u2660\\u2663\\u2665\\u2666\\u266A\\u266D-\\u266F\\u2713\\u2717\\u2720\\u2736\\u2758\\u2772\\u2773\\u27C8\\u27C9\\u27E6-\\u27ED\\u27F5-\\u27FA\\u27FC\\u27FF\\u2902-\\u2905\\u290C-\\u2913\\u2916\\u2919-\\u2920\\u2923-\\u292A\\u2933\\u2935-\\u2939\\u293C\\u293D\\u2945\\u2948-\\u294B\\u294E-\\u2976\\u2978\\u2979\\u297B-\\u297F\\u2985\\u2986\\u298B-\\u2996\\u299A\\u299C\\u299D\\u29A4-\\u29B7\\u29B9\\u29BB\\u29BC\\u29BE-\\u29C5\\u29C9\\u29CD-\\u29D0\\u29DC-\\u29DE\\u29E3-\\u29E5\\u29EB\\u29F4\\u29F6\\u2A00-\\u2A02\\u2A04\\u2A06\\u2A0C\\u2A0D\\u2A10-\\u2A17\\u2A22-\\u2A27\\u2A29\\u2A2A\\u2A2D-\\u2A31\\u2A33-\\u2A3C\\u2A3F\\u2A40\\u2A42-\\u2A4D\\u2A50\\u2A53-\\u2A58\\u2A5A-\\u2A5D\\u2A5F\\u2A66\\u2A6A\\u2A6D-\\u2A75\\u2A77-\\u2A9A\\u2A9D-\\u2AA2\\u2AA4-\\u2AB0\\u2AB3-\\u2AC8\\u2ACB\\u2ACC\\u2ACF-\\u2ADB\\u2AE4\\u2AE6-\\u2AE9\\u2AEB-\\u2AF3\\u2AFD\\uFB00-\\uFB04]|\\uD835[\\uDC9C\\uDC9E\\uDC9F\\uDCA2\\uDCA5\\uDCA6\\uDCA9-\\uDCAC\\uDCAE-\\uDCB9\\uDCBB\\uDCBD-\\uDCC3\\uDCC5-\\uDCCF\\uDD04\\uDD05\\uDD07-\\uDD0A\\uDD0D-\\uDD14\\uDD16-\\uDD1C\\uDD1E-\\uDD39\\uDD3B-\\uDD3E\\uDD40-\\uDD44\\uDD46\\uDD4A-\\uDD50\\uDD52-\\uDD6B]/g;\n\tvar encodeMap = {'\\xAD':'shy','\\u200C':'zwnj','\\u200D':'zwj','\\u200E':'lrm','\\u2063':'ic','\\u2062':'it','\\u2061':'af','\\u200F':'rlm','\\u200B':'ZeroWidthSpace','\\u2060':'NoBreak','\\u0311':'DownBreve','\\u20DB':'tdot','\\u20DC':'DotDot','\\t':'Tab','\\n':'NewLine','\\u2008':'puncsp','\\u205F':'MediumSpace','\\u2009':'thinsp','\\u200A':'hairsp','\\u2004':'emsp13','\\u2002':'ensp','\\u2005':'emsp14','\\u2003':'emsp','\\u2007':'numsp','\\xA0':'nbsp','\\u205F\\u200A':'ThickSpace','\\u203E':'oline','_':'lowbar','\\u2010':'dash','\\u2013':'ndash','\\u2014':'mdash','\\u2015':'horbar',',':'comma',';':'semi','\\u204F':'bsemi',':':'colon','\\u2A74':'Colone','!':'excl','\\xA1':'iexcl','?':'quest','\\xBF':'iquest','.':'period','\\u2025':'nldr','\\u2026':'mldr','\\xB7':'middot','\\'':'apos','\\u2018':'lsquo','\\u2019':'rsquo','\\u201A':'sbquo','\\u2039':'lsaquo','\\u203A':'rsaquo','\"':'quot','\\u201C':'ldquo','\\u201D':'rdquo','\\u201E':'bdquo','\\xAB':'laquo','\\xBB':'raquo','(':'lpar',')':'rpar','[':'lsqb',']':'rsqb','{':'lcub','}':'rcub','\\u2308':'lceil','\\u2309':'rceil','\\u230A':'lfloor','\\u230B':'rfloor','\\u2985':'lopar','\\u2986':'ropar','\\u298B':'lbrke','\\u298C':'rbrke','\\u298D':'lbrkslu','\\u298E':'rbrksld','\\u298F':'lbrksld','\\u2990':'rbrkslu','\\u2991':'langd','\\u2992':'rangd','\\u2993':'lparlt','\\u2994':'rpargt','\\u2995':'gtlPar','\\u2996':'ltrPar','\\u27E6':'lobrk','\\u27E7':'robrk','\\u27E8':'lang','\\u27E9':'rang','\\u27EA':'Lang','\\u27EB':'Rang','\\u27EC':'loang','\\u27ED':'roang','\\u2772':'lbbrk','\\u2773':'rbbrk','\\u2016':'Vert','\\xA7':'sect','\\xB6':'para','@':'commat','*':'ast','/':'sol','undefined':null,'&':'amp','#':'num','%':'percnt','\\u2030':'permil','\\u2031':'pertenk','\\u2020':'dagger','\\u2021':'Dagger','\\u2022':'bull','\\u2043':'hybull','\\u2032':'prime','\\u2033':'Prime','\\u2034':'tprime','\\u2057':'qprime','\\u2035':'bprime','\\u2041':'caret','`':'grave','\\xB4':'acute','\\u02DC':'tilde','^':'Hat','\\xAF':'macr','\\u02D8':'breve','\\u02D9':'dot','\\xA8':'die','\\u02DA':'ring','\\u02DD':'dblac','\\xB8':'cedil','\\u02DB':'ogon','\\u02C6':'circ','\\u02C7':'caron','\\xB0':'deg','\\xA9':'copy','\\xAE':'reg','\\u2117':'copysr','\\u2118':'wp','\\u211E':'rx','\\u2127':'mho','\\u2129':'iiota','\\u2190':'larr','\\u219A':'nlarr','\\u2192':'rarr','\\u219B':'nrarr','\\u2191':'uarr','\\u2193':'darr','\\u2194':'harr','\\u21AE':'nharr','\\u2195':'varr','\\u2196':'nwarr','\\u2197':'nearr','\\u2198':'searr','\\u2199':'swarr','\\u219D':'rarrw','\\u219D\\u0338':'nrarrw','\\u219E':'Larr','\\u219F':'Uarr','\\u21A0':'Rarr','\\u21A1':'Darr','\\u21A2':'larrtl','\\u21A3':'rarrtl','\\u21A4':'mapstoleft','\\u21A5':'mapstoup','\\u21A6':'map','\\u21A7':'mapstodown','\\u21A9':'larrhk','\\u21AA':'rarrhk','\\u21AB':'larrlp','\\u21AC':'rarrlp','\\u21AD':'harrw','\\u21B0':'lsh','\\u21B1':'rsh','\\u21B2':'ldsh','\\u21B3':'rdsh','\\u21B5':'crarr','\\u21B6':'cularr','\\u21B7':'curarr','\\u21BA':'olarr','\\u21BB':'orarr','\\u21BC':'lharu','\\u21BD':'lhard','\\u21BE':'uharr','\\u21BF':'uharl','\\u21C0':'rharu','\\u21C1':'rhard','\\u21C2':'dharr','\\u21C3':'dharl','\\u21C4':'rlarr','\\u21C5':'udarr','\\u21C6':'lrarr','\\u21C7':'llarr','\\u21C8':'uuarr','\\u21C9':'rrarr','\\u21CA':'ddarr','\\u21CB':'lrhar','\\u21CC':'rlhar','\\u21D0':'lArr','\\u21CD':'nlArr','\\u21D1':'uArr','\\u21D2':'rArr','\\u21CF':'nrArr','\\u21D3':'dArr','\\u21D4':'iff','\\u21CE':'nhArr','\\u21D5':'vArr','\\u21D6':'nwArr','\\u21D7':'neArr','\\u21D8':'seArr','\\u21D9':'swArr','\\u21DA':'lAarr','\\u21DB':'rAarr','\\u21DD':'zigrarr','\\u21E4':'larrb','\\u21E5':'rarrb','\\u21F5':'duarr','\\u21FD':'loarr','\\u21FE':'roarr','\\u21FF':'hoarr','\\u2200':'forall','\\u2201':'comp','\\u2202':'part','\\u2202\\u0338':'npart','\\u2203':'exist','\\u2204':'nexist','\\u2205':'empty','\\u2207':'Del','\\u2208':'in','\\u2209':'notin','\\u220B':'ni','\\u220C':'notni','\\u03F6':'bepsi','\\u220F':'prod','\\u2210':'coprod','\\u2211':'sum','+':'plus','\\xB1':'pm','\\xF7':'div','\\xD7':'times','<':'lt','\\u226E':'nlt','<\\u20D2':'nvlt','=':'equals','\\u2260':'ne','=\\u20E5':'bne','\\u2A75':'Equal','>':'gt','\\u226F':'ngt','>\\u20D2':'nvgt','\\xAC':'not','|':'vert','\\xA6':'brvbar','\\u2212':'minus','\\u2213':'mp','\\u2214':'plusdo','\\u2044':'frasl','\\u2216':'setmn','\\u2217':'lowast','\\u2218':'compfn','\\u221A':'Sqrt','\\u221D':'prop','\\u221E':'infin','\\u221F':'angrt','\\u2220':'ang','\\u2220\\u20D2':'nang','\\u2221':'angmsd','\\u2222':'angsph','\\u2223':'mid','\\u2224':'nmid','\\u2225':'par','\\u2226':'npar','\\u2227':'and','\\u2228':'or','\\u2229':'cap','\\u2229\\uFE00':'caps','\\u222A':'cup','\\u222A\\uFE00':'cups','\\u222B':'int','\\u222C':'Int','\\u222D':'tint','\\u2A0C':'qint','\\u222E':'oint','\\u222F':'Conint','\\u2230':'Cconint','\\u2231':'cwint','\\u2232':'cwconint','\\u2233':'awconint','\\u2234':'there4','\\u2235':'becaus','\\u2236':'ratio','\\u2237':'Colon','\\u2238':'minusd','\\u223A':'mDDot','\\u223B':'homtht','\\u223C':'sim','\\u2241':'nsim','\\u223C\\u20D2':'nvsim','\\u223D':'bsim','\\u223D\\u0331':'race','\\u223E':'ac','\\u223E\\u0333':'acE','\\u223F':'acd','\\u2240':'wr','\\u2242':'esim','\\u2242\\u0338':'nesim','\\u2243':'sime','\\u2244':'nsime','\\u2245':'cong','\\u2247':'ncong','\\u2246':'simne','\\u2248':'ap','\\u2249':'nap','\\u224A':'ape','\\u224B':'apid','\\u224B\\u0338':'napid','\\u224C':'bcong','\\u224D':'CupCap','\\u226D':'NotCupCap','\\u224D\\u20D2':'nvap','\\u224E':'bump','\\u224E\\u0338':'nbump','\\u224F':'bumpe','\\u224F\\u0338':'nbumpe','\\u2250':'doteq','\\u2250\\u0338':'nedot','\\u2251':'eDot','\\u2252':'efDot','\\u2253':'erDot','\\u2254':'colone','\\u2255':'ecolon','\\u2256':'ecir','\\u2257':'cire','\\u2259':'wedgeq','\\u225A':'veeeq','\\u225C':'trie','\\u225F':'equest','\\u2261':'equiv','\\u2262':'nequiv','\\u2261\\u20E5':'bnequiv','\\u2264':'le','\\u2270':'nle','\\u2264\\u20D2':'nvle','\\u2265':'ge','\\u2271':'nge','\\u2265\\u20D2':'nvge','\\u2266':'lE','\\u2266\\u0338':'nlE','\\u2267':'gE','\\u2267\\u0338':'ngE','\\u2268\\uFE00':'lvnE','\\u2268':'lnE','\\u2269':'gnE','\\u2269\\uFE00':'gvnE','\\u226A':'ll','\\u226A\\u0338':'nLtv','\\u226A\\u20D2':'nLt','\\u226B':'gg','\\u226B\\u0338':'nGtv','\\u226B\\u20D2':'nGt','\\u226C':'twixt','\\u2272':'lsim','\\u2274':'nlsim','\\u2273':'gsim','\\u2275':'ngsim','\\u2276':'lg','\\u2278':'ntlg','\\u2277':'gl','\\u2279':'ntgl','\\u227A':'pr','\\u2280':'npr','\\u227B':'sc','\\u2281':'nsc','\\u227C':'prcue','\\u22E0':'nprcue','\\u227D':'sccue','\\u22E1':'nsccue','\\u227E':'prsim','\\u227F':'scsim','\\u227F\\u0338':'NotSucceedsTilde','\\u2282':'sub','\\u2284':'nsub','\\u2282\\u20D2':'vnsub','\\u2283':'sup','\\u2285':'nsup','\\u2283\\u20D2':'vnsup','\\u2286':'sube','\\u2288':'nsube','\\u2287':'supe','\\u2289':'nsupe','\\u228A\\uFE00':'vsubne','\\u228A':'subne','\\u228B\\uFE00':'vsupne','\\u228B':'supne','\\u228D':'cupdot','\\u228E':'uplus','\\u228F':'sqsub','\\u228F\\u0338':'NotSquareSubset','\\u2290':'sqsup','\\u2290\\u0338':'NotSquareSuperset','\\u2291':'sqsube','\\u22E2':'nsqsube','\\u2292':'sqsupe','\\u22E3':'nsqsupe','\\u2293':'sqcap','\\u2293\\uFE00':'sqcaps','\\u2294':'sqcup','\\u2294\\uFE00':'sqcups','\\u2295':'oplus','\\u2296':'ominus','\\u2297':'otimes','\\u2298':'osol','\\u2299':'odot','\\u229A':'ocir','\\u229B':'oast','\\u229D':'odash','\\u229E':'plusb','\\u229F':'minusb','\\u22A0':'timesb','\\u22A1':'sdotb','\\u22A2':'vdash','\\u22AC':'nvdash','\\u22A3':'dashv','\\u22A4':'top','\\u22A5':'bot','\\u22A7':'models','\\u22A8':'vDash','\\u22AD':'nvDash','\\u22A9':'Vdash','\\u22AE':'nVdash','\\u22AA':'Vvdash','\\u22AB':'VDash','\\u22AF':'nVDash','\\u22B0':'prurel','\\u22B2':'vltri','\\u22EA':'nltri','\\u22B3':'vrtri','\\u22EB':'nrtri','\\u22B4':'ltrie','\\u22EC':'nltrie','\\u22B4\\u20D2':'nvltrie','\\u22B5':'rtrie','\\u22ED':'nrtrie','\\u22B5\\u20D2':'nvrtrie','\\u22B6':'origof','\\u22B7':'imof','\\u22B8':'mumap','\\u22B9':'hercon','\\u22BA':'intcal','\\u22BB':'veebar','\\u22BD':'barvee','\\u22BE':'angrtvb','\\u22BF':'lrtri','\\u22C0':'Wedge','\\u22C1':'Vee','\\u22C2':'xcap','\\u22C3':'xcup','\\u22C4':'diam','\\u22C5':'sdot','\\u22C6':'Star','\\u22C7':'divonx','\\u22C8':'bowtie','\\u22C9':'ltimes','\\u22CA':'rtimes','\\u22CB':'lthree','\\u22CC':'rthree','\\u22CD':'bsime','\\u22CE':'cuvee','\\u22CF':'cuwed','\\u22D0':'Sub','\\u22D1':'Sup','\\u22D2':'Cap','\\u22D3':'Cup','\\u22D4':'fork','\\u22D5':'epar','\\u22D6':'ltdot','\\u22D7':'gtdot','\\u22D8':'Ll','\\u22D8\\u0338':'nLl','\\u22D9':'Gg','\\u22D9\\u0338':'nGg','\\u22DA\\uFE00':'lesg','\\u22DA':'leg','\\u22DB':'gel','\\u22DB\\uFE00':'gesl','\\u22DE':'cuepr','\\u22DF':'cuesc','\\u22E6':'lnsim','\\u22E7':'gnsim','\\u22E8':'prnsim','\\u22E9':'scnsim','\\u22EE':'vellip','\\u22EF':'ctdot','\\u22F0':'utdot','\\u22F1':'dtdot','\\u22F2':'disin','\\u22F3':'isinsv','\\u22F4':'isins','\\u22F5':'isindot','\\u22F5\\u0338':'notindot','\\u22F6':'notinvc','\\u22F7':'notinvb','\\u22F9':'isinE','\\u22F9\\u0338':'notinE','\\u22FA':'nisd','\\u22FB':'xnis','\\u22FC':'nis','\\u22FD':'notnivc','\\u22FE':'notnivb','\\u2305':'barwed','\\u2306':'Barwed','\\u230C':'drcrop','\\u230D':'dlcrop','\\u230E':'urcrop','\\u230F':'ulcrop','\\u2310':'bnot','\\u2312':'profline','\\u2313':'profsurf','\\u2315':'telrec','\\u2316':'target','\\u231C':'ulcorn','\\u231D':'urcorn','\\u231E':'dlcorn','\\u231F':'drcorn','\\u2322':'frown','\\u2323':'smile','\\u232D':'cylcty','\\u232E':'profalar','\\u2336':'topbot','\\u233D':'ovbar','\\u233F':'solbar','\\u237C':'angzarr','\\u23B0':'lmoust','\\u23B1':'rmoust','\\u23B4':'tbrk','\\u23B5':'bbrk','\\u23B6':'bbrktbrk','\\u23DC':'OverParenthesis','\\u23DD':'UnderParenthesis','\\u23DE':'OverBrace','\\u23DF':'UnderBrace','\\u23E2':'trpezium','\\u23E7':'elinters','\\u2423':'blank','\\u2500':'boxh','\\u2502':'boxv','\\u250C':'boxdr','\\u2510':'boxdl','\\u2514':'boxur','\\u2518':'boxul','\\u251C':'boxvr','\\u2524':'boxvl','\\u252C':'boxhd','\\u2534':'boxhu','\\u253C':'boxvh','\\u2550':'boxH','\\u2551':'boxV','\\u2552':'boxdR','\\u2553':'boxDr','\\u2554':'boxDR','\\u2555':'boxdL','\\u2556':'boxDl','\\u2557':'boxDL','\\u2558':'boxuR','\\u2559':'boxUr','\\u255A':'boxUR','\\u255B':'boxuL','\\u255C':'boxUl','\\u255D':'boxUL','\\u255E':'boxvR','\\u255F':'boxVr','\\u2560':'boxVR','\\u2561':'boxvL','\\u2562':'boxVl','\\u2563':'boxVL','\\u2564':'boxHd','\\u2565':'boxhD','\\u2566':'boxHD','\\u2567':'boxHu','\\u2568':'boxhU','\\u2569':'boxHU','\\u256A':'boxvH','\\u256B':'boxVh','\\u256C':'boxVH','\\u2580':'uhblk','\\u2584':'lhblk','\\u2588':'block','\\u2591':'blk14','\\u2592':'blk12','\\u2593':'blk34','\\u25A1':'squ','\\u25AA':'squf','\\u25AB':'EmptyVerySmallSquare','\\u25AD':'rect','\\u25AE':'marker','\\u25B1':'fltns','\\u25B3':'xutri','\\u25B4':'utrif','\\u25B5':'utri','\\u25B8':'rtrif','\\u25B9':'rtri','\\u25BD':'xdtri','\\u25BE':'dtrif','\\u25BF':'dtri','\\u25C2':'ltrif','\\u25C3':'ltri','\\u25CA':'loz','\\u25CB':'cir','\\u25EC':'tridot','\\u25EF':'xcirc','\\u25F8':'ultri','\\u25F9':'urtri','\\u25FA':'lltri','\\u25FB':'EmptySmallSquare','\\u25FC':'FilledSmallSquare','\\u2605':'starf','\\u2606':'star','\\u260E':'phone','\\u2640':'female','\\u2642':'male','\\u2660':'spades','\\u2663':'clubs','\\u2665':'hearts','\\u2666':'diams','\\u266A':'sung','\\u2713':'check','\\u2717':'cross','\\u2720':'malt','\\u2736':'sext','\\u2758':'VerticalSeparator','\\u27C8':'bsolhsub','\\u27C9':'suphsol','\\u27F5':'xlarr','\\u27F6':'xrarr','\\u27F7':'xharr','\\u27F8':'xlArr','\\u27F9':'xrArr','\\u27FA':'xhArr','\\u27FC':'xmap','\\u27FF':'dzigrarr','\\u2902':'nvlArr','\\u2903':'nvrArr','\\u2904':'nvHarr','\\u2905':'Map','\\u290C':'lbarr','\\u290D':'rbarr','\\u290E':'lBarr','\\u290F':'rBarr','\\u2910':'RBarr','\\u2911':'DDotrahd','\\u2912':'UpArrowBar','\\u2913':'DownArrowBar','\\u2916':'Rarrtl','\\u2919':'latail','\\u291A':'ratail','\\u291B':'lAtail','\\u291C':'rAtail','\\u291D':'larrfs','\\u291E':'rarrfs','\\u291F':'larrbfs','\\u2920':'rarrbfs','\\u2923':'nwarhk','\\u2924':'nearhk','\\u2925':'searhk','\\u2926':'swarhk','\\u2927':'nwnear','\\u2928':'toea','\\u2929':'tosa','\\u292A':'swnwar','\\u2933':'rarrc','\\u2933\\u0338':'nrarrc','\\u2935':'cudarrr','\\u2936':'ldca','\\u2937':'rdca','\\u2938':'cudarrl','\\u2939':'larrpl','\\u293C':'curarrm','\\u293D':'cularrp','\\u2945':'rarrpl','\\u2948':'harrcir','\\u2949':'Uarrocir','\\u294A':'lurdshar','\\u294B':'ldrushar','\\u294E':'LeftRightVector','\\u294F':'RightUpDownVector','\\u2950':'DownLeftRightVector','\\u2951':'LeftUpDownVector','\\u2952':'LeftVectorBar','\\u2953':'RightVectorBar','\\u2954':'RightUpVectorBar','\\u2955':'RightDownVectorBar','\\u2956':'DownLeftVectorBar','\\u2957':'DownRightVectorBar','\\u2958':'LeftUpVectorBar','\\u2959':'LeftDownVectorBar','\\u295A':'LeftTeeVector','\\u295B':'RightTeeVector','\\u295C':'RightUpTeeVector','\\u295D':'RightDownTeeVector','\\u295E':'DownLeftTeeVector','\\u295F':'DownRightTeeVector','\\u2960':'LeftUpTeeVector','\\u2961':'LeftDownTeeVector','\\u2962':'lHar','\\u2963':'uHar','\\u2964':'rHar','\\u2965':'dHar','\\u2966':'luruhar','\\u2967':'ldrdhar','\\u2968':'ruluhar','\\u2969':'rdldhar','\\u296A':'lharul','\\u296B':'llhard','\\u296C':'rharul','\\u296D':'lrhard','\\u296E':'udhar','\\u296F':'duhar','\\u2970':'RoundImplies','\\u2971':'erarr','\\u2972':'simrarr','\\u2973':'larrsim','\\u2974':'rarrsim','\\u2975':'rarrap','\\u2976':'ltlarr','\\u2978':'gtrarr','\\u2979':'subrarr','\\u297B':'suplarr','\\u297C':'lfisht','\\u297D':'rfisht','\\u297E':'ufisht','\\u297F':'dfisht','\\u299A':'vzigzag','\\u299C':'vangrt','\\u299D':'angrtvbd','\\u29A4':'ange','\\u29A5':'range','\\u29A6':'dwangle','\\u29A7':'uwangle','\\u29A8':'angmsdaa','\\u29A9':'angmsdab','\\u29AA':'angmsdac','\\u29AB':'angmsdad','\\u29AC':'angmsdae','\\u29AD':'angmsdaf','\\u29AE':'angmsdag','\\u29AF':'angmsdah','\\u29B0':'bemptyv','\\u29B1':'demptyv','\\u29B2':'cemptyv','\\u29B3':'raemptyv','\\u29B4':'laemptyv','\\u29B5':'ohbar','\\u29B6':'omid','\\u29B7':'opar','\\u29B9':'operp','\\u29BB':'olcross','\\u29BC':'odsold','\\u29BE':'olcir','\\u29BF':'ofcir','\\u29C0':'olt','\\u29C1':'ogt','\\u29C2':'cirscir','\\u29C3':'cirE','\\u29C4':'solb','\\u29C5':'bsolb','\\u29C9':'boxbox','\\u29CD':'trisb','\\u29CE':'rtriltri','\\u29CF':'LeftTriangleBar','\\u29CF\\u0338':'NotLeftTriangleBar','\\u29D0':'RightTriangleBar','\\u29D0\\u0338':'NotRightTriangleBar','\\u29DC':'iinfin','\\u29DD':'infintie','\\u29DE':'nvinfin','\\u29E3':'eparsl','\\u29E4':'smeparsl','\\u29E5':'eqvparsl','\\u29EB':'lozf','\\u29F4':'RuleDelayed','\\u29F6':'dsol','\\u2A00':'xodot','\\u2A01':'xoplus','\\u2A02':'xotime','\\u2A04':'xuplus','\\u2A06':'xsqcup','\\u2A0D':'fpartint','\\u2A10':'cirfnint','\\u2A11':'awint','\\u2A12':'rppolint','\\u2A13':'scpolint','\\u2A14':'npolint','\\u2A15':'pointint','\\u2A16':'quatint','\\u2A17':'intlarhk','\\u2A22':'pluscir','\\u2A23':'plusacir','\\u2A24':'simplus','\\u2A25':'plusdu','\\u2A26':'plussim','\\u2A27':'plustwo','\\u2A29':'mcomma','\\u2A2A':'minusdu','\\u2A2D':'loplus','\\u2A2E':'roplus','\\u2A2F':'Cross','\\u2A30':'timesd','\\u2A31':'timesbar','\\u2A33':'smashp','\\u2A34':'lotimes','\\u2A35':'rotimes','\\u2A36':'otimesas','\\u2A37':'Otimes','\\u2A38':'odiv','\\u2A39':'triplus','\\u2A3A':'triminus','\\u2A3B':'tritime','\\u2A3C':'iprod','\\u2A3F':'amalg','\\u2A40':'capdot','\\u2A42':'ncup','\\u2A43':'ncap','\\u2A44':'capand','\\u2A45':'cupor','\\u2A46':'cupcap','\\u2A47':'capcup','\\u2A48':'cupbrcap','\\u2A49':'capbrcup','\\u2A4A':'cupcup','\\u2A4B':'capcap','\\u2A4C':'ccups','\\u2A4D':'ccaps','\\u2A50':'ccupssm','\\u2A53':'And','\\u2A54':'Or','\\u2A55':'andand','\\u2A56':'oror','\\u2A57':'orslope','\\u2A58':'andslope','\\u2A5A':'andv','\\u2A5B':'orv','\\u2A5C':'andd','\\u2A5D':'ord','\\u2A5F':'wedbar','\\u2A66':'sdote','\\u2A6A':'simdot','\\u2A6D':'congdot','\\u2A6D\\u0338':'ncongdot','\\u2A6E':'easter','\\u2A6F':'apacir','\\u2A70':'apE','\\u2A70\\u0338':'napE','\\u2A71':'eplus','\\u2A72':'pluse','\\u2A73':'Esim','\\u2A77':'eDDot','\\u2A78':'equivDD','\\u2A79':'ltcir','\\u2A7A':'gtcir','\\u2A7B':'ltquest','\\u2A7C':'gtquest','\\u2A7D':'les','\\u2A7D\\u0338':'nles','\\u2A7E':'ges','\\u2A7E\\u0338':'nges','\\u2A7F':'lesdot','\\u2A80':'gesdot','\\u2A81':'lesdoto','\\u2A82':'gesdoto','\\u2A83':'lesdotor','\\u2A84':'gesdotol','\\u2A85':'lap','\\u2A86':'gap','\\u2A87':'lne','\\u2A88':'gne','\\u2A89':'lnap','\\u2A8A':'gnap','\\u2A8B':'lEg','\\u2A8C':'gEl','\\u2A8D':'lsime','\\u2A8E':'gsime','\\u2A8F':'lsimg','\\u2A90':'gsiml','\\u2A91':'lgE','\\u2A92':'glE','\\u2A93':'lesges','\\u2A94':'gesles','\\u2A95':'els','\\u2A96':'egs','\\u2A97':'elsdot','\\u2A98':'egsdot','\\u2A99':'el','\\u2A9A':'eg','\\u2A9D':'siml','\\u2A9E':'simg','\\u2A9F':'simlE','\\u2AA0':'simgE','\\u2AA1':'LessLess','\\u2AA1\\u0338':'NotNestedLessLess','\\u2AA2':'GreaterGreater','\\u2AA2\\u0338':'NotNestedGreaterGreater','\\u2AA4':'glj','\\u2AA5':'gla','\\u2AA6':'ltcc','\\u2AA7':'gtcc','\\u2AA8':'lescc','\\u2AA9':'gescc','\\u2AAA':'smt','\\u2AAB':'lat','\\u2AAC':'smte','\\u2AAC\\uFE00':'smtes','\\u2AAD':'late','\\u2AAD\\uFE00':'lates','\\u2AAE':'bumpE','\\u2AAF':'pre','\\u2AAF\\u0338':'npre','\\u2AB0':'sce','\\u2AB0\\u0338':'nsce','\\u2AB3':'prE','\\u2AB4':'scE','\\u2AB5':'prnE','\\u2AB6':'scnE','\\u2AB7':'prap','\\u2AB8':'scap','\\u2AB9':'prnap','\\u2ABA':'scnap','\\u2ABB':'Pr','\\u2ABC':'Sc','\\u2ABD':'subdot','\\u2ABE':'supdot','\\u2ABF':'subplus','\\u2AC0':'supplus','\\u2AC1':'submult','\\u2AC2':'supmult','\\u2AC3':'subedot','\\u2AC4':'supedot','\\u2AC5':'subE','\\u2AC5\\u0338':'nsubE','\\u2AC6':'supE','\\u2AC6\\u0338':'nsupE','\\u2AC7':'subsim','\\u2AC8':'supsim','\\u2ACB\\uFE00':'vsubnE','\\u2ACB':'subnE','\\u2ACC\\uFE00':'vsupnE','\\u2ACC':'supnE','\\u2ACF':'csub','\\u2AD0':'csup','\\u2AD1':'csube','\\u2AD2':'csupe','\\u2AD3':'subsup','\\u2AD4':'supsub','\\u2AD5':'subsub','\\u2AD6':'supsup','\\u2AD7':'suphsub','\\u2AD8':'supdsub','\\u2AD9':'forkv','\\u2ADA':'topfork','\\u2ADB':'mlcp','\\u2AE4':'Dashv','\\u2AE6':'Vdashl','\\u2AE7':'Barv','\\u2AE8':'vBar','\\u2AE9':'vBarv','\\u2AEB':'Vbar','\\u2AEC':'Not','\\u2AED':'bNot','\\u2AEE':'rnmid','\\u2AEF':'cirmid','\\u2AF0':'midcir','\\u2AF1':'topcir','\\u2AF2':'nhpar','\\u2AF3':'parsim','\\u2AFD':'parsl','\\u2AFD\\u20E5':'nparsl','\\u266D':'flat','\\u266E':'natur','\\u266F':'sharp','\\xA4':'curren','\\xA2':'cent','$':'dollar','\\xA3':'pound','\\xA5':'yen','\\u20AC':'euro','\\xB9':'sup1','\\xBD':'half','\\u2153':'frac13','\\xBC':'frac14','\\u2155':'frac15','\\u2159':'frac16','\\u215B':'frac18','\\xB2':'sup2','\\u2154':'frac23','\\u2156':'frac25','\\xB3':'sup3','\\xBE':'frac34','\\u2157':'frac35','\\u215C':'frac38','\\u2158':'frac45','\\u215A':'frac56','\\u215D':'frac58','\\u215E':'frac78','\\uD835\\uDCB6':'ascr','\\uD835\\uDD52':'aopf','\\uD835\\uDD1E':'afr','\\uD835\\uDD38':'Aopf','\\uD835\\uDD04':'Afr','\\uD835\\uDC9C':'Ascr','\\xAA':'ordf','\\xE1':'aacute','\\xC1':'Aacute','\\xE0':'agrave','\\xC0':'Agrave','\\u0103':'abreve','\\u0102':'Abreve','\\xE2':'acirc','\\xC2':'Acirc','\\xE5':'aring','\\xC5':'angst','\\xE4':'auml','\\xC4':'Auml','\\xE3':'atilde','\\xC3':'Atilde','\\u0105':'aogon','\\u0104':'Aogon','\\u0101':'amacr','\\u0100':'Amacr','\\xE6':'aelig','\\xC6':'AElig','\\uD835\\uDCB7':'bscr','\\uD835\\uDD53':'bopf','\\uD835\\uDD1F':'bfr','\\uD835\\uDD39':'Bopf','\\u212C':'Bscr','\\uD835\\uDD05':'Bfr','\\uD835\\uDD20':'cfr','\\uD835\\uDCB8':'cscr','\\uD835\\uDD54':'copf','\\u212D':'Cfr','\\uD835\\uDC9E':'Cscr','\\u2102':'Copf','\\u0107':'cacute','\\u0106':'Cacute','\\u0109':'ccirc','\\u0108':'Ccirc','\\u010D':'ccaron','\\u010C':'Ccaron','\\u010B':'cdot','\\u010A':'Cdot','\\xE7':'ccedil','\\xC7':'Ccedil','\\u2105':'incare','\\uD835\\uDD21':'dfr','\\u2146':'dd','\\uD835\\uDD55':'dopf','\\uD835\\uDCB9':'dscr','\\uD835\\uDC9F':'Dscr','\\uD835\\uDD07':'Dfr','\\u2145':'DD','\\uD835\\uDD3B':'Dopf','\\u010F':'dcaron','\\u010E':'Dcaron','\\u0111':'dstrok','\\u0110':'Dstrok','\\xF0':'eth','\\xD0':'ETH','\\u2147':'ee','\\u212F':'escr','\\uD835\\uDD22':'efr','\\uD835\\uDD56':'eopf','\\u2130':'Escr','\\uD835\\uDD08':'Efr','\\uD835\\uDD3C':'Eopf','\\xE9':'eacute','\\xC9':'Eacute','\\xE8':'egrave','\\xC8':'Egrave','\\xEA':'ecirc','\\xCA':'Ecirc','\\u011B':'ecaron','\\u011A':'Ecaron','\\xEB':'euml','\\xCB':'Euml','\\u0117':'edot','\\u0116':'Edot','\\u0119':'eogon','\\u0118':'Eogon','\\u0113':'emacr','\\u0112':'Emacr','\\uD835\\uDD23':'ffr','\\uD835\\uDD57':'fopf','\\uD835\\uDCBB':'fscr','\\uD835\\uDD09':'Ffr','\\uD835\\uDD3D':'Fopf','\\u2131':'Fscr','\\uFB00':'fflig','\\uFB03':'ffilig','\\uFB04':'ffllig','\\uFB01':'filig','fj':'fjlig','\\uFB02':'fllig','\\u0192':'fnof','\\u210A':'gscr','\\uD835\\uDD58':'gopf','\\uD835\\uDD24':'gfr','\\uD835\\uDCA2':'Gscr','\\uD835\\uDD3E':'Gopf','\\uD835\\uDD0A':'Gfr','\\u01F5':'gacute','\\u011F':'gbreve','\\u011E':'Gbreve','\\u011D':'gcirc','\\u011C':'Gcirc','\\u0121':'gdot','\\u0120':'Gdot','\\u0122':'Gcedil','\\uD835\\uDD25':'hfr','\\u210E':'planckh','\\uD835\\uDCBD':'hscr','\\uD835\\uDD59':'hopf','\\u210B':'Hscr','\\u210C':'Hfr','\\u210D':'Hopf','\\u0125':'hcirc','\\u0124':'Hcirc','\\u210F':'hbar','\\u0127':'hstrok','\\u0126':'Hstrok','\\uD835\\uDD5A':'iopf','\\uD835\\uDD26':'ifr','\\uD835\\uDCBE':'iscr','\\u2148':'ii','\\uD835\\uDD40':'Iopf','\\u2110':'Iscr','\\u2111':'Im','\\xED':'iacute','\\xCD':'Iacute','\\xEC':'igrave','\\xCC':'Igrave','\\xEE':'icirc','\\xCE':'Icirc','\\xEF':'iuml','\\xCF':'Iuml','\\u0129':'itilde','\\u0128':'Itilde','\\u0130':'Idot','\\u012F':'iogon','\\u012E':'Iogon','\\u012B':'imacr','\\u012A':'Imacr','\\u0133':'ijlig','\\u0132':'IJlig','\\u0131':'imath','\\uD835\\uDCBF':'jscr','\\uD835\\uDD5B':'jopf','\\uD835\\uDD27':'jfr','\\uD835\\uDCA5':'Jscr','\\uD835\\uDD0D':'Jfr','\\uD835\\uDD41':'Jopf','\\u0135':'jcirc','\\u0134':'Jcirc','\\u0237':'jmath','\\uD835\\uDD5C':'kopf','\\uD835\\uDCC0':'kscr','\\uD835\\uDD28':'kfr','\\uD835\\uDCA6':'Kscr','\\uD835\\uDD42':'Kopf','\\uD835\\uDD0E':'Kfr','\\u0137':'kcedil','\\u0136':'Kcedil','\\uD835\\uDD29':'lfr','\\uD835\\uDCC1':'lscr','\\u2113':'ell','\\uD835\\uDD5D':'lopf','\\u2112':'Lscr','\\uD835\\uDD0F':'Lfr','\\uD835\\uDD43':'Lopf','\\u013A':'lacute','\\u0139':'Lacute','\\u013E':'lcaron','\\u013D':'Lcaron','\\u013C':'lcedil','\\u013B':'Lcedil','\\u0142':'lstrok','\\u0141':'Lstrok','\\u0140':'lmidot','\\u013F':'Lmidot','\\uD835\\uDD2A':'mfr','\\uD835\\uDD5E':'mopf','\\uD835\\uDCC2':'mscr','\\uD835\\uDD10':'Mfr','\\uD835\\uDD44':'Mopf','\\u2133':'Mscr','\\uD835\\uDD2B':'nfr','\\uD835\\uDD5F':'nopf','\\uD835\\uDCC3':'nscr','\\u2115':'Nopf','\\uD835\\uDCA9':'Nscr','\\uD835\\uDD11':'Nfr','\\u0144':'nacute','\\u0143':'Nacute','\\u0148':'ncaron','\\u0147':'Ncaron','\\xF1':'ntilde','\\xD1':'Ntilde','\\u0146':'ncedil','\\u0145':'Ncedil','\\u2116':'numero','\\u014B':'eng','\\u014A':'ENG','\\uD835\\uDD60':'oopf','\\uD835\\uDD2C':'ofr','\\u2134':'oscr','\\uD835\\uDCAA':'Oscr','\\uD835\\uDD12':'Ofr','\\uD835\\uDD46':'Oopf','\\xBA':'ordm','\\xF3':'oacute','\\xD3':'Oacute','\\xF2':'ograve','\\xD2':'Ograve','\\xF4':'ocirc','\\xD4':'Ocirc','\\xF6':'ouml','\\xD6':'Ouml','\\u0151':'odblac','\\u0150':'Odblac','\\xF5':'otilde','\\xD5':'Otilde','\\xF8':'oslash','\\xD8':'Oslash','\\u014D':'omacr','\\u014C':'Omacr','\\u0153':'oelig','\\u0152':'OElig','\\uD835\\uDD2D':'pfr','\\uD835\\uDCC5':'pscr','\\uD835\\uDD61':'popf','\\u2119':'Popf','\\uD835\\uDD13':'Pfr','\\uD835\\uDCAB':'Pscr','\\uD835\\uDD62':'qopf','\\uD835\\uDD2E':'qfr','\\uD835\\uDCC6':'qscr','\\uD835\\uDCAC':'Qscr','\\uD835\\uDD14':'Qfr','\\u211A':'Qopf','\\u0138':'kgreen','\\uD835\\uDD2F':'rfr','\\uD835\\uDD63':'ropf','\\uD835\\uDCC7':'rscr','\\u211B':'Rscr','\\u211C':'Re','\\u211D':'Ropf','\\u0155':'racute','\\u0154':'Racute','\\u0159':'rcaron','\\u0158':'Rcaron','\\u0157':'rcedil','\\u0156':'Rcedil','\\uD835\\uDD64':'sopf','\\uD835\\uDCC8':'sscr','\\uD835\\uDD30':'sfr','\\uD835\\uDD4A':'Sopf','\\uD835\\uDD16':'Sfr','\\uD835\\uDCAE':'Sscr','\\u24C8':'oS','\\u015B':'sacute','\\u015A':'Sacute','\\u015D':'scirc','\\u015C':'Scirc','\\u0161':'scaron','\\u0160':'Scaron','\\u015F':'scedil','\\u015E':'Scedil','\\xDF':'szlig','\\uD835\\uDD31':'tfr','\\uD835\\uDCC9':'tscr','\\uD835\\uDD65':'topf','\\uD835\\uDCAF':'Tscr','\\uD835\\uDD17':'Tfr','\\uD835\\uDD4B':'Topf','\\u0165':'tcaron','\\u0164':'Tcaron','\\u0163':'tcedil','\\u0162':'Tcedil','\\u2122':'trade','\\u0167':'tstrok','\\u0166':'Tstrok','\\uD835\\uDCCA':'uscr','\\uD835\\uDD66':'uopf','\\uD835\\uDD32':'ufr','\\uD835\\uDD4C':'Uopf','\\uD835\\uDD18':'Ufr','\\uD835\\uDCB0':'Uscr','\\xFA':'uacute','\\xDA':'Uacute','\\xF9':'ugrave','\\xD9':'Ugrave','\\u016D':'ubreve','\\u016C':'Ubreve','\\xFB':'ucirc','\\xDB':'Ucirc','\\u016F':'uring','\\u016E':'Uring','\\xFC':'uuml','\\xDC':'Uuml','\\u0171':'udblac','\\u0170':'Udblac','\\u0169':'utilde','\\u0168':'Utilde','\\u0173':'uogon','\\u0172':'Uogon','\\u016B':'umacr','\\u016A':'Umacr','\\uD835\\uDD33':'vfr','\\uD835\\uDD67':'vopf','\\uD835\\uDCCB':'vscr','\\uD835\\uDD19':'Vfr','\\uD835\\uDD4D':'Vopf','\\uD835\\uDCB1':'Vscr','\\uD835\\uDD68':'wopf','\\uD835\\uDCCC':'wscr','\\uD835\\uDD34':'wfr','\\uD835\\uDCB2':'Wscr','\\uD835\\uDD4E':'Wopf','\\uD835\\uDD1A':'Wfr','\\u0175':'wcirc','\\u0174':'Wcirc','\\uD835\\uDD35':'xfr','\\uD835\\uDCCD':'xscr','\\uD835\\uDD69':'xopf','\\uD835\\uDD4F':'Xopf','\\uD835\\uDD1B':'Xfr','\\uD835\\uDCB3':'Xscr','\\uD835\\uDD36':'yfr','\\uD835\\uDCCE':'yscr','\\uD835\\uDD6A':'yopf','\\uD835\\uDCB4':'Yscr','\\uD835\\uDD1C':'Yfr','\\uD835\\uDD50':'Yopf','\\xFD':'yacute','\\xDD':'Yacute','\\u0177':'ycirc','\\u0176':'Ycirc','\\xFF':'yuml','\\u0178':'Yuml','\\uD835\\uDCCF':'zscr','\\uD835\\uDD37':'zfr','\\uD835\\uDD6B':'zopf','\\u2128':'Zfr','\\u2124':'Zopf','\\uD835\\uDCB5':'Zscr','\\u017A':'zacute','\\u0179':'Zacute','\\u017E':'zcaron','\\u017D':'Zcaron','\\u017C':'zdot','\\u017B':'Zdot','\\u01B5':'imped','\\xFE':'thorn','\\xDE':'THORN','\\u0149':'napos','\\u03B1':'alpha','\\u0391':'Alpha','\\u03B2':'beta','\\u0392':'Beta','\\u03B3':'gamma','\\u0393':'Gamma','\\u03B4':'delta','\\u0394':'Delta','\\u03B5':'epsi','\\u03F5':'epsiv','\\u0395':'Epsilon','\\u03DD':'gammad','\\u03DC':'Gammad','\\u03B6':'zeta','\\u0396':'Zeta','\\u03B7':'eta','\\u0397':'Eta','\\u03B8':'theta','\\u03D1':'thetav','\\u0398':'Theta','\\u03B9':'iota','\\u0399':'Iota','\\u03BA':'kappa','\\u03F0':'kappav','\\u039A':'Kappa','\\u03BB':'lambda','\\u039B':'Lambda','\\u03BC':'mu','\\xB5':'micro','\\u039C':'Mu','\\u03BD':'nu','\\u039D':'Nu','\\u03BE':'xi','\\u039E':'Xi','\\u03BF':'omicron','\\u039F':'Omicron','\\u03C0':'pi','\\u03D6':'piv','\\u03A0':'Pi','\\u03C1':'rho','\\u03F1':'rhov','\\u03A1':'Rho','\\u03C3':'sigma','\\u03A3':'Sigma','\\u03C2':'sigmaf','\\u03C4':'tau','\\u03A4':'Tau','\\u03C5':'upsi','\\u03A5':'Upsilon','\\u03D2':'Upsi','\\u03C6':'phi','\\u03D5':'phiv','\\u03A6':'Phi','\\u03C7':'chi','\\u03A7':'Chi','\\u03C8':'psi','\\u03A8':'Psi','\\u03C9':'omega','\\u03A9':'ohm','\\u0430':'acy','\\u0410':'Acy','\\u0431':'bcy','\\u0411':'Bcy','\\u0432':'vcy','\\u0412':'Vcy','\\u0433':'gcy','\\u0413':'Gcy','\\u0453':'gjcy','\\u0403':'GJcy','\\u0434':'dcy','\\u0414':'Dcy','\\u0452':'djcy','\\u0402':'DJcy','\\u0435':'iecy','\\u0415':'IEcy','\\u0451':'iocy','\\u0401':'IOcy','\\u0454':'jukcy','\\u0404':'Jukcy','\\u0436':'zhcy','\\u0416':'ZHcy','\\u0437':'zcy','\\u0417':'Zcy','\\u0455':'dscy','\\u0405':'DScy','\\u0438':'icy','\\u0418':'Icy','\\u0456':'iukcy','\\u0406':'Iukcy','\\u0457':'yicy','\\u0407':'YIcy','\\u0439':'jcy','\\u0419':'Jcy','\\u0458':'jsercy','\\u0408':'Jsercy','\\u043A':'kcy','\\u041A':'Kcy','\\u045C':'kjcy','\\u040C':'KJcy','\\u043B':'lcy','\\u041B':'Lcy','\\u0459':'ljcy','\\u0409':'LJcy','\\u043C':'mcy','\\u041C':'Mcy','\\u043D':'ncy','\\u041D':'Ncy','\\u045A':'njcy','\\u040A':'NJcy','\\u043E':'ocy','\\u041E':'Ocy','\\u043F':'pcy','\\u041F':'Pcy','\\u0440':'rcy','\\u0420':'Rcy','\\u0441':'scy','\\u0421':'Scy','\\u0442':'tcy','\\u0422':'Tcy','\\u045B':'tshcy','\\u040B':'TSHcy','\\u0443':'ucy','\\u0423':'Ucy','\\u045E':'ubrcy','\\u040E':'Ubrcy','\\u0444':'fcy','\\u0424':'Fcy','\\u0445':'khcy','\\u0425':'KHcy','\\u0446':'tscy','\\u0426':'TScy','\\u0447':'chcy','\\u0427':'CHcy','\\u045F':'dzcy','\\u040F':'DZcy','\\u0448':'shcy','\\u0428':'SHcy','\\u0449':'shchcy','\\u0429':'SHCHcy','\\u044A':'hardcy','\\u042A':'HARDcy','\\u044B':'ycy','\\u042B':'Ycy','\\u044C':'softcy','\\u042C':'SOFTcy','\\u044D':'ecy','\\u042D':'Ecy','\\u044E':'yucy','\\u042E':'YUcy','\\u044F':'yacy','\\u042F':'YAcy','\\u2135':'aleph','\\u2136':'beth','\\u2137':'gimel','\\u2138':'daleth'};\n\n\tvar regexEscape = /[\"&'<>`]/g;\n\tvar escapeMap = {\n\t\t'\"': '&quot;',\n\t\t'&': '&amp;',\n\t\t'\\'': '&#x27;',\n\t\t'<': '&lt;',\n\t\t// See https://mathiasbynens.be/notes/ambiguous-ampersands: in HTML, the\n\t\t// following is not strictly necessary unless its part of a tag or an\n\t\t// unquoted attribute value. Were only escaping it to support those\n\t\t// situations, and for XML support.\n\t\t'>': '&gt;',\n\t\t// In Internet Explorer  8, the backtick character can be used\n\t\t// to break out of (un)quoted attribute values or HTML comments.\n\t\t// See http://html5sec.org/#102, http://html5sec.org/#108, and\n\t\t// http://html5sec.org/#133.\n\t\t'`': '&#x60;'\n\t};\n\n\tvar regexInvalidEntity = /&#(?:[xX][^a-fA-F0-9]|[^0-9xX])/;\n\tvar regexInvalidRawCodePoint = /[\\0-\\x08\\x0B\\x0E-\\x1F\\x7F-\\x9F\\uFDD0-\\uFDEF\\uFFFE\\uFFFF]|[\\uD83F\\uD87F\\uD8BF\\uD8FF\\uD93F\\uD97F\\uD9BF\\uD9FF\\uDA3F\\uDA7F\\uDABF\\uDAFF\\uDB3F\\uDB7F\\uDBBF\\uDBFF][\\uDFFE\\uDFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n\tvar regexDecode = /&#([0-9]+)(;?)|&#[xX]([a-fA-F0-9]+)(;?)|&([0-9a-zA-Z]+);|&(Aacute|Agrave|Atilde|Ccedil|Eacute|Egrave|Iacute|Igrave|Ntilde|Oacute|Ograve|Oslash|Otilde|Uacute|Ugrave|Yacute|aacute|agrave|atilde|brvbar|ccedil|curren|divide|eacute|egrave|frac12|frac14|frac34|iacute|igrave|iquest|middot|ntilde|oacute|ograve|oslash|otilde|plusmn|uacute|ugrave|yacute|AElig|Acirc|Aring|Ecirc|Icirc|Ocirc|THORN|Ucirc|acirc|acute|aelig|aring|cedil|ecirc|icirc|iexcl|laquo|micro|ocirc|pound|raquo|szlig|thorn|times|ucirc|Auml|COPY|Euml|Iuml|Ouml|QUOT|Uuml|auml|cent|copy|euml|iuml|macr|nbsp|ordf|ordm|ouml|para|quot|sect|sup1|sup2|sup3|uuml|yuml|AMP|ETH|REG|amp|deg|eth|not|reg|shy|uml|yen|GT|LT|gt|lt)([=a-zA-Z0-9])?/g;\n\tvar decodeMap = {'aacute':'\\xE1','Aacute':'\\xC1','abreve':'\\u0103','Abreve':'\\u0102','ac':'\\u223E','acd':'\\u223F','acE':'\\u223E\\u0333','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','acy':'\\u0430','Acy':'\\u0410','aelig':'\\xE6','AElig':'\\xC6','af':'\\u2061','afr':'\\uD835\\uDD1E','Afr':'\\uD835\\uDD04','agrave':'\\xE0','Agrave':'\\xC0','alefsym':'\\u2135','aleph':'\\u2135','alpha':'\\u03B1','Alpha':'\\u0391','amacr':'\\u0101','Amacr':'\\u0100','amalg':'\\u2A3F','amp':'&','AMP':'&','and':'\\u2227','And':'\\u2A53','andand':'\\u2A55','andd':'\\u2A5C','andslope':'\\u2A58','andv':'\\u2A5A','ang':'\\u2220','ange':'\\u29A4','angle':'\\u2220','angmsd':'\\u2221','angmsdaa':'\\u29A8','angmsdab':'\\u29A9','angmsdac':'\\u29AA','angmsdad':'\\u29AB','angmsdae':'\\u29AC','angmsdaf':'\\u29AD','angmsdag':'\\u29AE','angmsdah':'\\u29AF','angrt':'\\u221F','angrtvb':'\\u22BE','angrtvbd':'\\u299D','angsph':'\\u2222','angst':'\\xC5','angzarr':'\\u237C','aogon':'\\u0105','Aogon':'\\u0104','aopf':'\\uD835\\uDD52','Aopf':'\\uD835\\uDD38','ap':'\\u2248','apacir':'\\u2A6F','ape':'\\u224A','apE':'\\u2A70','apid':'\\u224B','apos':'\\'','ApplyFunction':'\\u2061','approx':'\\u2248','approxeq':'\\u224A','aring':'\\xE5','Aring':'\\xC5','ascr':'\\uD835\\uDCB6','Ascr':'\\uD835\\uDC9C','Assign':'\\u2254','ast':'*','asymp':'\\u2248','asympeq':'\\u224D','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','awconint':'\\u2233','awint':'\\u2A11','backcong':'\\u224C','backepsilon':'\\u03F6','backprime':'\\u2035','backsim':'\\u223D','backsimeq':'\\u22CD','Backslash':'\\u2216','Barv':'\\u2AE7','barvee':'\\u22BD','barwed':'\\u2305','Barwed':'\\u2306','barwedge':'\\u2305','bbrk':'\\u23B5','bbrktbrk':'\\u23B6','bcong':'\\u224C','bcy':'\\u0431','Bcy':'\\u0411','bdquo':'\\u201E','becaus':'\\u2235','because':'\\u2235','Because':'\\u2235','bemptyv':'\\u29B0','bepsi':'\\u03F6','bernou':'\\u212C','Bernoullis':'\\u212C','beta':'\\u03B2','Beta':'\\u0392','beth':'\\u2136','between':'\\u226C','bfr':'\\uD835\\uDD1F','Bfr':'\\uD835\\uDD05','bigcap':'\\u22C2','bigcirc':'\\u25EF','bigcup':'\\u22C3','bigodot':'\\u2A00','bigoplus':'\\u2A01','bigotimes':'\\u2A02','bigsqcup':'\\u2A06','bigstar':'\\u2605','bigtriangledown':'\\u25BD','bigtriangleup':'\\u25B3','biguplus':'\\u2A04','bigvee':'\\u22C1','bigwedge':'\\u22C0','bkarow':'\\u290D','blacklozenge':'\\u29EB','blacksquare':'\\u25AA','blacktriangle':'\\u25B4','blacktriangledown':'\\u25BE','blacktriangleleft':'\\u25C2','blacktriangleright':'\\u25B8','blank':'\\u2423','blk12':'\\u2592','blk14':'\\u2591','blk34':'\\u2593','block':'\\u2588','bne':'=\\u20E5','bnequiv':'\\u2261\\u20E5','bnot':'\\u2310','bNot':'\\u2AED','bopf':'\\uD835\\uDD53','Bopf':'\\uD835\\uDD39','bot':'\\u22A5','bottom':'\\u22A5','bowtie':'\\u22C8','boxbox':'\\u29C9','boxdl':'\\u2510','boxdL':'\\u2555','boxDl':'\\u2556','boxDL':'\\u2557','boxdr':'\\u250C','boxdR':'\\u2552','boxDr':'\\u2553','boxDR':'\\u2554','boxh':'\\u2500','boxH':'\\u2550','boxhd':'\\u252C','boxhD':'\\u2565','boxHd':'\\u2564','boxHD':'\\u2566','boxhu':'\\u2534','boxhU':'\\u2568','boxHu':'\\u2567','boxHU':'\\u2569','boxminus':'\\u229F','boxplus':'\\u229E','boxtimes':'\\u22A0','boxul':'\\u2518','boxuL':'\\u255B','boxUl':'\\u255C','boxUL':'\\u255D','boxur':'\\u2514','boxuR':'\\u2558','boxUr':'\\u2559','boxUR':'\\u255A','boxv':'\\u2502','boxV':'\\u2551','boxvh':'\\u253C','boxvH':'\\u256A','boxVh':'\\u256B','boxVH':'\\u256C','boxvl':'\\u2524','boxvL':'\\u2561','boxVl':'\\u2562','boxVL':'\\u2563','boxvr':'\\u251C','boxvR':'\\u255E','boxVr':'\\u255F','boxVR':'\\u2560','bprime':'\\u2035','breve':'\\u02D8','Breve':'\\u02D8','brvbar':'\\xA6','bscr':'\\uD835\\uDCB7','Bscr':'\\u212C','bsemi':'\\u204F','bsim':'\\u223D','bsime':'\\u22CD','bsol':'\\\\','bsolb':'\\u29C5','bsolhsub':'\\u27C8','bull':'\\u2022','bullet':'\\u2022','bump':'\\u224E','bumpe':'\\u224F','bumpE':'\\u2AAE','bumpeq':'\\u224F','Bumpeq':'\\u224E','cacute':'\\u0107','Cacute':'\\u0106','cap':'\\u2229','Cap':'\\u22D2','capand':'\\u2A44','capbrcup':'\\u2A49','capcap':'\\u2A4B','capcup':'\\u2A47','capdot':'\\u2A40','CapitalDifferentialD':'\\u2145','caps':'\\u2229\\uFE00','caret':'\\u2041','caron':'\\u02C7','Cayleys':'\\u212D','ccaps':'\\u2A4D','ccaron':'\\u010D','Ccaron':'\\u010C','ccedil':'\\xE7','Ccedil':'\\xC7','ccirc':'\\u0109','Ccirc':'\\u0108','Cconint':'\\u2230','ccups':'\\u2A4C','ccupssm':'\\u2A50','cdot':'\\u010B','Cdot':'\\u010A','cedil':'\\xB8','Cedilla':'\\xB8','cemptyv':'\\u29B2','cent':'\\xA2','centerdot':'\\xB7','CenterDot':'\\xB7','cfr':'\\uD835\\uDD20','Cfr':'\\u212D','chcy':'\\u0447','CHcy':'\\u0427','check':'\\u2713','checkmark':'\\u2713','chi':'\\u03C7','Chi':'\\u03A7','cir':'\\u25CB','circ':'\\u02C6','circeq':'\\u2257','circlearrowleft':'\\u21BA','circlearrowright':'\\u21BB','circledast':'\\u229B','circledcirc':'\\u229A','circleddash':'\\u229D','CircleDot':'\\u2299','circledR':'\\xAE','circledS':'\\u24C8','CircleMinus':'\\u2296','CirclePlus':'\\u2295','CircleTimes':'\\u2297','cire':'\\u2257','cirE':'\\u29C3','cirfnint':'\\u2A10','cirmid':'\\u2AEF','cirscir':'\\u29C2','ClockwiseContourIntegral':'\\u2232','CloseCurlyDoubleQuote':'\\u201D','CloseCurlyQuote':'\\u2019','clubs':'\\u2663','clubsuit':'\\u2663','colon':':','Colon':'\\u2237','colone':'\\u2254','Colone':'\\u2A74','coloneq':'\\u2254','comma':',','commat':'@','comp':'\\u2201','compfn':'\\u2218','complement':'\\u2201','complexes':'\\u2102','cong':'\\u2245','congdot':'\\u2A6D','Congruent':'\\u2261','conint':'\\u222E','Conint':'\\u222F','ContourIntegral':'\\u222E','copf':'\\uD835\\uDD54','Copf':'\\u2102','coprod':'\\u2210','Coproduct':'\\u2210','copy':'\\xA9','COPY':'\\xA9','copysr':'\\u2117','CounterClockwiseContourIntegral':'\\u2233','crarr':'\\u21B5','cross':'\\u2717','Cross':'\\u2A2F','cscr':'\\uD835\\uDCB8','Cscr':'\\uD835\\uDC9E','csub':'\\u2ACF','csube':'\\u2AD1','csup':'\\u2AD0','csupe':'\\u2AD2','ctdot':'\\u22EF','cudarrl':'\\u2938','cudarrr':'\\u2935','cuepr':'\\u22DE','cuesc':'\\u22DF','cularr':'\\u21B6','cularrp':'\\u293D','cup':'\\u222A','Cup':'\\u22D3','cupbrcap':'\\u2A48','cupcap':'\\u2A46','CupCap':'\\u224D','cupcup':'\\u2A4A','cupdot':'\\u228D','cupor':'\\u2A45','cups':'\\u222A\\uFE00','curarr':'\\u21B7','curarrm':'\\u293C','curlyeqprec':'\\u22DE','curlyeqsucc':'\\u22DF','curlyvee':'\\u22CE','curlywedge':'\\u22CF','curren':'\\xA4','curvearrowleft':'\\u21B6','curvearrowright':'\\u21B7','cuvee':'\\u22CE','cuwed':'\\u22CF','cwconint':'\\u2232','cwint':'\\u2231','cylcty':'\\u232D','dagger':'\\u2020','Dagger':'\\u2021','daleth':'\\u2138','darr':'\\u2193','dArr':'\\u21D3','Darr':'\\u21A1','dash':'\\u2010','dashv':'\\u22A3','Dashv':'\\u2AE4','dbkarow':'\\u290F','dblac':'\\u02DD','dcaron':'\\u010F','Dcaron':'\\u010E','dcy':'\\u0434','Dcy':'\\u0414','dd':'\\u2146','DD':'\\u2145','ddagger':'\\u2021','ddarr':'\\u21CA','DDotrahd':'\\u2911','ddotseq':'\\u2A77','deg':'\\xB0','Del':'\\u2207','delta':'\\u03B4','Delta':'\\u0394','demptyv':'\\u29B1','dfisht':'\\u297F','dfr':'\\uD835\\uDD21','Dfr':'\\uD835\\uDD07','dHar':'\\u2965','dharl':'\\u21C3','dharr':'\\u21C2','DiacriticalAcute':'\\xB4','DiacriticalDot':'\\u02D9','DiacriticalDoubleAcute':'\\u02DD','DiacriticalGrave':'`','DiacriticalTilde':'\\u02DC','diam':'\\u22C4','diamond':'\\u22C4','Diamond':'\\u22C4','diamondsuit':'\\u2666','diams':'\\u2666','die':'\\xA8','DifferentialD':'\\u2146','digamma':'\\u03DD','disin':'\\u22F2','div':'\\xF7','divide':'\\xF7','divideontimes':'\\u22C7','divonx':'\\u22C7','djcy':'\\u0452','DJcy':'\\u0402','dlcorn':'\\u231E','dlcrop':'\\u230D','dollar':'$','dopf':'\\uD835\\uDD55','Dopf':'\\uD835\\uDD3B','dot':'\\u02D9','Dot':'\\xA8','DotDot':'\\u20DC','doteq':'\\u2250','doteqdot':'\\u2251','DotEqual':'\\u2250','dotminus':'\\u2238','dotplus':'\\u2214','dotsquare':'\\u22A1','doublebarwedge':'\\u2306','DoubleContourIntegral':'\\u222F','DoubleDot':'\\xA8','DoubleDownArrow':'\\u21D3','DoubleLeftArrow':'\\u21D0','DoubleLeftRightArrow':'\\u21D4','DoubleLeftTee':'\\u2AE4','DoubleLongLeftArrow':'\\u27F8','DoubleLongLeftRightArrow':'\\u27FA','DoubleLongRightArrow':'\\u27F9','DoubleRightArrow':'\\u21D2','DoubleRightTee':'\\u22A8','DoubleUpArrow':'\\u21D1','DoubleUpDownArrow':'\\u21D5','DoubleVerticalBar':'\\u2225','downarrow':'\\u2193','Downarrow':'\\u21D3','DownArrow':'\\u2193','DownArrowBar':'\\u2913','DownArrowUpArrow':'\\u21F5','DownBreve':'\\u0311','downdownarrows':'\\u21CA','downharpoonleft':'\\u21C3','downharpoonright':'\\u21C2','DownLeftRightVector':'\\u2950','DownLeftTeeVector':'\\u295E','DownLeftVector':'\\u21BD','DownLeftVectorBar':'\\u2956','DownRightTeeVector':'\\u295F','DownRightVector':'\\u21C1','DownRightVectorBar':'\\u2957','DownTee':'\\u22A4','DownTeeArrow':'\\u21A7','drbkarow':'\\u2910','drcorn':'\\u231F','drcrop':'\\u230C','dscr':'\\uD835\\uDCB9','Dscr':'\\uD835\\uDC9F','dscy':'\\u0455','DScy':'\\u0405','dsol':'\\u29F6','dstrok':'\\u0111','Dstrok':'\\u0110','dtdot':'\\u22F1','dtri':'\\u25BF','dtrif':'\\u25BE','duarr':'\\u21F5','duhar':'\\u296F','dwangle':'\\u29A6','dzcy':'\\u045F','DZcy':'\\u040F','dzigrarr':'\\u27FF','eacute':'\\xE9','Eacute':'\\xC9','easter':'\\u2A6E','ecaron':'\\u011B','Ecaron':'\\u011A','ecir':'\\u2256','ecirc':'\\xEA','Ecirc':'\\xCA','ecolon':'\\u2255','ecy':'\\u044D','Ecy':'\\u042D','eDDot':'\\u2A77','edot':'\\u0117','eDot':'\\u2251','Edot':'\\u0116','ee':'\\u2147','efDot':'\\u2252','efr':'\\uD835\\uDD22','Efr':'\\uD835\\uDD08','eg':'\\u2A9A','egrave':'\\xE8','Egrave':'\\xC8','egs':'\\u2A96','egsdot':'\\u2A98','el':'\\u2A99','Element':'\\u2208','elinters':'\\u23E7','ell':'\\u2113','els':'\\u2A95','elsdot':'\\u2A97','emacr':'\\u0113','Emacr':'\\u0112','empty':'\\u2205','emptyset':'\\u2205','EmptySmallSquare':'\\u25FB','emptyv':'\\u2205','EmptyVerySmallSquare':'\\u25AB','emsp':'\\u2003','emsp13':'\\u2004','emsp14':'\\u2005','eng':'\\u014B','ENG':'\\u014A','ensp':'\\u2002','eogon':'\\u0119','Eogon':'\\u0118','eopf':'\\uD835\\uDD56','Eopf':'\\uD835\\uDD3C','epar':'\\u22D5','eparsl':'\\u29E3','eplus':'\\u2A71','epsi':'\\u03B5','epsilon':'\\u03B5','Epsilon':'\\u0395','epsiv':'\\u03F5','eqcirc':'\\u2256','eqcolon':'\\u2255','eqsim':'\\u2242','eqslantgtr':'\\u2A96','eqslantless':'\\u2A95','Equal':'\\u2A75','equals':'=','EqualTilde':'\\u2242','equest':'\\u225F','Equilibrium':'\\u21CC','equiv':'\\u2261','equivDD':'\\u2A78','eqvparsl':'\\u29E5','erarr':'\\u2971','erDot':'\\u2253','escr':'\\u212F','Escr':'\\u2130','esdot':'\\u2250','esim':'\\u2242','Esim':'\\u2A73','eta':'\\u03B7','Eta':'\\u0397','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','euro':'\\u20AC','excl':'!','exist':'\\u2203','Exists':'\\u2203','expectation':'\\u2130','exponentiale':'\\u2147','ExponentialE':'\\u2147','fallingdotseq':'\\u2252','fcy':'\\u0444','Fcy':'\\u0424','female':'\\u2640','ffilig':'\\uFB03','fflig':'\\uFB00','ffllig':'\\uFB04','ffr':'\\uD835\\uDD23','Ffr':'\\uD835\\uDD09','filig':'\\uFB01','FilledSmallSquare':'\\u25FC','FilledVerySmallSquare':'\\u25AA','fjlig':'fj','flat':'\\u266D','fllig':'\\uFB02','fltns':'\\u25B1','fnof':'\\u0192','fopf':'\\uD835\\uDD57','Fopf':'\\uD835\\uDD3D','forall':'\\u2200','ForAll':'\\u2200','fork':'\\u22D4','forkv':'\\u2AD9','Fouriertrf':'\\u2131','fpartint':'\\u2A0D','frac12':'\\xBD','frac13':'\\u2153','frac14':'\\xBC','frac15':'\\u2155','frac16':'\\u2159','frac18':'\\u215B','frac23':'\\u2154','frac25':'\\u2156','frac34':'\\xBE','frac35':'\\u2157','frac38':'\\u215C','frac45':'\\u2158','frac56':'\\u215A','frac58':'\\u215D','frac78':'\\u215E','frasl':'\\u2044','frown':'\\u2322','fscr':'\\uD835\\uDCBB','Fscr':'\\u2131','gacute':'\\u01F5','gamma':'\\u03B3','Gamma':'\\u0393','gammad':'\\u03DD','Gammad':'\\u03DC','gap':'\\u2A86','gbreve':'\\u011F','Gbreve':'\\u011E','Gcedil':'\\u0122','gcirc':'\\u011D','Gcirc':'\\u011C','gcy':'\\u0433','Gcy':'\\u0413','gdot':'\\u0121','Gdot':'\\u0120','ge':'\\u2265','gE':'\\u2267','gel':'\\u22DB','gEl':'\\u2A8C','geq':'\\u2265','geqq':'\\u2267','geqslant':'\\u2A7E','ges':'\\u2A7E','gescc':'\\u2AA9','gesdot':'\\u2A80','gesdoto':'\\u2A82','gesdotol':'\\u2A84','gesl':'\\u22DB\\uFE00','gesles':'\\u2A94','gfr':'\\uD835\\uDD24','Gfr':'\\uD835\\uDD0A','gg':'\\u226B','Gg':'\\u22D9','ggg':'\\u22D9','gimel':'\\u2137','gjcy':'\\u0453','GJcy':'\\u0403','gl':'\\u2277','gla':'\\u2AA5','glE':'\\u2A92','glj':'\\u2AA4','gnap':'\\u2A8A','gnapprox':'\\u2A8A','gne':'\\u2A88','gnE':'\\u2269','gneq':'\\u2A88','gneqq':'\\u2269','gnsim':'\\u22E7','gopf':'\\uD835\\uDD58','Gopf':'\\uD835\\uDD3E','grave':'`','GreaterEqual':'\\u2265','GreaterEqualLess':'\\u22DB','GreaterFullEqual':'\\u2267','GreaterGreater':'\\u2AA2','GreaterLess':'\\u2277','GreaterSlantEqual':'\\u2A7E','GreaterTilde':'\\u2273','gscr':'\\u210A','Gscr':'\\uD835\\uDCA2','gsim':'\\u2273','gsime':'\\u2A8E','gsiml':'\\u2A90','gt':'>','Gt':'\\u226B','GT':'>','gtcc':'\\u2AA7','gtcir':'\\u2A7A','gtdot':'\\u22D7','gtlPar':'\\u2995','gtquest':'\\u2A7C','gtrapprox':'\\u2A86','gtrarr':'\\u2978','gtrdot':'\\u22D7','gtreqless':'\\u22DB','gtreqqless':'\\u2A8C','gtrless':'\\u2277','gtrsim':'\\u2273','gvertneqq':'\\u2269\\uFE00','gvnE':'\\u2269\\uFE00','Hacek':'\\u02C7','hairsp':'\\u200A','half':'\\xBD','hamilt':'\\u210B','hardcy':'\\u044A','HARDcy':'\\u042A','harr':'\\u2194','hArr':'\\u21D4','harrcir':'\\u2948','harrw':'\\u21AD','Hat':'^','hbar':'\\u210F','hcirc':'\\u0125','Hcirc':'\\u0124','hearts':'\\u2665','heartsuit':'\\u2665','hellip':'\\u2026','hercon':'\\u22B9','hfr':'\\uD835\\uDD25','Hfr':'\\u210C','HilbertSpace':'\\u210B','hksearow':'\\u2925','hkswarow':'\\u2926','hoarr':'\\u21FF','homtht':'\\u223B','hookleftarrow':'\\u21A9','hookrightarrow':'\\u21AA','hopf':'\\uD835\\uDD59','Hopf':'\\u210D','horbar':'\\u2015','HorizontalLine':'\\u2500','hscr':'\\uD835\\uDCBD','Hscr':'\\u210B','hslash':'\\u210F','hstrok':'\\u0127','Hstrok':'\\u0126','HumpDownHump':'\\u224E','HumpEqual':'\\u224F','hybull':'\\u2043','hyphen':'\\u2010','iacute':'\\xED','Iacute':'\\xCD','ic':'\\u2063','icirc':'\\xEE','Icirc':'\\xCE','icy':'\\u0438','Icy':'\\u0418','Idot':'\\u0130','iecy':'\\u0435','IEcy':'\\u0415','iexcl':'\\xA1','iff':'\\u21D4','ifr':'\\uD835\\uDD26','Ifr':'\\u2111','igrave':'\\xEC','Igrave':'\\xCC','ii':'\\u2148','iiiint':'\\u2A0C','iiint':'\\u222D','iinfin':'\\u29DC','iiota':'\\u2129','ijlig':'\\u0133','IJlig':'\\u0132','Im':'\\u2111','imacr':'\\u012B','Imacr':'\\u012A','image':'\\u2111','ImaginaryI':'\\u2148','imagline':'\\u2110','imagpart':'\\u2111','imath':'\\u0131','imof':'\\u22B7','imped':'\\u01B5','Implies':'\\u21D2','in':'\\u2208','incare':'\\u2105','infin':'\\u221E','infintie':'\\u29DD','inodot':'\\u0131','int':'\\u222B','Int':'\\u222C','intcal':'\\u22BA','integers':'\\u2124','Integral':'\\u222B','intercal':'\\u22BA','Intersection':'\\u22C2','intlarhk':'\\u2A17','intprod':'\\u2A3C','InvisibleComma':'\\u2063','InvisibleTimes':'\\u2062','iocy':'\\u0451','IOcy':'\\u0401','iogon':'\\u012F','Iogon':'\\u012E','iopf':'\\uD835\\uDD5A','Iopf':'\\uD835\\uDD40','iota':'\\u03B9','Iota':'\\u0399','iprod':'\\u2A3C','iquest':'\\xBF','iscr':'\\uD835\\uDCBE','Iscr':'\\u2110','isin':'\\u2208','isindot':'\\u22F5','isinE':'\\u22F9','isins':'\\u22F4','isinsv':'\\u22F3','isinv':'\\u2208','it':'\\u2062','itilde':'\\u0129','Itilde':'\\u0128','iukcy':'\\u0456','Iukcy':'\\u0406','iuml':'\\xEF','Iuml':'\\xCF','jcirc':'\\u0135','Jcirc':'\\u0134','jcy':'\\u0439','Jcy':'\\u0419','jfr':'\\uD835\\uDD27','Jfr':'\\uD835\\uDD0D','jmath':'\\u0237','jopf':'\\uD835\\uDD5B','Jopf':'\\uD835\\uDD41','jscr':'\\uD835\\uDCBF','Jscr':'\\uD835\\uDCA5','jsercy':'\\u0458','Jsercy':'\\u0408','jukcy':'\\u0454','Jukcy':'\\u0404','kappa':'\\u03BA','Kappa':'\\u039A','kappav':'\\u03F0','kcedil':'\\u0137','Kcedil':'\\u0136','kcy':'\\u043A','Kcy':'\\u041A','kfr':'\\uD835\\uDD28','Kfr':'\\uD835\\uDD0E','kgreen':'\\u0138','khcy':'\\u0445','KHcy':'\\u0425','kjcy':'\\u045C','KJcy':'\\u040C','kopf':'\\uD835\\uDD5C','Kopf':'\\uD835\\uDD42','kscr':'\\uD835\\uDCC0','Kscr':'\\uD835\\uDCA6','lAarr':'\\u21DA','lacute':'\\u013A','Lacute':'\\u0139','laemptyv':'\\u29B4','lagran':'\\u2112','lambda':'\\u03BB','Lambda':'\\u039B','lang':'\\u27E8','Lang':'\\u27EA','langd':'\\u2991','langle':'\\u27E8','lap':'\\u2A85','Laplacetrf':'\\u2112','laquo':'\\xAB','larr':'\\u2190','lArr':'\\u21D0','Larr':'\\u219E','larrb':'\\u21E4','larrbfs':'\\u291F','larrfs':'\\u291D','larrhk':'\\u21A9','larrlp':'\\u21AB','larrpl':'\\u2939','larrsim':'\\u2973','larrtl':'\\u21A2','lat':'\\u2AAB','latail':'\\u2919','lAtail':'\\u291B','late':'\\u2AAD','lates':'\\u2AAD\\uFE00','lbarr':'\\u290C','lBarr':'\\u290E','lbbrk':'\\u2772','lbrace':'{','lbrack':'[','lbrke':'\\u298B','lbrksld':'\\u298F','lbrkslu':'\\u298D','lcaron':'\\u013E','Lcaron':'\\u013D','lcedil':'\\u013C','Lcedil':'\\u013B','lceil':'\\u2308','lcub':'{','lcy':'\\u043B','Lcy':'\\u041B','ldca':'\\u2936','ldquo':'\\u201C','ldquor':'\\u201E','ldrdhar':'\\u2967','ldrushar':'\\u294B','ldsh':'\\u21B2','le':'\\u2264','lE':'\\u2266','LeftAngleBracket':'\\u27E8','leftarrow':'\\u2190','Leftarrow':'\\u21D0','LeftArrow':'\\u2190','LeftArrowBar':'\\u21E4','LeftArrowRightArrow':'\\u21C6','leftarrowtail':'\\u21A2','LeftCeiling':'\\u2308','LeftDoubleBracket':'\\u27E6','LeftDownTeeVector':'\\u2961','LeftDownVector':'\\u21C3','LeftDownVectorBar':'\\u2959','LeftFloor':'\\u230A','leftharpoondown':'\\u21BD','leftharpoonup':'\\u21BC','leftleftarrows':'\\u21C7','leftrightarrow':'\\u2194','Leftrightarrow':'\\u21D4','LeftRightArrow':'\\u2194','leftrightarrows':'\\u21C6','leftrightharpoons':'\\u21CB','leftrightsquigarrow':'\\u21AD','LeftRightVector':'\\u294E','LeftTee':'\\u22A3','LeftTeeArrow':'\\u21A4','LeftTeeVector':'\\u295A','leftthreetimes':'\\u22CB','LeftTriangle':'\\u22B2','LeftTriangleBar':'\\u29CF','LeftTriangleEqual':'\\u22B4','LeftUpDownVector':'\\u2951','LeftUpTeeVector':'\\u2960','LeftUpVector':'\\u21BF','LeftUpVectorBar':'\\u2958','LeftVector':'\\u21BC','LeftVectorBar':'\\u2952','leg':'\\u22DA','lEg':'\\u2A8B','leq':'\\u2264','leqq':'\\u2266','leqslant':'\\u2A7D','les':'\\u2A7D','lescc':'\\u2AA8','lesdot':'\\u2A7F','lesdoto':'\\u2A81','lesdotor':'\\u2A83','lesg':'\\u22DA\\uFE00','lesges':'\\u2A93','lessapprox':'\\u2A85','lessdot':'\\u22D6','lesseqgtr':'\\u22DA','lesseqqgtr':'\\u2A8B','LessEqualGreater':'\\u22DA','LessFullEqual':'\\u2266','LessGreater':'\\u2276','lessgtr':'\\u2276','LessLess':'\\u2AA1','lesssim':'\\u2272','LessSlantEqual':'\\u2A7D','LessTilde':'\\u2272','lfisht':'\\u297C','lfloor':'\\u230A','lfr':'\\uD835\\uDD29','Lfr':'\\uD835\\uDD0F','lg':'\\u2276','lgE':'\\u2A91','lHar':'\\u2962','lhard':'\\u21BD','lharu':'\\u21BC','lharul':'\\u296A','lhblk':'\\u2584','ljcy':'\\u0459','LJcy':'\\u0409','ll':'\\u226A','Ll':'\\u22D8','llarr':'\\u21C7','llcorner':'\\u231E','Lleftarrow':'\\u21DA','llhard':'\\u296B','lltri':'\\u25FA','lmidot':'\\u0140','Lmidot':'\\u013F','lmoust':'\\u23B0','lmoustache':'\\u23B0','lnap':'\\u2A89','lnapprox':'\\u2A89','lne':'\\u2A87','lnE':'\\u2268','lneq':'\\u2A87','lneqq':'\\u2268','lnsim':'\\u22E6','loang':'\\u27EC','loarr':'\\u21FD','lobrk':'\\u27E6','longleftarrow':'\\u27F5','Longleftarrow':'\\u27F8','LongLeftArrow':'\\u27F5','longleftrightarrow':'\\u27F7','Longleftrightarrow':'\\u27FA','LongLeftRightArrow':'\\u27F7','longmapsto':'\\u27FC','longrightarrow':'\\u27F6','Longrightarrow':'\\u27F9','LongRightArrow':'\\u27F6','looparrowleft':'\\u21AB','looparrowright':'\\u21AC','lopar':'\\u2985','lopf':'\\uD835\\uDD5D','Lopf':'\\uD835\\uDD43','loplus':'\\u2A2D','lotimes':'\\u2A34','lowast':'\\u2217','lowbar':'_','LowerLeftArrow':'\\u2199','LowerRightArrow':'\\u2198','loz':'\\u25CA','lozenge':'\\u25CA','lozf':'\\u29EB','lpar':'(','lparlt':'\\u2993','lrarr':'\\u21C6','lrcorner':'\\u231F','lrhar':'\\u21CB','lrhard':'\\u296D','lrm':'\\u200E','lrtri':'\\u22BF','lsaquo':'\\u2039','lscr':'\\uD835\\uDCC1','Lscr':'\\u2112','lsh':'\\u21B0','Lsh':'\\u21B0','lsim':'\\u2272','lsime':'\\u2A8D','lsimg':'\\u2A8F','lsqb':'[','lsquo':'\\u2018','lsquor':'\\u201A','lstrok':'\\u0142','Lstrok':'\\u0141','lt':'<','Lt':'\\u226A','LT':'<','ltcc':'\\u2AA6','ltcir':'\\u2A79','ltdot':'\\u22D6','lthree':'\\u22CB','ltimes':'\\u22C9','ltlarr':'\\u2976','ltquest':'\\u2A7B','ltri':'\\u25C3','ltrie':'\\u22B4','ltrif':'\\u25C2','ltrPar':'\\u2996','lurdshar':'\\u294A','luruhar':'\\u2966','lvertneqq':'\\u2268\\uFE00','lvnE':'\\u2268\\uFE00','macr':'\\xAF','male':'\\u2642','malt':'\\u2720','maltese':'\\u2720','map':'\\u21A6','Map':'\\u2905','mapsto':'\\u21A6','mapstodown':'\\u21A7','mapstoleft':'\\u21A4','mapstoup':'\\u21A5','marker':'\\u25AE','mcomma':'\\u2A29','mcy':'\\u043C','Mcy':'\\u041C','mdash':'\\u2014','mDDot':'\\u223A','measuredangle':'\\u2221','MediumSpace':'\\u205F','Mellintrf':'\\u2133','mfr':'\\uD835\\uDD2A','Mfr':'\\uD835\\uDD10','mho':'\\u2127','micro':'\\xB5','mid':'\\u2223','midast':'*','midcir':'\\u2AF0','middot':'\\xB7','minus':'\\u2212','minusb':'\\u229F','minusd':'\\u2238','minusdu':'\\u2A2A','MinusPlus':'\\u2213','mlcp':'\\u2ADB','mldr':'\\u2026','mnplus':'\\u2213','models':'\\u22A7','mopf':'\\uD835\\uDD5E','Mopf':'\\uD835\\uDD44','mp':'\\u2213','mscr':'\\uD835\\uDCC2','Mscr':'\\u2133','mstpos':'\\u223E','mu':'\\u03BC','Mu':'\\u039C','multimap':'\\u22B8','mumap':'\\u22B8','nabla':'\\u2207','nacute':'\\u0144','Nacute':'\\u0143','nang':'\\u2220\\u20D2','nap':'\\u2249','napE':'\\u2A70\\u0338','napid':'\\u224B\\u0338','napos':'\\u0149','napprox':'\\u2249','natur':'\\u266E','natural':'\\u266E','naturals':'\\u2115','nbsp':'\\xA0','nbump':'\\u224E\\u0338','nbumpe':'\\u224F\\u0338','ncap':'\\u2A43','ncaron':'\\u0148','Ncaron':'\\u0147','ncedil':'\\u0146','Ncedil':'\\u0145','ncong':'\\u2247','ncongdot':'\\u2A6D\\u0338','ncup':'\\u2A42','ncy':'\\u043D','Ncy':'\\u041D','ndash':'\\u2013','ne':'\\u2260','nearhk':'\\u2924','nearr':'\\u2197','neArr':'\\u21D7','nearrow':'\\u2197','nedot':'\\u2250\\u0338','NegativeMediumSpace':'\\u200B','NegativeThickSpace':'\\u200B','NegativeThinSpace':'\\u200B','NegativeVeryThinSpace':'\\u200B','nequiv':'\\u2262','nesear':'\\u2928','nesim':'\\u2242\\u0338','NestedGreaterGreater':'\\u226B','NestedLessLess':'\\u226A','NewLine':'\\n','nexist':'\\u2204','nexists':'\\u2204','nfr':'\\uD835\\uDD2B','Nfr':'\\uD835\\uDD11','nge':'\\u2271','ngE':'\\u2267\\u0338','ngeq':'\\u2271','ngeqq':'\\u2267\\u0338','ngeqslant':'\\u2A7E\\u0338','nges':'\\u2A7E\\u0338','nGg':'\\u22D9\\u0338','ngsim':'\\u2275','ngt':'\\u226F','nGt':'\\u226B\\u20D2','ngtr':'\\u226F','nGtv':'\\u226B\\u0338','nharr':'\\u21AE','nhArr':'\\u21CE','nhpar':'\\u2AF2','ni':'\\u220B','nis':'\\u22FC','nisd':'\\u22FA','niv':'\\u220B','njcy':'\\u045A','NJcy':'\\u040A','nlarr':'\\u219A','nlArr':'\\u21CD','nldr':'\\u2025','nle':'\\u2270','nlE':'\\u2266\\u0338','nleftarrow':'\\u219A','nLeftarrow':'\\u21CD','nleftrightarrow':'\\u21AE','nLeftrightarrow':'\\u21CE','nleq':'\\u2270','nleqq':'\\u2266\\u0338','nleqslant':'\\u2A7D\\u0338','nles':'\\u2A7D\\u0338','nless':'\\u226E','nLl':'\\u22D8\\u0338','nlsim':'\\u2274','nlt':'\\u226E','nLt':'\\u226A\\u20D2','nltri':'\\u22EA','nltrie':'\\u22EC','nLtv':'\\u226A\\u0338','nmid':'\\u2224','NoBreak':'\\u2060','NonBreakingSpace':'\\xA0','nopf':'\\uD835\\uDD5F','Nopf':'\\u2115','not':'\\xAC','Not':'\\u2AEC','NotCongruent':'\\u2262','NotCupCap':'\\u226D','NotDoubleVerticalBar':'\\u2226','NotElement':'\\u2209','NotEqual':'\\u2260','NotEqualTilde':'\\u2242\\u0338','NotExists':'\\u2204','NotGreater':'\\u226F','NotGreaterEqual':'\\u2271','NotGreaterFullEqual':'\\u2267\\u0338','NotGreaterGreater':'\\u226B\\u0338','NotGreaterLess':'\\u2279','NotGreaterSlantEqual':'\\u2A7E\\u0338','NotGreaterTilde':'\\u2275','NotHumpDownHump':'\\u224E\\u0338','NotHumpEqual':'\\u224F\\u0338','notin':'\\u2209','notindot':'\\u22F5\\u0338','notinE':'\\u22F9\\u0338','notinva':'\\u2209','notinvb':'\\u22F7','notinvc':'\\u22F6','NotLeftTriangle':'\\u22EA','NotLeftTriangleBar':'\\u29CF\\u0338','NotLeftTriangleEqual':'\\u22EC','NotLess':'\\u226E','NotLessEqual':'\\u2270','NotLessGreater':'\\u2278','NotLessLess':'\\u226A\\u0338','NotLessSlantEqual':'\\u2A7D\\u0338','NotLessTilde':'\\u2274','NotNestedGreaterGreater':'\\u2AA2\\u0338','NotNestedLessLess':'\\u2AA1\\u0338','notni':'\\u220C','notniva':'\\u220C','notnivb':'\\u22FE','notnivc':'\\u22FD','NotPrecedes':'\\u2280','NotPrecedesEqual':'\\u2AAF\\u0338','NotPrecedesSlantEqual':'\\u22E0','NotReverseElement':'\\u220C','NotRightTriangle':'\\u22EB','NotRightTriangleBar':'\\u29D0\\u0338','NotRightTriangleEqual':'\\u22ED','NotSquareSubset':'\\u228F\\u0338','NotSquareSubsetEqual':'\\u22E2','NotSquareSuperset':'\\u2290\\u0338','NotSquareSupersetEqual':'\\u22E3','NotSubset':'\\u2282\\u20D2','NotSubsetEqual':'\\u2288','NotSucceeds':'\\u2281','NotSucceedsEqual':'\\u2AB0\\u0338','NotSucceedsSlantEqual':'\\u22E1','NotSucceedsTilde':'\\u227F\\u0338','NotSuperset':'\\u2283\\u20D2','NotSupersetEqual':'\\u2289','NotTilde':'\\u2241','NotTildeEqual':'\\u2244','NotTildeFullEqual':'\\u2247','NotTildeTilde':'\\u2249','NotVerticalBar':'\\u2224','npar':'\\u2226','nparallel':'\\u2226','nparsl':'\\u2AFD\\u20E5','npart':'\\u2202\\u0338','npolint':'\\u2A14','npr':'\\u2280','nprcue':'\\u22E0','npre':'\\u2AAF\\u0338','nprec':'\\u2280','npreceq':'\\u2AAF\\u0338','nrarr':'\\u219B','nrArr':'\\u21CF','nrarrc':'\\u2933\\u0338','nrarrw':'\\u219D\\u0338','nrightarrow':'\\u219B','nRightarrow':'\\u21CF','nrtri':'\\u22EB','nrtrie':'\\u22ED','nsc':'\\u2281','nsccue':'\\u22E1','nsce':'\\u2AB0\\u0338','nscr':'\\uD835\\uDCC3','Nscr':'\\uD835\\uDCA9','nshortmid':'\\u2224','nshortparallel':'\\u2226','nsim':'\\u2241','nsime':'\\u2244','nsimeq':'\\u2244','nsmid':'\\u2224','nspar':'\\u2226','nsqsube':'\\u22E2','nsqsupe':'\\u22E3','nsub':'\\u2284','nsube':'\\u2288','nsubE':'\\u2AC5\\u0338','nsubset':'\\u2282\\u20D2','nsubseteq':'\\u2288','nsubseteqq':'\\u2AC5\\u0338','nsucc':'\\u2281','nsucceq':'\\u2AB0\\u0338','nsup':'\\u2285','nsupe':'\\u2289','nsupE':'\\u2AC6\\u0338','nsupset':'\\u2283\\u20D2','nsupseteq':'\\u2289','nsupseteqq':'\\u2AC6\\u0338','ntgl':'\\u2279','ntilde':'\\xF1','Ntilde':'\\xD1','ntlg':'\\u2278','ntriangleleft':'\\u22EA','ntrianglelefteq':'\\u22EC','ntriangleright':'\\u22EB','ntrianglerighteq':'\\u22ED','nu':'\\u03BD','Nu':'\\u039D','num':'#','numero':'\\u2116','numsp':'\\u2007','nvap':'\\u224D\\u20D2','nvdash':'\\u22AC','nvDash':'\\u22AD','nVdash':'\\u22AE','nVDash':'\\u22AF','nvge':'\\u2265\\u20D2','nvgt':'>\\u20D2','nvHarr':'\\u2904','nvinfin':'\\u29DE','nvlArr':'\\u2902','nvle':'\\u2264\\u20D2','nvlt':'<\\u20D2','nvltrie':'\\u22B4\\u20D2','nvrArr':'\\u2903','nvrtrie':'\\u22B5\\u20D2','nvsim':'\\u223C\\u20D2','nwarhk':'\\u2923','nwarr':'\\u2196','nwArr':'\\u21D6','nwarrow':'\\u2196','nwnear':'\\u2927','oacute':'\\xF3','Oacute':'\\xD3','oast':'\\u229B','ocir':'\\u229A','ocirc':'\\xF4','Ocirc':'\\xD4','ocy':'\\u043E','Ocy':'\\u041E','odash':'\\u229D','odblac':'\\u0151','Odblac':'\\u0150','odiv':'\\u2A38','odot':'\\u2299','odsold':'\\u29BC','oelig':'\\u0153','OElig':'\\u0152','ofcir':'\\u29BF','ofr':'\\uD835\\uDD2C','Ofr':'\\uD835\\uDD12','ogon':'\\u02DB','ograve':'\\xF2','Ograve':'\\xD2','ogt':'\\u29C1','ohbar':'\\u29B5','ohm':'\\u03A9','oint':'\\u222E','olarr':'\\u21BA','olcir':'\\u29BE','olcross':'\\u29BB','oline':'\\u203E','olt':'\\u29C0','omacr':'\\u014D','Omacr':'\\u014C','omega':'\\u03C9','Omega':'\\u03A9','omicron':'\\u03BF','Omicron':'\\u039F','omid':'\\u29B6','ominus':'\\u2296','oopf':'\\uD835\\uDD60','Oopf':'\\uD835\\uDD46','opar':'\\u29B7','OpenCurlyDoubleQuote':'\\u201C','OpenCurlyQuote':'\\u2018','operp':'\\u29B9','oplus':'\\u2295','or':'\\u2228','Or':'\\u2A54','orarr':'\\u21BB','ord':'\\u2A5D','order':'\\u2134','orderof':'\\u2134','ordf':'\\xAA','ordm':'\\xBA','origof':'\\u22B6','oror':'\\u2A56','orslope':'\\u2A57','orv':'\\u2A5B','oS':'\\u24C8','oscr':'\\u2134','Oscr':'\\uD835\\uDCAA','oslash':'\\xF8','Oslash':'\\xD8','osol':'\\u2298','otilde':'\\xF5','Otilde':'\\xD5','otimes':'\\u2297','Otimes':'\\u2A37','otimesas':'\\u2A36','ouml':'\\xF6','Ouml':'\\xD6','ovbar':'\\u233D','OverBar':'\\u203E','OverBrace':'\\u23DE','OverBracket':'\\u23B4','OverParenthesis':'\\u23DC','par':'\\u2225','para':'\\xB6','parallel':'\\u2225','parsim':'\\u2AF3','parsl':'\\u2AFD','part':'\\u2202','PartialD':'\\u2202','pcy':'\\u043F','Pcy':'\\u041F','percnt':'%','period':'.','permil':'\\u2030','perp':'\\u22A5','pertenk':'\\u2031','pfr':'\\uD835\\uDD2D','Pfr':'\\uD835\\uDD13','phi':'\\u03C6','Phi':'\\u03A6','phiv':'\\u03D5','phmmat':'\\u2133','phone':'\\u260E','pi':'\\u03C0','Pi':'\\u03A0','pitchfork':'\\u22D4','piv':'\\u03D6','planck':'\\u210F','planckh':'\\u210E','plankv':'\\u210F','plus':'+','plusacir':'\\u2A23','plusb':'\\u229E','pluscir':'\\u2A22','plusdo':'\\u2214','plusdu':'\\u2A25','pluse':'\\u2A72','PlusMinus':'\\xB1','plusmn':'\\xB1','plussim':'\\u2A26','plustwo':'\\u2A27','pm':'\\xB1','Poincareplane':'\\u210C','pointint':'\\u2A15','popf':'\\uD835\\uDD61','Popf':'\\u2119','pound':'\\xA3','pr':'\\u227A','Pr':'\\u2ABB','prap':'\\u2AB7','prcue':'\\u227C','pre':'\\u2AAF','prE':'\\u2AB3','prec':'\\u227A','precapprox':'\\u2AB7','preccurlyeq':'\\u227C','Precedes':'\\u227A','PrecedesEqual':'\\u2AAF','PrecedesSlantEqual':'\\u227C','PrecedesTilde':'\\u227E','preceq':'\\u2AAF','precnapprox':'\\u2AB9','precneqq':'\\u2AB5','precnsim':'\\u22E8','precsim':'\\u227E','prime':'\\u2032','Prime':'\\u2033','primes':'\\u2119','prnap':'\\u2AB9','prnE':'\\u2AB5','prnsim':'\\u22E8','prod':'\\u220F','Product':'\\u220F','profalar':'\\u232E','profline':'\\u2312','profsurf':'\\u2313','prop':'\\u221D','Proportion':'\\u2237','Proportional':'\\u221D','propto':'\\u221D','prsim':'\\u227E','prurel':'\\u22B0','pscr':'\\uD835\\uDCC5','Pscr':'\\uD835\\uDCAB','psi':'\\u03C8','Psi':'\\u03A8','puncsp':'\\u2008','qfr':'\\uD835\\uDD2E','Qfr':'\\uD835\\uDD14','qint':'\\u2A0C','qopf':'\\uD835\\uDD62','Qopf':'\\u211A','qprime':'\\u2057','qscr':'\\uD835\\uDCC6','Qscr':'\\uD835\\uDCAC','quaternions':'\\u210D','quatint':'\\u2A16','quest':'?','questeq':'\\u225F','quot':'\"','QUOT':'\"','rAarr':'\\u21DB','race':'\\u223D\\u0331','racute':'\\u0155','Racute':'\\u0154','radic':'\\u221A','raemptyv':'\\u29B3','rang':'\\u27E9','Rang':'\\u27EB','rangd':'\\u2992','range':'\\u29A5','rangle':'\\u27E9','raquo':'\\xBB','rarr':'\\u2192','rArr':'\\u21D2','Rarr':'\\u21A0','rarrap':'\\u2975','rarrb':'\\u21E5','rarrbfs':'\\u2920','rarrc':'\\u2933','rarrfs':'\\u291E','rarrhk':'\\u21AA','rarrlp':'\\u21AC','rarrpl':'\\u2945','rarrsim':'\\u2974','rarrtl':'\\u21A3','Rarrtl':'\\u2916','rarrw':'\\u219D','ratail':'\\u291A','rAtail':'\\u291C','ratio':'\\u2236','rationals':'\\u211A','rbarr':'\\u290D','rBarr':'\\u290F','RBarr':'\\u2910','rbbrk':'\\u2773','rbrace':'}','rbrack':']','rbrke':'\\u298C','rbrksld':'\\u298E','rbrkslu':'\\u2990','rcaron':'\\u0159','Rcaron':'\\u0158','rcedil':'\\u0157','Rcedil':'\\u0156','rceil':'\\u2309','rcub':'}','rcy':'\\u0440','Rcy':'\\u0420','rdca':'\\u2937','rdldhar':'\\u2969','rdquo':'\\u201D','rdquor':'\\u201D','rdsh':'\\u21B3','Re':'\\u211C','real':'\\u211C','realine':'\\u211B','realpart':'\\u211C','reals':'\\u211D','rect':'\\u25AD','reg':'\\xAE','REG':'\\xAE','ReverseElement':'\\u220B','ReverseEquilibrium':'\\u21CB','ReverseUpEquilibrium':'\\u296F','rfisht':'\\u297D','rfloor':'\\u230B','rfr':'\\uD835\\uDD2F','Rfr':'\\u211C','rHar':'\\u2964','rhard':'\\u21C1','rharu':'\\u21C0','rharul':'\\u296C','rho':'\\u03C1','Rho':'\\u03A1','rhov':'\\u03F1','RightAngleBracket':'\\u27E9','rightarrow':'\\u2192','Rightarrow':'\\u21D2','RightArrow':'\\u2192','RightArrowBar':'\\u21E5','RightArrowLeftArrow':'\\u21C4','rightarrowtail':'\\u21A3','RightCeiling':'\\u2309','RightDoubleBracket':'\\u27E7','RightDownTeeVector':'\\u295D','RightDownVector':'\\u21C2','RightDownVectorBar':'\\u2955','RightFloor':'\\u230B','rightharpoondown':'\\u21C1','rightharpoonup':'\\u21C0','rightleftarrows':'\\u21C4','rightleftharpoons':'\\u21CC','rightrightarrows':'\\u21C9','rightsquigarrow':'\\u219D','RightTee':'\\u22A2','RightTeeArrow':'\\u21A6','RightTeeVector':'\\u295B','rightthreetimes':'\\u22CC','RightTriangle':'\\u22B3','RightTriangleBar':'\\u29D0','RightTriangleEqual':'\\u22B5','RightUpDownVector':'\\u294F','RightUpTeeVector':'\\u295C','RightUpVector':'\\u21BE','RightUpVectorBar':'\\u2954','RightVector':'\\u21C0','RightVectorBar':'\\u2953','ring':'\\u02DA','risingdotseq':'\\u2253','rlarr':'\\u21C4','rlhar':'\\u21CC','rlm':'\\u200F','rmoust':'\\u23B1','rmoustache':'\\u23B1','rnmid':'\\u2AEE','roang':'\\u27ED','roarr':'\\u21FE','robrk':'\\u27E7','ropar':'\\u2986','ropf':'\\uD835\\uDD63','Ropf':'\\u211D','roplus':'\\u2A2E','rotimes':'\\u2A35','RoundImplies':'\\u2970','rpar':')','rpargt':'\\u2994','rppolint':'\\u2A12','rrarr':'\\u21C9','Rrightarrow':'\\u21DB','rsaquo':'\\u203A','rscr':'\\uD835\\uDCC7','Rscr':'\\u211B','rsh':'\\u21B1','Rsh':'\\u21B1','rsqb':']','rsquo':'\\u2019','rsquor':'\\u2019','rthree':'\\u22CC','rtimes':'\\u22CA','rtri':'\\u25B9','rtrie':'\\u22B5','rtrif':'\\u25B8','rtriltri':'\\u29CE','RuleDelayed':'\\u29F4','ruluhar':'\\u2968','rx':'\\u211E','sacute':'\\u015B','Sacute':'\\u015A','sbquo':'\\u201A','sc':'\\u227B','Sc':'\\u2ABC','scap':'\\u2AB8','scaron':'\\u0161','Scaron':'\\u0160','sccue':'\\u227D','sce':'\\u2AB0','scE':'\\u2AB4','scedil':'\\u015F','Scedil':'\\u015E','scirc':'\\u015D','Scirc':'\\u015C','scnap':'\\u2ABA','scnE':'\\u2AB6','scnsim':'\\u22E9','scpolint':'\\u2A13','scsim':'\\u227F','scy':'\\u0441','Scy':'\\u0421','sdot':'\\u22C5','sdotb':'\\u22A1','sdote':'\\u2A66','searhk':'\\u2925','searr':'\\u2198','seArr':'\\u21D8','searrow':'\\u2198','sect':'\\xA7','semi':';','seswar':'\\u2929','setminus':'\\u2216','setmn':'\\u2216','sext':'\\u2736','sfr':'\\uD835\\uDD30','Sfr':'\\uD835\\uDD16','sfrown':'\\u2322','sharp':'\\u266F','shchcy':'\\u0449','SHCHcy':'\\u0429','shcy':'\\u0448','SHcy':'\\u0428','ShortDownArrow':'\\u2193','ShortLeftArrow':'\\u2190','shortmid':'\\u2223','shortparallel':'\\u2225','ShortRightArrow':'\\u2192','ShortUpArrow':'\\u2191','shy':'\\xAD','sigma':'\\u03C3','Sigma':'\\u03A3','sigmaf':'\\u03C2','sigmav':'\\u03C2','sim':'\\u223C','simdot':'\\u2A6A','sime':'\\u2243','simeq':'\\u2243','simg':'\\u2A9E','simgE':'\\u2AA0','siml':'\\u2A9D','simlE':'\\u2A9F','simne':'\\u2246','simplus':'\\u2A24','simrarr':'\\u2972','slarr':'\\u2190','SmallCircle':'\\u2218','smallsetminus':'\\u2216','smashp':'\\u2A33','smeparsl':'\\u29E4','smid':'\\u2223','smile':'\\u2323','smt':'\\u2AAA','smte':'\\u2AAC','smtes':'\\u2AAC\\uFE00','softcy':'\\u044C','SOFTcy':'\\u042C','sol':'/','solb':'\\u29C4','solbar':'\\u233F','sopf':'\\uD835\\uDD64','Sopf':'\\uD835\\uDD4A','spades':'\\u2660','spadesuit':'\\u2660','spar':'\\u2225','sqcap':'\\u2293','sqcaps':'\\u2293\\uFE00','sqcup':'\\u2294','sqcups':'\\u2294\\uFE00','Sqrt':'\\u221A','sqsub':'\\u228F','sqsube':'\\u2291','sqsubset':'\\u228F','sqsubseteq':'\\u2291','sqsup':'\\u2290','sqsupe':'\\u2292','sqsupset':'\\u2290','sqsupseteq':'\\u2292','squ':'\\u25A1','square':'\\u25A1','Square':'\\u25A1','SquareIntersection':'\\u2293','SquareSubset':'\\u228F','SquareSubsetEqual':'\\u2291','SquareSuperset':'\\u2290','SquareSupersetEqual':'\\u2292','SquareUnion':'\\u2294','squarf':'\\u25AA','squf':'\\u25AA','srarr':'\\u2192','sscr':'\\uD835\\uDCC8','Sscr':'\\uD835\\uDCAE','ssetmn':'\\u2216','ssmile':'\\u2323','sstarf':'\\u22C6','star':'\\u2606','Star':'\\u22C6','starf':'\\u2605','straightepsilon':'\\u03F5','straightphi':'\\u03D5','strns':'\\xAF','sub':'\\u2282','Sub':'\\u22D0','subdot':'\\u2ABD','sube':'\\u2286','subE':'\\u2AC5','subedot':'\\u2AC3','submult':'\\u2AC1','subne':'\\u228A','subnE':'\\u2ACB','subplus':'\\u2ABF','subrarr':'\\u2979','subset':'\\u2282','Subset':'\\u22D0','subseteq':'\\u2286','subseteqq':'\\u2AC5','SubsetEqual':'\\u2286','subsetneq':'\\u228A','subsetneqq':'\\u2ACB','subsim':'\\u2AC7','subsub':'\\u2AD5','subsup':'\\u2AD3','succ':'\\u227B','succapprox':'\\u2AB8','succcurlyeq':'\\u227D','Succeeds':'\\u227B','SucceedsEqual':'\\u2AB0','SucceedsSlantEqual':'\\u227D','SucceedsTilde':'\\u227F','succeq':'\\u2AB0','succnapprox':'\\u2ABA','succneqq':'\\u2AB6','succnsim':'\\u22E9','succsim':'\\u227F','SuchThat':'\\u220B','sum':'\\u2211','Sum':'\\u2211','sung':'\\u266A','sup':'\\u2283','Sup':'\\u22D1','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','supdot':'\\u2ABE','supdsub':'\\u2AD8','supe':'\\u2287','supE':'\\u2AC6','supedot':'\\u2AC4','Superset':'\\u2283','SupersetEqual':'\\u2287','suphsol':'\\u27C9','suphsub':'\\u2AD7','suplarr':'\\u297B','supmult':'\\u2AC2','supne':'\\u228B','supnE':'\\u2ACC','supplus':'\\u2AC0','supset':'\\u2283','Supset':'\\u22D1','supseteq':'\\u2287','supseteqq':'\\u2AC6','supsetneq':'\\u228B','supsetneqq':'\\u2ACC','supsim':'\\u2AC8','supsub':'\\u2AD4','supsup':'\\u2AD6','swarhk':'\\u2926','swarr':'\\u2199','swArr':'\\u21D9','swarrow':'\\u2199','swnwar':'\\u292A','szlig':'\\xDF','Tab':'\\t','target':'\\u2316','tau':'\\u03C4','Tau':'\\u03A4','tbrk':'\\u23B4','tcaron':'\\u0165','Tcaron':'\\u0164','tcedil':'\\u0163','Tcedil':'\\u0162','tcy':'\\u0442','Tcy':'\\u0422','tdot':'\\u20DB','telrec':'\\u2315','tfr':'\\uD835\\uDD31','Tfr':'\\uD835\\uDD17','there4':'\\u2234','therefore':'\\u2234','Therefore':'\\u2234','theta':'\\u03B8','Theta':'\\u0398','thetasym':'\\u03D1','thetav':'\\u03D1','thickapprox':'\\u2248','thicksim':'\\u223C','ThickSpace':'\\u205F\\u200A','thinsp':'\\u2009','ThinSpace':'\\u2009','thkap':'\\u2248','thksim':'\\u223C','thorn':'\\xFE','THORN':'\\xDE','tilde':'\\u02DC','Tilde':'\\u223C','TildeEqual':'\\u2243','TildeFullEqual':'\\u2245','TildeTilde':'\\u2248','times':'\\xD7','timesb':'\\u22A0','timesbar':'\\u2A31','timesd':'\\u2A30','tint':'\\u222D','toea':'\\u2928','top':'\\u22A4','topbot':'\\u2336','topcir':'\\u2AF1','topf':'\\uD835\\uDD65','Topf':'\\uD835\\uDD4B','topfork':'\\u2ADA','tosa':'\\u2929','tprime':'\\u2034','trade':'\\u2122','TRADE':'\\u2122','triangle':'\\u25B5','triangledown':'\\u25BF','triangleleft':'\\u25C3','trianglelefteq':'\\u22B4','triangleq':'\\u225C','triangleright':'\\u25B9','trianglerighteq':'\\u22B5','tridot':'\\u25EC','trie':'\\u225C','triminus':'\\u2A3A','TripleDot':'\\u20DB','triplus':'\\u2A39','trisb':'\\u29CD','tritime':'\\u2A3B','trpezium':'\\u23E2','tscr':'\\uD835\\uDCC9','Tscr':'\\uD835\\uDCAF','tscy':'\\u0446','TScy':'\\u0426','tshcy':'\\u045B','TSHcy':'\\u040B','tstrok':'\\u0167','Tstrok':'\\u0166','twixt':'\\u226C','twoheadleftarrow':'\\u219E','twoheadrightarrow':'\\u21A0','uacute':'\\xFA','Uacute':'\\xDA','uarr':'\\u2191','uArr':'\\u21D1','Uarr':'\\u219F','Uarrocir':'\\u2949','ubrcy':'\\u045E','Ubrcy':'\\u040E','ubreve':'\\u016D','Ubreve':'\\u016C','ucirc':'\\xFB','Ucirc':'\\xDB','ucy':'\\u0443','Ucy':'\\u0423','udarr':'\\u21C5','udblac':'\\u0171','Udblac':'\\u0170','udhar':'\\u296E','ufisht':'\\u297E','ufr':'\\uD835\\uDD32','Ufr':'\\uD835\\uDD18','ugrave':'\\xF9','Ugrave':'\\xD9','uHar':'\\u2963','uharl':'\\u21BF','uharr':'\\u21BE','uhblk':'\\u2580','ulcorn':'\\u231C','ulcorner':'\\u231C','ulcrop':'\\u230F','ultri':'\\u25F8','umacr':'\\u016B','Umacr':'\\u016A','uml':'\\xA8','UnderBar':'_','UnderBrace':'\\u23DF','UnderBracket':'\\u23B5','UnderParenthesis':'\\u23DD','Union':'\\u22C3','UnionPlus':'\\u228E','uogon':'\\u0173','Uogon':'\\u0172','uopf':'\\uD835\\uDD66','Uopf':'\\uD835\\uDD4C','uparrow':'\\u2191','Uparrow':'\\u21D1','UpArrow':'\\u2191','UpArrowBar':'\\u2912','UpArrowDownArrow':'\\u21C5','updownarrow':'\\u2195','Updownarrow':'\\u21D5','UpDownArrow':'\\u2195','UpEquilibrium':'\\u296E','upharpoonleft':'\\u21BF','upharpoonright':'\\u21BE','uplus':'\\u228E','UpperLeftArrow':'\\u2196','UpperRightArrow':'\\u2197','upsi':'\\u03C5','Upsi':'\\u03D2','upsih':'\\u03D2','upsilon':'\\u03C5','Upsilon':'\\u03A5','UpTee':'\\u22A5','UpTeeArrow':'\\u21A5','upuparrows':'\\u21C8','urcorn':'\\u231D','urcorner':'\\u231D','urcrop':'\\u230E','uring':'\\u016F','Uring':'\\u016E','urtri':'\\u25F9','uscr':'\\uD835\\uDCCA','Uscr':'\\uD835\\uDCB0','utdot':'\\u22F0','utilde':'\\u0169','Utilde':'\\u0168','utri':'\\u25B5','utrif':'\\u25B4','uuarr':'\\u21C8','uuml':'\\xFC','Uuml':'\\xDC','uwangle':'\\u29A7','vangrt':'\\u299C','varepsilon':'\\u03F5','varkappa':'\\u03F0','varnothing':'\\u2205','varphi':'\\u03D5','varpi':'\\u03D6','varpropto':'\\u221D','varr':'\\u2195','vArr':'\\u21D5','varrho':'\\u03F1','varsigma':'\\u03C2','varsubsetneq':'\\u228A\\uFE00','varsubsetneqq':'\\u2ACB\\uFE00','varsupsetneq':'\\u228B\\uFE00','varsupsetneqq':'\\u2ACC\\uFE00','vartheta':'\\u03D1','vartriangleleft':'\\u22B2','vartriangleright':'\\u22B3','vBar':'\\u2AE8','Vbar':'\\u2AEB','vBarv':'\\u2AE9','vcy':'\\u0432','Vcy':'\\u0412','vdash':'\\u22A2','vDash':'\\u22A8','Vdash':'\\u22A9','VDash':'\\u22AB','Vdashl':'\\u2AE6','vee':'\\u2228','Vee':'\\u22C1','veebar':'\\u22BB','veeeq':'\\u225A','vellip':'\\u22EE','verbar':'|','Verbar':'\\u2016','vert':'|','Vert':'\\u2016','VerticalBar':'\\u2223','VerticalLine':'|','VerticalSeparator':'\\u2758','VerticalTilde':'\\u2240','VeryThinSpace':'\\u200A','vfr':'\\uD835\\uDD33','Vfr':'\\uD835\\uDD19','vltri':'\\u22B2','vnsub':'\\u2282\\u20D2','vnsup':'\\u2283\\u20D2','vopf':'\\uD835\\uDD67','Vopf':'\\uD835\\uDD4D','vprop':'\\u221D','vrtri':'\\u22B3','vscr':'\\uD835\\uDCCB','Vscr':'\\uD835\\uDCB1','vsubne':'\\u228A\\uFE00','vsubnE':'\\u2ACB\\uFE00','vsupne':'\\u228B\\uFE00','vsupnE':'\\u2ACC\\uFE00','Vvdash':'\\u22AA','vzigzag':'\\u299A','wcirc':'\\u0175','Wcirc':'\\u0174','wedbar':'\\u2A5F','wedge':'\\u2227','Wedge':'\\u22C0','wedgeq':'\\u2259','weierp':'\\u2118','wfr':'\\uD835\\uDD34','Wfr':'\\uD835\\uDD1A','wopf':'\\uD835\\uDD68','Wopf':'\\uD835\\uDD4E','wp':'\\u2118','wr':'\\u2240','wreath':'\\u2240','wscr':'\\uD835\\uDCCC','Wscr':'\\uD835\\uDCB2','xcap':'\\u22C2','xcirc':'\\u25EF','xcup':'\\u22C3','xdtri':'\\u25BD','xfr':'\\uD835\\uDD35','Xfr':'\\uD835\\uDD1B','xharr':'\\u27F7','xhArr':'\\u27FA','xi':'\\u03BE','Xi':'\\u039E','xlarr':'\\u27F5','xlArr':'\\u27F8','xmap':'\\u27FC','xnis':'\\u22FB','xodot':'\\u2A00','xopf':'\\uD835\\uDD69','Xopf':'\\uD835\\uDD4F','xoplus':'\\u2A01','xotime':'\\u2A02','xrarr':'\\u27F6','xrArr':'\\u27F9','xscr':'\\uD835\\uDCCD','Xscr':'\\uD835\\uDCB3','xsqcup':'\\u2A06','xuplus':'\\u2A04','xutri':'\\u25B3','xvee':'\\u22C1','xwedge':'\\u22C0','yacute':'\\xFD','Yacute':'\\xDD','yacy':'\\u044F','YAcy':'\\u042F','ycirc':'\\u0177','Ycirc':'\\u0176','ycy':'\\u044B','Ycy':'\\u042B','yen':'\\xA5','yfr':'\\uD835\\uDD36','Yfr':'\\uD835\\uDD1C','yicy':'\\u0457','YIcy':'\\u0407','yopf':'\\uD835\\uDD6A','Yopf':'\\uD835\\uDD50','yscr':'\\uD835\\uDCCE','Yscr':'\\uD835\\uDCB4','yucy':'\\u044E','YUcy':'\\u042E','yuml':'\\xFF','Yuml':'\\u0178','zacute':'\\u017A','Zacute':'\\u0179','zcaron':'\\u017E','Zcaron':'\\u017D','zcy':'\\u0437','Zcy':'\\u0417','zdot':'\\u017C','Zdot':'\\u017B','zeetrf':'\\u2128','ZeroWidthSpace':'\\u200B','zeta':'\\u03B6','Zeta':'\\u0396','zfr':'\\uD835\\uDD37','Zfr':'\\u2128','zhcy':'\\u0436','ZHcy':'\\u0416','zigrarr':'\\u21DD','zopf':'\\uD835\\uDD6B','Zopf':'\\u2124','zscr':'\\uD835\\uDCCF','Zscr':'\\uD835\\uDCB5','zwj':'\\u200D','zwnj':'\\u200C'};\n\tvar decodeMapLegacy = {'aacute':'\\xE1','Aacute':'\\xC1','acirc':'\\xE2','Acirc':'\\xC2','acute':'\\xB4','aelig':'\\xE6','AElig':'\\xC6','agrave':'\\xE0','Agrave':'\\xC0','amp':'&','AMP':'&','aring':'\\xE5','Aring':'\\xC5','atilde':'\\xE3','Atilde':'\\xC3','auml':'\\xE4','Auml':'\\xC4','brvbar':'\\xA6','ccedil':'\\xE7','Ccedil':'\\xC7','cedil':'\\xB8','cent':'\\xA2','copy':'\\xA9','COPY':'\\xA9','curren':'\\xA4','deg':'\\xB0','divide':'\\xF7','eacute':'\\xE9','Eacute':'\\xC9','ecirc':'\\xEA','Ecirc':'\\xCA','egrave':'\\xE8','Egrave':'\\xC8','eth':'\\xF0','ETH':'\\xD0','euml':'\\xEB','Euml':'\\xCB','frac12':'\\xBD','frac14':'\\xBC','frac34':'\\xBE','gt':'>','GT':'>','iacute':'\\xED','Iacute':'\\xCD','icirc':'\\xEE','Icirc':'\\xCE','iexcl':'\\xA1','igrave':'\\xEC','Igrave':'\\xCC','iquest':'\\xBF','iuml':'\\xEF','Iuml':'\\xCF','laquo':'\\xAB','lt':'<','LT':'<','macr':'\\xAF','micro':'\\xB5','middot':'\\xB7','nbsp':'\\xA0','not':'\\xAC','ntilde':'\\xF1','Ntilde':'\\xD1','oacute':'\\xF3','Oacute':'\\xD3','ocirc':'\\xF4','Ocirc':'\\xD4','ograve':'\\xF2','Ograve':'\\xD2','ordf':'\\xAA','ordm':'\\xBA','oslash':'\\xF8','Oslash':'\\xD8','otilde':'\\xF5','Otilde':'\\xD5','ouml':'\\xF6','Ouml':'\\xD6','para':'\\xB6','plusmn':'\\xB1','pound':'\\xA3','quot':'\"','QUOT':'\"','raquo':'\\xBB','reg':'\\xAE','REG':'\\xAE','sect':'\\xA7','shy':'\\xAD','sup1':'\\xB9','sup2':'\\xB2','sup3':'\\xB3','szlig':'\\xDF','thorn':'\\xFE','THORN':'\\xDE','times':'\\xD7','uacute':'\\xFA','Uacute':'\\xDA','ucirc':'\\xFB','Ucirc':'\\xDB','ugrave':'\\xF9','Ugrave':'\\xD9','uml':'\\xA8','uuml':'\\xFC','Uuml':'\\xDC','yacute':'\\xFD','Yacute':'\\xDD','yen':'\\xA5','yuml':'\\xFF'};\n\tvar decodeMapNumeric = {'0':'\\uFFFD','128':'\\u20AC','130':'\\u201A','131':'\\u0192','132':'\\u201E','133':'\\u2026','134':'\\u2020','135':'\\u2021','136':'\\u02C6','137':'\\u2030','138':'\\u0160','139':'\\u2039','140':'\\u0152','142':'\\u017D','145':'\\u2018','146':'\\u2019','147':'\\u201C','148':'\\u201D','149':'\\u2022','150':'\\u2013','151':'\\u2014','152':'\\u02DC','153':'\\u2122','154':'\\u0161','155':'\\u203A','156':'\\u0153','158':'\\u017E','159':'\\u0178'};\n\tvar invalidReferenceCodePoints = [1,2,3,4,5,6,7,8,11,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,127,128,129,130,131,132,133,134,135,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,153,154,155,156,157,158,159,64976,64977,64978,64979,64980,64981,64982,64983,64984,64985,64986,64987,64988,64989,64990,64991,64992,64993,64994,64995,64996,64997,64998,64999,65000,65001,65002,65003,65004,65005,65006,65007,65534,65535,131070,131071,196606,196607,262142,262143,327678,327679,393214,393215,458750,458751,524286,524287,589822,589823,655358,655359,720894,720895,786430,786431,851966,851967,917502,917503,983038,983039,1048574,1048575,1114110,1114111];\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar stringFromCharCode = String.fromCharCode;\n\n\tvar object = {};\n\tvar hasOwnProperty = object.hasOwnProperty;\n\tvar has = function(object, propertyName) {\n\t\treturn hasOwnProperty.call(object, propertyName);\n\t};\n\n\tvar contains = function(array, value) {\n\t\tvar index = -1;\n\t\tvar length = array.length;\n\t\twhile (++index < length) {\n\t\t\tif (array[index] == value) {\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t};\n\n\tvar merge = function(options, defaults) {\n\t\tif (!options) {\n\t\t\treturn defaults;\n\t\t}\n\t\tvar result = {};\n\t\tvar key;\n\t\tfor (key in defaults) {\n\t\t\t// A `hasOwnProperty` check is not needed here, since only recognized\n\t\t\t// option names are used anyway. Any others are ignored.\n\t\t\tresult[key] = has(options, key) ? options[key] : defaults[key];\n\t\t}\n\t\treturn result;\n\t};\n\n\t// Modified version of `ucs2encode`; see https://mths.be/punycode.\n\tvar codePointToSymbol = function(codePoint, strict) {\n\t\tvar output = '';\n\t\tif ((codePoint >= 0xD800 && codePoint <= 0xDFFF) || codePoint > 0x10FFFF) {\n\t\t\t// See issue #4:\n\t\t\t// Otherwise, if the number is in the range 0xD800 to 0xDFFF or is\n\t\t\t// greater than 0x10FFFF, then this is a parse error. Return a U+FFFD\n\t\t\t// REPLACEMENT CHARACTER.\n\t\t\tif (strict) {\n\t\t\t\tparseError('character reference outside the permissible Unicode range');\n\t\t\t}\n\t\t\treturn '\\uFFFD';\n\t\t}\n\t\tif (has(decodeMapNumeric, codePoint)) {\n\t\t\tif (strict) {\n\t\t\t\tparseError('disallowed character reference');\n\t\t\t}\n\t\t\treturn decodeMapNumeric[codePoint];\n\t\t}\n\t\tif (strict && contains(invalidReferenceCodePoints, codePoint)) {\n\t\t\tparseError('disallowed character reference');\n\t\t}\n\t\tif (codePoint > 0xFFFF) {\n\t\t\tcodePoint -= 0x10000;\n\t\t\toutput += stringFromCharCode(codePoint >>> 10 & 0x3FF | 0xD800);\n\t\t\tcodePoint = 0xDC00 | codePoint & 0x3FF;\n\t\t}\n\t\toutput += stringFromCharCode(codePoint);\n\t\treturn output;\n\t};\n\n\tvar hexEscape = function(codePoint) {\n\t\treturn '&#x' + codePoint.toString(16).toUpperCase() + ';';\n\t};\n\n\tvar decEscape = function(codePoint) {\n\t\treturn '&#' + codePoint + ';';\n\t};\n\n\tvar parseError = function(message) {\n\t\tthrow Error('Parse error: ' + message);\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar encode = function(string, options) {\n\t\toptions = merge(options, encode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidRawCodePoint.test(string)) {\n\t\t\tparseError('forbidden code point');\n\t\t}\n\t\tvar encodeEverything = options.encodeEverything;\n\t\tvar useNamedReferences = options.useNamedReferences;\n\t\tvar allowUnsafeSymbols = options.allowUnsafeSymbols;\n\t\tvar escapeCodePoint = options.decimal ? decEscape : hexEscape;\n\n\t\tvar escapeBmpSymbol = function(symbol) {\n\t\t\treturn escapeCodePoint(symbol.charCodeAt(0));\n\t\t};\n\n\t\tif (encodeEverything) {\n\t\t\t// Encode ASCII symbols.\n\t\t\tstring = string.replace(regexAsciiWhitelist, function(symbol) {\n\t\t\t\t// Use named references if requested & possible.\n\t\t\t\tif (useNamedReferences && has(encodeMap, symbol)) {\n\t\t\t\t\treturn '&' + encodeMap[symbol] + ';';\n\t\t\t\t}\n\t\t\t\treturn escapeBmpSymbol(symbol);\n\t\t\t});\n\t\t\t// Shorten a few escapes that represent two symbols, of which at least one\n\t\t\t// is within the ASCII range.\n\t\t\tif (useNamedReferences) {\n\t\t\t\tstring = string\n\t\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;')\n\t\t\t\t\t.replace(/&#x66;&#x6A;/g, '&fjlig;');\n\t\t\t}\n\t\t\t// Encode non-ASCII symbols.\n\t\t\tif (useNamedReferences) {\n\t\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Note: any remaining non-ASCII symbols are handled outside of the `if`.\n\t\t} else if (useNamedReferences) {\n\t\t\t// Apply named character references.\n\t\t\t// Encode `<>\"'&` using named character references.\n\t\t\tif (!allowUnsafeSymbols) {\n\t\t\t\tstring = string.replace(regexEscape, function(string) {\n\t\t\t\t\treturn '&' + encodeMap[string] + ';'; // no need to check `has()` here\n\t\t\t\t});\n\t\t\t}\n\t\t\t// Shorten escapes that represent two symbols, of which at least one is\n\t\t\t// `<>\"'&`.\n\t\t\tstring = string\n\t\t\t\t.replace(/&gt;\\u20D2/g, '&nvgt;')\n\t\t\t\t.replace(/&lt;\\u20D2/g, '&nvlt;');\n\t\t\t// Encode non-ASCII symbols that can be replaced with a named reference.\n\t\t\tstring = string.replace(regexEncodeNonAscii, function(string) {\n\t\t\t\t// Note: there is no need to check `has(encodeMap, string)` here.\n\t\t\t\treturn '&' + encodeMap[string] + ';';\n\t\t\t});\n\t\t} else if (!allowUnsafeSymbols) {\n\t\t\t// Encode `<>\"'&` using hexadecimal escapes, now that theyre not handled\n\t\t\t// using named character references.\n\t\t\tstring = string.replace(regexEscape, escapeBmpSymbol);\n\t\t}\n\t\treturn string\n\t\t\t// Encode astral symbols.\n\t\t\t.replace(regexAstralSymbols, function($0) {\n\t\t\t\t// https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n\t\t\t\tvar high = $0.charCodeAt(0);\n\t\t\t\tvar low = $0.charCodeAt(1);\n\t\t\t\tvar codePoint = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;\n\t\t\t\treturn escapeCodePoint(codePoint);\n\t\t\t})\n\t\t\t// Encode any remaining BMP symbols that are not printable ASCII symbols\n\t\t\t// using a hexadecimal escape.\n\t\t\t.replace(regexBmpWhitelist, escapeBmpSymbol);\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tencode.options = {\n\t\t'allowUnsafeSymbols': false,\n\t\t'encodeEverything': false,\n\t\t'strict': false,\n\t\t'useNamedReferences': false,\n\t\t'decimal' : false\n\t};\n\n\tvar decode = function(html, options) {\n\t\toptions = merge(options, decode.options);\n\t\tvar strict = options.strict;\n\t\tif (strict && regexInvalidEntity.test(html)) {\n\t\t\tparseError('malformed character reference');\n\t\t}\n\t\treturn html.replace(regexDecode, function($0, $1, $2, $3, $4, $5, $6, $7) {\n\t\t\tvar codePoint;\n\t\t\tvar semicolon;\n\t\t\tvar decDigits;\n\t\t\tvar hexDigits;\n\t\t\tvar reference;\n\t\t\tvar next;\n\t\t\tif ($1) {\n\t\t\t\t// Decode decimal escapes, e.g. `&#119558;`.\n\t\t\t\tdecDigits = $1;\n\t\t\t\tsemicolon = $2;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(decDigits, 10);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($3) {\n\t\t\t\t// Decode hexadecimal escapes, e.g. `&#x1D306;`.\n\t\t\t\thexDigits = $3;\n\t\t\t\tsemicolon = $4;\n\t\t\t\tif (strict && !semicolon) {\n\t\t\t\t\tparseError('character reference was not terminated by a semicolon');\n\t\t\t\t}\n\t\t\t\tcodePoint = parseInt(hexDigits, 16);\n\t\t\t\treturn codePointToSymbol(codePoint, strict);\n\t\t\t}\n\t\t\tif ($5) {\n\t\t\t\t// Decode named character references with trailing `;`, e.g. `&copy;`.\n\t\t\t\treference = $5;\n\t\t\t\tif (has(decodeMap, reference)) {\n\t\t\t\t\treturn decodeMap[reference];\n\t\t\t\t} else {\n\t\t\t\t\t// Ambiguous ampersand. https://mths.be/notes/ambiguous-ampersands\n\t\t\t\t\tif (strict) {\n\t\t\t\t\t\tparseError(\n\t\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t\t);\n\t\t\t\t\t}\n\t\t\t\t\treturn $0;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// If were still here, its a legacy reference for sure. No need for an\n\t\t\t// extra `if` check.\n\t\t\t// Decode named character references without trailing `;`, e.g. `&amp`\n\t\t\t// This is only a parse error if it gets converted to `&`, or if it is\n\t\t\t// followed by `=` in an attribute context.\n\t\t\treference = $6;\n\t\t\tnext = $7;\n\t\t\tif (next && options.isAttributeValue) {\n\t\t\t\tif (strict && next == '=') {\n\t\t\t\t\tparseError('`&` did not start a character reference');\n\t\t\t\t}\n\t\t\t\treturn $0;\n\t\t\t} else {\n\t\t\t\tif (strict) {\n\t\t\t\t\tparseError(\n\t\t\t\t\t\t'named character reference was not terminated by a semicolon'\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\t// Note: there is no need to check `has(decodeMapLegacy, reference)`.\n\t\t\t\treturn decodeMapLegacy[reference] + (next || '');\n\t\t\t}\n\t\t});\n\t};\n\t// Expose default options (so they can be overridden globally).\n\tdecode.options = {\n\t\t'isAttributeValue': false,\n\t\t'strict': false\n\t};\n\n\tvar escape = function(string) {\n\t\treturn string.replace(regexEscape, function($0) {\n\t\t\t// Note: there is no need to check `has(escapeMap, $0)` here.\n\t\t\treturn escapeMap[$0];\n\t\t});\n\t};\n\n\t/*--------------------------------------------------------------------------*/\n\n\tvar he = {\n\t\t'version': '1.1.1',\n\t\t'encode': encode,\n\t\t'decode': decode,\n\t\t'escape': escape,\n\t\t'unescape': decode\n\t};\n\n\t// Some AMD build optimizers, like r.js, check for specific condition patterns\n\t// like the following:\n\tif (\n\t\tfalse\n\t) {\n\t\tdefine(function() {\n\t\t\treturn he;\n\t\t});\n\t}\telse if (freeExports && !freeExports.nodeType) {\n\t\tif (freeModule) { // in Node.js, io.js, or RingoJS v0.8.0+\n\t\t\tfreeModule.exports = he;\n\t\t} else { // in Narwhal or RingoJS v0.7.0-\n\t\t\tfor (var key in he) {\n\t\t\t\thas(he, key) && (freeExports[key] = he[key]);\n\t\t\t}\n\t\t}\n\t} else { // in Rhino or a web browser\n\t\troot.he = he;\n\t}\n\n}(this));\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],49:[function(require,module,exports){\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = nBytes * 8 - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n\n},{}],50:[function(require,module,exports){\nif (typeof Object.create === 'function') {\n  // implementation from standard node.js 'util' module\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    ctor.prototype = Object.create(superCtor.prototype, {\n      constructor: {\n        value: ctor,\n        enumerable: false,\n        writable: true,\n        configurable: true\n      }\n    });\n  };\n} else {\n  // old school shim for old browsers\n  module.exports = function inherits(ctor, superCtor) {\n    ctor.super_ = superCtor\n    var TempCtor = function () {}\n    TempCtor.prototype = superCtor.prototype\n    ctor.prototype = new TempCtor()\n    ctor.prototype.constructor = ctor\n  }\n}\n\n},{}],51:[function(require,module,exports){\n/*!\n * Determine if an object is a Buffer\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\n\n// The _isBuffer check is for Safari 5-7 support, because it's missing\n// Object.prototype.constructor. Remove this eventually\nmodule.exports = function (obj) {\n  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer)\n}\n\nfunction isBuffer (obj) {\n  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj)\n}\n\n// For Node v0.10 support. Remove this eventually.\nfunction isSlowBuffer (obj) {\n  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0))\n}\n\n},{}],52:[function(require,module,exports){\nvar toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n\n},{}],53:[function(require,module,exports){\n(function (process){\nvar path = require('path');\nvar fs = require('fs');\nvar _0777 = parseInt('0777', 8);\n\nmodule.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;\n\nfunction mkdirP (p, opts, f, made) {\n    if (typeof opts === 'function') {\n        f = opts;\n        opts = {};\n    }\n    else if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n    \n    var cb = f || function () {};\n    p = path.resolve(p);\n    \n    xfs.mkdir(p, mode, function (er) {\n        if (!er) {\n            made = made || p;\n            return cb(null, made);\n        }\n        switch (er.code) {\n            case 'ENOENT':\n                mkdirP(path.dirname(p), opts, function (er, made) {\n                    if (er) cb(er, made);\n                    else mkdirP(p, opts, cb, made);\n                });\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                xfs.stat(p, function (er2, stat) {\n                    // if the stat fails, then that's super weird.\n                    // let the original error be the failure reason.\n                    if (er2 || !stat.isDirectory()) cb(er, made)\n                    else cb(null, made);\n                });\n                break;\n        }\n    });\n}\n\nmkdirP.sync = function sync (p, opts, made) {\n    if (!opts || typeof opts !== 'object') {\n        opts = { mode: opts };\n    }\n    \n    var mode = opts.mode;\n    var xfs = opts.fs || fs;\n    \n    if (mode === undefined) {\n        mode = _0777 & (~process.umask());\n    }\n    if (!made) made = null;\n\n    p = path.resolve(p);\n\n    try {\n        xfs.mkdirSync(p, mode);\n        made = made || p;\n    }\n    catch (err0) {\n        switch (err0.code) {\n            case 'ENOENT' :\n                made = sync(path.dirname(p), opts, made);\n                sync(p, opts, made);\n                break;\n\n            // In the case of any other error, just see if there's a dir\n            // there already.  If so, then hooray!  If not, then something\n            // is borked.\n            default:\n                var stat;\n                try {\n                    stat = xfs.statSync(p);\n                }\n                catch (err1) {\n                    throw err0;\n                }\n                if (!stat.isDirectory()) throw err0;\n                break;\n        }\n    }\n\n    return made;\n};\n\n}).call(this,require('_process'))\n},{\"_process\":56,\"fs\":40,\"path\":40}],54:[function(require,module,exports){\n/**\n * Helpers.\n */\n\nvar s = 1000;\nvar m = s * 60;\nvar h = m * 60;\nvar d = h * 24;\nvar y = d * 365.25;\n\n/**\n * Parse or format the given `val`.\n *\n * Options:\n *\n *  - `long` verbose formatting [false]\n *\n * @param {String|Number} val\n * @param {Object} [options]\n * @throws {Error} throw an error if val is not a non-empty string or a number\n * @return {String|Number}\n * @api public\n */\n\nmodule.exports = function(val, options) {\n  options = options || {};\n  var type = typeof val;\n  if (type === 'string' && val.length > 0) {\n    return parse(val);\n  } else if (type === 'number' && isNaN(val) === false) {\n    return options.long ? fmtLong(val) : fmtShort(val);\n  }\n  throw new Error(\n    'val is not a non-empty string or a valid number. val=' +\n      JSON.stringify(val)\n  );\n};\n\n/**\n * Parse the given `str` and return milliseconds.\n *\n * @param {String} str\n * @return {Number}\n * @api private\n */\n\nfunction parse(str) {\n  str = String(str);\n  if (str.length > 100) {\n    return;\n  }\n  var match = /^((?:\\d+)?\\.?\\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|years?|yrs?|y)?$/i.exec(\n    str\n  );\n  if (!match) {\n    return;\n  }\n  var n = parseFloat(match[1]);\n  var type = (match[2] || 'ms').toLowerCase();\n  switch (type) {\n    case 'years':\n    case 'year':\n    case 'yrs':\n    case 'yr':\n    case 'y':\n      return n * y;\n    case 'days':\n    case 'day':\n    case 'd':\n      return n * d;\n    case 'hours':\n    case 'hour':\n    case 'hrs':\n    case 'hr':\n    case 'h':\n      return n * h;\n    case 'minutes':\n    case 'minute':\n    case 'mins':\n    case 'min':\n    case 'm':\n      return n * m;\n    case 'seconds':\n    case 'second':\n    case 'secs':\n    case 'sec':\n    case 's':\n      return n * s;\n    case 'milliseconds':\n    case 'millisecond':\n    case 'msecs':\n    case 'msec':\n    case 'ms':\n      return n;\n    default:\n      return undefined;\n  }\n}\n\n/**\n * Short format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtShort(ms) {\n  if (ms >= d) {\n    return Math.round(ms / d) + 'd';\n  }\n  if (ms >= h) {\n    return Math.round(ms / h) + 'h';\n  }\n  if (ms >= m) {\n    return Math.round(ms / m) + 'm';\n  }\n  if (ms >= s) {\n    return Math.round(ms / s) + 's';\n  }\n  return ms + 'ms';\n}\n\n/**\n * Long format for `ms`.\n *\n * @param {Number} ms\n * @return {String}\n * @api private\n */\n\nfunction fmtLong(ms) {\n  return plural(ms, d, 'day') ||\n    plural(ms, h, 'hour') ||\n    plural(ms, m, 'minute') ||\n    plural(ms, s, 'second') ||\n    ms + ' ms';\n}\n\n/**\n * Pluralization helper.\n */\n\nfunction plural(ms, n, name) {\n  if (ms < n) {\n    return;\n  }\n  if (ms < n * 1.5) {\n    return Math.floor(ms / n) + ' ' + name;\n  }\n  return Math.ceil(ms / n) + ' ' + name + 's';\n}\n\n},{}],55:[function(require,module,exports){\n(function (process){\n'use strict';\n\nif (!process.version ||\n    process.version.indexOf('v0.') === 0 ||\n    process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {\n  module.exports = nextTick;\n} else {\n  module.exports = process.nextTick;\n}\n\nfunction nextTick(fn, arg1, arg2, arg3) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('\"callback\" argument must be a function');\n  }\n  var len = arguments.length;\n  var args, i;\n  switch (len) {\n  case 0:\n  case 1:\n    return process.nextTick(fn);\n  case 2:\n    return process.nextTick(function afterTickOne() {\n      fn.call(null, arg1);\n    });\n  case 3:\n    return process.nextTick(function afterTickTwo() {\n      fn.call(null, arg1, arg2);\n    });\n  case 4:\n    return process.nextTick(function afterTickThree() {\n      fn.call(null, arg1, arg2, arg3);\n    });\n  default:\n    args = new Array(len - 1);\n    i = 0;\n    while (i < args.length) {\n      args[i++] = arguments[i];\n    }\n    return process.nextTick(function afterTick() {\n      fn.apply(null, args);\n    });\n  }\n}\n\n}).call(this,require('_process'))\n},{\"_process\":56}],56:[function(require,module,exports){\n// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n\n},{}],57:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_duplex.js');\n\n},{\"./lib/_stream_duplex.js\":58}],58:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a duplex stream is just a stream that is both readable and writable.\n// Since JS doesn't have multiple prototypal inheritance, this class\n// prototypally inherits from Readable, and then parasitically from\n// Writable.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n/*<replacement>*/\nvar objectKeys = Object.keys || function (obj) {\n  var keys = [];\n  for (var key in obj) {\n    keys.push(key);\n  }return keys;\n};\n/*</replacement>*/\n\nmodule.exports = Duplex;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nvar Readable = require('./_stream_readable');\nvar Writable = require('./_stream_writable');\n\nutil.inherits(Duplex, Readable);\n\nvar keys = objectKeys(Writable.prototype);\nfor (var v = 0; v < keys.length; v++) {\n  var method = keys[v];\n  if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];\n}\n\nfunction Duplex(options) {\n  if (!(this instanceof Duplex)) return new Duplex(options);\n\n  Readable.call(this, options);\n  Writable.call(this, options);\n\n  if (options && options.readable === false) this.readable = false;\n\n  if (options && options.writable === false) this.writable = false;\n\n  this.allowHalfOpen = true;\n  if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;\n\n  this.once('end', onend);\n}\n\n// the no-half-open enforcer\nfunction onend() {\n  // if we allow half-open state, or if the writable side ended,\n  // then we're ok.\n  if (this.allowHalfOpen || this._writableState.ended) return;\n\n  // no more data can be written.\n  // But allow more writes to happen in this tick.\n  processNextTick(onEndNT, this);\n}\n\nfunction onEndNT(self) {\n  self.end();\n}\n\nObject.defineProperty(Duplex.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed && this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (this._readableState === undefined || this._writableState === undefined) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n    this._writableState.destroyed = value;\n  }\n});\n\nDuplex.prototype._destroy = function (err, cb) {\n  this.push(null);\n  this.end();\n\n  processNextTick(cb, err);\n};\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n},{\"./_stream_readable\":60,\"./_stream_writable\":62,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55}],59:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a passthrough stream.\n// basically just the most minimal sort of Transform stream.\n// Every written chunk gets output as-is.\n\n'use strict';\n\nmodule.exports = PassThrough;\n\nvar Transform = require('./_stream_transform');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(PassThrough, Transform);\n\nfunction PassThrough(options) {\n  if (!(this instanceof PassThrough)) return new PassThrough(options);\n\n  Transform.call(this, options);\n}\n\nPassThrough.prototype._transform = function (chunk, encoding, cb) {\n  cb(null, chunk);\n};\n},{\"./_stream_transform\":61,\"core-util-is\":42,\"inherits\":50}],60:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Readable;\n\n/*<replacement>*/\nvar isArray = require('isarray');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nReadable.ReadableState = ReadableState;\n\n/*<replacement>*/\nvar EE = require('events').EventEmitter;\n\nvar EElistenerCount = function (emitter, type) {\n  return emitter.listeners(type).length;\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n// TODO(bmeurer): Change this back to const once hole checks are\n// properly optimized away early in Ignition+TurboFan.\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar debugUtil = require('util');\nvar debug = void 0;\nif (debugUtil && debugUtil.debuglog) {\n  debug = debugUtil.debuglog('stream');\n} else {\n  debug = function () {};\n}\n/*</replacement>*/\n\nvar BufferList = require('./internal/streams/BufferList');\nvar destroyImpl = require('./internal/streams/destroy');\nvar StringDecoder;\n\nutil.inherits(Readable, Stream);\n\nvar kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];\n\nfunction prependListener(emitter, event, fn) {\n  // Sadly this is not cacheable as some libraries bundle their own\n  // event emitter implementation with them.\n  if (typeof emitter.prependListener === 'function') {\n    return emitter.prependListener(event, fn);\n  } else {\n    // This is a hack to make sure that our error handler is attached before any\n    // userland ones.  NEVER DO THIS. This is here only because this code needs\n    // to continue to work with older versions of Node.js that do not include\n    // the prependListener() method. The goal is to eventually remove this hack.\n    if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];\n  }\n}\n\nfunction ReadableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag. Used to make read(n) ignore n and to\n  // make all the buffer merging and length checks go away\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.readableObjectMode;\n\n  // the point at which it stops calling _read() to fill the buffer\n  // Note: 0 is a valid value, means \"don't call _read preemptively ever\"\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // A linked list is used to store data chunks instead of an array because the\n  // linked list can remove elements from the beginning faster than\n  // array.shift()\n  this.buffer = new BufferList();\n  this.length = 0;\n  this.pipes = null;\n  this.pipesCount = 0;\n  this.flowing = null;\n  this.ended = false;\n  this.endEmitted = false;\n  this.reading = false;\n\n  // a flag to be able to tell if the event 'readable'/'data' is emitted\n  // immediately, or on a later tick.  We set this to true at first, because\n  // any actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first read call.\n  this.sync = true;\n\n  // whenever we return null, then we set a flag to say\n  // that we're awaiting a 'readable' event emission.\n  this.needReadable = false;\n  this.emittedReadable = false;\n  this.readableListening = false;\n  this.resumeScheduled = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // the number of writers that are awaiting a drain event in .pipe()s\n  this.awaitDrain = 0;\n\n  // if true, a maybeReadMore has been scheduled\n  this.readingMore = false;\n\n  this.decoder = null;\n  this.encoding = null;\n  if (options.encoding) {\n    if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n    this.decoder = new StringDecoder(options.encoding);\n    this.encoding = options.encoding;\n  }\n}\n\nfunction Readable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  if (!(this instanceof Readable)) return new Readable(options);\n\n  this._readableState = new ReadableState(options, this);\n\n  // legacy\n  this.readable = true;\n\n  if (options) {\n    if (typeof options.read === 'function') this._read = options.read;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n  }\n\n  Stream.call(this);\n}\n\nObject.defineProperty(Readable.prototype, 'destroyed', {\n  get: function () {\n    if (this._readableState === undefined) {\n      return false;\n    }\n    return this._readableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._readableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._readableState.destroyed = value;\n  }\n});\n\nReadable.prototype.destroy = destroyImpl.destroy;\nReadable.prototype._undestroy = destroyImpl.undestroy;\nReadable.prototype._destroy = function (err, cb) {\n  this.push(null);\n  cb(err);\n};\n\n// Manually shove something into the read() buffer.\n// This returns true if the highWaterMark has not been hit yet,\n// similar to how Writable.write() returns true if you should\n// write() some more.\nReadable.prototype.push = function (chunk, encoding) {\n  var state = this._readableState;\n  var skipChunkCheck;\n\n  if (!state.objectMode) {\n    if (typeof chunk === 'string') {\n      encoding = encoding || state.defaultEncoding;\n      if (encoding !== state.encoding) {\n        chunk = Buffer.from(chunk, encoding);\n        encoding = '';\n      }\n      skipChunkCheck = true;\n    }\n  } else {\n    skipChunkCheck = true;\n  }\n\n  return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);\n};\n\n// Unshift should *always* be something directly out of read()\nReadable.prototype.unshift = function (chunk) {\n  return readableAddChunk(this, chunk, null, true, false);\n};\n\nfunction readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {\n  var state = stream._readableState;\n  if (chunk === null) {\n    state.reading = false;\n    onEofChunk(stream, state);\n  } else {\n    var er;\n    if (!skipChunkCheck) er = chunkInvalid(state, chunk);\n    if (er) {\n      stream.emit('error', er);\n    } else if (state.objectMode || chunk && chunk.length > 0) {\n      if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {\n        chunk = _uint8ArrayToBuffer(chunk);\n      }\n\n      if (addToFront) {\n        if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);\n      } else if (state.ended) {\n        stream.emit('error', new Error('stream.push() after EOF'));\n      } else {\n        state.reading = false;\n        if (state.decoder && !encoding) {\n          chunk = state.decoder.write(chunk);\n          if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);\n        } else {\n          addChunk(stream, state, chunk, false);\n        }\n      }\n    } else if (!addToFront) {\n      state.reading = false;\n    }\n  }\n\n  return needMoreData(state);\n}\n\nfunction addChunk(stream, state, chunk, addToFront) {\n  if (state.flowing && state.length === 0 && !state.sync) {\n    stream.emit('data', chunk);\n    stream.read(0);\n  } else {\n    // update the buffer info.\n    state.length += state.objectMode ? 1 : chunk.length;\n    if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);\n\n    if (state.needReadable) emitReadable(stream);\n  }\n  maybeReadMore(stream, state);\n}\n\nfunction chunkInvalid(state, chunk) {\n  var er;\n  if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  return er;\n}\n\n// if it's past the high water mark, we can push in some more.\n// Also, if we have no data yet, we can stand some\n// more bytes.  This is to work around cases where hwm=0,\n// such as the repl.  Also, if the push() triggered a\n// readable event, and the user called read(largeNumber) such that\n// needReadable was set, then we ought to push more, so that another\n// 'readable' event will be triggered.\nfunction needMoreData(state) {\n  return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);\n}\n\nReadable.prototype.isPaused = function () {\n  return this._readableState.flowing === false;\n};\n\n// backwards compatibility.\nReadable.prototype.setEncoding = function (enc) {\n  if (!StringDecoder) StringDecoder = require('string_decoder/').StringDecoder;\n  this._readableState.decoder = new StringDecoder(enc);\n  this._readableState.encoding = enc;\n  return this;\n};\n\n// Don't raise the hwm > 8MB\nvar MAX_HWM = 0x800000;\nfunction computeNewHighWaterMark(n) {\n  if (n >= MAX_HWM) {\n    n = MAX_HWM;\n  } else {\n    // Get the next highest power of 2 to prevent increasing hwm excessively in\n    // tiny amounts\n    n--;\n    n |= n >>> 1;\n    n |= n >>> 2;\n    n |= n >>> 4;\n    n |= n >>> 8;\n    n |= n >>> 16;\n    n++;\n  }\n  return n;\n}\n\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction howMuchToRead(n, state) {\n  if (n <= 0 || state.length === 0 && state.ended) return 0;\n  if (state.objectMode) return 1;\n  if (n !== n) {\n    // Only flow one buffer at a time\n    if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;\n  }\n  // If we're asking for more than the current hwm, then raise the hwm.\n  if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);\n  if (n <= state.length) return n;\n  // Don't have enough\n  if (!state.ended) {\n    state.needReadable = true;\n    return 0;\n  }\n  return state.length;\n}\n\n// you can override either this method, or the async _read(n) below.\nReadable.prototype.read = function (n) {\n  debug('read', n);\n  n = parseInt(n, 10);\n  var state = this._readableState;\n  var nOrig = n;\n\n  if (n !== 0) state.emittedReadable = false;\n\n  // if we're doing read(0) to trigger a readable event, but we\n  // already have a bunch of data in the buffer, then just trigger\n  // the 'readable' event and move on.\n  if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {\n    debug('read: emitReadable', state.length, state.ended);\n    if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);\n    return null;\n  }\n\n  n = howMuchToRead(n, state);\n\n  // if we've ended, and we're now clear, then finish it up.\n  if (n === 0 && state.ended) {\n    if (state.length === 0) endReadable(this);\n    return null;\n  }\n\n  // All the actual chunk generation logic needs to be\n  // *below* the call to _read.  The reason is that in certain\n  // synthetic stream cases, such as passthrough streams, _read\n  // may be a completely synchronous operation which may change\n  // the state of the read buffer, providing enough data when\n  // before there was *not* enough.\n  //\n  // So, the steps are:\n  // 1. Figure out what the state of things will be after we do\n  // a read from the buffer.\n  //\n  // 2. If that resulting state will trigger a _read, then call _read.\n  // Note that this may be asynchronous, or synchronous.  Yes, it is\n  // deeply ugly to write APIs this way, but that still doesn't mean\n  // that the Readable class should behave improperly, as streams are\n  // designed to be sync/async agnostic.\n  // Take note if the _read call is sync or async (ie, if the read call\n  // has returned yet), so that we know whether or not it's safe to emit\n  // 'readable' etc.\n  //\n  // 3. Actually pull the requested chunks out of the buffer and return.\n\n  // if we need a readable event, then we need to do some reading.\n  var doRead = state.needReadable;\n  debug('need readable', doRead);\n\n  // if we currently have less than the highWaterMark, then also read some\n  if (state.length === 0 || state.length - n < state.highWaterMark) {\n    doRead = true;\n    debug('length less than watermark', doRead);\n  }\n\n  // however, if we've ended, then there's no point, and if we're already\n  // reading, then it's unnecessary.\n  if (state.ended || state.reading) {\n    doRead = false;\n    debug('reading or ended', doRead);\n  } else if (doRead) {\n    debug('do read');\n    state.reading = true;\n    state.sync = true;\n    // if the length is currently zero, then we *need* a readable event.\n    if (state.length === 0) state.needReadable = true;\n    // call internal read method\n    this._read(state.highWaterMark);\n    state.sync = false;\n    // If _read pushed data synchronously, then `reading` will be false,\n    // and we need to re-evaluate how much data we can return to the user.\n    if (!state.reading) n = howMuchToRead(nOrig, state);\n  }\n\n  var ret;\n  if (n > 0) ret = fromList(n, state);else ret = null;\n\n  if (ret === null) {\n    state.needReadable = true;\n    n = 0;\n  } else {\n    state.length -= n;\n  }\n\n  if (state.length === 0) {\n    // If we have nothing in the buffer, then we want to know\n    // as soon as we *do* get something into the buffer.\n    if (!state.ended) state.needReadable = true;\n\n    // If we tried to read() past the EOF, then emit end on the next tick.\n    if (nOrig !== n && state.ended) endReadable(this);\n  }\n\n  if (ret !== null) this.emit('data', ret);\n\n  return ret;\n};\n\nfunction onEofChunk(stream, state) {\n  if (state.ended) return;\n  if (state.decoder) {\n    var chunk = state.decoder.end();\n    if (chunk && chunk.length) {\n      state.buffer.push(chunk);\n      state.length += state.objectMode ? 1 : chunk.length;\n    }\n  }\n  state.ended = true;\n\n  // emit 'readable' now to make sure it gets picked up.\n  emitReadable(stream);\n}\n\n// Don't emit readable right away in sync mode, because this can trigger\n// another read() call => stack overflow.  This way, it might trigger\n// a nextTick recursion warning, but that's not so bad.\nfunction emitReadable(stream) {\n  var state = stream._readableState;\n  state.needReadable = false;\n  if (!state.emittedReadable) {\n    debug('emitReadable', state.flowing);\n    state.emittedReadable = true;\n    if (state.sync) processNextTick(emitReadable_, stream);else emitReadable_(stream);\n  }\n}\n\nfunction emitReadable_(stream) {\n  debug('emit readable');\n  stream.emit('readable');\n  flow(stream);\n}\n\n// at this point, the user has presumably seen the 'readable' event,\n// and called read() to consume some data.  that may have triggered\n// in turn another _read(n) call, in which case reading = true if\n// it's in progress.\n// However, if we're not ended, or reading, and the length < hwm,\n// then go ahead and try to read some more preemptively.\nfunction maybeReadMore(stream, state) {\n  if (!state.readingMore) {\n    state.readingMore = true;\n    processNextTick(maybeReadMore_, stream, state);\n  }\n}\n\nfunction maybeReadMore_(stream, state) {\n  var len = state.length;\n  while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {\n    debug('maybeReadMore read 0');\n    stream.read(0);\n    if (len === state.length)\n      // didn't get any data, stop spinning.\n      break;else len = state.length;\n  }\n  state.readingMore = false;\n}\n\n// abstract method.  to be overridden in specific implementation classes.\n// call cb(er, data) where data is <= n in length.\n// for virtual (non-string, non-buffer) streams, \"length\" is somewhat\n// arbitrary, and perhaps not very meaningful.\nReadable.prototype._read = function (n) {\n  this.emit('error', new Error('_read() is not implemented'));\n};\n\nReadable.prototype.pipe = function (dest, pipeOpts) {\n  var src = this;\n  var state = this._readableState;\n\n  switch (state.pipesCount) {\n    case 0:\n      state.pipes = dest;\n      break;\n    case 1:\n      state.pipes = [state.pipes, dest];\n      break;\n    default:\n      state.pipes.push(dest);\n      break;\n  }\n  state.pipesCount += 1;\n  debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);\n\n  var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;\n\n  var endFn = doEnd ? onend : unpipe;\n  if (state.endEmitted) processNextTick(endFn);else src.once('end', endFn);\n\n  dest.on('unpipe', onunpipe);\n  function onunpipe(readable, unpipeInfo) {\n    debug('onunpipe');\n    if (readable === src) {\n      if (unpipeInfo && unpipeInfo.hasUnpiped === false) {\n        unpipeInfo.hasUnpiped = true;\n        cleanup();\n      }\n    }\n  }\n\n  function onend() {\n    debug('onend');\n    dest.end();\n  }\n\n  // when the dest drains, it reduces the awaitDrain counter\n  // on the source.  This would be more elegant with a .once()\n  // handler in flow(), but adding and removing repeatedly is\n  // too slow.\n  var ondrain = pipeOnDrain(src);\n  dest.on('drain', ondrain);\n\n  var cleanedUp = false;\n  function cleanup() {\n    debug('cleanup');\n    // cleanup event handlers once the pipe is broken\n    dest.removeListener('close', onclose);\n    dest.removeListener('finish', onfinish);\n    dest.removeListener('drain', ondrain);\n    dest.removeListener('error', onerror);\n    dest.removeListener('unpipe', onunpipe);\n    src.removeListener('end', onend);\n    src.removeListener('end', unpipe);\n    src.removeListener('data', ondata);\n\n    cleanedUp = true;\n\n    // if the reader is waiting for a drain event from this\n    // specific writer, then it would cause it to never start\n    // flowing again.\n    // So, if this is awaiting a drain, then we just call it now.\n    // If we don't know, then assume that we are waiting for one.\n    if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();\n  }\n\n  // If the user pushes more data while we're writing to dest then we'll end up\n  // in ondata again. However, we only want to increase awaitDrain once because\n  // dest will only emit one 'drain' event for the multiple writes.\n  // => Introduce a guard on increasing awaitDrain.\n  var increasedAwaitDrain = false;\n  src.on('data', ondata);\n  function ondata(chunk) {\n    debug('ondata');\n    increasedAwaitDrain = false;\n    var ret = dest.write(chunk);\n    if (false === ret && !increasedAwaitDrain) {\n      // If the user unpiped during `dest.write()`, it is possible\n      // to get stuck in a permanently paused state if that write\n      // also returned false.\n      // => Check whether `dest` is still a piping destination.\n      if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {\n        debug('false write response, pause', src._readableState.awaitDrain);\n        src._readableState.awaitDrain++;\n        increasedAwaitDrain = true;\n      }\n      src.pause();\n    }\n  }\n\n  // if the dest has an error, then stop piping into it.\n  // however, don't suppress the throwing behavior for this.\n  function onerror(er) {\n    debug('onerror', er);\n    unpipe();\n    dest.removeListener('error', onerror);\n    if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);\n  }\n\n  // Make sure our error handler is attached before userland ones.\n  prependListener(dest, 'error', onerror);\n\n  // Both close and finish should trigger unpipe, but only once.\n  function onclose() {\n    dest.removeListener('finish', onfinish);\n    unpipe();\n  }\n  dest.once('close', onclose);\n  function onfinish() {\n    debug('onfinish');\n    dest.removeListener('close', onclose);\n    unpipe();\n  }\n  dest.once('finish', onfinish);\n\n  function unpipe() {\n    debug('unpipe');\n    src.unpipe(dest);\n  }\n\n  // tell the dest that it's being piped to\n  dest.emit('pipe', src);\n\n  // start the flow if it hasn't been started already.\n  if (!state.flowing) {\n    debug('pipe resume');\n    src.resume();\n  }\n\n  return dest;\n};\n\nfunction pipeOnDrain(src) {\n  return function () {\n    var state = src._readableState;\n    debug('pipeOnDrain', state.awaitDrain);\n    if (state.awaitDrain) state.awaitDrain--;\n    if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {\n      state.flowing = true;\n      flow(src);\n    }\n  };\n}\n\nReadable.prototype.unpipe = function (dest) {\n  var state = this._readableState;\n  var unpipeInfo = { hasUnpiped: false };\n\n  // if we're not piping anywhere, then do nothing.\n  if (state.pipesCount === 0) return this;\n\n  // just one destination.  most common case.\n  if (state.pipesCount === 1) {\n    // passed in one, but it's not the right one.\n    if (dest && dest !== state.pipes) return this;\n\n    if (!dest) dest = state.pipes;\n\n    // got a match.\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n    if (dest) dest.emit('unpipe', this, unpipeInfo);\n    return this;\n  }\n\n  // slow case. multiple pipe destinations.\n\n  if (!dest) {\n    // remove all.\n    var dests = state.pipes;\n    var len = state.pipesCount;\n    state.pipes = null;\n    state.pipesCount = 0;\n    state.flowing = false;\n\n    for (var i = 0; i < len; i++) {\n      dests[i].emit('unpipe', this, unpipeInfo);\n    }return this;\n  }\n\n  // try to find the right one.\n  var index = indexOf(state.pipes, dest);\n  if (index === -1) return this;\n\n  state.pipes.splice(index, 1);\n  state.pipesCount -= 1;\n  if (state.pipesCount === 1) state.pipes = state.pipes[0];\n\n  dest.emit('unpipe', this, unpipeInfo);\n\n  return this;\n};\n\n// set up data events if they are asked for\n// Ensure readable listeners eventually get something\nReadable.prototype.on = function (ev, fn) {\n  var res = Stream.prototype.on.call(this, ev, fn);\n\n  if (ev === 'data') {\n    // Start flowing on next tick if stream isn't explicitly paused\n    if (this._readableState.flowing !== false) this.resume();\n  } else if (ev === 'readable') {\n    var state = this._readableState;\n    if (!state.endEmitted && !state.readableListening) {\n      state.readableListening = state.needReadable = true;\n      state.emittedReadable = false;\n      if (!state.reading) {\n        processNextTick(nReadingNextTick, this);\n      } else if (state.length) {\n        emitReadable(this);\n      }\n    }\n  }\n\n  return res;\n};\nReadable.prototype.addListener = Readable.prototype.on;\n\nfunction nReadingNextTick(self) {\n  debug('readable nexttick read 0');\n  self.read(0);\n}\n\n// pause() and resume() are remnants of the legacy readable stream API\n// If the user uses them, then switch into old mode.\nReadable.prototype.resume = function () {\n  var state = this._readableState;\n  if (!state.flowing) {\n    debug('resume');\n    state.flowing = true;\n    resume(this, state);\n  }\n  return this;\n};\n\nfunction resume(stream, state) {\n  if (!state.resumeScheduled) {\n    state.resumeScheduled = true;\n    processNextTick(resume_, stream, state);\n  }\n}\n\nfunction resume_(stream, state) {\n  if (!state.reading) {\n    debug('resume read 0');\n    stream.read(0);\n  }\n\n  state.resumeScheduled = false;\n  state.awaitDrain = 0;\n  stream.emit('resume');\n  flow(stream);\n  if (state.flowing && !state.reading) stream.read(0);\n}\n\nReadable.prototype.pause = function () {\n  debug('call pause flowing=%j', this._readableState.flowing);\n  if (false !== this._readableState.flowing) {\n    debug('pause');\n    this._readableState.flowing = false;\n    this.emit('pause');\n  }\n  return this;\n};\n\nfunction flow(stream) {\n  var state = stream._readableState;\n  debug('flow', state.flowing);\n  while (state.flowing && stream.read() !== null) {}\n}\n\n// wrap an old-style stream as the async data source.\n// This is *not* part of the readable stream interface.\n// It is an ugly unfortunate mess of history.\nReadable.prototype.wrap = function (stream) {\n  var state = this._readableState;\n  var paused = false;\n\n  var self = this;\n  stream.on('end', function () {\n    debug('wrapped end');\n    if (state.decoder && !state.ended) {\n      var chunk = state.decoder.end();\n      if (chunk && chunk.length) self.push(chunk);\n    }\n\n    self.push(null);\n  });\n\n  stream.on('data', function (chunk) {\n    debug('wrapped data');\n    if (state.decoder) chunk = state.decoder.write(chunk);\n\n    // don't skip over falsy values in objectMode\n    if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;\n\n    var ret = self.push(chunk);\n    if (!ret) {\n      paused = true;\n      stream.pause();\n    }\n  });\n\n  // proxy all the other methods.\n  // important when wrapping filters and duplexes.\n  for (var i in stream) {\n    if (this[i] === undefined && typeof stream[i] === 'function') {\n      this[i] = function (method) {\n        return function () {\n          return stream[method].apply(stream, arguments);\n        };\n      }(i);\n    }\n  }\n\n  // proxy certain important events.\n  for (var n = 0; n < kProxyEvents.length; n++) {\n    stream.on(kProxyEvents[n], self.emit.bind(self, kProxyEvents[n]));\n  }\n\n  // when we try to consume some more bytes, simply unpause the\n  // underlying stream.\n  self._read = function (n) {\n    debug('wrapped _read', n);\n    if (paused) {\n      paused = false;\n      stream.resume();\n    }\n  };\n\n  return self;\n};\n\n// exposed for testing purposes only.\nReadable._fromList = fromList;\n\n// Pluck off n bytes from an array of buffers.\n// Length is the combined lengths of all the buffers in the list.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromList(n, state) {\n  // nothing buffered\n  if (state.length === 0) return null;\n\n  var ret;\n  if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {\n    // read it all, truncate the list\n    if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);\n    state.buffer.clear();\n  } else {\n    // read part of list\n    ret = fromListPartial(n, state.buffer, state.decoder);\n  }\n\n  return ret;\n}\n\n// Extracts only enough buffered data to satisfy the amount requested.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction fromListPartial(n, list, hasStrings) {\n  var ret;\n  if (n < list.head.data.length) {\n    // slice is the same for buffers and strings\n    ret = list.head.data.slice(0, n);\n    list.head.data = list.head.data.slice(n);\n  } else if (n === list.head.data.length) {\n    // first chunk is a perfect match\n    ret = list.shift();\n  } else {\n    // result spans more than one buffer\n    ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);\n  }\n  return ret;\n}\n\n// Copies a specified amount of characters from the list of buffered data\n// chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBufferString(n, list) {\n  var p = list.head;\n  var c = 1;\n  var ret = p.data;\n  n -= ret.length;\n  while (p = p.next) {\n    var str = p.data;\n    var nb = n > str.length ? str.length : n;\n    if (nb === str.length) ret += str;else ret += str.slice(0, n);\n    n -= nb;\n    if (n === 0) {\n      if (nb === str.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = str.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\n// Copies a specified amount of bytes from the list of buffered data chunks.\n// This function is designed to be inlinable, so please take care when making\n// changes to the function body.\nfunction copyFromBuffer(n, list) {\n  var ret = Buffer.allocUnsafe(n);\n  var p = list.head;\n  var c = 1;\n  p.data.copy(ret);\n  n -= p.data.length;\n  while (p = p.next) {\n    var buf = p.data;\n    var nb = n > buf.length ? buf.length : n;\n    buf.copy(ret, ret.length - n, 0, nb);\n    n -= nb;\n    if (n === 0) {\n      if (nb === buf.length) {\n        ++c;\n        if (p.next) list.head = p.next;else list.head = list.tail = null;\n      } else {\n        list.head = p;\n        p.data = buf.slice(nb);\n      }\n      break;\n    }\n    ++c;\n  }\n  list.length -= c;\n  return ret;\n}\n\nfunction endReadable(stream) {\n  var state = stream._readableState;\n\n  // If we get here before consuming all the bytes, then that is a\n  // bug in node.  Should never happen.\n  if (state.length > 0) throw new Error('\"endReadable()\" called on non-empty stream');\n\n  if (!state.endEmitted) {\n    state.ended = true;\n    processNextTick(endReadableNT, state, stream);\n  }\n}\n\nfunction endReadableNT(state, stream) {\n  // Check that we didn't get one last unshift.\n  if (!state.endEmitted && state.length === 0) {\n    state.endEmitted = true;\n    stream.readable = false;\n    stream.emit('end');\n  }\n}\n\nfunction forEach(xs, f) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    f(xs[i], i);\n  }\n}\n\nfunction indexOf(xs, x) {\n  for (var i = 0, l = xs.length; i < l; i++) {\n    if (xs[i] === x) return i;\n  }\n  return -1;\n}\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/BufferList\":63,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"events\":47,\"inherits\":50,\"isarray\":52,\"process-nextick-args\":55,\"safe-buffer\":70,\"string_decoder/\":72,\"util\":38}],61:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// a transform stream is a readable/writable stream where you do\n// something with the data.  Sometimes it's called a \"filter\",\n// but that's not a great name for it, since that implies a thing where\n// some bits pass through, and others are simply ignored.  (That would\n// be a valid example of a transform, of course.)\n//\n// While the output is causally related to the input, it's not a\n// necessarily symmetric or synchronous transformation.  For example,\n// a zlib stream might take multiple plain-text writes(), and then\n// emit a single compressed chunk some time in the future.\n//\n// Here's how this works:\n//\n// The Transform stream has all the aspects of the readable and writable\n// stream classes.  When you write(chunk), that calls _write(chunk,cb)\n// internally, and returns false if there's a lot of pending writes\n// buffered up.  When you call read(), that calls _read(n) until\n// there's enough pending readable data buffered up.\n//\n// In a transform stream, the written data is placed in a buffer.  When\n// _read(n) is called, it transforms the queued up data, calling the\n// buffered _write cb's as it consumes chunks.  If consuming a single\n// written chunk would result in multiple output chunks, then the first\n// outputted bit calls the readcb, and subsequent chunks just go into\n// the read buffer, and will cause it to emit 'readable' if necessary.\n//\n// This way, back-pressure is actually determined by the reading side,\n// since _read has to be called to start processing a new chunk.  However,\n// a pathological inflate type of transform can cause excessive buffering\n// here.  For example, imagine a stream where every byte of input is\n// interpreted as an integer from 0-255, and then results in that many\n// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in\n// 1kb of data being output.  In this case, you could write a very small\n// amount of input, and end up with a very large amount of output.  In\n// such a pathological inflating mechanism, there'd be no way to tell\n// the system to stop doing the transform.  A single 4MB write could\n// cause the system to run out of memory.\n//\n// However, even in such a pathological case, only a single written chunk\n// would be consumed, and then the rest would wait (un-transformed) until\n// the results of the previous transformed chunk were consumed.\n\n'use strict';\n\nmodule.exports = Transform;\n\nvar Duplex = require('./_stream_duplex');\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\nutil.inherits(Transform, Duplex);\n\nfunction TransformState(stream) {\n  this.afterTransform = function (er, data) {\n    return afterTransform(stream, er, data);\n  };\n\n  this.needTransform = false;\n  this.transforming = false;\n  this.writecb = null;\n  this.writechunk = null;\n  this.writeencoding = null;\n}\n\nfunction afterTransform(stream, er, data) {\n  var ts = stream._transformState;\n  ts.transforming = false;\n\n  var cb = ts.writecb;\n\n  if (!cb) {\n    return stream.emit('error', new Error('write callback called multiple times'));\n  }\n\n  ts.writechunk = null;\n  ts.writecb = null;\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  cb(er);\n\n  var rs = stream._readableState;\n  rs.reading = false;\n  if (rs.needReadable || rs.length < rs.highWaterMark) {\n    stream._read(rs.highWaterMark);\n  }\n}\n\nfunction Transform(options) {\n  if (!(this instanceof Transform)) return new Transform(options);\n\n  Duplex.call(this, options);\n\n  this._transformState = new TransformState(this);\n\n  var stream = this;\n\n  // start out asking for a readable event once data is transformed.\n  this._readableState.needReadable = true;\n\n  // we have implemented the _read method, and done the other things\n  // that Readable wants before the first _read call, so unset the\n  // sync guard flag.\n  this._readableState.sync = false;\n\n  if (options) {\n    if (typeof options.transform === 'function') this._transform = options.transform;\n\n    if (typeof options.flush === 'function') this._flush = options.flush;\n  }\n\n  // When the writable side finishes, then flush out anything remaining.\n  this.once('prefinish', function () {\n    if (typeof this._flush === 'function') this._flush(function (er, data) {\n      done(stream, er, data);\n    });else done(stream);\n  });\n}\n\nTransform.prototype.push = function (chunk, encoding) {\n  this._transformState.needTransform = false;\n  return Duplex.prototype.push.call(this, chunk, encoding);\n};\n\n// This is the part where you do stuff!\n// override this function in implementation classes.\n// 'chunk' is an input chunk.\n//\n// Call `push(newChunk)` to pass along transformed output\n// to the readable side.  You may call 'push' zero or more times.\n//\n// Call `cb(err)` when you are done with this chunk.  If you pass\n// an error, then that'll put the hurt on the whole operation.  If you\n// never call cb(), then you'll never get another chunk.\nTransform.prototype._transform = function (chunk, encoding, cb) {\n  throw new Error('_transform() is not implemented');\n};\n\nTransform.prototype._write = function (chunk, encoding, cb) {\n  var ts = this._transformState;\n  ts.writecb = cb;\n  ts.writechunk = chunk;\n  ts.writeencoding = encoding;\n  if (!ts.transforming) {\n    var rs = this._readableState;\n    if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);\n  }\n};\n\n// Doesn't matter what the args are here.\n// _transform does all the work.\n// That we got here means that the readable side wants more data.\nTransform.prototype._read = function (n) {\n  var ts = this._transformState;\n\n  if (ts.writechunk !== null && ts.writecb && !ts.transforming) {\n    ts.transforming = true;\n    this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);\n  } else {\n    // mark that we need a transform, so that any data that comes in\n    // will get processed, now that we've asked for it.\n    ts.needTransform = true;\n  }\n};\n\nTransform.prototype._destroy = function (err, cb) {\n  var _this = this;\n\n  Duplex.prototype._destroy.call(this, err, function (err2) {\n    cb(err2);\n    _this.emit('close');\n  });\n};\n\nfunction done(stream, er, data) {\n  if (er) return stream.emit('error', er);\n\n  if (data !== null && data !== undefined) stream.push(data);\n\n  // if there's nothing in the write buffer, then that means\n  // that nothing more will ever be provided\n  var ws = stream._writableState;\n  var ts = stream._transformState;\n\n  if (ws.length) throw new Error('Calling transform done when ws.length != 0');\n\n  if (ts.transforming) throw new Error('Calling transform done when still transforming');\n\n  return stream.push(null);\n}\n},{\"./_stream_duplex\":58,\"core-util-is\":42,\"inherits\":50}],62:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\n// A bit simpler than readable streams.\n// Implement an async ._write(chunk, encoding, cb), and it'll handle all\n// the drain event emission and buffering.\n\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\nmodule.exports = Writable;\n\n/* <replacement> */\nfunction WriteReq(chunk, encoding, cb) {\n  this.chunk = chunk;\n  this.encoding = encoding;\n  this.callback = cb;\n  this.next = null;\n}\n\n// It seems a linked list but it is not\n// there will be only 2 of these for each stream\nfunction CorkedRequest(state) {\n  var _this = this;\n\n  this.next = null;\n  this.entry = null;\n  this.finish = function () {\n    onCorkedFinish(_this, state);\n  };\n}\n/* </replacement> */\n\n/*<replacement>*/\nvar asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : processNextTick;\n/*</replacement>*/\n\n/*<replacement>*/\nvar Duplex;\n/*</replacement>*/\n\nWritable.WritableState = WritableState;\n\n/*<replacement>*/\nvar util = require('core-util-is');\nutil.inherits = require('inherits');\n/*</replacement>*/\n\n/*<replacement>*/\nvar internalUtil = {\n  deprecate: require('util-deprecate')\n};\n/*</replacement>*/\n\n/*<replacement>*/\nvar Stream = require('./internal/streams/stream');\n/*</replacement>*/\n\n/*<replacement>*/\nvar Buffer = require('safe-buffer').Buffer;\nvar OurUint8Array = global.Uint8Array || function () {};\nfunction _uint8ArrayToBuffer(chunk) {\n  return Buffer.from(chunk);\n}\nfunction _isUint8Array(obj) {\n  return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;\n}\n/*</replacement>*/\n\nvar destroyImpl = require('./internal/streams/destroy');\n\nutil.inherits(Writable, Stream);\n\nfunction nop() {}\n\nfunction WritableState(options, stream) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  options = options || {};\n\n  // object stream flag to indicate whether or not this stream\n  // contains buffers or objects.\n  this.objectMode = !!options.objectMode;\n\n  if (stream instanceof Duplex) this.objectMode = this.objectMode || !!options.writableObjectMode;\n\n  // the point at which write() starts returning false\n  // Note: 0 is a valid value, means that we always return false if\n  // the entire buffer is not flushed immediately on write()\n  var hwm = options.highWaterMark;\n  var defaultHwm = this.objectMode ? 16 : 16 * 1024;\n  this.highWaterMark = hwm || hwm === 0 ? hwm : defaultHwm;\n\n  // cast to ints.\n  this.highWaterMark = Math.floor(this.highWaterMark);\n\n  // if _final has been called\n  this.finalCalled = false;\n\n  // drain event flag.\n  this.needDrain = false;\n  // at the start of calling end()\n  this.ending = false;\n  // when end() has been called, and returned\n  this.ended = false;\n  // when 'finish' is emitted\n  this.finished = false;\n\n  // has it been destroyed\n  this.destroyed = false;\n\n  // should we decode strings into buffers before passing to _write?\n  // this is here so that some node-core streams can optimize string\n  // handling at a lower level.\n  var noDecode = options.decodeStrings === false;\n  this.decodeStrings = !noDecode;\n\n  // Crypto is kind of old and crusty.  Historically, its default string\n  // encoding is 'binary' so we have to make this configurable.\n  // Everything else in the universe uses 'utf8', though.\n  this.defaultEncoding = options.defaultEncoding || 'utf8';\n\n  // not an actual buffer we keep track of, but a measurement\n  // of how much we're waiting to get pushed to some underlying\n  // socket or file.\n  this.length = 0;\n\n  // a flag to see when we're in the middle of a write.\n  this.writing = false;\n\n  // when true all writes will be buffered until .uncork() call\n  this.corked = 0;\n\n  // a flag to be able to tell if the onwrite cb is called immediately,\n  // or on a later tick.  We set this to true at first, because any\n  // actions that shouldn't happen until \"later\" should generally also\n  // not happen before the first write call.\n  this.sync = true;\n\n  // a flag to know if we're processing previously buffered items, which\n  // may call the _write() callback in the same tick, so that we don't\n  // end up in an overlapped onwrite situation.\n  this.bufferProcessing = false;\n\n  // the callback that's passed to _write(chunk,cb)\n  this.onwrite = function (er) {\n    onwrite(stream, er);\n  };\n\n  // the callback that the user supplies to write(chunk,encoding,cb)\n  this.writecb = null;\n\n  // the amount that is being written when _write is called.\n  this.writelen = 0;\n\n  this.bufferedRequest = null;\n  this.lastBufferedRequest = null;\n\n  // number of pending user-supplied write callbacks\n  // this must be 0 before 'finish' can be emitted\n  this.pendingcb = 0;\n\n  // emit prefinish if the only thing we're waiting for is _write cbs\n  // This is relevant for synchronous Transform streams\n  this.prefinished = false;\n\n  // True if the error was already emitted and should not be thrown again\n  this.errorEmitted = false;\n\n  // count buffered requests\n  this.bufferedRequestCount = 0;\n\n  // allocate the first CorkedRequest, there is always\n  // one allocated and free to use, and we maintain at most two\n  this.corkedRequestsFree = new CorkedRequest(this);\n}\n\nWritableState.prototype.getBuffer = function getBuffer() {\n  var current = this.bufferedRequest;\n  var out = [];\n  while (current) {\n    out.push(current);\n    current = current.next;\n  }\n  return out;\n};\n\n(function () {\n  try {\n    Object.defineProperty(WritableState.prototype, 'buffer', {\n      get: internalUtil.deprecate(function () {\n        return this.getBuffer();\n      }, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')\n    });\n  } catch (_) {}\n})();\n\n// Test _writableState for inheritance to account for Duplex streams,\n// whose prototype chain only points to Readable.\nvar realHasInstance;\nif (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {\n  realHasInstance = Function.prototype[Symbol.hasInstance];\n  Object.defineProperty(Writable, Symbol.hasInstance, {\n    value: function (object) {\n      if (realHasInstance.call(this, object)) return true;\n\n      return object && object._writableState instanceof WritableState;\n    }\n  });\n} else {\n  realHasInstance = function (object) {\n    return object instanceof this;\n  };\n}\n\nfunction Writable(options) {\n  Duplex = Duplex || require('./_stream_duplex');\n\n  // Writable ctor is applied to Duplexes, too.\n  // `realHasInstance` is necessary because using plain `instanceof`\n  // would return false, as no `_writableState` property is attached.\n\n  // Trying to use the custom `instanceof` for Writable here will also break the\n  // Node.js LazyTransform implementation, which has a non-trivial getter for\n  // `_writableState` that would lead to infinite recursion.\n  if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {\n    return new Writable(options);\n  }\n\n  this._writableState = new WritableState(options, this);\n\n  // legacy.\n  this.writable = true;\n\n  if (options) {\n    if (typeof options.write === 'function') this._write = options.write;\n\n    if (typeof options.writev === 'function') this._writev = options.writev;\n\n    if (typeof options.destroy === 'function') this._destroy = options.destroy;\n\n    if (typeof options.final === 'function') this._final = options.final;\n  }\n\n  Stream.call(this);\n}\n\n// Otherwise people can pipe Writable streams, which is just wrong.\nWritable.prototype.pipe = function () {\n  this.emit('error', new Error('Cannot pipe, not readable'));\n};\n\nfunction writeAfterEnd(stream, cb) {\n  var er = new Error('write after end');\n  // TODO: defer error events consistently everywhere, not just the cb\n  stream.emit('error', er);\n  processNextTick(cb, er);\n}\n\n// Checks that a user-supplied chunk is valid, especially for the particular\n// mode the stream is in. Currently this means that `null` is never accepted\n// and undefined/non-string values are only allowed in object mode.\nfunction validChunk(stream, state, chunk, cb) {\n  var valid = true;\n  var er = false;\n\n  if (chunk === null) {\n    er = new TypeError('May not write null values to stream');\n  } else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {\n    er = new TypeError('Invalid non-string/buffer chunk');\n  }\n  if (er) {\n    stream.emit('error', er);\n    processNextTick(cb, er);\n    valid = false;\n  }\n  return valid;\n}\n\nWritable.prototype.write = function (chunk, encoding, cb) {\n  var state = this._writableState;\n  var ret = false;\n  var isBuf = _isUint8Array(chunk) && !state.objectMode;\n\n  if (isBuf && !Buffer.isBuffer(chunk)) {\n    chunk = _uint8ArrayToBuffer(chunk);\n  }\n\n  if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;\n\n  if (typeof cb !== 'function') cb = nop;\n\n  if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {\n    state.pendingcb++;\n    ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);\n  }\n\n  return ret;\n};\n\nWritable.prototype.cork = function () {\n  var state = this._writableState;\n\n  state.corked++;\n};\n\nWritable.prototype.uncork = function () {\n  var state = this._writableState;\n\n  if (state.corked) {\n    state.corked--;\n\n    if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);\n  }\n};\n\nWritable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {\n  // node::ParseEncoding() requires lower case.\n  if (typeof encoding === 'string') encoding = encoding.toLowerCase();\n  if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);\n  this._writableState.defaultEncoding = encoding;\n  return this;\n};\n\nfunction decodeChunk(state, chunk, encoding) {\n  if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {\n    chunk = Buffer.from(chunk, encoding);\n  }\n  return chunk;\n}\n\n// if we're already writing something, then just put this\n// in the queue, and wait our turn.  Otherwise, call _write\n// If we return false, then we need a drain event, so set that flag.\nfunction writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {\n  if (!isBuf) {\n    var newChunk = decodeChunk(state, chunk, encoding);\n    if (chunk !== newChunk) {\n      isBuf = true;\n      encoding = 'buffer';\n      chunk = newChunk;\n    }\n  }\n  var len = state.objectMode ? 1 : chunk.length;\n\n  state.length += len;\n\n  var ret = state.length < state.highWaterMark;\n  // we must ensure that previous needDrain will not be reset to false.\n  if (!ret) state.needDrain = true;\n\n  if (state.writing || state.corked) {\n    var last = state.lastBufferedRequest;\n    state.lastBufferedRequest = {\n      chunk: chunk,\n      encoding: encoding,\n      isBuf: isBuf,\n      callback: cb,\n      next: null\n    };\n    if (last) {\n      last.next = state.lastBufferedRequest;\n    } else {\n      state.bufferedRequest = state.lastBufferedRequest;\n    }\n    state.bufferedRequestCount += 1;\n  } else {\n    doWrite(stream, state, false, len, chunk, encoding, cb);\n  }\n\n  return ret;\n}\n\nfunction doWrite(stream, state, writev, len, chunk, encoding, cb) {\n  state.writelen = len;\n  state.writecb = cb;\n  state.writing = true;\n  state.sync = true;\n  if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);\n  state.sync = false;\n}\n\nfunction onwriteError(stream, state, sync, er, cb) {\n  --state.pendingcb;\n\n  if (sync) {\n    // defer the callback if we are being called synchronously\n    // to avoid piling up things on the stack\n    processNextTick(cb, er);\n    // this can emit finish, and it will always happen\n    // after error\n    processNextTick(finishMaybe, stream, state);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n  } else {\n    // the caller expect this to happen before if\n    // it is async\n    cb(er);\n    stream._writableState.errorEmitted = true;\n    stream.emit('error', er);\n    // this can emit finish, but finish must\n    // always follow error\n    finishMaybe(stream, state);\n  }\n}\n\nfunction onwriteStateUpdate(state) {\n  state.writing = false;\n  state.writecb = null;\n  state.length -= state.writelen;\n  state.writelen = 0;\n}\n\nfunction onwrite(stream, er) {\n  var state = stream._writableState;\n  var sync = state.sync;\n  var cb = state.writecb;\n\n  onwriteStateUpdate(state);\n\n  if (er) onwriteError(stream, state, sync, er, cb);else {\n    // Check if we're actually ready to finish, but don't emit yet\n    var finished = needFinish(state);\n\n    if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {\n      clearBuffer(stream, state);\n    }\n\n    if (sync) {\n      /*<replacement>*/\n      asyncWrite(afterWrite, stream, state, finished, cb);\n      /*</replacement>*/\n    } else {\n      afterWrite(stream, state, finished, cb);\n    }\n  }\n}\n\nfunction afterWrite(stream, state, finished, cb) {\n  if (!finished) onwriteDrain(stream, state);\n  state.pendingcb--;\n  cb();\n  finishMaybe(stream, state);\n}\n\n// Must force callback to be called on nextTick, so that we don't\n// emit 'drain' before the write() consumer gets the 'false' return\n// value, and has a chance to attach a 'drain' listener.\nfunction onwriteDrain(stream, state) {\n  if (state.length === 0 && state.needDrain) {\n    state.needDrain = false;\n    stream.emit('drain');\n  }\n}\n\n// if there's something in the buffer waiting, then process it\nfunction clearBuffer(stream, state) {\n  state.bufferProcessing = true;\n  var entry = state.bufferedRequest;\n\n  if (stream._writev && entry && entry.next) {\n    // Fast case, write everything using _writev()\n    var l = state.bufferedRequestCount;\n    var buffer = new Array(l);\n    var holder = state.corkedRequestsFree;\n    holder.entry = entry;\n\n    var count = 0;\n    var allBuffers = true;\n    while (entry) {\n      buffer[count] = entry;\n      if (!entry.isBuf) allBuffers = false;\n      entry = entry.next;\n      count += 1;\n    }\n    buffer.allBuffers = allBuffers;\n\n    doWrite(stream, state, true, state.length, buffer, '', holder.finish);\n\n    // doWrite is almost always async, defer these to save a bit of time\n    // as the hot path ends with doWrite\n    state.pendingcb++;\n    state.lastBufferedRequest = null;\n    if (holder.next) {\n      state.corkedRequestsFree = holder.next;\n      holder.next = null;\n    } else {\n      state.corkedRequestsFree = new CorkedRequest(state);\n    }\n  } else {\n    // Slow case, write chunks one-by-one\n    while (entry) {\n      var chunk = entry.chunk;\n      var encoding = entry.encoding;\n      var cb = entry.callback;\n      var len = state.objectMode ? 1 : chunk.length;\n\n      doWrite(stream, state, false, len, chunk, encoding, cb);\n      entry = entry.next;\n      // if we didn't call the onwrite immediately, then\n      // it means that we need to wait until it does.\n      // also, that means that the chunk and cb are currently\n      // being processed, so move the buffer counter past them.\n      if (state.writing) {\n        break;\n      }\n    }\n\n    if (entry === null) state.lastBufferedRequest = null;\n  }\n\n  state.bufferedRequestCount = 0;\n  state.bufferedRequest = entry;\n  state.bufferProcessing = false;\n}\n\nWritable.prototype._write = function (chunk, encoding, cb) {\n  cb(new Error('_write() is not implemented'));\n};\n\nWritable.prototype._writev = null;\n\nWritable.prototype.end = function (chunk, encoding, cb) {\n  var state = this._writableState;\n\n  if (typeof chunk === 'function') {\n    cb = chunk;\n    chunk = null;\n    encoding = null;\n  } else if (typeof encoding === 'function') {\n    cb = encoding;\n    encoding = null;\n  }\n\n  if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);\n\n  // .end() fully uncorks\n  if (state.corked) {\n    state.corked = 1;\n    this.uncork();\n  }\n\n  // ignore unnecessary end() calls.\n  if (!state.ending && !state.finished) endWritable(this, state, cb);\n};\n\nfunction needFinish(state) {\n  return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;\n}\nfunction callFinal(stream, state) {\n  stream._final(function (err) {\n    state.pendingcb--;\n    if (err) {\n      stream.emit('error', err);\n    }\n    state.prefinished = true;\n    stream.emit('prefinish');\n    finishMaybe(stream, state);\n  });\n}\nfunction prefinish(stream, state) {\n  if (!state.prefinished && !state.finalCalled) {\n    if (typeof stream._final === 'function') {\n      state.pendingcb++;\n      state.finalCalled = true;\n      processNextTick(callFinal, stream, state);\n    } else {\n      state.prefinished = true;\n      stream.emit('prefinish');\n    }\n  }\n}\n\nfunction finishMaybe(stream, state) {\n  var need = needFinish(state);\n  if (need) {\n    prefinish(stream, state);\n    if (state.pendingcb === 0) {\n      state.finished = true;\n      stream.emit('finish');\n    }\n  }\n  return need;\n}\n\nfunction endWritable(stream, state, cb) {\n  state.ending = true;\n  finishMaybe(stream, state);\n  if (cb) {\n    if (state.finished) processNextTick(cb);else stream.once('finish', cb);\n  }\n  state.ended = true;\n  stream.writable = false;\n}\n\nfunction onCorkedFinish(corkReq, state, err) {\n  var entry = corkReq.entry;\n  corkReq.entry = null;\n  while (entry) {\n    var cb = entry.callback;\n    state.pendingcb--;\n    cb(err);\n    entry = entry.next;\n  }\n  if (state.corkedRequestsFree) {\n    state.corkedRequestsFree.next = corkReq;\n  } else {\n    state.corkedRequestsFree = corkReq;\n  }\n}\n\nObject.defineProperty(Writable.prototype, 'destroyed', {\n  get: function () {\n    if (this._writableState === undefined) {\n      return false;\n    }\n    return this._writableState.destroyed;\n  },\n  set: function (value) {\n    // we ignore the value if the stream\n    // has not been initialized yet\n    if (!this._writableState) {\n      return;\n    }\n\n    // backward compatibility, the user is explicitly\n    // managing destroyed\n    this._writableState.destroyed = value;\n  }\n});\n\nWritable.prototype.destroy = destroyImpl.destroy;\nWritable.prototype._undestroy = destroyImpl.undestroy;\nWritable.prototype._destroy = function (err, cb) {\n  this.end();\n  cb(err);\n};\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./_stream_duplex\":58,\"./internal/streams/destroy\":64,\"./internal/streams/stream\":65,\"_process\":56,\"core-util-is\":42,\"inherits\":50,\"process-nextick-args\":55,\"safe-buffer\":70,\"util-deprecate\":73}],63:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nvar Buffer = require('safe-buffer').Buffer;\n/*</replacement>*/\n\nfunction copyBuffer(src, target, offset) {\n  src.copy(target, offset);\n}\n\nmodule.exports = function () {\n  function BufferList() {\n    _classCallCheck(this, BufferList);\n\n    this.head = null;\n    this.tail = null;\n    this.length = 0;\n  }\n\n  BufferList.prototype.push = function push(v) {\n    var entry = { data: v, next: null };\n    if (this.length > 0) this.tail.next = entry;else this.head = entry;\n    this.tail = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.unshift = function unshift(v) {\n    var entry = { data: v, next: this.head };\n    if (this.length === 0) this.tail = entry;\n    this.head = entry;\n    ++this.length;\n  };\n\n  BufferList.prototype.shift = function shift() {\n    if (this.length === 0) return;\n    var ret = this.head.data;\n    if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;\n    --this.length;\n    return ret;\n  };\n\n  BufferList.prototype.clear = function clear() {\n    this.head = this.tail = null;\n    this.length = 0;\n  };\n\n  BufferList.prototype.join = function join(s) {\n    if (this.length === 0) return '';\n    var p = this.head;\n    var ret = '' + p.data;\n    while (p = p.next) {\n      ret += s + p.data;\n    }return ret;\n  };\n\n  BufferList.prototype.concat = function concat(n) {\n    if (this.length === 0) return Buffer.alloc(0);\n    if (this.length === 1) return this.head.data;\n    var ret = Buffer.allocUnsafe(n >>> 0);\n    var p = this.head;\n    var i = 0;\n    while (p) {\n      copyBuffer(p.data, ret, i);\n      i += p.data.length;\n      p = p.next;\n    }\n    return ret;\n  };\n\n  return BufferList;\n}();\n},{\"safe-buffer\":70}],64:[function(require,module,exports){\n'use strict';\n\n/*<replacement>*/\n\nvar processNextTick = require('process-nextick-args');\n/*</replacement>*/\n\n// undocumented cb() API, needed for core, not for public API\nfunction destroy(err, cb) {\n  var _this = this;\n\n  var readableDestroyed = this._readableState && this._readableState.destroyed;\n  var writableDestroyed = this._writableState && this._writableState.destroyed;\n\n  if (readableDestroyed || writableDestroyed) {\n    if (cb) {\n      cb(err);\n    } else if (err && (!this._writableState || !this._writableState.errorEmitted)) {\n      processNextTick(emitErrorNT, this, err);\n    }\n    return;\n  }\n\n  // we set destroyed to true before firing error callbacks in order\n  // to make it re-entrance safe in case destroy() is called within callbacks\n\n  if (this._readableState) {\n    this._readableState.destroyed = true;\n  }\n\n  // if this is a duplex stream mark the writable part as destroyed as well\n  if (this._writableState) {\n    this._writableState.destroyed = true;\n  }\n\n  this._destroy(err || null, function (err) {\n    if (!cb && err) {\n      processNextTick(emitErrorNT, _this, err);\n      if (_this._writableState) {\n        _this._writableState.errorEmitted = true;\n      }\n    } else if (cb) {\n      cb(err);\n    }\n  });\n}\n\nfunction undestroy() {\n  if (this._readableState) {\n    this._readableState.destroyed = false;\n    this._readableState.reading = false;\n    this._readableState.ended = false;\n    this._readableState.endEmitted = false;\n  }\n\n  if (this._writableState) {\n    this._writableState.destroyed = false;\n    this._writableState.ended = false;\n    this._writableState.ending = false;\n    this._writableState.finished = false;\n    this._writableState.errorEmitted = false;\n  }\n}\n\nfunction emitErrorNT(self, err) {\n  self.emit('error', err);\n}\n\nmodule.exports = {\n  destroy: destroy,\n  undestroy: undestroy\n};\n},{\"process-nextick-args\":55}],65:[function(require,module,exports){\nmodule.exports = require('events').EventEmitter;\n\n},{\"events\":47}],66:[function(require,module,exports){\nmodule.exports = require('./readable').PassThrough\n\n},{\"./readable\":67}],67:[function(require,module,exports){\nexports = module.exports = require('./lib/_stream_readable.js');\nexports.Stream = exports;\nexports.Readable = exports;\nexports.Writable = require('./lib/_stream_writable.js');\nexports.Duplex = require('./lib/_stream_duplex.js');\nexports.Transform = require('./lib/_stream_transform.js');\nexports.PassThrough = require('./lib/_stream_passthrough.js');\n\n},{\"./lib/_stream_duplex.js\":58,\"./lib/_stream_passthrough.js\":59,\"./lib/_stream_readable.js\":60,\"./lib/_stream_transform.js\":61,\"./lib/_stream_writable.js\":62}],68:[function(require,module,exports){\nmodule.exports = require('./readable').Transform\n\n},{\"./readable\":67}],69:[function(require,module,exports){\nmodule.exports = require('./lib/_stream_writable.js');\n\n},{\"./lib/_stream_writable.js\":62}],70:[function(require,module,exports){\n/* eslint-disable node/no-deprecated-api */\nvar buffer = require('buffer')\nvar Buffer = buffer.Buffer\n\n// alternative to using Object.keys for old browsers\nfunction copyProps (src, dst) {\n  for (var key in src) {\n    dst[key] = src[key]\n  }\n}\nif (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {\n  module.exports = buffer\n} else {\n  // Copy properties from require('buffer')\n  copyProps(buffer, exports)\n  exports.Buffer = SafeBuffer\n}\n\nfunction SafeBuffer (arg, encodingOrOffset, length) {\n  return Buffer(arg, encodingOrOffset, length)\n}\n\n// Copy static methods from Buffer\ncopyProps(Buffer, SafeBuffer)\n\nSafeBuffer.from = function (arg, encodingOrOffset, length) {\n  if (typeof arg === 'number') {\n    throw new TypeError('Argument must not be a number')\n  }\n  return Buffer(arg, encodingOrOffset, length)\n}\n\nSafeBuffer.alloc = function (size, fill, encoding) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  var buf = Buffer(size)\n  if (fill !== undefined) {\n    if (typeof encoding === 'string') {\n      buf.fill(fill, encoding)\n    } else {\n      buf.fill(fill)\n    }\n  } else {\n    buf.fill(0)\n  }\n  return buf\n}\n\nSafeBuffer.allocUnsafe = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return Buffer(size)\n}\n\nSafeBuffer.allocUnsafeSlow = function (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('Argument must be a number')\n  }\n  return buffer.SlowBuffer(size)\n}\n\n},{\"buffer\":41}],71:[function(require,module,exports){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nmodule.exports = Stream;\n\nvar EE = require('events').EventEmitter;\nvar inherits = require('inherits');\n\ninherits(Stream, EE);\nStream.Readable = require('readable-stream/readable.js');\nStream.Writable = require('readable-stream/writable.js');\nStream.Duplex = require('readable-stream/duplex.js');\nStream.Transform = require('readable-stream/transform.js');\nStream.PassThrough = require('readable-stream/passthrough.js');\n\n// Backwards-compat with node 0.4.x\nStream.Stream = Stream;\n\n\n\n// old-style streams.  Note that the pipe method (the only relevant\n// part of this class) is overridden in the Readable class.\n\nfunction Stream() {\n  EE.call(this);\n}\n\nStream.prototype.pipe = function(dest, options) {\n  var source = this;\n\n  function ondata(chunk) {\n    if (dest.writable) {\n      if (false === dest.write(chunk) && source.pause) {\n        source.pause();\n      }\n    }\n  }\n\n  source.on('data', ondata);\n\n  function ondrain() {\n    if (source.readable && source.resume) {\n      source.resume();\n    }\n  }\n\n  dest.on('drain', ondrain);\n\n  // If the 'end' option is not supplied, dest.end() will be called when\n  // source gets the 'end' or 'close' events.  Only dest.end() once.\n  if (!dest._isStdio && (!options || options.end !== false)) {\n    source.on('end', onend);\n    source.on('close', onclose);\n  }\n\n  var didOnEnd = false;\n  function onend() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    dest.end();\n  }\n\n\n  function onclose() {\n    if (didOnEnd) return;\n    didOnEnd = true;\n\n    if (typeof dest.destroy === 'function') dest.destroy();\n  }\n\n  // don't leave dangling pipes when there are errors.\n  function onerror(er) {\n    cleanup();\n    if (EE.listenerCount(this, 'error') === 0) {\n      throw er; // Unhandled stream error in pipe.\n    }\n  }\n\n  source.on('error', onerror);\n  dest.on('error', onerror);\n\n  // remove all the event listeners that were added.\n  function cleanup() {\n    source.removeListener('data', ondata);\n    dest.removeListener('drain', ondrain);\n\n    source.removeListener('end', onend);\n    source.removeListener('close', onclose);\n\n    source.removeListener('error', onerror);\n    dest.removeListener('error', onerror);\n\n    source.removeListener('end', cleanup);\n    source.removeListener('close', cleanup);\n\n    dest.removeListener('close', cleanup);\n  }\n\n  source.on('end', cleanup);\n  source.on('close', cleanup);\n\n  dest.on('close', cleanup);\n\n  dest.emit('pipe', source);\n\n  // Allow for unix-like usage: A.pipe(B).pipe(C)\n  return dest;\n};\n\n},{\"events\":47,\"inherits\":50,\"readable-stream/duplex.js\":57,\"readable-stream/passthrough.js\":66,\"readable-stream/readable.js\":67,\"readable-stream/transform.js\":68,\"readable-stream/writable.js\":69}],72:[function(require,module,exports){\n'use strict';\n\nvar Buffer = require('safe-buffer').Buffer;\n\nvar isEncoding = Buffer.isEncoding || function (encoding) {\n  encoding = '' + encoding;\n  switch (encoding && encoding.toLowerCase()) {\n    case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':\n      return true;\n    default:\n      return false;\n  }\n};\n\nfunction _normalizeEncoding(enc) {\n  if (!enc) return 'utf8';\n  var retried;\n  while (true) {\n    switch (enc) {\n      case 'utf8':\n      case 'utf-8':\n        return 'utf8';\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return 'utf16le';\n      case 'latin1':\n      case 'binary':\n        return 'latin1';\n      case 'base64':\n      case 'ascii':\n      case 'hex':\n        return enc;\n      default:\n        if (retried) return; // undefined\n        enc = ('' + enc).toLowerCase();\n        retried = true;\n    }\n  }\n};\n\n// Do not cache `Buffer.isEncoding` when checking encoding names as some\n// modules monkey-patch it to support additional encodings\nfunction normalizeEncoding(enc) {\n  var nenc = _normalizeEncoding(enc);\n  if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);\n  return nenc || enc;\n}\n\n// StringDecoder provides an interface for efficiently splitting a series of\n// buffers into a series of JS strings without breaking apart multi-byte\n// characters.\nexports.StringDecoder = StringDecoder;\nfunction StringDecoder(encoding) {\n  this.encoding = normalizeEncoding(encoding);\n  var nb;\n  switch (this.encoding) {\n    case 'utf16le':\n      this.text = utf16Text;\n      this.end = utf16End;\n      nb = 4;\n      break;\n    case 'utf8':\n      this.fillLast = utf8FillLast;\n      nb = 4;\n      break;\n    case 'base64':\n      this.text = base64Text;\n      this.end = base64End;\n      nb = 3;\n      break;\n    default:\n      this.write = simpleWrite;\n      this.end = simpleEnd;\n      return;\n  }\n  this.lastNeed = 0;\n  this.lastTotal = 0;\n  this.lastChar = Buffer.allocUnsafe(nb);\n}\n\nStringDecoder.prototype.write = function (buf) {\n  if (buf.length === 0) return '';\n  var r;\n  var i;\n  if (this.lastNeed) {\n    r = this.fillLast(buf);\n    if (r === undefined) return '';\n    i = this.lastNeed;\n    this.lastNeed = 0;\n  } else {\n    i = 0;\n  }\n  if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);\n  return r || '';\n};\n\nStringDecoder.prototype.end = utf8End;\n\n// Returns only complete characters in a Buffer\nStringDecoder.prototype.text = utf8Text;\n\n// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer\nStringDecoder.prototype.fillLast = function (buf) {\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);\n  this.lastNeed -= buf.length;\n};\n\n// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a\n// continuation byte.\nfunction utf8CheckByte(byte) {\n  if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;\n  return -1;\n}\n\n// Checks at most 3 bytes at the end of a Buffer in order to detect an\n// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)\n// needed to complete the UTF-8 character (if applicable) are returned.\nfunction utf8CheckIncomplete(self, buf, i) {\n  var j = buf.length - 1;\n  if (j < i) return 0;\n  var nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 1;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) self.lastNeed = nb - 2;\n    return nb;\n  }\n  if (--j < i) return 0;\n  nb = utf8CheckByte(buf[j]);\n  if (nb >= 0) {\n    if (nb > 0) {\n      if (nb === 2) nb = 0;else self.lastNeed = nb - 3;\n    }\n    return nb;\n  }\n  return 0;\n}\n\n// Validates as many continuation bytes for a multi-byte UTF-8 character as\n// needed or are available. If we see a non-continuation byte where we expect\n// one, we \"replace\" the validated continuation bytes we've seen so far with\n// UTF-8 replacement characters ('\\ufffd'), to match v8's UTF-8 decoding\n// behavior. The continuation byte check is included three times in the case\n// where all of the continuation bytes for a character exist in the same buffer.\n// It is also done this way as a slight performance increase instead of using a\n// loop.\nfunction utf8CheckExtraBytes(self, buf, p) {\n  if ((buf[0] & 0xC0) !== 0x80) {\n    self.lastNeed = 0;\n    return '\\ufffd'.repeat(p);\n  }\n  if (self.lastNeed > 1 && buf.length > 1) {\n    if ((buf[1] & 0xC0) !== 0x80) {\n      self.lastNeed = 1;\n      return '\\ufffd'.repeat(p + 1);\n    }\n    if (self.lastNeed > 2 && buf.length > 2) {\n      if ((buf[2] & 0xC0) !== 0x80) {\n        self.lastNeed = 2;\n        return '\\ufffd'.repeat(p + 2);\n      }\n    }\n  }\n}\n\n// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.\nfunction utf8FillLast(buf) {\n  var p = this.lastTotal - this.lastNeed;\n  var r = utf8CheckExtraBytes(this, buf, p);\n  if (r !== undefined) return r;\n  if (this.lastNeed <= buf.length) {\n    buf.copy(this.lastChar, p, 0, this.lastNeed);\n    return this.lastChar.toString(this.encoding, 0, this.lastTotal);\n  }\n  buf.copy(this.lastChar, p, 0, buf.length);\n  this.lastNeed -= buf.length;\n}\n\n// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a\n// partial character, the character's bytes are buffered until the required\n// number of bytes are available.\nfunction utf8Text(buf, i) {\n  var total = utf8CheckIncomplete(this, buf, i);\n  if (!this.lastNeed) return buf.toString('utf8', i);\n  this.lastTotal = total;\n  var end = buf.length - (total - this.lastNeed);\n  buf.copy(this.lastChar, 0, end);\n  return buf.toString('utf8', i, end);\n}\n\n// For UTF-8, a replacement character for each buffered byte of a (partial)\n// character needs to be added to the output.\nfunction utf8End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + '\\ufffd'.repeat(this.lastTotal - this.lastNeed);\n  return r;\n}\n\n// UTF-16LE typically needs two bytes per character, but even if we have an even\n// number of bytes available, we need to check if we end on a leading/high\n// surrogate. In that case, we need to wait for the next two bytes in order to\n// decode the last character properly.\nfunction utf16Text(buf, i) {\n  if ((buf.length - i) % 2 === 0) {\n    var r = buf.toString('utf16le', i);\n    if (r) {\n      var c = r.charCodeAt(r.length - 1);\n      if (c >= 0xD800 && c <= 0xDBFF) {\n        this.lastNeed = 2;\n        this.lastTotal = 4;\n        this.lastChar[0] = buf[buf.length - 2];\n        this.lastChar[1] = buf[buf.length - 1];\n        return r.slice(0, -1);\n      }\n    }\n    return r;\n  }\n  this.lastNeed = 1;\n  this.lastTotal = 2;\n  this.lastChar[0] = buf[buf.length - 1];\n  return buf.toString('utf16le', i, buf.length - 1);\n}\n\n// For UTF-16LE we do not explicitly append special replacement characters if we\n// end on a partial character, we simply let v8 handle that.\nfunction utf16End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) {\n    var end = this.lastTotal - this.lastNeed;\n    return r + this.lastChar.toString('utf16le', 0, end);\n  }\n  return r;\n}\n\nfunction base64Text(buf, i) {\n  var n = (buf.length - i) % 3;\n  if (n === 0) return buf.toString('base64', i);\n  this.lastNeed = 3 - n;\n  this.lastTotal = 3;\n  if (n === 1) {\n    this.lastChar[0] = buf[buf.length - 1];\n  } else {\n    this.lastChar[0] = buf[buf.length - 2];\n    this.lastChar[1] = buf[buf.length - 1];\n  }\n  return buf.toString('base64', i, buf.length - n);\n}\n\nfunction base64End(buf) {\n  var r = buf && buf.length ? this.write(buf) : '';\n  if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);\n  return r;\n}\n\n// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)\nfunction simpleWrite(buf) {\n  return buf.toString(this.encoding);\n}\n\nfunction simpleEnd(buf) {\n  return buf && buf.length ? this.write(buf) : '';\n}\n},{\"safe-buffer\":70}],73:[function(require,module,exports){\n(function (global){\n\n/**\n * Module exports.\n */\n\nmodule.exports = deprecate;\n\n/**\n * Mark that a method should not be used.\n * Returns a modified function which warns once by default.\n *\n * If `localStorage.noDeprecation = true` is set, then it is a no-op.\n *\n * If `localStorage.throwDeprecation = true` is set, then deprecated functions\n * will throw an Error when invoked.\n *\n * If `localStorage.traceDeprecation = true` is set, then deprecated functions\n * will invoke `console.trace()` instead of `console.error()`.\n *\n * @param {Function} fn - the function to deprecate\n * @param {String} msg - the string to print to the console when `fn` is invoked\n * @returns {Function} a new \"deprecated\" version of `fn`\n * @api public\n */\n\nfunction deprecate (fn, msg) {\n  if (config('noDeprecation')) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (config('throwDeprecation')) {\n        throw new Error(msg);\n      } else if (config('traceDeprecation')) {\n        console.trace(msg);\n      } else {\n        console.warn(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n}\n\n/**\n * Checks `localStorage` for boolean values for the given `name`.\n *\n * @param {String} name\n * @returns {Boolean}\n * @api private\n */\n\nfunction config (name) {\n  // accessing global.localStorage can trigger a DOMException in sandboxed iframes\n  try {\n    if (!global.localStorage) return false;\n  } catch (_) {\n    return false;\n  }\n  var val = global.localStorage[name];\n  if (null == val) return false;\n  return String(val).toLowerCase() === 'true';\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{}],74:[function(require,module,exports){\narguments[4][50][0].apply(exports,arguments)\n},{\"dup\":50}],75:[function(require,module,exports){\nmodule.exports = function isBuffer(arg) {\n  return arg && typeof arg === 'object'\n    && typeof arg.copy === 'function'\n    && typeof arg.fill === 'function'\n    && typeof arg.readUInt8 === 'function';\n}\n},{}],76:[function(require,module,exports){\n(function (process,global){\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nvar formatRegExp = /%[sdj%]/g;\nexports.format = function(f) {\n  if (!isString(f)) {\n    var objects = [];\n    for (var i = 0; i < arguments.length; i++) {\n      objects.push(inspect(arguments[i]));\n    }\n    return objects.join(' ');\n  }\n\n  var i = 1;\n  var args = arguments;\n  var len = args.length;\n  var str = String(f).replace(formatRegExp, function(x) {\n    if (x === '%%') return '%';\n    if (i >= len) return x;\n    switch (x) {\n      case '%s': return String(args[i++]);\n      case '%d': return Number(args[i++]);\n      case '%j':\n        try {\n          return JSON.stringify(args[i++]);\n        } catch (_) {\n          return '[Circular]';\n        }\n      default:\n        return x;\n    }\n  });\n  for (var x = args[i]; i < len; x = args[++i]) {\n    if (isNull(x) || !isObject(x)) {\n      str += ' ' + x;\n    } else {\n      str += ' ' + inspect(x);\n    }\n  }\n  return str;\n};\n\n\n// Mark that a method should not be used.\n// Returns a modified function which warns once by default.\n// If --no-deprecation is set, then it is a no-op.\nexports.deprecate = function(fn, msg) {\n  // Allow for deprecating things in the process of starting up.\n  if (isUndefined(global.process)) {\n    return function() {\n      return exports.deprecate(fn, msg).apply(this, arguments);\n    };\n  }\n\n  if (process.noDeprecation === true) {\n    return fn;\n  }\n\n  var warned = false;\n  function deprecated() {\n    if (!warned) {\n      if (process.throwDeprecation) {\n        throw new Error(msg);\n      } else if (process.traceDeprecation) {\n        console.trace(msg);\n      } else {\n        console.error(msg);\n      }\n      warned = true;\n    }\n    return fn.apply(this, arguments);\n  }\n\n  return deprecated;\n};\n\n\nvar debugs = {};\nvar debugEnviron;\nexports.debuglog = function(set) {\n  if (isUndefined(debugEnviron))\n    debugEnviron = process.env.NODE_DEBUG || '';\n  set = set.toUpperCase();\n  if (!debugs[set]) {\n    if (new RegExp('\\\\b' + set + '\\\\b', 'i').test(debugEnviron)) {\n      var pid = process.pid;\n      debugs[set] = function() {\n        var msg = exports.format.apply(exports, arguments);\n        console.error('%s %d: %s', set, pid, msg);\n      };\n    } else {\n      debugs[set] = function() {};\n    }\n  }\n  return debugs[set];\n};\n\n\n/**\n * Echos the value of a value. Trys to print the value out\n * in the best way possible given the different types.\n *\n * @param {Object} obj The object to print out.\n * @param {Object} opts Optional options object that alters the output.\n */\n/* legacy: obj, showHidden, depth, colors*/\nfunction inspect(obj, opts) {\n  // default options\n  var ctx = {\n    seen: [],\n    stylize: stylizeNoColor\n  };\n  // legacy...\n  if (arguments.length >= 3) ctx.depth = arguments[2];\n  if (arguments.length >= 4) ctx.colors = arguments[3];\n  if (isBoolean(opts)) {\n    // legacy...\n    ctx.showHidden = opts;\n  } else if (opts) {\n    // got an \"options\" object\n    exports._extend(ctx, opts);\n  }\n  // set default options\n  if (isUndefined(ctx.showHidden)) ctx.showHidden = false;\n  if (isUndefined(ctx.depth)) ctx.depth = 2;\n  if (isUndefined(ctx.colors)) ctx.colors = false;\n  if (isUndefined(ctx.customInspect)) ctx.customInspect = true;\n  if (ctx.colors) ctx.stylize = stylizeWithColor;\n  return formatValue(ctx, obj, ctx.depth);\n}\nexports.inspect = inspect;\n\n\n// http://en.wikipedia.org/wiki/ANSI_escape_code#graphics\ninspect.colors = {\n  'bold' : [1, 22],\n  'italic' : [3, 23],\n  'underline' : [4, 24],\n  'inverse' : [7, 27],\n  'white' : [37, 39],\n  'grey' : [90, 39],\n  'black' : [30, 39],\n  'blue' : [34, 39],\n  'cyan' : [36, 39],\n  'green' : [32, 39],\n  'magenta' : [35, 39],\n  'red' : [31, 39],\n  'yellow' : [33, 39]\n};\n\n// Don't use 'blue' not visible on cmd.exe\ninspect.styles = {\n  'special': 'cyan',\n  'number': 'yellow',\n  'boolean': 'yellow',\n  'undefined': 'grey',\n  'null': 'bold',\n  'string': 'green',\n  'date': 'magenta',\n  // \"name\": intentionally not styling\n  'regexp': 'red'\n};\n\n\nfunction stylizeWithColor(str, styleType) {\n  var style = inspect.styles[styleType];\n\n  if (style) {\n    return '\\u001b[' + inspect.colors[style][0] + 'm' + str +\n           '\\u001b[' + inspect.colors[style][1] + 'm';\n  } else {\n    return str;\n  }\n}\n\n\nfunction stylizeNoColor(str, styleType) {\n  return str;\n}\n\n\nfunction arrayToHash(array) {\n  var hash = {};\n\n  array.forEach(function(val, idx) {\n    hash[val] = true;\n  });\n\n  return hash;\n}\n\n\nfunction formatValue(ctx, value, recurseTimes) {\n  // Provide a hook for user-specified inspect functions.\n  // Check that value is an object with an inspect function on it\n  if (ctx.customInspect &&\n      value &&\n      isFunction(value.inspect) &&\n      // Filter out the util module, it's inspect function is special\n      value.inspect !== exports.inspect &&\n      // Also filter out any prototype objects using the circular check.\n      !(value.constructor && value.constructor.prototype === value)) {\n    var ret = value.inspect(recurseTimes, ctx);\n    if (!isString(ret)) {\n      ret = formatValue(ctx, ret, recurseTimes);\n    }\n    return ret;\n  }\n\n  // Primitive types cannot have properties\n  var primitive = formatPrimitive(ctx, value);\n  if (primitive) {\n    return primitive;\n  }\n\n  // Look up the keys of the object.\n  var keys = Object.keys(value);\n  var visibleKeys = arrayToHash(keys);\n\n  if (ctx.showHidden) {\n    keys = Object.getOwnPropertyNames(value);\n  }\n\n  // IE doesn't make error fields non-enumerable\n  // http://msdn.microsoft.com/en-us/library/ie/dww52sbt(v=vs.94).aspx\n  if (isError(value)\n      && (keys.indexOf('message') >= 0 || keys.indexOf('description') >= 0)) {\n    return formatError(value);\n  }\n\n  // Some type of object without properties can be shortcutted.\n  if (keys.length === 0) {\n    if (isFunction(value)) {\n      var name = value.name ? ': ' + value.name : '';\n      return ctx.stylize('[Function' + name + ']', 'special');\n    }\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    }\n    if (isDate(value)) {\n      return ctx.stylize(Date.prototype.toString.call(value), 'date');\n    }\n    if (isError(value)) {\n      return formatError(value);\n    }\n  }\n\n  var base = '', array = false, braces = ['{', '}'];\n\n  // Make Array say that they are Array\n  if (isArray(value)) {\n    array = true;\n    braces = ['[', ']'];\n  }\n\n  // Make functions say that they are functions\n  if (isFunction(value)) {\n    var n = value.name ? ': ' + value.name : '';\n    base = ' [Function' + n + ']';\n  }\n\n  // Make RegExps say that they are RegExps\n  if (isRegExp(value)) {\n    base = ' ' + RegExp.prototype.toString.call(value);\n  }\n\n  // Make dates with properties first say the date\n  if (isDate(value)) {\n    base = ' ' + Date.prototype.toUTCString.call(value);\n  }\n\n  // Make error with message first say the error\n  if (isError(value)) {\n    base = ' ' + formatError(value);\n  }\n\n  if (keys.length === 0 && (!array || value.length == 0)) {\n    return braces[0] + base + braces[1];\n  }\n\n  if (recurseTimes < 0) {\n    if (isRegExp(value)) {\n      return ctx.stylize(RegExp.prototype.toString.call(value), 'regexp');\n    } else {\n      return ctx.stylize('[Object]', 'special');\n    }\n  }\n\n  ctx.seen.push(value);\n\n  var output;\n  if (array) {\n    output = formatArray(ctx, value, recurseTimes, visibleKeys, keys);\n  } else {\n    output = keys.map(function(key) {\n      return formatProperty(ctx, value, recurseTimes, visibleKeys, key, array);\n    });\n  }\n\n  ctx.seen.pop();\n\n  return reduceToSingleString(output, base, braces);\n}\n\n\nfunction formatPrimitive(ctx, value) {\n  if (isUndefined(value))\n    return ctx.stylize('undefined', 'undefined');\n  if (isString(value)) {\n    var simple = '\\'' + JSON.stringify(value).replace(/^\"|\"$/g, '')\n                                             .replace(/'/g, \"\\\\'\")\n                                             .replace(/\\\\\"/g, '\"') + '\\'';\n    return ctx.stylize(simple, 'string');\n  }\n  if (isNumber(value))\n    return ctx.stylize('' + value, 'number');\n  if (isBoolean(value))\n    return ctx.stylize('' + value, 'boolean');\n  // For some reason typeof null is \"object\", so special case here.\n  if (isNull(value))\n    return ctx.stylize('null', 'null');\n}\n\n\nfunction formatError(value) {\n  return '[' + Error.prototype.toString.call(value) + ']';\n}\n\n\nfunction formatArray(ctx, value, recurseTimes, visibleKeys, keys) {\n  var output = [];\n  for (var i = 0, l = value.length; i < l; ++i) {\n    if (hasOwnProperty(value, String(i))) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          String(i), true));\n    } else {\n      output.push('');\n    }\n  }\n  keys.forEach(function(key) {\n    if (!key.match(/^\\d+$/)) {\n      output.push(formatProperty(ctx, value, recurseTimes, visibleKeys,\n          key, true));\n    }\n  });\n  return output;\n}\n\n\nfunction formatProperty(ctx, value, recurseTimes, visibleKeys, key, array) {\n  var name, str, desc;\n  desc = Object.getOwnPropertyDescriptor(value, key) || { value: value[key] };\n  if (desc.get) {\n    if (desc.set) {\n      str = ctx.stylize('[Getter/Setter]', 'special');\n    } else {\n      str = ctx.stylize('[Getter]', 'special');\n    }\n  } else {\n    if (desc.set) {\n      str = ctx.stylize('[Setter]', 'special');\n    }\n  }\n  if (!hasOwnProperty(visibleKeys, key)) {\n    name = '[' + key + ']';\n  }\n  if (!str) {\n    if (ctx.seen.indexOf(desc.value) < 0) {\n      if (isNull(recurseTimes)) {\n        str = formatValue(ctx, desc.value, null);\n      } else {\n        str = formatValue(ctx, desc.value, recurseTimes - 1);\n      }\n      if (str.indexOf('\\n') > -1) {\n        if (array) {\n          str = str.split('\\n').map(function(line) {\n            return '  ' + line;\n          }).join('\\n').substr(2);\n        } else {\n          str = '\\n' + str.split('\\n').map(function(line) {\n            return '   ' + line;\n          }).join('\\n');\n        }\n      }\n    } else {\n      str = ctx.stylize('[Circular]', 'special');\n    }\n  }\n  if (isUndefined(name)) {\n    if (array && key.match(/^\\d+$/)) {\n      return str;\n    }\n    name = JSON.stringify('' + key);\n    if (name.match(/^\"([a-zA-Z_][a-zA-Z_0-9]*)\"$/)) {\n      name = name.substr(1, name.length - 2);\n      name = ctx.stylize(name, 'name');\n    } else {\n      name = name.replace(/'/g, \"\\\\'\")\n                 .replace(/\\\\\"/g, '\"')\n                 .replace(/(^\"|\"$)/g, \"'\");\n      name = ctx.stylize(name, 'string');\n    }\n  }\n\n  return name + ': ' + str;\n}\n\n\nfunction reduceToSingleString(output, base, braces) {\n  var numLinesEst = 0;\n  var length = output.reduce(function(prev, cur) {\n    numLinesEst++;\n    if (cur.indexOf('\\n') >= 0) numLinesEst++;\n    return prev + cur.replace(/\\u001b\\[\\d\\d?m/g, '').length + 1;\n  }, 0);\n\n  if (length > 60) {\n    return braces[0] +\n           (base === '' ? '' : base + '\\n ') +\n           ' ' +\n           output.join(',\\n  ') +\n           ' ' +\n           braces[1];\n  }\n\n  return braces[0] + base + ' ' + output.join(', ') + ' ' + braces[1];\n}\n\n\n// NOTE: These type checking functions intentionally don't use `instanceof`\n// because it is fragile and can be easily faked with `Object.create()`.\nfunction isArray(ar) {\n  return Array.isArray(ar);\n}\nexports.isArray = isArray;\n\nfunction isBoolean(arg) {\n  return typeof arg === 'boolean';\n}\nexports.isBoolean = isBoolean;\n\nfunction isNull(arg) {\n  return arg === null;\n}\nexports.isNull = isNull;\n\nfunction isNullOrUndefined(arg) {\n  return arg == null;\n}\nexports.isNullOrUndefined = isNullOrUndefined;\n\nfunction isNumber(arg) {\n  return typeof arg === 'number';\n}\nexports.isNumber = isNumber;\n\nfunction isString(arg) {\n  return typeof arg === 'string';\n}\nexports.isString = isString;\n\nfunction isSymbol(arg) {\n  return typeof arg === 'symbol';\n}\nexports.isSymbol = isSymbol;\n\nfunction isUndefined(arg) {\n  return arg === void 0;\n}\nexports.isUndefined = isUndefined;\n\nfunction isRegExp(re) {\n  return isObject(re) && objectToString(re) === '[object RegExp]';\n}\nexports.isRegExp = isRegExp;\n\nfunction isObject(arg) {\n  return typeof arg === 'object' && arg !== null;\n}\nexports.isObject = isObject;\n\nfunction isDate(d) {\n  return isObject(d) && objectToString(d) === '[object Date]';\n}\nexports.isDate = isDate;\n\nfunction isError(e) {\n  return isObject(e) &&\n      (objectToString(e) === '[object Error]' || e instanceof Error);\n}\nexports.isError = isError;\n\nfunction isFunction(arg) {\n  return typeof arg === 'function';\n}\nexports.isFunction = isFunction;\n\nfunction isPrimitive(arg) {\n  return arg === null ||\n         typeof arg === 'boolean' ||\n         typeof arg === 'number' ||\n         typeof arg === 'string' ||\n         typeof arg === 'symbol' ||  // ES6 symbol\n         typeof arg === 'undefined';\n}\nexports.isPrimitive = isPrimitive;\n\nexports.isBuffer = require('./support/isBuffer');\n\nfunction objectToString(o) {\n  return Object.prototype.toString.call(o);\n}\n\n\nfunction pad(n) {\n  return n < 10 ? '0' + n.toString(10) : n.toString(10);\n}\n\n\nvar months = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep',\n              'Oct', 'Nov', 'Dec'];\n\n// 26 Feb 16:19:34\nfunction timestamp() {\n  var d = new Date();\n  var time = [pad(d.getHours()),\n              pad(d.getMinutes()),\n              pad(d.getSeconds())].join(':');\n  return [d.getDate(), months[d.getMonth()], time].join(' ');\n}\n\n\n// log is just a thin wrapper to console.log that prepends a timestamp\nexports.log = function() {\n  console.log('%s - %s', timestamp(), exports.format.apply(exports, arguments));\n};\n\n\n/**\n * Inherit the prototype methods from one constructor into another.\n *\n * The Function.prototype.inherits from lang.js rewritten as a standalone\n * function (not on Function.prototype). NOTE: If this file is to be loaded\n * during bootstrapping this function needs to be rewritten using some native\n * functions as prototype setup using normal JavaScript does not work as\n * expected during bootstrapping (see mirror.js in r114903).\n *\n * @param {function} ctor Constructor function which needs to inherit the\n *     prototype.\n * @param {function} superCtor Constructor function to inherit prototype from.\n */\nexports.inherits = require('inherits');\n\nexports._extend = function(origin, add) {\n  // Don't do anything if add isn't an object\n  if (!add || !isObject(add)) return origin;\n\n  var keys = Object.keys(add);\n  var i = keys.length;\n  while (i--) {\n    origin[keys[i]] = add[keys[i]];\n  }\n  return origin;\n};\n\nfunction hasOwnProperty(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n}\n\n}).call(this,require('_process'),typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n},{\"./support/isBuffer\":75,\"_process\":56,\"inherits\":74}]},{},[1]);\n"

/***/ }),

/***/ "./node_modules/script-loader/addScript.js":
/*!*************************************************!*\
  !*** ./node_modules/script-loader/addScript.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
module.exports = function(src) {
	function log(error) {
		(typeof console !== "undefined")
		&& (console.error || console.log)("[Script Loader]", error);
	}

	// Check for IE =< 8
	function isIE() {
		return typeof attachEvent !== "undefined" && typeof addEventListener === "undefined";
	}

	try {
		if (typeof execScript !== "undefined" && isIE()) {
			execScript(src);
		} else if (typeof eval !== "undefined") {
			eval.call(null, src);
		} else {
			log("EvalError: No eval function available");
		}
	} catch (error) {
		log(error);
	}
}


/***/ }),

/***/ "./node_modules/script-loader/index.js!./node_modules/mocha/mocha.js":
/*!******************************************************************!*\
  !*** ./node_modules/script-loader!./node_modules/mocha/mocha.js ***!
  \******************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(/*! !./node_modules/script-loader/addScript.js */ "./node_modules/script-loader/addScript.js")(__webpack_require__(/*! !./node_modules/raw-loader!./node_modules/mocha/mocha.js */ "./node_modules/raw-loader/index.js!./node_modules/mocha/mocha.js"))

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vdGVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEvbW9jaGEuY3NzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5jc3M/ZDZlNSIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci9zdGFydC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3dlYi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vY2hhL21vY2hhLmpzPzNmNjMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHVEQUF1RDtBQUN2RDs7QUFFQSw2QkFBNkIsbUJBQW1COztBQUVoRDs7QUFFQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7O0FDNVdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxXQUFXLEVBQUU7QUFDckQsd0NBQXdDLFdBQVcsRUFBRTs7QUFFckQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxzQ0FBc0M7QUFDdEMsR0FBRztBQUNIO0FBQ0EsOERBQThEO0FBQzlEOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDeEZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUNORCx5Q0FBeUMsNENBQTRDOztBQUVyRjtBQUNBOzs7Ozs7Ozs7Ozs7QUNIQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7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aGUgbW9kdWxlIGNhY2hlXG4gXHR2YXIgaW5zdGFsbGVkTW9kdWxlcyA9IHt9O1xuXG4gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuIFx0ZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXG4gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuIFx0XHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSkge1xuIFx0XHRcdHJldHVybiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5leHBvcnRzO1xuIFx0XHR9XG4gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4gXHRcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcbiBcdFx0XHRpOiBtb2R1bGVJZCxcbiBcdFx0XHRsOiBmYWxzZSxcbiBcdFx0XHRleHBvcnRzOiB7fVxuIFx0XHR9O1xuXG4gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHtcbiBcdFx0XHRcdGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBnZXR0ZXJcbiBcdFx0XHR9KTtcbiBcdFx0fVxuIFx0fTtcblxuIFx0Ly8gZGVmaW5lIF9fZXNNb2R1bGUgb24gZXhwb3J0c1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5yID0gZnVuY3Rpb24oZXhwb3J0cykge1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL2luZGV4LmpzIS4vdGVzdC9pbmRleC5qc1wiKTtcbiIsInJlcXVpcmUoXCIhIS9Vc2Vycy9tZWdhbi90dXJpbmcvbW9kMi9nYW1lLXRpbWUvbm9kZV9tb2R1bGVzL21vY2hhLWxvYWRlci93ZWIuanNcIik7XG5pZih0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuaW5pdE1vY2hhUGhhbnRvbUpTKSB7IHdpbmRvdy5pbml0TW9jaGFQaGFudG9tSlMoKTsgfVxubW9jaGEuc2V0dXAoe1widWlcIjpcImJkZFwifSk7XG5yZXF1aXJlKFwiISEvVXNlcnMvbWVnYW4vdHVyaW5nL21vZDIvZ2FtZS10aW1lL25vZGVfbW9kdWxlcy9iYWJlbC1sb2FkZXIvbGliL2luZGV4LmpzIS9Vc2Vycy9tZWdhbi90dXJpbmcvbW9kMi9nYW1lLXRpbWUvdGVzdC9pbmRleC5qc1wiKVxucmVxdWlyZShcIiEhL1VzZXJzL21lZ2FuL3R1cmluZy9tb2QyL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvbW9jaGEtbG9hZGVyL3N0YXJ0LmpzXCIpO1xuaWYobW9kdWxlLmhvdCkge1xuXHRtb2R1bGUuaG90LmFjY2VwdCgpO1xuXHRtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7XG5cdFx0bW9jaGEuc3VpdGUuc3VpdGVzLmxlbmd0aCA9IDA7XG5cdFx0dmFyIHN0YXRzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21vY2hhLXN0YXRzJyk7XG5cdFx0dmFyIHJlcG9ydCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYS1yZXBvcnQnKTtcblx0XHRzdGF0cyAmJiBzdGF0cy5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0YXRzKTtcblx0XHRyZXBvcnQgJiYgcmVwb3J0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQocmVwb3J0KTtcblx0fSk7XG59IiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikoZmFsc2UpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGNoYXJzZXQgXFxcInV0Zi04XFxcIjtcXG5cXG5ib2R5IHtcXG4gIG1hcmdpbjowO1xcbn1cXG5cXG4jbW9jaGEge1xcbiAgZm9udDogMjBweC8xLjUgXFxcIkhlbHZldGljYSBOZXVlXFxcIiwgSGVsdmV0aWNhLCBBcmlhbCwgc2Fucy1zZXJpZjtcXG4gIG1hcmdpbjogNjBweCA1MHB4O1xcbn1cXG5cXG4jbW9jaGEgdWwsXFxuI21vY2hhIGxpIHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbiNtb2NoYSB1bCB7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbn1cXG5cXG4jbW9jaGEgaDEsXFxuI21vY2hhIGgyIHtcXG4gIG1hcmdpbjogMDtcXG59XFxuXFxuI21vY2hhIGgxIHtcXG4gIG1hcmdpbi10b3A6IDE1cHg7XFxuICBmb250LXNpemU6IDFlbTtcXG4gIGZvbnQtd2VpZ2h0OiAyMDA7XFxufVxcblxcbiNtb2NoYSBoMSBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jbW9jaGEgaDEgYTpob3ZlciB7XFxuICB0ZXh0LWRlY29yYXRpb246IHVuZGVybGluZTtcXG59XFxuXFxuI21vY2hhIC5zdWl0ZSAuc3VpdGUgaDEge1xcbiAgbWFyZ2luLXRvcDogMDtcXG4gIGZvbnQtc2l6ZTogLjhlbTtcXG59XFxuXFxuI21vY2hhIC5oaWRkZW4ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhIGgyIHtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGZvbnQtd2VpZ2h0OiBub3JtYWw7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbiNtb2NoYSAuc3VpdGUge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxufVxcblxcbiNtb2NoYSAudGVzdCB7XFxuICBtYXJnaW4tbGVmdDogMTVweDtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nOmhvdmVyIGgyOjphZnRlciB7XFxuICBjb250ZW50OiAnKHBlbmRpbmcpJztcXG4gIGZvbnQtZmFtaWx5OiBhcmlhbCwgc2Fucy1zZXJpZjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MubWVkaXVtIC5kdXJhdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiAjYzA5ODUzO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzcy5zbG93IC5kdXJhdGlvbiB7XFxuICBiYWNrZ3JvdW5kOiAjYjk0YTQ4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QucGFzczo6YmVmb3JlIHtcXG4gIGNvbnRlbnQ6ICdcXFxcMjcxMyc7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgbWFyZ2luLXJpZ2h0OiA1cHg7XFxuICBjb2xvcjogIzAwZDZiMjtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MgLmR1cmF0aW9uIHtcXG4gIGZvbnQtc2l6ZTogOXB4O1xcbiAgbWFyZ2luLWxlZnQ6IDVweDtcXG4gIHBhZGRpbmc6IDJweCA1cHg7XFxuICBjb2xvcjogI2ZmZjtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogaW5zZXQgMCAxcHggMXB4IHJnYmEoMCwwLDAsLjIpO1xcbiAgLW1vei1ib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICBib3gtc2hhZG93OiBpbnNldCAwIDFweCAxcHggcmdiYSgwLDAsMCwuMik7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgLW1zLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIC1vLWJvcmRlci1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBhc3MuZmFzdCAuZHVyYXRpb24ge1xcbiAgZGlzcGxheTogbm9uZTtcXG59XFxuXFxuI21vY2hhIC50ZXN0LnBlbmRpbmcge1xcbiAgY29sb3I6ICMwYjk3YzQ7XFxufVxcblxcbiNtb2NoYSAudGVzdC5wZW5kaW5nOjpiZWZvcmUge1xcbiAgY29udGVudDogJ1xcXFwyNUU2JztcXG4gIGNvbG9yOiAjMGI5N2M0O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QuZmFpbCB7XFxuICBjb2xvcjogI2MwMDtcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWwgcHJlIHtcXG4gIGNvbG9yOiBibGFjaztcXG59XFxuXFxuI21vY2hhIC50ZXN0LmZhaWw6OmJlZm9yZSB7XFxuICBjb250ZW50OiAnXFxcXDI3MTYnO1xcbiAgZm9udC1zaXplOiAxMnB4O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIG1hcmdpbi1yaWdodDogNXB4O1xcbiAgY29sb3I6ICNjMDA7XFxufVxcblxcbiNtb2NoYSAudGVzdCBwcmUuZXJyb3Ige1xcbiAgY29sb3I6ICNjMDA7XFxuICBtYXgtaGVpZ2h0OiAzMDBweDtcXG4gIG92ZXJmbG93OiBhdXRvO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgLmh0bWwtZXJyb3Ige1xcbiAgb3ZlcmZsb3c6IGF1dG87XFxuICBjb2xvcjogYmxhY2s7XFxuICBsaW5lLWhlaWdodDogMS41O1xcbiAgZGlzcGxheTogYmxvY2s7XFxuICBmbG9hdDogbGVmdDtcXG4gIGNsZWFyOiBsZWZ0O1xcbiAgZm9udDogMTJweC8xLjUgbW9uYWNvLCBtb25vc3BhY2U7XFxuICBtYXJnaW46IDVweDtcXG4gIHBhZGRpbmc6IDE1cHg7XFxuICBib3JkZXI6IDFweCBzb2xpZCAjZWVlO1xcbiAgbWF4LXdpZHRoOiA4NSU7IC8qKDEpKi9cXG4gIG1heC13aWR0aDogLXdlYmtpdC1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogLW1vei1jYWxjKDEwMCUgLSA0MnB4KTtcXG4gIG1heC13aWR0aDogY2FsYygxMDAlIC0gNDJweCk7IC8qKDIpKi9cXG4gIG1heC1oZWlnaHQ6IDMwMHB4O1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgLmh0bWwtZXJyb3IgcHJlLmVycm9yIHtcXG4gIGJvcmRlcjogbm9uZTtcXG4gIC13ZWJraXQtYm9yZGVyLXJhZGl1czogMDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDA7XFxuICAtd2Via2l0LWJveC1zaGFkb3c6IDA7XFxuICAtbW96LWJveC1zaGFkb3c6IDA7XFxuICBib3gtc2hhZG93OiAwO1xcbiAgcGFkZGluZzogMDtcXG4gIG1hcmdpbjogMDtcXG4gIG1hcmdpbi10b3A6IDE4cHg7XFxuICBtYXgtaGVpZ2h0OiBub25lO1xcbn1cXG5cXG4vKipcXG4gKiAoMSk6IGFwcHJveGltYXRlIGZvciBicm93c2VycyBub3Qgc3VwcG9ydGluZyBjYWxjXFxuICogKDIpOiA0MiA9IDIqMTUgKyAyKjEwICsgMioxIChwYWRkaW5nICsgbWFyZ2luICsgYm9yZGVyKVxcbiAqICAgICAgXl4gc2VyaW91c2x5XFxuICovXFxuI21vY2hhIC50ZXN0IHByZSB7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIGZsb2F0OiBsZWZ0O1xcbiAgY2xlYXI6IGxlZnQ7XFxuICBmb250OiAxMnB4LzEuNSBtb25hY28sIG1vbm9zcGFjZTtcXG4gIG1hcmdpbjogNXB4O1xcbiAgcGFkZGluZzogMTVweDtcXG4gIGJvcmRlcjogMXB4IHNvbGlkICNlZWU7XFxuICBtYXgtd2lkdGg6IDg1JTsgLyooMSkqL1xcbiAgbWF4LXdpZHRoOiAtd2Via2l0LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiAtbW96LWNhbGMoMTAwJSAtIDQycHgpO1xcbiAgbWF4LXdpZHRoOiBjYWxjKDEwMCUgLSA0MnB4KTsgLyooMikqL1xcbiAgd29yZC13cmFwOiBicmVhay13b3JkO1xcbiAgYm9yZGVyLWJvdHRvbS1jb2xvcjogI2RkZDtcXG4gIC13ZWJraXQtYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtbW96LWJveC1zaGFkb3c6IDAgMXB4IDNweCAjZWVlO1xcbiAgYm94LXNoYWRvdzogMCAxcHggM3B4ICNlZWU7XFxuICAtd2Via2l0LWJvcmRlci1yYWRpdXM6IDNweDtcXG4gIC1tb3otYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgaDIge1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4jbW9jaGEgLnRlc3QgYS5yZXBsYXkge1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiAzcHg7XFxuICByaWdodDogMDtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIHZlcnRpY2FsLWFsaWduOiBtaWRkbGU7XFxuICBkaXNwbGF5OiBibG9jaztcXG4gIHdpZHRoOiAxNXB4O1xcbiAgaGVpZ2h0OiAxNXB4O1xcbiAgbGluZS1oZWlnaHQ6IDE1cHg7XFxuICB0ZXh0LWFsaWduOiBjZW50ZXI7XFxuICBiYWNrZ3JvdW5kOiAjZWVlO1xcbiAgZm9udC1zaXplOiAxNXB4O1xcbiAgLXdlYmtpdC1ib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgLW1vei1ib3JkZXItcmFkaXVzOiAxNXB4O1xcbiAgYm9yZGVyLXJhZGl1czogMTVweDtcXG4gIC13ZWJraXQtdHJhbnNpdGlvbjpvcGFjaXR5IDIwMG1zO1xcbiAgLW1vei10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICAtby10cmFuc2l0aW9uOm9wYWNpdHkgMjAwbXM7XFxuICB0cmFuc2l0aW9uOiBvcGFjaXR5IDIwMG1zO1xcbiAgb3BhY2l0eTogMC4zO1xcbiAgY29sb3I6ICM4ODg7XFxufVxcblxcbiNtb2NoYSAudGVzdDpob3ZlciBhLnJlcGxheSB7XFxuICBvcGFjaXR5OiAxO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBhc3MgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LmZhaWwgLnRlc3QucGFzcyB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG5cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcyxcXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QuZmFpbCB7XFxuICBkaXNwbGF5OiBub25lO1xcbn1cXG4jbW9jaGEtcmVwb3J0LnBlbmRpbmcgLnRlc3QucGFzcy5wZW5kaW5nIHtcXG4gIGRpc3BsYXk6IGJsb2NrO1xcbn1cXG5cXG4jbW9jaGEtZXJyb3Ige1xcbiAgY29sb3I6ICNjMDA7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgZm9udC13ZWlnaHQ6IDEwMDtcXG4gIGxldHRlci1zcGFjaW5nOiAxcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICB0b3A6IDE1cHg7XFxuICByaWdodDogMTBweDtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIG1hcmdpbjogMDtcXG4gIGNvbG9yOiAjODg4O1xcbiAgei1pbmRleDogMTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIC5wcm9ncmVzcyB7XFxuICBmbG9hdDogcmlnaHQ7XFxuICBwYWRkaW5nLXRvcDogMDtcXG5cXG4gIC8qKlxcbiAgICogU2V0IHNhZmUgaW5pdGlhbCB2YWx1ZXMsIHNvIG1vY2hhcyAucHJvZ3Jlc3MgZG9lcyBub3QgaW5oZXJpdCB0aGVzZVxcbiAgICogcHJvcGVydGllcyBmcm9tIEJvb3RzdHJhcCAucHJvZ3Jlc3MgKHdoaWNoIGNhdXNlcyAucHJvZ3Jlc3MgaGVpZ2h0IHRvXFxuICAgKiBlcXVhbCBsaW5lIGhlaWdodCBzZXQgaW4gQm9vdHN0cmFwKS5cXG4gICAqL1xcbiAgaGVpZ2h0OiBhdXRvO1xcbiAgLXdlYmtpdC1ib3gtc2hhZG93OiBub25lO1xcbiAgLW1vei1ib3gtc2hhZG93OiBub25lO1xcbiAgYm94LXNoYWRvdzogbm9uZTtcXG4gIGJhY2tncm91bmQtY29sb3I6IGluaXRpYWw7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBlbSB7XFxuICBjb2xvcjogYmxhY2s7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBhIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbm9uZTtcXG4gIGNvbG9yOiBpbmhlcml0O1xcbn1cXG5cXG4jbW9jaGEtc3RhdHMgYTpob3ZlciB7XFxuICBib3JkZXItYm90dG9tOiAxcHggc29saWQgI2VlZTtcXG59XFxuXFxuI21vY2hhLXN0YXRzIGxpIHtcXG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcXG4gIG1hcmdpbjogMCA1cHg7XFxuICBsaXN0LXN0eWxlOiBub25lO1xcbiAgcGFkZGluZy10b3A6IDExcHg7XFxufVxcblxcbiNtb2NoYS1zdGF0cyBjYW52YXMge1xcbiAgd2lkdGg6IDQwcHg7XFxuICBoZWlnaHQ6IDQwcHg7XFxufVxcblxcbiNtb2NoYSBjb2RlIC5jb21tZW50IHsgY29sb3I6ICNkZGQ7IH1cXG4jbW9jaGEgY29kZSAuaW5pdCB7IGNvbG9yOiAjMmY2ZmFkOyB9XFxuI21vY2hhIGNvZGUgLnN0cmluZyB7IGNvbG9yOiAjNTg5MGFkOyB9XFxuI21vY2hhIGNvZGUgLmtleXdvcmQgeyBjb2xvcjogIzhhNjM0MzsgfVxcbiNtb2NoYSBjb2RlIC5udW1iZXIgeyBjb2xvcjogIzJmNmZhZDsgfVxcblxcbkBtZWRpYSBzY3JlZW4gYW5kIChtYXgtZGV2aWNlLXdpZHRoOiA0ODBweCkge1xcbiAgI21vY2hhIHtcXG4gICAgbWFyZ2luOiA2MHB4IDBweDtcXG4gIH1cXG5cXG4gICNtb2NoYSAjc3RhdHMge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB9XFxufVxcblwiLCBcIlwiXSk7XG5cbi8vIGV4cG9ydHNcbiIsIi8qXG5cdE1JVCBMaWNlbnNlIGh0dHA6Ly93d3cub3BlbnNvdXJjZS5vcmcvbGljZW5zZXMvbWl0LWxpY2Vuc2UucGhwXG5cdEF1dGhvciBUb2JpYXMgS29wcGVycyBAc29rcmFcbiovXG4vLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcblx0dmFyIGxpc3QgPSBbXTtcblxuXHQvLyByZXR1cm4gdGhlIGxpc3Qgb2YgbW9kdWxlcyBhcyBjc3Mgc3RyaW5nXG5cdGxpc3QudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcblx0XHRcdHZhciBjb250ZW50ID0gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApO1xuXHRcdFx0aWYoaXRlbVsyXSkge1xuXHRcdFx0XHRyZXR1cm4gXCJAbWVkaWEgXCIgKyBpdGVtWzJdICsgXCJ7XCIgKyBjb250ZW50ICsgXCJ9XCI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gY29udGVudDtcblx0XHRcdH1cblx0XHR9KS5qb2luKFwiXCIpO1xuXHR9O1xuXG5cdC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG5cdGxpc3QuaSA9IGZ1bmN0aW9uKG1vZHVsZXMsIG1lZGlhUXVlcnkpIHtcblx0XHRpZih0eXBlb2YgbW9kdWxlcyA9PT0gXCJzdHJpbmdcIilcblx0XHRcdG1vZHVsZXMgPSBbW251bGwsIG1vZHVsZXMsIFwiXCJdXTtcblx0XHR2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuXHRcdGZvcih2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaWQgPSB0aGlzW2ldWzBdO1xuXHRcdFx0aWYodHlwZW9mIGlkID09PSBcIm51bWJlclwiKVxuXHRcdFx0XHRhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG5cdFx0fVxuXHRcdGZvcihpID0gMDsgaSA8IG1vZHVsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gbW9kdWxlc1tpXTtcblx0XHRcdC8vIHNraXAgYWxyZWFkeSBpbXBvcnRlZCBtb2R1bGVcblx0XHRcdC8vIHRoaXMgaW1wbGVtZW50YXRpb24gaXMgbm90IDEwMCUgcGVyZmVjdCBmb3Igd2VpcmQgbWVkaWEgcXVlcnkgY29tYmluYXRpb25zXG5cdFx0XHQvLyAgd2hlbiBhIG1vZHVsZSBpcyBpbXBvcnRlZCBtdWx0aXBsZSB0aW1lcyB3aXRoIGRpZmZlcmVudCBtZWRpYSBxdWVyaWVzLlxuXHRcdFx0Ly8gIEkgaG9wZSB0aGlzIHdpbGwgbmV2ZXIgb2NjdXIgKEhleSB0aGlzIHdheSB3ZSBoYXZlIHNtYWxsZXIgYnVuZGxlcylcblx0XHRcdGlmKHR5cGVvZiBpdGVtWzBdICE9PSBcIm51bWJlclwiIHx8ICFhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2l0ZW1bMF1dKSB7XG5cdFx0XHRcdGlmKG1lZGlhUXVlcnkgJiYgIWl0ZW1bMl0pIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gbWVkaWFRdWVyeTtcblx0XHRcdFx0fSBlbHNlIGlmKG1lZGlhUXVlcnkpIHtcblx0XHRcdFx0XHRpdGVtWzJdID0gXCIoXCIgKyBpdGVtWzJdICsgXCIpIGFuZCAoXCIgKyBtZWRpYVF1ZXJ5ICsgXCIpXCI7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGlzdC5wdXNoKGl0ZW0pO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcblx0cmV0dXJuIGxpc3Q7XG59O1xuXG5mdW5jdGlvbiBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCkge1xuXHR2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgJyc7XG5cdHZhciBjc3NNYXBwaW5nID0gaXRlbVszXTtcblx0aWYgKCFjc3NNYXBwaW5nKSB7XG5cdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdH1cblxuXHRpZiAodXNlU291cmNlTWFwICYmIHR5cGVvZiBidG9hID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0dmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG5cdFx0dmFyIHNvdXJjZVVSTHMgPSBjc3NNYXBwaW5nLnNvdXJjZXMubWFwKGZ1bmN0aW9uIChzb3VyY2UpIHtcblx0XHRcdHJldHVybiAnLyojIHNvdXJjZVVSTD0nICsgY3NzTWFwcGluZy5zb3VyY2VSb290ICsgc291cmNlICsgJyAqLydcblx0XHR9KTtcblxuXHRcdHJldHVybiBbY29udGVudF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oJ1xcbicpO1xuXHR9XG5cblx0cmV0dXJuIFtjb250ZW50XS5qb2luKCdcXG4nKTtcbn1cblxuLy8gQWRhcHRlZCBmcm9tIGNvbnZlcnQtc291cmNlLW1hcCAoTUlUKVxuZnVuY3Rpb24gdG9Db21tZW50KHNvdXJjZU1hcCkge1xuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcblx0dmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSk7XG5cdHZhciBkYXRhID0gJ3NvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2NoYXJzZXQ9dXRmLTg7YmFzZTY0LCcgKyBiYXNlNjQ7XG5cblx0cmV0dXJuICcvKiMgJyArIGRhdGEgKyAnICovJztcbn1cbiIsIi8vIHN0eWxlLWxvYWRlcjogQWRkcyBzb21lIGNzcyB0byB0aGUgRE9NIGJ5IGFkZGluZyBhIDxzdHlsZT4gdGFnXG5cbi8vIGxvYWQgdGhlIHN0eWxlc1xudmFyIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge1wiaG1yXCI6dHJ1ZX1cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXCIpKGNvbnRlbnQsIG9wdGlvbnMpO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG5cdC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG5cdGlmKCFjb250ZW50LmxvY2Fscykge1xuXHRcdG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi9tb2NoYS1sb2FkZXIvbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanMhLi9tb2NoYS5jc3NcIiwgZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uL21vY2hhLWxvYWRlci9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL21vY2hhLmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59IiwiLypcblx0TUlUIExpY2Vuc2UgaHR0cDovL3d3dy5vcGVuc291cmNlLm9yZy9saWNlbnNlcy9taXQtbGljZW5zZS5waHBcblx0QXV0aG9yIFRvYmlhcyBLb3BwZXJzIEBzb2tyYVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0ge307XG5cbnZhclx0bWVtb2l6ZSA9IGZ1bmN0aW9uIChmbikge1xuXHR2YXIgbWVtbztcblxuXHRyZXR1cm4gZnVuY3Rpb24gKCkge1xuXHRcdGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikgbWVtbyA9IGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG1lbW87XG5cdH07XG59O1xuXG52YXIgaXNPbGRJRSA9IG1lbW9pemUoZnVuY3Rpb24gKCkge1xuXHQvLyBUZXN0IGZvciBJRSA8PSA5IGFzIHByb3Bvc2VkIGJ5IEJyb3dzZXJoYWNrc1xuXHQvLyBAc2VlIGh0dHA6Ly9icm93c2VyaGFja3MuY29tLyNoYWNrLWU3MWQ4NjkyZjY1MzM0MTczZmVlNzE1YzIyMmNiODA1XG5cdC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcblx0Ly8gdG8gb3BlcmF0ZSBjb3JyZWN0bHkgaW50byBub24tc3RhbmRhcmQgZW52aXJvbm1lbnRzXG5cdC8vIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL3dlYnBhY2stY29udHJpYi9zdHlsZS1sb2FkZXIvaXNzdWVzLzE3N1xuXHRyZXR1cm4gd2luZG93ICYmIGRvY3VtZW50ICYmIGRvY3VtZW50LmFsbCAmJiAhd2luZG93LmF0b2I7XG59KTtcblxudmFyIGdldEVsZW1lbnQgPSAoZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vID0ge307XG5cblx0cmV0dXJuIGZ1bmN0aW9uKHNlbGVjdG9yKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vW3NlbGVjdG9yXSA9PT0gXCJ1bmRlZmluZWRcIikge1xuXHRcdFx0dmFyIHN0eWxlVGFyZ2V0ID0gZm4uY2FsbCh0aGlzLCBzZWxlY3Rvcik7XG5cdFx0XHQvLyBTcGVjaWFsIGNhc2UgdG8gcmV0dXJuIGhlYWQgb2YgaWZyYW1lIGluc3RlYWQgb2YgaWZyYW1lIGl0c2VsZlxuXHRcdFx0aWYgKHN0eWxlVGFyZ2V0IGluc3RhbmNlb2Ygd2luZG93LkhUTUxJRnJhbWVFbGVtZW50KSB7XG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Ly8gVGhpcyB3aWxsIHRocm93IGFuIGV4Y2VwdGlvbiBpZiBhY2Nlc3MgdG8gaWZyYW1lIGlzIGJsb2NrZWRcblx0XHRcdFx0XHQvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG5cdFx0XHRcdH0gY2F0Y2goZSkge1xuXHRcdFx0XHRcdHN0eWxlVGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0bWVtb1tzZWxlY3Rvcl0gPSBzdHlsZVRhcmdldDtcblx0XHR9XG5cdFx0cmV0dXJuIG1lbW9bc2VsZWN0b3JdXG5cdH07XG59KShmdW5jdGlvbiAodGFyZ2V0KSB7XG5cdHJldHVybiBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldClcbn0pO1xuXG52YXIgc2luZ2xldG9uID0gbnVsbDtcbnZhclx0c2luZ2xldG9uQ291bnRlciA9IDA7XG52YXJcdHN0eWxlc0luc2VydGVkQXRUb3AgPSBbXTtcblxudmFyXHRmaXhVcmxzID0gcmVxdWlyZShcIi4vdXJsc1wiKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihsaXN0LCBvcHRpb25zKSB7XG5cdGlmICh0eXBlb2YgREVCVUcgIT09IFwidW5kZWZpbmVkXCIgJiYgREVCVUcpIHtcblx0XHRpZiAodHlwZW9mIGRvY3VtZW50ICE9PSBcIm9iamVjdFwiKSB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgc3R5bGUtbG9hZGVyIGNhbm5vdCBiZSB1c2VkIGluIGEgbm9uLWJyb3dzZXIgZW52aXJvbm1lbnRcIik7XG5cdH1cblxuXHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRvcHRpb25zLmF0dHJzID0gdHlwZW9mIG9wdGlvbnMuYXR0cnMgPT09IFwib2JqZWN0XCIgPyBvcHRpb25zLmF0dHJzIDoge307XG5cblx0Ly8gRm9yY2Ugc2luZ2xlLXRhZyBzb2x1dGlvbiBvbiBJRTYtOSwgd2hpY2ggaGFzIGEgaGFyZCBsaW1pdCBvbiB0aGUgIyBvZiA8c3R5bGU+XG5cdC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2Vcblx0aWYgKCFvcHRpb25zLnNpbmdsZXRvbiAmJiB0eXBlb2Ygb3B0aW9ucy5zaW5nbGV0b24gIT09IFwiYm9vbGVhblwiKSBvcHRpb25zLnNpbmdsZXRvbiA9IGlzT2xkSUUoKTtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSA8aGVhZD4gZWxlbWVudFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0SW50bykgb3B0aW9ucy5pbnNlcnRJbnRvID0gXCJoZWFkXCI7XG5cblx0Ly8gQnkgZGVmYXVsdCwgYWRkIDxzdHlsZT4gdGFncyB0byB0aGUgYm90dG9tIG9mIHRoZSB0YXJnZXRcblx0aWYgKCFvcHRpb25zLmluc2VydEF0KSBvcHRpb25zLmluc2VydEF0ID0gXCJib3R0b21cIjtcblxuXHR2YXIgc3R5bGVzID0gbGlzdFRvU3R5bGVzKGxpc3QsIG9wdGlvbnMpO1xuXG5cdGFkZFN0eWxlc1RvRG9tKHN0eWxlcywgb3B0aW9ucyk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZSAobmV3TGlzdCkge1xuXHRcdHZhciBtYXlSZW1vdmUgPSBbXTtcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHN0eWxlc1tpXTtcblx0XHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0XHRkb21TdHlsZS5yZWZzLS07XG5cdFx0XHRtYXlSZW1vdmUucHVzaChkb21TdHlsZSk7XG5cdFx0fVxuXG5cdFx0aWYobmV3TGlzdCkge1xuXHRcdFx0dmFyIG5ld1N0eWxlcyA9IGxpc3RUb1N0eWxlcyhuZXdMaXN0LCBvcHRpb25zKTtcblx0XHRcdGFkZFN0eWxlc1RvRG9tKG5ld1N0eWxlcywgb3B0aW9ucyk7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtYXlSZW1vdmUubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBkb21TdHlsZSA9IG1heVJlbW92ZVtpXTtcblxuXHRcdFx0aWYoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSBkb21TdHlsZS5wYXJ0c1tqXSgpO1xuXG5cdFx0XHRcdGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF07XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcywgb3B0aW9ucykge1xuXHRmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdO1xuXG5cdFx0aWYoZG9tU3R5bGUpIHtcblx0XHRcdGRvbVN0eWxlLnJlZnMrKztcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzW2pdKGl0ZW0ucGFydHNbal0pO1xuXHRcdFx0fVxuXG5cdFx0XHRmb3IoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuXHRcdFx0XHRkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0sIG9wdGlvbnMpKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBhcnRzID0gW107XG5cblx0XHRcdGZvcih2YXIgaiA9IDA7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXG5cdFx0XHRzdHlsZXNJbkRvbVtpdGVtLmlkXSA9IHtpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzfTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChsaXN0LCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZXMgPSBbXTtcblx0dmFyIG5ld1N0eWxlcyA9IHt9O1xuXG5cdGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuXHRcdHZhciBpdGVtID0gbGlzdFtpXTtcblx0XHR2YXIgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcblx0XHR2YXIgY3NzID0gaXRlbVsxXTtcblx0XHR2YXIgbWVkaWEgPSBpdGVtWzJdO1xuXHRcdHZhciBzb3VyY2VNYXAgPSBpdGVtWzNdO1xuXHRcdHZhciBwYXJ0ID0ge2NzczogY3NzLCBtZWRpYTogbWVkaWEsIHNvdXJjZU1hcDogc291cmNlTWFwfTtcblxuXHRcdGlmKCFuZXdTdHlsZXNbaWRdKSBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0ge2lkOiBpZCwgcGFydHM6IFtwYXJ0XX0pO1xuXHRcdGVsc2UgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpO1xuXHR9XG5cblx0cmV0dXJuIHN0eWxlcztcbn1cblxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50IChvcHRpb25zLCBzdHlsZSkge1xuXHR2YXIgdGFyZ2V0ID0gZ2V0RWxlbWVudChvcHRpb25zLmluc2VydEludG8pXG5cblx0aWYgKCF0YXJnZXQpIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZG4ndCBmaW5kIGEgc3R5bGUgdGFyZ2V0LiBUaGlzIHByb2JhYmx5IG1lYW5zIHRoYXQgdGhlIHZhbHVlIGZvciB0aGUgJ2luc2VydEludG8nIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcblx0fVxuXG5cdHZhciBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCA9IHN0eWxlc0luc2VydGVkQXRUb3Bbc3R5bGVzSW5zZXJ0ZWRBdFRvcC5sZW5ndGggLSAxXTtcblxuXHRpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJ0b3BcIikge1xuXHRcdGlmICghbGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3ApIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIHRhcmdldC5maXJzdENoaWxkKTtcblx0XHR9IGVsc2UgaWYgKGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKSB7XG5cdFx0XHR0YXJnZXQuaW5zZXJ0QmVmb3JlKHN0eWxlLCBsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcC5uZXh0U2libGluZyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdFx0fVxuXHRcdHN0eWxlc0luc2VydGVkQXRUb3AucHVzaChzdHlsZSk7XG5cdH0gZWxzZSBpZiAob3B0aW9ucy5pbnNlcnRBdCA9PT0gXCJib3R0b21cIikge1xuXHRcdHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG5cdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMuaW5zZXJ0QXQgPT09IFwib2JqZWN0XCIgJiYgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpIHtcblx0XHR2YXIgbmV4dFNpYmxpbmcgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50byArIFwiIFwiICsgb3B0aW9ucy5pbnNlcnRBdC5iZWZvcmUpO1xuXHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIG5leHRTaWJsaW5nKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJbU3R5bGUgTG9hZGVyXVxcblxcbiBJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0JyAoJ29wdGlvbnMuaW5zZXJ0QXQnKSBmb3VuZC5cXG4gTXVzdCBiZSAndG9wJywgJ2JvdHRvbScsIG9yIE9iamVjdC5cXG4gKGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrLWNvbnRyaWIvc3R5bGUtbG9hZGVyI2luc2VydGF0KVxcblwiKTtcblx0fVxufVxuXG5mdW5jdGlvbiByZW1vdmVTdHlsZUVsZW1lbnQgKHN0eWxlKSB7XG5cdGlmIChzdHlsZS5wYXJlbnROb2RlID09PSBudWxsKSByZXR1cm4gZmFsc2U7XG5cdHN0eWxlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGUpO1xuXG5cdHZhciBpZHggPSBzdHlsZXNJbnNlcnRlZEF0VG9wLmluZGV4T2Yoc3R5bGUpO1xuXHRpZihpZHggPj0gMCkge1xuXHRcdHN0eWxlc0luc2VydGVkQXRUb3Auc3BsaWNlKGlkeCwgMSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cblx0YWRkQXR0cnMoc3R5bGUsIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgc3R5bGUpO1xuXG5cdHJldHVybiBzdHlsZTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTGlua0VsZW1lbnQgKG9wdGlvbnMpIHtcblx0dmFyIGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcblxuXHRvcHRpb25zLmF0dHJzLnR5cGUgPSBcInRleHQvY3NzXCI7XG5cdG9wdGlvbnMuYXR0cnMucmVsID0gXCJzdHlsZXNoZWV0XCI7XG5cblx0YWRkQXR0cnMobGluaywgb3B0aW9ucy5hdHRycyk7XG5cdGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zLCBsaW5rKTtcblxuXHRyZXR1cm4gbGluaztcbn1cblxuZnVuY3Rpb24gYWRkQXR0cnMgKGVsLCBhdHRycykge1xuXHRPYmplY3Qua2V5cyhhdHRycykuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG5cdFx0ZWwuc2V0QXR0cmlidXRlKGtleSwgYXR0cnNba2V5XSk7XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBhZGRTdHlsZSAob2JqLCBvcHRpb25zKSB7XG5cdHZhciBzdHlsZSwgdXBkYXRlLCByZW1vdmUsIHJlc3VsdDtcblxuXHQvLyBJZiBhIHRyYW5zZm9ybSBmdW5jdGlvbiB3YXMgZGVmaW5lZCwgcnVuIGl0IG9uIHRoZSBjc3Ncblx0aWYgKG9wdGlvbnMudHJhbnNmb3JtICYmIG9iai5jc3MpIHtcblx0ICAgIHJlc3VsdCA9IG9wdGlvbnMudHJhbnNmb3JtKG9iai5jc3MpO1xuXG5cdCAgICBpZiAocmVzdWx0KSB7XG5cdCAgICBcdC8vIElmIHRyYW5zZm9ybSByZXR1cm5zIGEgdmFsdWUsIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIG9yaWdpbmFsIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgcnVubmluZyBydW50aW1lIHRyYW5zZm9ybWF0aW9ucyBvbiB0aGUgY3NzLlxuXHQgICAgXHRvYmouY3NzID0gcmVzdWx0O1xuXHQgICAgfSBlbHNlIHtcblx0ICAgIFx0Ly8gSWYgdGhlIHRyYW5zZm9ybSBmdW5jdGlvbiByZXR1cm5zIGEgZmFsc3kgdmFsdWUsIGRvbid0IGFkZCB0aGlzIGNzcy5cblx0ICAgIFx0Ly8gVGhpcyBhbGxvd3MgY29uZGl0aW9uYWwgbG9hZGluZyBvZiBjc3Ncblx0ICAgIFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHQgICAgXHRcdC8vIG5vb3Bcblx0ICAgIFx0fTtcblx0ICAgIH1cblx0fVxuXG5cdGlmIChvcHRpb25zLnNpbmdsZXRvbikge1xuXHRcdHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrO1xuXG5cdFx0c3R5bGUgPSBzaW5nbGV0b24gfHwgKHNpbmdsZXRvbiA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKSk7XG5cblx0XHR1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcblx0XHRyZW1vdmUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIHRydWUpO1xuXG5cdH0gZWxzZSBpZiAoXG5cdFx0b2JqLnNvdXJjZU1hcCAmJlxuXHRcdHR5cGVvZiBVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBVUkwuY3JlYXRlT2JqZWN0VVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLnJldm9rZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIEJsb2IgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBidG9hID09PSBcImZ1bmN0aW9uXCJcblx0KSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVMaW5rRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSB1cGRhdGVMaW5rLmJpbmQobnVsbCwgc3R5bGUsIG9wdGlvbnMpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cblx0XHRcdGlmKHN0eWxlLmhyZWYpIFVSTC5yZXZva2VPYmplY3RVUkwoc3R5bGUuaHJlZik7XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRzdHlsZSA9IGNyZWF0ZVN0eWxlRWxlbWVudChvcHRpb25zKTtcblx0XHR1cGRhdGUgPSBhcHBseVRvVGFnLmJpbmQobnVsbCwgc3R5bGUpO1xuXHRcdHJlbW92ZSA9IGZ1bmN0aW9uICgpIHtcblx0XHRcdHJlbW92ZVN0eWxlRWxlbWVudChzdHlsZSk7XG5cdFx0fTtcblx0fVxuXG5cdHVwZGF0ZShvYmopO1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGVTdHlsZSAobmV3T2JqKSB7XG5cdFx0aWYgKG5ld09iaikge1xuXHRcdFx0aWYgKFxuXHRcdFx0XHRuZXdPYmouY3NzID09PSBvYmouY3NzICYmXG5cdFx0XHRcdG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG5cdFx0XHRcdG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXBcblx0XHRcdCkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdHVwZGF0ZShvYmogPSBuZXdPYmopO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZW1vdmUoKTtcblx0XHR9XG5cdH07XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG5cdHZhciB0ZXh0U3RvcmUgPSBbXTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gKGluZGV4LCByZXBsYWNlbWVudCkge1xuXHRcdHRleHRTdG9yZVtpbmRleF0gPSByZXBsYWNlbWVudDtcblxuXHRcdHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJ1xcbicpO1xuXHR9O1xufSkoKTtcblxuZnVuY3Rpb24gYXBwbHlUb1NpbmdsZXRvblRhZyAoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuXHR2YXIgY3NzID0gcmVtb3ZlID8gXCJcIiA6IG9iai5jc3M7XG5cblx0aWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSByZXBsYWNlVGV4dChpbmRleCwgY3NzKTtcblx0fSBlbHNlIHtcblx0XHR2YXIgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG5cdFx0dmFyIGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXNbaW5kZXhdKSBzdHlsZS5yZW1vdmVDaGlsZChjaGlsZE5vZGVzW2luZGV4XSk7XG5cblx0XHRpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcblx0XHRcdHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0eWxlLmFwcGVuZENoaWxkKGNzc05vZGUpO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBhcHBseVRvVGFnIChzdHlsZSwgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgbWVkaWEgPSBvYmoubWVkaWE7XG5cblx0aWYobWVkaWEpIHtcblx0XHRzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSlcblx0fVxuXG5cdGlmKHN0eWxlLnN0eWxlU2hlZXQpIHtcblx0XHRzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG5cdH0gZWxzZSB7XG5cdFx0d2hpbGUoc3R5bGUuZmlyc3RDaGlsZCkge1xuXHRcdFx0c3R5bGUucmVtb3ZlQ2hpbGQoc3R5bGUuZmlyc3RDaGlsZCk7XG5cdFx0fVxuXG5cdFx0c3R5bGUuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG5cdH1cbn1cblxuZnVuY3Rpb24gdXBkYXRlTGluayAobGluaywgb3B0aW9ucywgb2JqKSB7XG5cdHZhciBjc3MgPSBvYmouY3NzO1xuXHR2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcDtcblxuXHQvKlxuXHRcdElmIGNvbnZlcnRUb0Fic29sdXRlVXJscyBpc24ndCBkZWZpbmVkLCBidXQgc291cmNlbWFwcyBhcmUgZW5hYmxlZFxuXHRcdGFuZCB0aGVyZSBpcyBubyBwdWJsaWNQYXRoIGRlZmluZWQgdGhlbiBsZXRzIHR1cm4gY29udmVydFRvQWJzb2x1dGVVcmxzXG5cdFx0b24gYnkgZGVmYXVsdC4gIE90aGVyd2lzZSBkZWZhdWx0IHRvIHRoZSBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgb3B0aW9uXG5cdFx0ZGlyZWN0bHlcblx0Ki9cblx0dmFyIGF1dG9GaXhVcmxzID0gb3B0aW9ucy5jb252ZXJ0VG9BYnNvbHV0ZVVybHMgPT09IHVuZGVmaW5lZCAmJiBzb3VyY2VNYXA7XG5cblx0aWYgKG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzIHx8IGF1dG9GaXhVcmxzKSB7XG5cdFx0Y3NzID0gZml4VXJscyhjc3MpO1xuXHR9XG5cblx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG5cdFx0Y3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuXHR9XG5cblx0dmFyIGJsb2IgPSBuZXcgQmxvYihbY3NzXSwgeyB0eXBlOiBcInRleHQvY3NzXCIgfSk7XG5cblx0dmFyIG9sZFNyYyA9IGxpbmsuaHJlZjtcblxuXHRsaW5rLmhyZWYgPSBVUkwuY3JlYXRlT2JqZWN0VVJMKGJsb2IpO1xuXG5cdGlmKG9sZFNyYykgVVJMLnJldm9rZU9iamVjdFVSTChvbGRTcmMpO1xufVxuIiwiXG4vKipcbiAqIFdoZW4gc291cmNlIG1hcHMgYXJlIGVuYWJsZWQsIGBzdHlsZS1sb2FkZXJgIHVzZXMgYSBsaW5rIGVsZW1lbnQgd2l0aCBhIGRhdGEtdXJpIHRvXG4gKiBlbWJlZCB0aGUgY3NzIG9uIHRoZSBwYWdlLiBUaGlzIGJyZWFrcyBhbGwgcmVsYXRpdmUgdXJscyBiZWNhdXNlIG5vdyB0aGV5IGFyZSByZWxhdGl2ZSB0byBhXG4gKiBidW5kbGUgaW5zdGVhZCBvZiB0aGUgY3VycmVudCBwYWdlLlxuICpcbiAqIE9uZSBzb2x1dGlvbiBpcyB0byBvbmx5IHVzZSBmdWxsIHVybHMsIGJ1dCB0aGF0IG1heSBiZSBpbXBvc3NpYmxlLlxuICpcbiAqIEluc3RlYWQsIHRoaXMgZnVuY3Rpb24gXCJmaXhlc1wiIHRoZSByZWxhdGl2ZSB1cmxzIHRvIGJlIGFic29sdXRlIGFjY29yZGluZyB0byB0aGUgY3VycmVudCBwYWdlIGxvY2F0aW9uLlxuICpcbiAqIEEgcnVkaW1lbnRhcnkgdGVzdCBzdWl0ZSBpcyBsb2NhdGVkIGF0IGB0ZXN0L2ZpeFVybHMuanNgIGFuZCBjYW4gYmUgcnVuIHZpYSB0aGUgYG5wbSB0ZXN0YCBjb21tYW5kLlxuICpcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChjc3MpIHtcbiAgLy8gZ2V0IGN1cnJlbnQgbG9jYXRpb25cbiAgdmFyIGxvY2F0aW9uID0gdHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiAmJiB3aW5kb3cubG9jYXRpb247XG5cbiAgaWYgKCFsb2NhdGlvbikge1xuICAgIHRocm93IG5ldyBFcnJvcihcImZpeFVybHMgcmVxdWlyZXMgd2luZG93LmxvY2F0aW9uXCIpO1xuICB9XG5cblx0Ly8gYmxhbmsgb3IgbnVsbD9cblx0aWYgKCFjc3MgfHwgdHlwZW9mIGNzcyAhPT0gXCJzdHJpbmdcIikge1xuXHQgIHJldHVybiBjc3M7XG4gIH1cblxuICB2YXIgYmFzZVVybCA9IGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICsgbG9jYXRpb24uaG9zdDtcbiAgdmFyIGN1cnJlbnREaXIgPSBiYXNlVXJsICsgbG9jYXRpb24ucGF0aG5hbWUucmVwbGFjZSgvXFwvW15cXC9dKiQvLCBcIi9cIik7XG5cblx0Ly8gY29udmVydCBlYWNoIHVybCguLi4pXG5cdC8qXG5cdFRoaXMgcmVndWxhciBleHByZXNzaW9uIGlzIGp1c3QgYSB3YXkgdG8gcmVjdXJzaXZlbHkgbWF0Y2ggYnJhY2tldHMgd2l0aGluXG5cdGEgc3RyaW5nLlxuXG5cdCAvdXJsXFxzKlxcKCAgPSBNYXRjaCBvbiB0aGUgd29yZCBcInVybFwiIHdpdGggYW55IHdoaXRlc3BhY2UgYWZ0ZXIgaXQgYW5kIHRoZW4gYSBwYXJlbnNcblx0ICAgKCAgPSBTdGFydCBhIGNhcHR1cmluZyBncm91cFxuXHQgICAgICg/OiAgPSBTdGFydCBhIG5vbi1jYXB0dXJpbmcgZ3JvdXBcblx0ICAgICAgICAgW14pKF0gID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgXFwoICA9IE1hdGNoIGEgc3RhcnQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICg/OiAgPSBTdGFydCBhbm90aGVyIG5vbi1jYXB0dXJpbmcgZ3JvdXBzXG5cdCAgICAgICAgICAgICAgICAgW14pKF0rICA9IE1hdGNoIGFueXRoaW5nIHRoYXQgaXNuJ3QgYSBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgIHwgID0gT1Jcblx0ICAgICAgICAgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgICAgICAgICBbXikoXSogID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgXFwpICA9IE1hdGNoIGEgZW5kIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICApICA9IEVuZCBHcm91cFxuICAgICAgICAgICAgICAqXFwpID0gTWF0Y2ggYW55dGhpbmcgYW5kIHRoZW4gYSBjbG9zZSBwYXJlbnNcbiAgICAgICAgICApICA9IENsb3NlIG5vbi1jYXB0dXJpbmcgZ3JvdXBcbiAgICAgICAgICAqICA9IE1hdGNoIGFueXRoaW5nXG4gICAgICAgKSAgPSBDbG9zZSBjYXB0dXJpbmcgZ3JvdXBcblx0IFxcKSAgPSBNYXRjaCBhIGNsb3NlIHBhcmVuc1xuXG5cdCAvZ2kgID0gR2V0IGFsbCBtYXRjaGVzLCBub3QgdGhlIGZpcnN0LiAgQmUgY2FzZSBpbnNlbnNpdGl2ZS5cblx0ICovXG5cdHZhciBmaXhlZENzcyA9IGNzcy5yZXBsYWNlKC91cmxcXHMqXFwoKCg/OlteKShdfFxcKCg/OlteKShdK3xcXChbXikoXSpcXCkpKlxcKSkqKVxcKS9naSwgZnVuY3Rpb24oZnVsbE1hdGNoLCBvcmlnVXJsKSB7XG5cdFx0Ly8gc3RyaXAgcXVvdGVzIChpZiB0aGV5IGV4aXN0KVxuXHRcdHZhciB1bnF1b3RlZE9yaWdVcmwgPSBvcmlnVXJsXG5cdFx0XHQudHJpbSgpXG5cdFx0XHQucmVwbGFjZSgvXlwiKC4qKVwiJC8sIGZ1bmN0aW9uKG8sICQxKXsgcmV0dXJuICQxOyB9KVxuXHRcdFx0LnJlcGxhY2UoL14nKC4qKSckLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pO1xuXG5cdFx0Ly8gYWxyZWFkeSBhIGZ1bGwgdXJsPyBubyBjaGFuZ2Vcblx0XHRpZiAoL14oI3xkYXRhOnxodHRwOlxcL1xcL3xodHRwczpcXC9cXC98ZmlsZTpcXC9cXC9cXC8pL2kudGVzdCh1bnF1b3RlZE9yaWdVcmwpKSB7XG5cdFx0ICByZXR1cm4gZnVsbE1hdGNoO1xuXHRcdH1cblxuXHRcdC8vIGNvbnZlcnQgdGhlIHVybCB0byBhIGZ1bGwgdXJsXG5cdFx0dmFyIG5ld1VybDtcblxuXHRcdGlmICh1bnF1b3RlZE9yaWdVcmwuaW5kZXhPZihcIi8vXCIpID09PSAwKSB7XG5cdFx0ICBcdC8vVE9ETzogc2hvdWxkIHdlIGFkZCBwcm90b2NvbD9cblx0XHRcdG5ld1VybCA9IHVucXVvdGVkT3JpZ1VybDtcblx0XHR9IGVsc2UgaWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiL1wiKSA9PT0gMCkge1xuXHRcdFx0Ly8gcGF0aCBzaG91bGQgYmUgcmVsYXRpdmUgdG8gdGhlIGJhc2UgdXJsXG5cdFx0XHRuZXdVcmwgPSBiYXNlVXJsICsgdW5xdW90ZWRPcmlnVXJsOyAvLyBhbHJlYWR5IHN0YXJ0cyB3aXRoICcvJ1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byBjdXJyZW50IGRpcmVjdG9yeVxuXHRcdFx0bmV3VXJsID0gY3VycmVudERpciArIHVucXVvdGVkT3JpZ1VybC5yZXBsYWNlKC9eXFwuXFwvLywgXCJcIik7IC8vIFN0cmlwIGxlYWRpbmcgJy4vJ1xuXHRcdH1cblxuXHRcdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgdXJsKC4uLilcblx0XHRyZXR1cm4gXCJ1cmwoXCIgKyBKU09OLnN0cmluZ2lmeShuZXdVcmwpICsgXCIpXCI7XG5cdH0pO1xuXG5cdC8vIHNlbmQgYmFjayB0aGUgZml4ZWQgY3NzXG5cdHJldHVybiBmaXhlZENzcztcbn07XG4iLCJwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uKCkge1xuXHRkZWxldGUgcmVxdWlyZS5jYWNoZVttb2R1bGUuaWRdO1xuXHRpZih0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5tb2NoYVBoYW50b21KUylcblx0XHRtb2NoYVBoYW50b21KUy5ydW4oKTtcblx0ZWxzZVxuXHRcdG1vY2hhLnJ1bigpO1xufSk7XG4iLCJpZiAoISBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChcIm1vY2hhXCIpKSB7IGRvY3VtZW50LndyaXRlKFwiPGRpdiBpZD1cXFwibW9jaGFcXFwiPjwvZGl2PlwiKTsgfVxuXG5yZXF1aXJlKFwiIXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyIW1vY2hhL21vY2hhLmNzc1wiKTtcbnJlcXVpcmUoXCIhc2NyaXB0LWxvYWRlciFtb2NoYS9tb2NoYS5qc1wiKTtcbiIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCJtb2R1bGUuZXhwb3J0cyA9IFwiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFxcXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1xcXCIrbytcXFwiJ1xcXCIpO3Rocm93IGYuY29kZT1cXFwiTU9EVUxFX05PVF9GT1VORFxcXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cXFwiZnVuY3Rpb25cXFwiJiZyZXF1aXJlO2Zvcih2YXIgbz0wO288ci5sZW5ndGg7bysrKXMocltvXSk7cmV0dXJuIHN9KSh7MTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qIGVzbGludCBuby11bnVzZWQtdmFyczogb2ZmICovXFxuLyogZXNsaW50LWVudiBjb21tb25qcyAqL1xcblxcbi8qKlxcbiAqIFNoaW0gcHJvY2Vzcy5zdGRvdXQuXFxuICovXFxuXFxucHJvY2Vzcy5zdGRvdXQgPSByZXF1aXJlKCdicm93c2VyLXN0ZG91dCcpKHtsZXZlbDogZmFsc2V9KTtcXG5cXG52YXIgTW9jaGEgPSByZXF1aXJlKCcuL2xpYi9tb2NoYScpO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhIE1vY2hhIGluc3RhbmNlLlxcbiAqXFxuICogQHJldHVybiB7dW5kZWZpbmVkfVxcbiAqL1xcblxcbnZhciBtb2NoYSA9IG5ldyBNb2NoYSh7IHJlcG9ydGVyOiAnaHRtbCcgfSk7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuXFxudmFyIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMgPSBbXTtcXG5cXG52YXIgb3JpZ2luYWxPbmVycm9ySGFuZGxlciA9IGdsb2JhbC5vbmVycm9yO1xcblxcbi8qKlxcbiAqIFJlbW92ZSB1bmNhdWdodEV4Y2VwdGlvbiBsaXN0ZW5lci5cXG4gKiBSZXZlcnQgdG8gb3JpZ2luYWwgb25lcnJvciBoYW5kbGVyIGlmIHByZXZpb3VzbHkgZGVmaW5lZC5cXG4gKi9cXG5cXG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24gKGUsIGZuKSB7XFxuICBpZiAoZSA9PT0gJ3VuY2F1Z2h0RXhjZXB0aW9uJykge1xcbiAgICBpZiAob3JpZ2luYWxPbmVycm9ySGFuZGxlcikge1xcbiAgICAgIGdsb2JhbC5vbmVycm9yID0gb3JpZ2luYWxPbmVycm9ySGFuZGxlcjtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBnbG9iYWwub25lcnJvciA9IGZ1bmN0aW9uICgpIHt9O1xcbiAgICB9XFxuICAgIHZhciBpID0gdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5pbmRleE9mKGZuKTtcXG4gICAgaWYgKGkgIT09IC0xKSB7XFxuICAgICAgdW5jYXVnaHRFeGNlcHRpb25IYW5kbGVycy5zcGxpY2UoaSwgMSk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEltcGxlbWVudHMgdW5jYXVnaHRFeGNlcHRpb24gbGlzdGVuZXIuXFxuICovXFxuXFxucHJvY2Vzcy5vbiA9IGZ1bmN0aW9uIChlLCBmbikge1xcbiAgaWYgKGUgPT09ICd1bmNhdWdodEV4Y2VwdGlvbicpIHtcXG4gICAgZ2xvYmFsLm9uZXJyb3IgPSBmdW5jdGlvbiAoZXJyLCB1cmwsIGxpbmUpIHtcXG4gICAgICBmbihuZXcgRXJyb3IoZXJyICsgJyAoJyArIHVybCArICc6JyArIGxpbmUgKyAnKScpKTtcXG4gICAgICByZXR1cm4gIW1vY2hhLmFsbG93VW5jYXVnaHQ7XFxuICAgIH07XFxuICAgIHVuY2F1Z2h0RXhjZXB0aW9uSGFuZGxlcnMucHVzaChmbik7XFxuICB9XFxufTtcXG5cXG4vLyBUaGUgQkREIFVJIGlzIHJlZ2lzdGVyZWQgYnkgZGVmYXVsdCwgYnV0IG5vIFVJIHdpbGwgYmUgZnVuY3Rpb25hbCBpbiB0aGVcXG4vLyBicm93c2VyIHdpdGhvdXQgYW4gZXhwbGljaXQgY2FsbCB0byB0aGUgb3ZlcnJpZGRlbiBgbW9jaGEudWlgIChzZWUgYmVsb3cpLlxcbi8vIEVuc3VyZSB0aGF0IHRoaXMgZGVmYXVsdCBVSSBkb2VzIG5vdCBleHBvc2UgaXRzIG1ldGhvZHMgdG8gdGhlIGdsb2JhbCBzY29wZS5cXG5tb2NoYS5zdWl0ZS5yZW1vdmVBbGxMaXN0ZW5lcnMoJ3ByZS1yZXF1aXJlJyk7XFxuXFxudmFyIGltbWVkaWF0ZVF1ZXVlID0gW107XFxudmFyIGltbWVkaWF0ZVRpbWVvdXQ7XFxuXFxuZnVuY3Rpb24gdGltZXNsaWNlICgpIHtcXG4gIHZhciBpbW1lZGlhdGVTdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xcbiAgd2hpbGUgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCAmJiAobmV3IERhdGUoKS5nZXRUaW1lKCkgLSBpbW1lZGlhdGVTdGFydCkgPCAxMDApIHtcXG4gICAgaW1tZWRpYXRlUXVldWUuc2hpZnQoKSgpO1xcbiAgfVxcbiAgaWYgKGltbWVkaWF0ZVF1ZXVlLmxlbmd0aCkge1xcbiAgICBpbW1lZGlhdGVUaW1lb3V0ID0gc2V0VGltZW91dCh0aW1lc2xpY2UsIDApO1xcbiAgfSBlbHNlIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IG51bGw7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEhpZ2gtcGVyZm9ybWFuY2Ugb3ZlcnJpZGUgb2YgUnVubmVyLmltbWVkaWF0ZWx5LlxcbiAqL1xcblxcbk1vY2hhLlJ1bm5lci5pbW1lZGlhdGVseSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xcbiAgaW1tZWRpYXRlUXVldWUucHVzaChjYWxsYmFjayk7XFxuICBpZiAoIWltbWVkaWF0ZVRpbWVvdXQpIHtcXG4gICAgaW1tZWRpYXRlVGltZW91dCA9IHNldFRpbWVvdXQodGltZXNsaWNlLCAwKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZ1bmN0aW9uIHRvIGFsbG93IGFzc2VydGlvbiBsaWJyYXJpZXMgdG8gdGhyb3cgZXJyb3JzIGRpcmVjdGx5IGludG8gbW9jaGEuXFxuICogVGhpcyBpcyB1c2VmdWwgd2hlbiBydW5uaW5nIHRlc3RzIGluIGEgYnJvd3NlciBiZWNhdXNlIHdpbmRvdy5vbmVycm9yIHdpbGxcXG4gKiBvbmx5IHJlY2VpdmUgdGhlICdtZXNzYWdlJyBhdHRyaWJ1dGUgb2YgdGhlIEVycm9yLlxcbiAqL1xcbm1vY2hhLnRocm93RXJyb3IgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICB1bmNhdWdodEV4Y2VwdGlvbkhhbmRsZXJzLmZvckVhY2goZnVuY3Rpb24gKGZuKSB7XFxuICAgIGZuKGVycik7XFxuICB9KTtcXG4gIHRocm93IGVycjtcXG59O1xcblxcbi8qKlxcbiAqIE92ZXJyaWRlIHVpIHRvIGVuc3VyZSB0aGF0IHRoZSB1aSBmdW5jdGlvbnMgYXJlIGluaXRpYWxpemVkLlxcbiAqIE5vcm1hbGx5IHRoaXMgd291bGQgaGFwcGVuIGluIE1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMuXFxuICovXFxuXFxubW9jaGEudWkgPSBmdW5jdGlvbiAodWkpIHtcXG4gIE1vY2hhLnByb3RvdHlwZS51aS5jYWxsKHRoaXMsIHVpKTtcXG4gIHRoaXMuc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIG51bGwsIHRoaXMpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXR1cCBtb2NoYSB3aXRoIHRoZSBnaXZlbiBzZXR0aW5nIG9wdGlvbnMuXFxuICovXFxuXFxubW9jaGEuc2V0dXAgPSBmdW5jdGlvbiAob3B0cykge1xcbiAgaWYgKHR5cGVvZiBvcHRzID09PSAnc3RyaW5nJykge1xcbiAgICBvcHRzID0geyB1aTogb3B0cyB9O1xcbiAgfVxcbiAgZm9yICh2YXIgb3B0IGluIG9wdHMpIHtcXG4gICAgaWYgKG9wdHMuaGFzT3duUHJvcGVydHkob3B0KSkge1xcbiAgICAgIHRoaXNbb3B0XShvcHRzW29wdF0pO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBtb2NoYSwgcmV0dXJuaW5nIHRoZSBSdW5uZXIuXFxuICovXFxuXFxubW9jaGEucnVuID0gZnVuY3Rpb24gKGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IG1vY2hhLm9wdGlvbnM7XFxuICBtb2NoYS5nbG9iYWxzKCdsb2NhdGlvbicpO1xcblxcbiAgdmFyIHF1ZXJ5ID0gTW9jaGEudXRpbHMucGFyc2VRdWVyeShnbG9iYWwubG9jYXRpb24uc2VhcmNoIHx8ICcnKTtcXG4gIGlmIChxdWVyeS5ncmVwKSB7XFxuICAgIG1vY2hhLmdyZXAocXVlcnkuZ3JlcCk7XFxuICB9XFxuICBpZiAocXVlcnkuZmdyZXApIHtcXG4gICAgbW9jaGEuZmdyZXAocXVlcnkuZmdyZXApO1xcbiAgfVxcbiAgaWYgKHF1ZXJ5LmludmVydCkge1xcbiAgICBtb2NoYS5pbnZlcnQoKTtcXG4gIH1cXG5cXG4gIHJldHVybiBNb2NoYS5wcm90b3R5cGUucnVuLmNhbGwobW9jaGEsIGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgLy8gVGhlIERPTSBEb2N1bWVudCBpcyBub3QgYXZhaWxhYmxlIGluIFdlYiBXb3JrZXJzLlxcbiAgICB2YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XFxuICAgIGlmIChkb2N1bWVudCAmJiBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKSAmJiBvcHRpb25zLm5vSGlnaGxpZ2h0aW5nICE9PSB0cnVlKSB7XFxuICAgICAgTW9jaGEudXRpbHMuaGlnaGxpZ2h0VGFncygnY29kZScpO1xcbiAgICB9XFxuICAgIGlmIChmbikge1xcbiAgICAgIGZuKGVycik7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogRXhwb3NlIHRoZSBwcm9jZXNzIHNoaW0uXFxuICogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvcHVsbC85MTZcXG4gKi9cXG5cXG5Nb2NoYS5wcm9jZXNzID0gcHJvY2VzcztcXG5cXG4vKipcXG4gKiBFeHBvc2UgbW9jaGEuXFxuICovXFxuXFxuZ2xvYmFsLk1vY2hhID0gTW9jaGE7XFxuZ2xvYmFsLm1vY2hhID0gbW9jaGE7XFxuXFxuLy8gdGhpcyBhbGxvd3MgdGVzdC9hY2NlcHRhbmNlL3JlcXVpcmVkLXRva2Vucy5qcyB0byBwYXNzOyB0aHVzLFxcbi8vIHlvdSBjYW4gbm93IGRvIGBjb25zdCBkZXNjcmliZSA9IHJlcXVpcmUoJ21vY2hhJykuZGVzY3JpYmVgIGluIGFcXG4vLyBicm93c2VyIGNvbnRleHQgKGFzc3VtaW5nIGJyb3dzZXJpZmljYXRpb24pLiAgc2hvdWxkIGZpeCAjODgwXFxubW9kdWxlLmV4cG9ydHMgPSBnbG9iYWw7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9saWIvbW9jaGFcXFwiOjEzLFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImJyb3dzZXItc3Rkb3V0XFxcIjozOX1dLDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vLyBqdXN0IHN0dWIgb3V0IGdyb3dsXFxuXFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuLi91dGlscycpLm5vb3A7XFxuXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNn1dLDM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFByb2dyZXNzYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFByb2dyZXNzO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFByb2dyZXNzYCBpbmRpY2F0b3IuXFxuICovXFxuZnVuY3Rpb24gUHJvZ3Jlc3MgKCkge1xcbiAgdGhpcy5wZXJjZW50ID0gMDtcXG4gIHRoaXMuc2l6ZSgwKTtcXG4gIHRoaXMuZm9udFNpemUoMTEpO1xcbiAgdGhpcy5mb250KCdoZWx2ZXRpY2EsIGFyaWFsLCBzYW5zLXNlcmlmJyk7XFxufVxcblxcbi8qKlxcbiAqIFNldCBwcm9ncmVzcyBzaXplIHRvIGBzaXplYC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHNpemVcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgdGhpcy5fc2l6ZSA9IHNpemU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXh0IHRvIGB0ZXh0YC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IHRleHRcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLnRleHQgPSBmdW5jdGlvbiAodGV4dCkge1xcbiAgdGhpcy5fdGV4dCA9IHRleHQ7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBmb250IHNpemUgdG8gYHNpemVgLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge251bWJlcn0gc2l6ZVxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUuZm9udFNpemUgPSBmdW5jdGlvbiAoc2l6ZSkge1xcbiAgdGhpcy5fZm9udFNpemUgPSBzaXplO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgZm9udCB0byBgZmFtaWx5YC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBmYW1pbHlcXG4gKiBAcmV0dXJuIHtQcm9ncmVzc30gUHJvZ3Jlc3MgaW5zdGFuY2UuXFxuICovXFxuUHJvZ3Jlc3MucHJvdG90eXBlLmZvbnQgPSBmdW5jdGlvbiAoZmFtaWx5KSB7XFxuICB0aGlzLl9mb250ID0gZmFtaWx5O1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBVcGRhdGUgcGVyY2VudGFnZSB0byBgbmAuXFxuICpcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqIEByZXR1cm4ge1Byb2dyZXNzfSBQcm9ncmVzcyBpbnN0YW5jZS5cXG4gKi9cXG5Qcm9ncmVzcy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMucGVyY2VudCA9IG47XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIERyYXcgb24gYGN0eGAuXFxuICpcXG4gKiBAcGFyYW0ge0NhbnZhc1JlbmRlcmluZ0NvbnRleHQyZH0gY3R4XFxuICogQHJldHVybiB7UHJvZ3Jlc3N9IFByb2dyZXNzIGluc3RhbmNlLlxcbiAqL1xcblByb2dyZXNzLnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKGN0eCkge1xcbiAgdHJ5IHtcXG4gICAgdmFyIHBlcmNlbnQgPSBNYXRoLm1pbih0aGlzLnBlcmNlbnQsIDEwMCk7XFxuICAgIHZhciBzaXplID0gdGhpcy5fc2l6ZTtcXG4gICAgdmFyIGhhbGYgPSBzaXplIC8gMjtcXG4gICAgdmFyIHggPSBoYWxmO1xcbiAgICB2YXIgeSA9IGhhbGY7XFxuICAgIHZhciByYWQgPSBoYWxmIC0gMTtcXG4gICAgdmFyIGZvbnRTaXplID0gdGhpcy5fZm9udFNpemU7XFxuXFxuICAgIGN0eC5mb250ID0gZm9udFNpemUgKyAncHggJyArIHRoaXMuX2ZvbnQ7XFxuXFxuICAgIHZhciBhbmdsZSA9IE1hdGguUEkgKiAyICogKHBlcmNlbnQgLyAxMDApO1xcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUsIHNpemUpO1xcblxcbiAgICAvLyBvdXRlciBjaXJjbGVcXG4gICAgY3R4LnN0cm9rZVN0eWxlID0gJyM5ZjlmOWYnO1xcbiAgICBjdHguYmVnaW5QYXRoKCk7XFxuICAgIGN0eC5hcmMoeCwgeSwgcmFkLCAwLCBhbmdsZSwgZmFsc2UpO1xcbiAgICBjdHguc3Ryb2tlKCk7XFxuXFxuICAgIC8vIGlubmVyIGNpcmNsZVxcbiAgICBjdHguc3Ryb2tlU3R5bGUgPSAnI2VlZSc7XFxuICAgIGN0eC5iZWdpblBhdGgoKTtcXG4gICAgY3R4LmFyYyh4LCB5LCByYWQgLSAxLCAwLCBhbmdsZSwgdHJ1ZSk7XFxuICAgIGN0eC5zdHJva2UoKTtcXG5cXG4gICAgLy8gdGV4dFxcbiAgICB2YXIgdGV4dCA9IHRoaXMuX3RleHQgfHwgKHBlcmNlbnQgfCAwKSArICclJztcXG4gICAgdmFyIHcgPSBjdHgubWVhc3VyZVRleHQodGV4dCkud2lkdGg7XFxuXFxuICAgIGN0eC5maWxsVGV4dCh0ZXh0LCB4IC0gdyAvIDIgKyAxLCB5ICsgZm9udFNpemUgLyAyIC0gMSk7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgLy8gZG9uJ3QgZmFpbCBpZiB3ZSBjYW4ndCByZW5kZXIgcHJvZ3Jlc3NcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLmlzYXR0eSA9IGZ1bmN0aW9uIGlzYXR0eSAoKSB7XFxuICByZXR1cm4gdHJ1ZTtcXG59O1xcblxcbmV4cG9ydHMuZ2V0V2luZG93U2l6ZSA9IGZ1bmN0aW9uIGdldFdpbmRvd1NpemUgKCkge1xcbiAgaWYgKCdpbm5lckhlaWdodCcgaW4gZ2xvYmFsKSB7XFxuICAgIHJldHVybiBbZ2xvYmFsLmlubmVySGVpZ2h0LCBnbG9iYWwuaW5uZXJXaWR0aF07XFxuICB9XFxuICAvLyBJbiBhIFdlYiBXb3JrZXIsIHRoZSBET00gV2luZG93IGlzIG5vdCBhdmFpbGFibGUuXFxuICByZXR1cm4gWzY0MCwgNDgwXTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se31dLDU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIENvbnRleHRcXG4gKi9cXG4vKipcXG4gKiBFeHBvc2UgYENvbnRleHRgLlxcbiAqL1xcblxcbm1vZHVsZS5leHBvcnRzID0gQ29udGV4dDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBDb250ZXh0YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIENvbnRleHQgKCkge31cXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRoZSBjb250ZXh0IGBSdW5uYWJsZWAgdG8gYHJ1bm5hYmxlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7UnVubmFibGV9IHJ1bm5hYmxlXFxuICogQHJldHVybiB7Q29udGV4dH0gY29udGV4dFxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLnJ1bm5hYmxlID0gZnVuY3Rpb24gKHJ1bm5hYmxlKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3J1bm5hYmxlO1xcbiAgfVxcbiAgdGhpcy50ZXN0ID0gdGhpcy5fcnVubmFibGUgPSBydW5uYWJsZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCB0ZXN0IHRpbWVvdXQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS50aW1lb3V0KCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkudGltZW91dChtcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IHRpbWVvdXQgYGVuYWJsZWRgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBlbmFibGVkXFxuICogQHJldHVybiB7Q29udGV4dH0gc2VsZlxcbiAqL1xcbkNvbnRleHQucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5ydW5uYWJsZSgpLmVuYWJsZVRpbWVvdXRzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkuZW5hYmxlVGltZW91dHMoZW5hYmxlZCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgdGVzdCBzbG93bmVzcyB0aHJlc2hvbGQgYG1zYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge0NvbnRleHR9IHNlbGZcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5zbG93ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5zbG93KCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkuc2xvdyhtcyk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIE1hcmsgYSB0ZXN0IGFzIHNraXBwZWQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAdGhyb3dzIFBlbmRpbmdcXG4gKi9cXG5Db250ZXh0LnByb3RvdHlwZS5za2lwID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5ydW5uYWJsZSgpLnNraXAoKTtcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgYSBudW1iZXIgb2YgYWxsb3dlZCByZXRyaWVzIG9uIGZhaWxlZCB0ZXN0c1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ9IG5cXG4gKiBAcmV0dXJuIHtDb250ZXh0fSBzZWxmXFxuICovXFxuQ29udGV4dC5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMucnVubmFibGUoKS5yZXRyaWVzKCk7XFxuICB9XFxuICB0aGlzLnJ1bm5hYmxlKCkucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxufSx7fV0sNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgSG9va1xcbiAqXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSG9va2AuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBIb29rO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEhvb2tgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuIERlcml2ZWQgZnJvbVxcbiAqIGBSdW5uYWJsZWAuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBIb29rICh0aXRsZSwgZm4pIHtcXG4gIFJ1bm5hYmxlLmNhbGwodGhpcywgdGl0bGUsIGZuKTtcXG4gIHRoaXMudHlwZSA9ICdob29rJztcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBSdW5uYWJsZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKEhvb2ssIFJ1bm5hYmxlKTtcXG5cXG4vKipcXG4gKiBHZXQgb3Igc2V0IHRoZSB0ZXN0IGBlcnJgLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLkhvb2tcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7RXJyb3J9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Ib29rLnByb3RvdHlwZS5lcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICBlcnIgPSB0aGlzLl9lcnJvcjtcXG4gICAgdGhpcy5fZXJyb3IgPSBudWxsO1xcbiAgICByZXR1cm4gZXJyO1xcbiAgfVxcblxcbiAgdGhpcy5fZXJyb3IgPSBlcnI7XFxufTtcXG5cXG59LHtcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vdXRpbHNcXFwiOjM2fV0sNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogQkRELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgZGVzY3JpYmUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIGRlc2NyaWJlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgaXQoJ3Nob3VsZCByZXR1cm4gLTEgd2hlbiBub3QgcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqICAgICAgICAgICAgLy8gLi4uXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBpdCgnc2hvdWxkIHJldHVybiB0aGUgaW5kZXggd2hlbiBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgICAvLyAuLi5cXG4gKiAgICAgICAgICB9KTtcXG4gKiAgICAgICAgfSk7XFxuICogICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgXFxuICAgICAqIGFuZCBjYWxsYmFjayBgZm5gIGNvbnRhaW5pbmcgbmVzdGVkIHN1aXRlc1xcbiAgICAgKiBhbmQvb3IgdGVzdHMuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LmRlc2NyaWJlID0gY29udGV4dC5jb250ZXh0ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIFBlbmRpbmcgZGVzY3JpYmUuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhkZXNjcmliZSA9IGNvbnRleHQueGNvbnRleHQgPSBjb250ZXh0LmRlc2NyaWJlLnNraXAgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi5zdWl0ZS5za2lwKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZm5cXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSBzdWl0ZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuZGVzY3JpYmUub25seSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLm9ubHkoe1xcbiAgICAgICAgdGl0bGU6IHRpdGxlLFxcbiAgICAgICAgZmlsZTogZmlsZSxcXG4gICAgICAgIGZuOiBmblxcbiAgICAgIH0pO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRGVzY3JpYmUgYSBzcGVjaWZpY2F0aW9uIG9yIHRlc3QtY2FzZVxcbiAgICAgKiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBjYWxsYmFjayBgZm5gXFxuICAgICAqIGFjdGluZyBhcyBhIHRodW5rLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdCA9IGNvbnRleHQuc3BlY2lmeSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICB2YXIgc3VpdGUgPSBzdWl0ZXNbMF07XFxuICAgICAgaWYgKHN1aXRlLmlzUGVuZGluZygpKSB7XFxuICAgICAgICBmbiA9IG51bGw7XFxuICAgICAgfVxcbiAgICAgIHZhciB0ZXN0ID0gbmV3IFRlc3QodGl0bGUsIGZuKTtcXG4gICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgIHN1aXRlLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5pdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0Lml0KHRpdGxlLCBmbikpO1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnhpdCA9IGNvbnRleHQueHNwZWNpZnkgPSBjb250ZXh0Lml0LnNraXAgPSBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICByZXR1cm4gY29udGV4dC5pdCh0aXRsZSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBOdW1iZXIgb2YgYXR0ZW1wdHMgdG8gcmV0cnkuXFxuICAgICAqL1xcbiAgICBjb250ZXh0Lml0LnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgfTtcXG4gIH0pO1xcbn07XFxuXFxufSx7XFxcIi4uL3Rlc3RcXFwiOjM1LFxcXCIuL2NvbW1vblxcXCI6OH1dLDg6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgU3VpdGUgPSByZXF1aXJlKCcuLi9zdWl0ZScpO1xcblxcbi8qKlxcbiAqIEZ1bmN0aW9ucyBjb21tb24gdG8gbW9yZSB0aGFuIG9uZSBpbnRlcmZhY2UuXFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlW119IHN1aXRlc1xcbiAqIEBwYXJhbSB7Q29udGV4dH0gY29udGV4dFxcbiAqIEBwYXJhbSB7TW9jaGF9IG1vY2hhXFxuICogQHJldHVybiB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyBjb21tb24gZnVuY3Rpb25zLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlcywgY29udGV4dCwgbW9jaGEpIHtcXG4gIHJldHVybiB7XFxuICAgIC8qKlxcbiAgICAgKiBUaGlzIGlzIG9ubHkgcHJlc2VudCBpZiBmbGFnIC0tZGVsYXkgaXMgcGFzc2VkIGludG8gTW9jaGEuIEl0IHRyaWdnZXJzXFxuICAgICAqIHJvb3Qgc3VpdGUgZXhlY3V0aW9uLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBUaGUgcm9vdCBzdWl0ZS5cXG4gICAgICogQHJldHVybiB7RnVuY3Rpb259IEEgZnVuY3Rpb24gd2hpY2ggcnVucyB0aGUgcm9vdCBzdWl0ZVxcbiAgICAgKi9cXG4gICAgcnVuV2l0aFN1aXRlOiBmdW5jdGlvbiBydW5XaXRoU3VpdGUgKHN1aXRlKSB7XFxuICAgICAgcmV0dXJuIGZ1bmN0aW9uIHJ1biAoKSB7XFxuICAgICAgICBzdWl0ZS5ydW4oKTtcXG4gICAgICB9O1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBiZWZvcmUgcnVubmluZyB0ZXN0cy5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGJlZm9yZTogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmJlZm9yZUFsbChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGVjdXRlIGFmdGVyIHJ1bm5pbmcgdGVzdHMuXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICAgICAqL1xcbiAgICBhZnRlcjogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmFmdGVyQWxsKG5hbWUsIGZuKTtcXG4gICAgfSxcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4ZWN1dGUgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAgICAgKi9cXG4gICAgYmVmb3JlRWFjaDogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmJlZm9yZUVhY2gobmFtZSwgZm4pO1xcbiAgICB9LFxcblxcbiAgICAvKipcXG4gICAgICogRXhlY3V0ZSBhZnRlciBlYWNoIHRlc3QgY2FzZS5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gICAgICovXFxuICAgIGFmdGVyRWFjaDogZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICAgICAgc3VpdGVzWzBdLmFmdGVyRWFjaChuYW1lLCBmbik7XFxuICAgIH0sXFxuXFxuICAgIHN1aXRlOiB7XFxuICAgICAgLyoqXFxuICAgICAgICogQ3JlYXRlIGFuIGV4Y2x1c2l2ZSBTdWl0ZTsgY29udmVuaWVuY2UgZnVuY3Rpb25cXG4gICAgICAgKiBTZWUgZG9jc3RyaW5nIGZvciBjcmVhdGUoKSBiZWxvdy5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXFxuICAgICAgICogQHJldHVybnMge1N1aXRlfVxcbiAgICAgICAqL1xcbiAgICAgIG9ubHk6IGZ1bmN0aW9uIG9ubHkgKG9wdHMpIHtcXG4gICAgICAgIG9wdHMuaXNPbmx5ID0gdHJ1ZTtcXG4gICAgICAgIHJldHVybiB0aGlzLmNyZWF0ZShvcHRzKTtcXG4gICAgICB9LFxcblxcbiAgICAgIC8qKlxcbiAgICAgICAqIENyZWF0ZSBhIFN1aXRlLCBidXQgc2tpcCBpdDsgY29udmVuaWVuY2UgZnVuY3Rpb25cXG4gICAgICAgKiBTZWUgZG9jc3RyaW5nIGZvciBjcmVhdGUoKSBiZWxvdy5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRzXFxuICAgICAgICogQHJldHVybnMge1N1aXRlfVxcbiAgICAgICAqL1xcbiAgICAgIHNraXA6IGZ1bmN0aW9uIHNraXAgKG9wdHMpIHtcXG4gICAgICAgIG9wdHMucGVuZGluZyA9IHRydWU7XFxuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGUob3B0cyk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBDcmVhdGVzIGEgc3VpdGUuXFxuICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uc1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBvcHRzLnRpdGxlIFRpdGxlIG9mIFN1aXRlXFxuICAgICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW29wdHMuZm5dIFN1aXRlIEZ1bmN0aW9uIChub3QgYWx3YXlzIGFwcGxpY2FibGUpXFxuICAgICAgICogQHBhcmFtIHtib29sZWFufSBbb3B0cy5wZW5kaW5nXSBJcyBTdWl0ZSBwZW5kaW5nP1xcbiAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0cy5maWxlXSBGaWxlcGF0aCB3aGVyZSB0aGlzIFN1aXRlIHJlc2lkZXNcXG4gICAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmlzT25seV0gSXMgU3VpdGUgZXhjbHVzaXZlP1xcbiAgICAgICAqIEByZXR1cm5zIHtTdWl0ZX1cXG4gICAgICAgKi9cXG4gICAgICBjcmVhdGU6IGZ1bmN0aW9uIGNyZWF0ZSAob3B0cykge1xcbiAgICAgICAgdmFyIHN1aXRlID0gU3VpdGUuY3JlYXRlKHN1aXRlc1swXSwgb3B0cy50aXRsZSk7XFxuICAgICAgICBzdWl0ZS5wZW5kaW5nID0gQm9vbGVhbihvcHRzLnBlbmRpbmcpO1xcbiAgICAgICAgc3VpdGUuZmlsZSA9IG9wdHMuZmlsZTtcXG4gICAgICAgIHN1aXRlcy51bnNoaWZ0KHN1aXRlKTtcXG4gICAgICAgIGlmIChvcHRzLmlzT25seSkge1xcbiAgICAgICAgICBzdWl0ZS5wYXJlbnQuX29ubHlTdWl0ZXMgPSBzdWl0ZS5wYXJlbnQuX29ubHlTdWl0ZXMuY29uY2F0KHN1aXRlKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2Ygb3B0cy5mbiA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICBvcHRzLmZuLmNhbGwoc3VpdGUpO1xcbiAgICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICAgIH0gZWxzZSBpZiAodHlwZW9mIG9wdHMuZm4gPT09ICd1bmRlZmluZWQnICYmICFzdWl0ZS5wZW5kaW5nKSB7XFxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcignU3VpdGUgXFxcIicgKyBzdWl0ZS5mdWxsVGl0bGUoKSArICdcXFwiIHdhcyBkZWZpbmVkIGJ1dCBubyBjYWxsYmFjayB3YXMgc3VwcGxpZWQuIFN1cHBseSBhIGNhbGxiYWNrIG9yIGV4cGxpY2l0bHkgc2tpcCB0aGUgc3VpdGUuJyk7XFxuICAgICAgICB9IGVsc2UgaWYgKCFvcHRzLmZuICYmIHN1aXRlLnBlbmRpbmcpIHtcXG4gICAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gc3VpdGU7XFxuICAgICAgfVxcbiAgICB9LFxcblxcbiAgICB0ZXN0OiB7XFxuXFxuICAgICAgLyoqXFxuICAgICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtb2NoYVxcbiAgICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRlc3RcXG4gICAgICAgKiBAcmV0dXJucyB7Kn1cXG4gICAgICAgKi9cXG4gICAgICBvbmx5OiBmdW5jdGlvbiAobW9jaGEsIHRlc3QpIHtcXG4gICAgICAgIHRlc3QucGFyZW50Ll9vbmx5VGVzdHMgPSB0ZXN0LnBhcmVudC5fb25seVRlc3RzLmNvbmNhdCh0ZXN0KTtcXG4gICAgICAgIHJldHVybiB0ZXN0O1xcbiAgICAgIH0sXFxuXFxuICAgICAgLyoqXFxuICAgICAgICogUGVuZGluZyB0ZXN0IGNhc2UuXFxuICAgICAgICpcXG4gICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gICAgICAgKi9cXG4gICAgICBza2lwOiBmdW5jdGlvbiAodGl0bGUpIHtcXG4gICAgICAgIGNvbnRleHQudGVzdCh0aXRsZSk7XFxuICAgICAgfSxcXG5cXG4gICAgICAvKipcXG4gICAgICAgKiBOdW1iZXIgb2YgcmV0cnkgYXR0ZW1wdHNcXG4gICAgICAgKlxcbiAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuXFxuICAgICAgICovXFxuICAgICAgcmV0cmllczogZnVuY3Rpb24gKG4pIHtcXG4gICAgICAgIGNvbnRleHQucmV0cmllcyhuKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxufTtcXG5cXG59LHtcXFwiLi4vc3VpdGVcXFwiOjM0fV0sOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFN1aXRlID0gcmVxdWlyZSgnLi4vc3VpdGUnKTtcXG52YXIgVGVzdCA9IHJlcXVpcmUoJy4uL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBFeHBvcnRzLXN0eWxlIChhcyBOb2RlLmpzIG1vZHVsZSkgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIGV4cG9ydHMuQXJyYXkgPSB7XFxuICogICAgICAgJyNpbmRleE9mKCknOiB7XFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiAtMSB3aGVuIHRoZSB2YWx1ZSBpcyBub3QgcHJlc2VudCc6IGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICB9LFxcbiAqXFxuICogICAgICAgICAnc2hvdWxkIHJldHVybiB0aGUgY29ycmVjdCBpbmRleCB3aGVuIHRoZSB2YWx1ZSBpcyBwcmVzZW50JzogZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgIH1cXG4gKiAgICAgICB9XFxuICogICAgIH07XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdyZXF1aXJlJywgdmlzaXQpO1xcblxcbiAgZnVuY3Rpb24gdmlzaXQgKG9iaiwgZmlsZSkge1xcbiAgICB2YXIgc3VpdGU7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9ialtrZXldID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB2YXIgZm4gPSBvYmpba2V5XTtcXG4gICAgICAgIHN3aXRjaCAoa2V5KSB7XFxuICAgICAgICAgIGNhc2UgJ2JlZm9yZSc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmJlZm9yZUFsbChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2FmdGVyJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYWZ0ZXJBbGwoZm4pO1xcbiAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgICBjYXNlICdiZWZvcmVFYWNoJzpcXG4gICAgICAgICAgICBzdWl0ZXNbMF0uYmVmb3JlRWFjaChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGNhc2UgJ2FmdGVyRWFjaCc6XFxuICAgICAgICAgICAgc3VpdGVzWzBdLmFmdGVyRWFjaChmbik7XFxuICAgICAgICAgICAgYnJlYWs7XFxuICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdChrZXksIGZuKTtcXG4gICAgICAgICAgICB0ZXN0LmZpbGUgPSBmaWxlO1xcbiAgICAgICAgICAgIHN1aXRlc1swXS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgICAgfVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdWl0ZSA9IFN1aXRlLmNyZWF0ZShzdWl0ZXNbMF0sIGtleSk7XFxuICAgICAgICBzdWl0ZXMudW5zaGlmdChzdWl0ZSk7XFxuICAgICAgICB2aXNpdChvYmpba2V5XSwgZmlsZSk7XFxuICAgICAgICBzdWl0ZXMuc2hpZnQoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbn0se1xcXCIuLi9zdWl0ZVxcXCI6MzQsXFxcIi4uL3Rlc3RcXFwiOjM1fV0sMTA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG5leHBvcnRzLmJkZCA9IHJlcXVpcmUoJy4vYmRkJyk7XFxuZXhwb3J0cy50ZGQgPSByZXF1aXJlKCcuL3RkZCcpO1xcbmV4cG9ydHMucXVuaXQgPSByZXF1aXJlKCcuL3F1bml0Jyk7XFxuZXhwb3J0cy5leHBvcnRzID0gcmVxdWlyZSgnLi9leHBvcnRzJyk7XFxuXFxufSx7XFxcIi4vYmRkXFxcIjo3LFxcXCIuL2V4cG9ydHNcXFwiOjksXFxcIi4vcXVuaXRcXFwiOjExLFxcXCIuL3RkZFxcXCI6MTJ9XSwxMTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogUVVuaXQtc3R5bGUgaW50ZXJmYWNlOlxcbiAqXFxuICogICAgIHN1aXRlKCdBcnJheScpO1xcbiAqXFxuICogICAgIHRlc3QoJyNsZW5ndGgnLCBmdW5jdGlvbigpIHtcXG4gKiAgICAgICB2YXIgYXJyID0gWzEsMiwzXTtcXG4gKiAgICAgICBvayhhcnIubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgdmFyIGFyciA9IFsxLDIsM107XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMSkgPT0gMCk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMikgPT0gMSk7XFxuICogICAgICAgb2soYXJyLmluZGV4T2YoMykgPT0gMik7XFxuICogICAgIH0pO1xcbiAqXFxuICogICAgIHN1aXRlKCdTdHJpbmcnKTtcXG4gKlxcbiAqICAgICB0ZXN0KCcjbGVuZ3RoJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgb2soJ2ZvbycubGVuZ3RoID09IDMpO1xcbiAqICAgICB9KTtcXG4gKlxcbiAqIEBwYXJhbSB7U3VpdGV9IHN1aXRlIFJvb3Qgc3VpdGUuXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzdWl0ZXMgPSBbc3VpdGVdO1xcblxcbiAgc3VpdGUub24oJ3ByZS1yZXF1aXJlJywgZnVuY3Rpb24gKGNvbnRleHQsIGZpbGUsIG1vY2hhKSB7XFxuICAgIHZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpKHN1aXRlcywgY29udGV4dCwgbW9jaGEpO1xcblxcbiAgICBjb250ZXh0LmJlZm9yZSA9IGNvbW1vbi5iZWZvcmU7XFxuICAgIGNvbnRleHQuYWZ0ZXIgPSBjb21tb24uYWZ0ZXI7XFxuICAgIGNvbnRleHQuYmVmb3JlRWFjaCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LmFmdGVyRWFjaCA9IGNvbW1vbi5hZnRlckVhY2g7XFxuICAgIGNvbnRleHQucnVuID0gbW9jaGEub3B0aW9ucy5kZWxheSAmJiBjb21tb24ucnVuV2l0aFN1aXRlKHN1aXRlKTtcXG4gICAgLyoqXFxuICAgICAqIERlc2NyaWJlIGEgXFxcInN1aXRlXFxcIiB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuY3JlYXRlKHtcXG4gICAgICAgIHRpdGxlOiB0aXRsZSxcXG4gICAgICAgIGZpbGU6IGZpbGUsXFxuICAgICAgICBmbjogZmFsc2VcXG4gICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgLyoqXFxuICAgICAqIEV4Y2x1c2l2ZSBTdWl0ZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQuc3VpdGUub25seSA9IGZ1bmN0aW9uICh0aXRsZSkge1xcbiAgICAgIGlmIChzdWl0ZXMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgc3VpdGVzLnNoaWZ0KCk7XFxuICAgICAgfVxcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZhbHNlXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlXFxuICAgICAqIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmBcXG4gICAgICogYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcblxcbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHRlc3QgPSBuZXcgVGVzdCh0aXRsZSwgZm4pO1xcbiAgICAgIHRlc3QuZmlsZSA9IGZpbGU7XFxuICAgICAgc3VpdGVzWzBdLmFkZFRlc3QodGVzdCk7XFxuICAgICAgcmV0dXJuIHRlc3Q7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG5cXG4gICAgY29udGV4dC50ZXN0Lm9ubHkgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgcmV0dXJuIGNvbW1vbi50ZXN0Lm9ubHkobW9jaGEsIGNvbnRleHQudGVzdCh0aXRsZSwgZm4pKTtcXG4gICAgfTtcXG5cXG4gICAgY29udGV4dC50ZXN0LnNraXAgPSBjb21tb24udGVzdC5za2lwO1xcbiAgICBjb250ZXh0LnRlc3QucmV0cmllcyA9IGNvbW1vbi50ZXN0LnJldHJpZXM7XFxuICB9KTtcXG59O1xcblxcbn0se1xcXCIuLi90ZXN0XFxcIjozNSxcXFwiLi9jb21tb25cXFwiOjh9XSwxMjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIFRlc3QgPSByZXF1aXJlKCcuLi90ZXN0Jyk7XFxuXFxuLyoqXFxuICogVERELXN0eWxlIGludGVyZmFjZTpcXG4gKlxcbiAqICAgICAgc3VpdGUoJ0FycmF5JywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgIHN1aXRlKCcjaW5kZXhPZigpJywgZnVuY3Rpb24oKSB7XFxuICogICAgICAgICAgc3VpdGVTZXR1cChmdW5jdGlvbigpIHtcXG4gKlxcbiAqICAgICAgICAgIH0pO1xcbiAqXFxuICogICAgICAgICAgdGVzdCgnc2hvdWxkIHJldHVybiAtMSB3aGVuIG5vdCBwcmVzZW50JywgZnVuY3Rpb24oKSB7XFxuICpcXG4gKiAgICAgICAgICB9KTtcXG4gKlxcbiAqICAgICAgICAgIHRlc3QoJ3Nob3VsZCByZXR1cm4gdGhlIGluZGV4IHdoZW4gcHJlc2VudCcsIGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICpcXG4gKiAgICAgICAgICBzdWl0ZVRlYXJkb3duKGZ1bmN0aW9uKCkge1xcbiAqXFxuICogICAgICAgICAgfSk7XFxuICogICAgICAgIH0pO1xcbiAqICAgICAgfSk7XFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZSBSb290IHN1aXRlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICB2YXIgc3VpdGVzID0gW3N1aXRlXTtcXG5cXG4gIHN1aXRlLm9uKCdwcmUtcmVxdWlyZScsIGZ1bmN0aW9uIChjb250ZXh0LCBmaWxlLCBtb2NoYSkge1xcbiAgICB2YXIgY29tbW9uID0gcmVxdWlyZSgnLi9jb21tb24nKShzdWl0ZXMsIGNvbnRleHQsIG1vY2hhKTtcXG5cXG4gICAgY29udGV4dC5zZXR1cCA9IGNvbW1vbi5iZWZvcmVFYWNoO1xcbiAgICBjb250ZXh0LnRlYXJkb3duID0gY29tbW9uLmFmdGVyRWFjaDtcXG4gICAgY29udGV4dC5zdWl0ZVNldHVwID0gY29tbW9uLmJlZm9yZTtcXG4gICAgY29udGV4dC5zdWl0ZVRlYXJkb3duID0gY29tbW9uLmFmdGVyO1xcbiAgICBjb250ZXh0LnJ1biA9IG1vY2hhLm9wdGlvbnMuZGVsYXkgJiYgY29tbW9uLnJ1bldpdGhTdWl0ZShzdWl0ZSk7XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIFxcXCJzdWl0ZVxcXCIgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYCBjb250YWluaW5nXFxuICAgICAqIG5lc3RlZCBzdWl0ZXMgYW5kL29yIHRlc3RzLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZSA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gICAgICByZXR1cm4gY29tbW9uLnN1aXRlLmNyZWF0ZSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBQZW5kaW5nIHN1aXRlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5za2lwID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUuc2tpcCh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBFeGNsdXNpdmUgdGVzdC1jYXNlLlxcbiAgICAgKi9cXG4gICAgY29udGV4dC5zdWl0ZS5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24uc3VpdGUub25seSh7XFxuICAgICAgICB0aXRsZTogdGl0bGUsXFxuICAgICAgICBmaWxlOiBmaWxlLFxcbiAgICAgICAgZm46IGZuXFxuICAgICAgfSk7XFxuICAgIH07XFxuXFxuICAgIC8qKlxcbiAgICAgKiBEZXNjcmliZSBhIHNwZWNpZmljYXRpb24gb3IgdGVzdC1jYXNlIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kXFxuICAgICAqIGNhbGxiYWNrIGBmbmAgYWN0aW5nIGFzIGEgdGh1bmsuXFxuICAgICAqL1xcbiAgICBjb250ZXh0LnRlc3QgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICAgICAgdmFyIHN1aXRlID0gc3VpdGVzWzBdO1xcbiAgICAgIGlmIChzdWl0ZS5pc1BlbmRpbmcoKSkge1xcbiAgICAgICAgZm4gPSBudWxsO1xcbiAgICAgIH1cXG4gICAgICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRpdGxlLCBmbik7XFxuICAgICAgdGVzdC5maWxlID0gZmlsZTtcXG4gICAgICBzdWl0ZS5hZGRUZXN0KHRlc3QpO1xcbiAgICAgIHJldHVybiB0ZXN0O1xcbiAgICB9O1xcblxcbiAgICAvKipcXG4gICAgICogRXhjbHVzaXZlIHRlc3QtY2FzZS5cXG4gICAgICovXFxuXFxuICAgIGNvbnRleHQudGVzdC5vbmx5ID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgICAgIHJldHVybiBjb21tb24udGVzdC5vbmx5KG1vY2hhLCBjb250ZXh0LnRlc3QodGl0bGUsIGZuKSk7XFxuICAgIH07XFxuXFxuICAgIGNvbnRleHQudGVzdC5za2lwID0gY29tbW9uLnRlc3Quc2tpcDtcXG4gICAgY29udGV4dC50ZXN0LnJldHJpZXMgPSBjb21tb24udGVzdC5yZXRyaWVzO1xcbiAgfSk7XFxufTtcXG5cXG59LHtcXFwiLi4vdGVzdFxcXCI6MzUsXFxcIi4vY29tbW9uXFxcIjo4fV0sMTM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwsX19kaXJuYW1lKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyohXFxuICogbW9jaGFcXG4gKiBDb3B5cmlnaHQoYykgMjAxMSBUSiBIb2xvd2F5Y2h1ayA8dGpAdmlzaW9uLW1lZGlhLmNhPlxcbiAqIE1JVCBMaWNlbnNlZFxcbiAqL1xcbi8qKlxcbiAqIEBuYW1lc3BhY2UgTW9jaGFcXG4gKiBAbW9kdWxlIE1vY2hhXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciByZXBvcnRlcnMgPSByZXF1aXJlKCcuL3JlcG9ydGVycycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYE1vY2hhYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBNb2NoYTtcXG5cXG4vKipcXG4gKiBUbyByZXF1aXJlIGxvY2FsIFVJcyBhbmQgcmVwb3J0ZXJzIHdoZW4gcnVubmluZyBpbiBub2RlLlxcbiAqL1xcblxcbmlmICghcHJvY2Vzcy5icm93c2VyKSB7XFxuICB2YXIgY3dkID0gcHJvY2Vzcy5jd2QoKTtcXG4gIG1vZHVsZS5wYXRocy5wdXNoKGN3ZCwgcGF0aC5qb2luKGN3ZCwgJ25vZGVfbW9kdWxlcycpKTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIGludGVybmFscy5cXG4gKi9cXG5cXG4vKipcXG4gKiBAcHVibGljXFxuICogQGNsYXNzIHV0aWxzXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICovXFxuZXhwb3J0cy51dGlscyA9IHV0aWxzO1xcbmV4cG9ydHMuaW50ZXJmYWNlcyA9IHJlcXVpcmUoJy4vaW50ZXJmYWNlcycpO1xcbi8qKlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqL1xcbmV4cG9ydHMucmVwb3J0ZXJzID0gcmVwb3J0ZXJzO1xcbmV4cG9ydHMuUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxuZXhwb3J0cy5Db250ZXh0ID0gcmVxdWlyZSgnLi9jb250ZXh0Jyk7XFxuLyoqXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKi9cXG5leHBvcnRzLlJ1bm5lciA9IHJlcXVpcmUoJy4vcnVubmVyJyk7XFxuZXhwb3J0cy5TdWl0ZSA9IHJlcXVpcmUoJy4vc3VpdGUnKTtcXG5leHBvcnRzLkhvb2sgPSByZXF1aXJlKCcuL2hvb2snKTtcXG5leHBvcnRzLlRlc3QgPSByZXF1aXJlKCcuL3Rlc3QnKTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gaW1hZ2UgYG5hbWVgIHBhdGguXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBpbWFnZSAobmFtZSkge1xcbiAgcmV0dXJuIHBhdGguam9pbihfX2Rpcm5hbWUsICcuLi9pbWFnZXMnLCBuYW1lICsgJy5wbmcnKTtcXG59XFxuXFxuLyoqXFxuICogU2V0IHVwIG1vY2hhIHdpdGggYG9wdGlvbnNgLlxcbiAqXFxuICogT3B0aW9uczpcXG4gKlxcbiAqICAgLSBgdWlgIG5hbWUgXFxcImJkZFxcXCIsIFxcXCJ0ZGRcXFwiLCBcXFwiZXhwb3J0c1xcXCIgZXRjXFxuICogICAtIGByZXBvcnRlcmAgcmVwb3J0ZXIgaW5zdGFuY2UsIGRlZmF1bHRzIHRvIGBtb2NoYS5yZXBvcnRlcnMuc3BlY2BcXG4gKiAgIC0gYGdsb2JhbHNgIGFycmF5IG9mIGFjY2VwdGVkIGdsb2JhbHNcXG4gKiAgIC0gYHRpbWVvdXRgIHRpbWVvdXQgaW4gbWlsbGlzZWNvbmRzXFxuICogICAtIGByZXRyaWVzYCBudW1iZXIgb2YgdGltZXMgdG8gcmV0cnkgZmFpbGVkIHRlc3RzXFxuICogICAtIGBiYWlsYCBiYWlsIG9uIHRoZSBmaXJzdCB0ZXN0IGZhaWx1cmVcXG4gKiAgIC0gYHNsb3dgIG1pbGxpc2Vjb25kcyB0byB3YWl0IGJlZm9yZSBjb25zaWRlcmluZyBhIHRlc3Qgc2xvd1xcbiAqICAgLSBgaWdub3JlTGVha3NgIGlnbm9yZSBnbG9iYWwgbGVha3NcXG4gKiAgIC0gYGZ1bGxUcmFjZWAgZGlzcGxheSB0aGUgZnVsbCBzdGFjay10cmFjZSBvbiBmYWlsaW5nXFxuICogICAtIGBncmVwYCBzdHJpbmcgb3IgcmVnZXhwIHRvIGZpbHRlciB0ZXN0cyB3aXRoXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzIE1vY2hhXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbmZ1bmN0aW9uIE1vY2hhIChvcHRpb25zKSB7XFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHRoaXMuZmlsZXMgPSBbXTtcXG4gIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHRoaXMuZ3JlcChuZXcgUmVnRXhwKG9wdGlvbnMuZ3JlcCkpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZmdyZXApIHtcXG4gICAgdGhpcy5mZ3JlcChvcHRpb25zLmZncmVwKTtcXG4gIH1cXG4gIHRoaXMuc3VpdGUgPSBuZXcgZXhwb3J0cy5TdWl0ZSgnJywgbmV3IGV4cG9ydHMuQ29udGV4dCgpKTtcXG4gIHRoaXMudWkob3B0aW9ucy51aSk7XFxuICB0aGlzLmJhaWwob3B0aW9ucy5iYWlsKTtcXG4gIHRoaXMucmVwb3J0ZXIob3B0aW9ucy5yZXBvcnRlciwgb3B0aW9ucy5yZXBvcnRlck9wdGlvbnMpO1xcbiAgaWYgKHR5cGVvZiBvcHRpb25zLnRpbWVvdXQgIT09ICd1bmRlZmluZWQnICYmIG9wdGlvbnMudGltZW91dCAhPT0gbnVsbCkge1xcbiAgICB0aGlzLnRpbWVvdXQob3B0aW9ucy50aW1lb3V0KTtcXG4gIH1cXG4gIGlmICh0eXBlb2Ygb3B0aW9ucy5yZXRyaWVzICE9PSAndW5kZWZpbmVkJyAmJiBvcHRpb25zLnJldHJpZXMgIT09IG51bGwpIHtcXG4gICAgdGhpcy5yZXRyaWVzKG9wdGlvbnMucmV0cmllcyk7XFxuICB9XFxuICB0aGlzLnVzZUNvbG9ycyhvcHRpb25zLnVzZUNvbG9ycyk7XFxuICBpZiAob3B0aW9ucy5lbmFibGVUaW1lb3V0cyAhPT0gbnVsbCkge1xcbiAgICB0aGlzLmVuYWJsZVRpbWVvdXRzKG9wdGlvbnMuZW5hYmxlVGltZW91dHMpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuc2xvdykge1xcbiAgICB0aGlzLnNsb3cob3B0aW9ucy5zbG93KTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogRW5hYmxlIG9yIGRpc2FibGUgYmFpbGluZyBvbiB0aGUgZmlyc3QgZmFpbHVyZS5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2JhaWxdXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmJhaWwgPSBmdW5jdGlvbiAoYmFpbCkge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIGJhaWwgPSB0cnVlO1xcbiAgfVxcbiAgdGhpcy5zdWl0ZS5iYWlsKGJhaWwpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgdGVzdCBgZmlsZWAuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge3N0cmluZ30gZmlsZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hZGRGaWxlID0gZnVuY3Rpb24gKGZpbGUpIHtcXG4gIHRoaXMuZmlsZXMucHVzaChmaWxlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHJlcG9ydGVyIHRvIGByZXBvcnRlcmAsIGRlZmF1bHRzIHRvIFxcXCJzcGVjXFxcIi5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gcmVwb3J0ZXIgbmFtZSBvciBjb25zdHJ1Y3RvclxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXBvcnRlck9wdGlvbnMgb3B0aW9uYWwgb3B0aW9uc1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd8RnVuY3Rpb259IHJlcG9ydGVyIG5hbWUgb3IgY29uc3RydWN0b3JcXG4gKiBAcGFyYW0ge09iamVjdH0gcmVwb3J0ZXJPcHRpb25zIG9wdGlvbmFsIG9wdGlvbnNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUucmVwb3J0ZXIgPSBmdW5jdGlvbiAocmVwb3J0ZXIsIHJlcG9ydGVyT3B0aW9ucykge1xcbiAgaWYgKHR5cGVvZiByZXBvcnRlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aGlzLl9yZXBvcnRlciA9IHJlcG9ydGVyO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVwb3J0ZXIgPSByZXBvcnRlciB8fCAnc3BlYyc7XFxuICAgIHZhciBfcmVwb3J0ZXI7XFxuICAgIC8vIFRyeSB0byBsb2FkIGEgYnVpbHQtaW4gcmVwb3J0ZXIuXFxuICAgIGlmIChyZXBvcnRlcnNbcmVwb3J0ZXJdKSB7XFxuICAgICAgX3JlcG9ydGVyID0gcmVwb3J0ZXJzW3JlcG9ydGVyXTtcXG4gICAgfVxcbiAgICAvLyBUcnkgdG8gbG9hZCByZXBvcnRlcnMgZnJvbSBwcm9jZXNzLmN3ZCgpIGFuZCBub2RlX21vZHVsZXNcXG4gICAgaWYgKCFfcmVwb3J0ZXIpIHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgX3JlcG9ydGVyID0gcmVxdWlyZShyZXBvcnRlcik7XFxuICAgICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZignQ2Fubm90IGZpbmQgbW9kdWxlJykgIT09IC0xKSB7XFxuICAgICAgICAgIC8vIFRyeSB0byBsb2FkIHJlcG9ydGVycyBmcm9tIGEgcGF0aCAoYWJzb2x1dGUgb3IgcmVsYXRpdmUpXFxuICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgX3JlcG9ydGVyID0gcmVxdWlyZShwYXRoLnJlc29sdmUocHJvY2Vzcy5jd2QoKSwgcmVwb3J0ZXIpKTtcXG4gICAgICAgICAgfSBjYXRjaCAoX2Vycikge1xcbiAgICAgICAgICAgIGVyci5tZXNzYWdlLmluZGV4T2YoJ0Nhbm5vdCBmaW5kIG1vZHVsZScpICE9PSAtMSA/IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIG5vdCBmb3VuZCcpXFxuICAgICAgICAgICAgICA6IGNvbnNvbGUud2FybignXFxcIicgKyByZXBvcnRlciArICdcXFwiIHJlcG9ydGVyIGJsZXcgdXAgd2l0aCBlcnJvcjpcXFxcbicgKyBlcnIuc3RhY2spO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBjb25zb2xlLndhcm4oJ1xcXCInICsgcmVwb3J0ZXIgKyAnXFxcIiByZXBvcnRlciBibGV3IHVwIHdpdGggZXJyb3I6XFxcXG4nICsgZXJyLnN0YWNrKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKCFfcmVwb3J0ZXIgJiYgcmVwb3J0ZXIgPT09ICd0ZWFtY2l0eScpIHtcXG4gICAgICBjb25zb2xlLndhcm4oJ1RoZSBUZWFtY2l0eSByZXBvcnRlciB3YXMgbW92ZWQgdG8gYSBwYWNrYWdlIG5hbWVkICcgK1xcbiAgICAgICAgJ21vY2hhLXRlYW1jaXR5LXJlcG9ydGVyICcgK1xcbiAgICAgICAgJyhodHRwczovL25wbWpzLm9yZy9wYWNrYWdlL21vY2hhLXRlYW1jaXR5LXJlcG9ydGVyKS4nKTtcXG4gICAgfVxcbiAgICBpZiAoIV9yZXBvcnRlcikge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCByZXBvcnRlciBcXFwiJyArIHJlcG9ydGVyICsgJ1xcXCInKTtcXG4gICAgfVxcbiAgICB0aGlzLl9yZXBvcnRlciA9IF9yZXBvcnRlcjtcXG4gIH1cXG4gIHRoaXMub3B0aW9ucy5yZXBvcnRlck9wdGlvbnMgPSByZXBvcnRlck9wdGlvbnM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0ZXN0IFVJIGBuYW1lYCwgZGVmYXVsdHMgdG8gXFxcImJkZFxcXCIuXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd9IGJkZFxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS51aSA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICBuYW1lID0gbmFtZSB8fCAnYmRkJztcXG4gIHRoaXMuX3VpID0gZXhwb3J0cy5pbnRlcmZhY2VzW25hbWVdO1xcbiAgaWYgKCF0aGlzLl91aSkge1xcbiAgICB0cnkge1xcbiAgICAgIHRoaXMuX3VpID0gcmVxdWlyZShuYW1lKTtcXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGludGVyZmFjZSBcXFwiJyArIG5hbWUgKyAnXFxcIicpO1xcbiAgICB9XFxuICB9XFxuICB0aGlzLl91aSA9IHRoaXMuX3VpKHRoaXMuc3VpdGUpO1xcblxcbiAgdGhpcy5zdWl0ZS5vbigncHJlLXJlcXVpcmUnLCBmdW5jdGlvbiAoY29udGV4dCkge1xcbiAgICBleHBvcnRzLmFmdGVyRWFjaCA9IGNvbnRleHQuYWZ0ZXJFYWNoIHx8IGNvbnRleHQudGVhcmRvd247XFxuICAgIGV4cG9ydHMuYWZ0ZXIgPSBjb250ZXh0LmFmdGVyIHx8IGNvbnRleHQuc3VpdGVUZWFyZG93bjtcXG4gICAgZXhwb3J0cy5iZWZvcmVFYWNoID0gY29udGV4dC5iZWZvcmVFYWNoIHx8IGNvbnRleHQuc2V0dXA7XFxuICAgIGV4cG9ydHMuYmVmb3JlID0gY29udGV4dC5iZWZvcmUgfHwgY29udGV4dC5zdWl0ZVNldHVwO1xcbiAgICBleHBvcnRzLmRlc2NyaWJlID0gY29udGV4dC5kZXNjcmliZSB8fCBjb250ZXh0LnN1aXRlO1xcbiAgICBleHBvcnRzLml0ID0gY29udGV4dC5pdCB8fCBjb250ZXh0LnRlc3Q7XFxuICAgIGV4cG9ydHMueGl0ID0gY29udGV4dC54aXQgfHwgY29udGV4dC50ZXN0LnNraXA7XFxuICAgIGV4cG9ydHMuc2V0dXAgPSBjb250ZXh0LnNldHVwIHx8IGNvbnRleHQuYmVmb3JlRWFjaDtcXG4gICAgZXhwb3J0cy5zdWl0ZVNldHVwID0gY29udGV4dC5zdWl0ZVNldHVwIHx8IGNvbnRleHQuYmVmb3JlO1xcbiAgICBleHBvcnRzLnN1aXRlVGVhcmRvd24gPSBjb250ZXh0LnN1aXRlVGVhcmRvd24gfHwgY29udGV4dC5hZnRlcjtcXG4gICAgZXhwb3J0cy5zdWl0ZSA9IGNvbnRleHQuc3VpdGUgfHwgY29udGV4dC5kZXNjcmliZTtcXG4gICAgZXhwb3J0cy50ZWFyZG93biA9IGNvbnRleHQudGVhcmRvd24gfHwgY29udGV4dC5hZnRlckVhY2g7XFxuICAgIGV4cG9ydHMudGVzdCA9IGNvbnRleHQudGVzdCB8fCBjb250ZXh0Lml0O1xcbiAgICBleHBvcnRzLnJ1biA9IGNvbnRleHQucnVuO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIExvYWQgcmVnaXN0ZXJlZCBmaWxlcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5sb2FkRmlsZXMgPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICB0aGlzLmZpbGVzLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgZmlsZSA9IHBhdGgucmVzb2x2ZShmaWxlKTtcXG4gICAgc3VpdGUuZW1pdCgncHJlLXJlcXVpcmUnLCBnbG9iYWwsIGZpbGUsIHNlbGYpO1xcbiAgICBzdWl0ZS5lbWl0KCdyZXF1aXJlJywgcmVxdWlyZShmaWxlKSwgZmlsZSwgc2VsZik7XFxuICAgIHN1aXRlLmVtaXQoJ3Bvc3QtcmVxdWlyZScsIGdsb2JhbCwgZmlsZSwgc2VsZik7XFxuICB9KTtcXG4gIGZuICYmIGZuKCk7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ3Jvd2wgc3VwcG9ydC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5fZ3Jvd2wgPSBmdW5jdGlvbiAocnVubmVyLCByZXBvcnRlcikge1xcbiAgdmFyIG5vdGlmeSA9IHJlcXVpcmUoJ2dyb3dsJyk7XFxuXFxuICBydW5uZXIub24oJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRzID0gcmVwb3J0ZXIuc3RhdHM7XFxuICAgIGlmIChzdGF0cy5mYWlsdXJlcykge1xcbiAgICAgIHZhciBtc2cgPSBzdGF0cy5mYWlsdXJlcyArICcgb2YgJyArIHJ1bm5lci50b3RhbCArICcgdGVzdHMgZmFpbGVkJztcXG4gICAgICBub3RpZnkobXNnLCB7IG5hbWU6ICdtb2NoYScsIHRpdGxlOiAnRmFpbGVkJywgaW1hZ2U6IGltYWdlKCdlcnJvcicpIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG5vdGlmeShzdGF0cy5wYXNzZXMgKyAnIHRlc3RzIHBhc3NlZCBpbiAnICsgc3RhdHMuZHVyYXRpb24gKyAnbXMnLCB7XFxuICAgICAgICBuYW1lOiAnbW9jaGEnLFxcbiAgICAgICAgdGl0bGU6ICdQYXNzZWQnLFxcbiAgICAgICAgaW1hZ2U6IGltYWdlKCdvaycpXFxuICAgICAgfSk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogRXNjYXBlIHN0cmluZyBhbmQgYWRkIGl0IHRvIGdyZXAgYXMgYSByZWdleHAuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0gc3RyXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mZ3JlcCA9IGZ1bmN0aW9uIChzdHIpIHtcXG4gIHJldHVybiB0aGlzLmdyZXAobmV3IFJlZ0V4cChlc2NhcGVSZShzdHIpKSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgcmVnZXhwIHRvIGdyZXAsIGlmIGByZWAgaXMgYSBzdHJpbmcgaXQgaXMgZXNjYXBlZC5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge1JlZ0V4cHxTdHJpbmd9IHJlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHJlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmdyZXAgPSBmdW5jdGlvbiAocmUpIHtcXG4gIGlmICh1dGlscy5pc1N0cmluZyhyZSkpIHtcXG4gICAgLy8gZXh0cmFjdCBhcmdzIGlmIGl0J3MgcmVnZXgtbGlrZSwgaS5lOiBbc3RyaW5nLCBwYXR0ZXJuLCBmbGFnXVxcbiAgICB2YXIgYXJnID0gcmUubWF0Y2goL15cXFxcLyguKilcXFxcLyhnfGl8KSR8LiovKTtcXG4gICAgdGhpcy5vcHRpb25zLmdyZXAgPSBuZXcgUmVnRXhwKGFyZ1sxXSB8fCBhcmdbMF0sIGFyZ1syXSk7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLm9wdGlvbnMuZ3JlcCA9IHJlO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG4vKipcXG4gKiBJbnZlcnQgYC5ncmVwKClgIG1hdGNoZXMuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuaW52ZXJ0ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmludmVydCA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIElnbm9yZSBnbG9iYWwgbGVha3MuXFxuICpcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtCb29sZWFufSBpZ25vcmVcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gaWdub3JlXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmlnbm9yZUxlYWtzID0gZnVuY3Rpb24gKGlnbm9yZSkge1xcbiAgdGhpcy5vcHRpb25zLmlnbm9yZUxlYWtzID0gQm9vbGVhbihpZ25vcmUpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgZ2xvYmFsIGxlYWsgY2hlY2tpbmcuXFxuICpcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuY2hlY2tMZWFrcyA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5pZ25vcmVMZWFrcyA9IGZhbHNlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEaXNwbGF5IGxvbmcgc3RhY2stdHJhY2Ugb24gZmFpbGluZ1xcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZ1bGxUcmFjZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5mdWxsU3RhY2tUcmFjZSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSBncm93bCBzdXBwb3J0LlxcbiAqXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICovXFxuTW9jaGEucHJvdG90eXBlLmdyb3dsID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmdyb3dsID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSWdub3JlIGBnbG9iYWxzYCBhcnJheSBvciBzdHJpbmcuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fFN0cmluZ30gZ2xvYmFsc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBnbG9iYWxzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoZ2xvYmFscykge1xcbiAgdGhpcy5vcHRpb25zLmdsb2JhbHMgPSAodGhpcy5vcHRpb25zLmdsb2JhbHMgfHwgW10pLmNvbmNhdChnbG9iYWxzKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRW1pdCBjb2xvciBvdXRwdXQuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGNvbG9yc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gY29sb3JzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUNvbG9ycyA9IGZ1bmN0aW9uIChjb2xvcnMpIHtcXG4gIGlmIChjb2xvcnMgIT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzLm9wdGlvbnMudXNlQ29sb3JzID0gY29sb3JzO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBVc2UgaW5saW5lIGRpZmZzIHJhdGhlciB0aGFuICsvLS5cXG4gKlxcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gaW5saW5lRGlmZnNcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlubGluZURpZmZzXFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnVzZUlubGluZURpZmZzID0gZnVuY3Rpb24gKGlubGluZURpZmZzKSB7XFxuICB0aGlzLm9wdGlvbnMudXNlSW5saW5lRGlmZnMgPSBpbmxpbmVEaWZmcyAhPT0gdW5kZWZpbmVkICYmIGlubGluZURpZmZzO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEbyBub3Qgc2hvdyBkaWZmcyBhdCBhbGwuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGhpZGVEaWZmXFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtib29sZWFufSBoaWRlRGlmZlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5oaWRlRGlmZiA9IGZ1bmN0aW9uIChoaWRlRGlmZikge1xcbiAgdGhpcy5vcHRpb25zLmhpZGVEaWZmID0gaGlkZURpZmYgIT09IHVuZGVmaW5lZCAmJiBoaWRlRGlmZjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHRoZSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSB0aW1lb3V0XFxuICogQHJldHVybiB7TW9jaGF9XFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtudW1iZXJ9IHRpbWVvdXRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUudGltZW91dCA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XFxuICB0aGlzLnN1aXRlLnRpbWVvdXQodGltZW91dCk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCB0aGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJldHJ5IGZhaWxlZCB0ZXN0cy5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSByZXRyeSB0aW1lc1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5yZXRyaWVzID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMuc3VpdGUucmV0cmllcyhuKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IHNsb3duZXNzIHRocmVzaG9sZCBpbiBtaWxsaXNlY29uZHMuXFxuICpcXG4gKiBAcGFyYW0ge051bWJlcn0gc2xvd1xcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBwYXJhbSB7bnVtYmVyfSBzbG93XFxuICogQHJldHVybiB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnNsb3cgPSBmdW5jdGlvbiAoc2xvdykge1xcbiAgdGhpcy5zdWl0ZS5zbG93KHNsb3cpO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBFbmFibGUgdGltZW91dHMuXFxuICpcXG4gKiBAcGFyYW0ge0Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGVuYWJsZWRcXG4gKiBAcmV0dXJuIHtNb2NoYX1cXG4gKi9cXG5Nb2NoYS5wcm90b3R5cGUuZW5hYmxlVGltZW91dHMgPSBmdW5jdGlvbiAoZW5hYmxlZCkge1xcbiAgdGhpcy5zdWl0ZS5lbmFibGVUaW1lb3V0cyhhcmd1bWVudHMubGVuZ3RoICYmIGVuYWJsZWQgIT09IHVuZGVmaW5lZCA/IGVuYWJsZWQgOiB0cnVlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogTWFrZXMgYWxsIHRlc3RzIGFzeW5jIChhY2NlcHRpbmcgYSBjYWxsYmFjaylcXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hc3luY09ubHkgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogRGlzYWJsZSBzeW50YXggaGlnaGxpZ2h0aW5nIChpbiBicm93c2VyKS5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5ub0hpZ2hsaWdodGluZyA9IGZ1bmN0aW9uICgpIHtcXG4gIHRoaXMub3B0aW9ucy5ub0hpZ2hsaWdodGluZyA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEVuYWJsZSB1bmNhdWdodCBlcnJvcnMgdG8gcHJvcGFnYXRlIChpbiBicm93c2VyKS5cXG4gKlxcbiAqIEByZXR1cm4ge01vY2hhfVxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5hbGxvd1VuY2F1Z2h0ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBEZWxheSByb290IHN1aXRlIGV4ZWN1dGlvbi5cXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmRlbGF5ID0gZnVuY3Rpb24gZGVsYXkgKCkge1xcbiAgdGhpcy5vcHRpb25zLmRlbGF5ID0gdHJ1ZTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVGVzdHMgbWFya2VkIG9ubHkgZmFpbCB0aGUgc3VpdGVcXG4gKiBAcmV0dXJucyB7TW9jaGF9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLmZvcmJpZE9ubHkgPSBmdW5jdGlvbiAoKSB7XFxuICB0aGlzLm9wdGlvbnMuZm9yYmlkT25seSA9IHRydWU7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFBlbmRpbmcgdGVzdHMgYW5kIHRlc3RzIG1hcmtlZCBza2lwIGZhaWwgdGhlIHN1aXRlXFxuICogQHJldHVybnMge01vY2hhfVxcbiAqL1xcbk1vY2hhLnByb3RvdHlwZS5mb3JiaWRQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5vcHRpb25zLmZvcmJpZFBlbmRpbmcgPSB0cnVlO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgYW5kIGludm9rZSBgZm4oKWAgd2hlbiBjb21wbGV0ZS5cXG4gKlxcbiAqIE5vdGUgdGhhdCBgbG9hZEZpbGVzYCByZWxpZXMgb24gTm9kZSdzIGByZXF1aXJlYCB0byBleGVjdXRlXFxuICogdGhlIHRlc3QgaW50ZXJmYWNlIGZ1bmN0aW9ucyBhbmQgd2lsbCBiZSBzdWJqZWN0IHRvIHRoZVxcbiAqIGNhY2hlIC0gaWYgdGhlIGZpbGVzIGFyZSBhbHJlYWR5IGluIHRoZSBgcmVxdWlyZWAgY2FjaGUsXFxuICogdGhleSB3aWxsIGVmZmVjdGl2ZWx5IGJlIHNraXBwZWQuIFRoZXJlZm9yZSwgdG8gcnVuIHRlc3RzXFxuICogbXVsdGlwbGUgdGltZXMgb3IgdG8gcnVuIHRlc3RzIGluIGZpbGVzIHRoYXQgYXJlIGFscmVhZHlcXG4gKiBpbiB0aGUgYHJlcXVpcmVgIGNhY2hlLCBtYWtlIHN1cmUgdG8gY2xlYXIgdGhlbSBmcm9tIHRoZVxcbiAqIGNhY2hlIGZpcnN0IGluIHdoaWNoZXZlciBtYW5uZXIgYmVzdCBzdWl0cyB5b3VyIG5lZWRzLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtSdW5uZXJ9XFxuICovXFxuTW9jaGEucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIChmbikge1xcbiAgaWYgKHRoaXMuZmlsZXMubGVuZ3RoKSB7XFxuICAgIHRoaXMubG9hZEZpbGVzKCk7XFxuICB9XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIG9wdGlvbnMgPSB0aGlzLm9wdGlvbnM7XFxuICBvcHRpb25zLmZpbGVzID0gdGhpcy5maWxlcztcXG4gIHZhciBydW5uZXIgPSBuZXcgZXhwb3J0cy5SdW5uZXIoc3VpdGUsIG9wdGlvbnMuZGVsYXkpO1xcbiAgdmFyIHJlcG9ydGVyID0gbmV3IHRoaXMuX3JlcG9ydGVyKHJ1bm5lciwgb3B0aW9ucyk7XFxuICBydW5uZXIuaWdub3JlTGVha3MgPSBvcHRpb25zLmlnbm9yZUxlYWtzICE9PSBmYWxzZTtcXG4gIHJ1bm5lci5mdWxsU3RhY2tUcmFjZSA9IG9wdGlvbnMuZnVsbFN0YWNrVHJhY2U7XFxuICBydW5uZXIuYXN5bmNPbmx5ID0gb3B0aW9ucy5hc3luY09ubHk7XFxuICBydW5uZXIuYWxsb3dVbmNhdWdodCA9IG9wdGlvbnMuYWxsb3dVbmNhdWdodDtcXG4gIHJ1bm5lci5mb3JiaWRPbmx5ID0gb3B0aW9ucy5mb3JiaWRPbmx5O1xcbiAgcnVubmVyLmZvcmJpZFBlbmRpbmcgPSBvcHRpb25zLmZvcmJpZFBlbmRpbmc7XFxuICBpZiAob3B0aW9ucy5ncmVwKSB7XFxuICAgIHJ1bm5lci5ncmVwKG9wdGlvbnMuZ3JlcCwgb3B0aW9ucy5pbnZlcnQpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZ2xvYmFscykge1xcbiAgICBydW5uZXIuZ2xvYmFscyhvcHRpb25zLmdsb2JhbHMpO1xcbiAgfVxcbiAgaWYgKG9wdGlvbnMuZ3Jvd2wpIHtcXG4gICAgdGhpcy5fZ3Jvd2wocnVubmVyLCByZXBvcnRlcik7XFxuICB9XFxuICBpZiAob3B0aW9ucy51c2VDb2xvcnMgIT09IHVuZGVmaW5lZCkge1xcbiAgICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLnVzZUNvbG9ycyA9IG9wdGlvbnMudXNlQ29sb3JzO1xcbiAgfVxcbiAgZXhwb3J0cy5yZXBvcnRlcnMuQmFzZS5pbmxpbmVEaWZmcyA9IG9wdGlvbnMudXNlSW5saW5lRGlmZnM7XFxuICBleHBvcnRzLnJlcG9ydGVycy5CYXNlLmhpZGVEaWZmID0gb3B0aW9ucy5oaWRlRGlmZjtcXG5cXG4gIGZ1bmN0aW9uIGRvbmUgKGZhaWx1cmVzKSB7XFxuICAgIGlmIChyZXBvcnRlci5kb25lKSB7XFxuICAgICAgcmVwb3J0ZXIuZG9uZShmYWlsdXJlcywgZm4pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZuICYmIGZuKGZhaWx1cmVzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJ1bm5lci5ydW4oZG9uZSk7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9LFxcXCIvbGliXFxcIilcXG59LHtcXFwiLi9jb250ZXh0XFxcIjo1LFxcXCIuL2hvb2tcXFwiOjYsXFxcIi4vaW50ZXJmYWNlc1xcXCI6MTAsXFxcIi4vcmVwb3J0ZXJzXFxcIjoyMCxcXFwiLi9ydW5uYWJsZVxcXCI6MzIsXFxcIi4vcnVubmVyXFxcIjozMyxcXFwiLi9zdWl0ZVxcXCI6MzQsXFxcIi4vdGVzdFxcXCI6MzUsXFxcIi4vdXRpbHNcXFwiOjM2LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0NixcXFwiZ3Jvd2xcXFwiOjIsXFxcInBhdGhcXFwiOjQwfV0sMTQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIG1pbGxpc2Vjb25kc1xcbiAqL1xcbi8qKlxcbiAqIEhlbHBlcnMuXFxuICovXFxuXFxudmFyIHMgPSAxMDAwO1xcbnZhciBtID0gcyAqIDYwO1xcbnZhciBoID0gbSAqIDYwO1xcbnZhciBkID0gaCAqIDI0O1xcbnZhciB5ID0gZCAqIDM2NS4yNTtcXG5cXG4vKipcXG4gKiBQYXJzZSBvciBmb3JtYXQgdGhlIGdpdmVuIGB2YWxgLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB2YWxcXG4gKiBAcmV0dXJuIHtzdHJpbmd8bnVtYmVyfVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHZhbCkge1xcbiAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBwYXJzZSh2YWwpO1xcbiAgfVxcbiAgcmV0dXJuIGZvcm1hdCh2YWwpO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2UgdGhlIGdpdmVuIGBzdHJgIGFuZCByZXR1cm4gbWlsbGlzZWNvbmRzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5mdW5jdGlvbiBwYXJzZSAoc3RyKSB7XFxuICB2YXIgbWF0Y2ggPSAoL14oKD86XFxcXGQrKT9cXFxcLj9cXFxcZCspICoobXN8c2Vjb25kcz98c3xtaW51dGVzP3xtfGhvdXJzP3xofGRheXM/fGR8eWVhcnM/fHkpPyQvaSkuZXhlYyhzdHIpO1xcbiAgaWYgKCFtYXRjaCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xcbiAgdmFyIHR5cGUgPSAobWF0Y2hbMl0gfHwgJ21zJykudG9Mb3dlckNhc2UoKTtcXG4gIHN3aXRjaCAodHlwZSkge1xcbiAgICBjYXNlICd5ZWFycyc6XFxuICAgIGNhc2UgJ3llYXInOlxcbiAgICBjYXNlICd5JzpcXG4gICAgICByZXR1cm4gbiAqIHk7XFxuICAgIGNhc2UgJ2RheXMnOlxcbiAgICBjYXNlICdkYXknOlxcbiAgICBjYXNlICdkJzpcXG4gICAgICByZXR1cm4gbiAqIGQ7XFxuICAgIGNhc2UgJ2hvdXJzJzpcXG4gICAgY2FzZSAnaG91cic6XFxuICAgIGNhc2UgJ2gnOlxcbiAgICAgIHJldHVybiBuICogaDtcXG4gICAgY2FzZSAnbWludXRlcyc6XFxuICAgIGNhc2UgJ21pbnV0ZSc6XFxuICAgIGNhc2UgJ20nOlxcbiAgICAgIHJldHVybiBuICogbTtcXG4gICAgY2FzZSAnc2Vjb25kcyc6XFxuICAgIGNhc2UgJ3NlY29uZCc6XFxuICAgIGNhc2UgJ3MnOlxcbiAgICAgIHJldHVybiBuICogcztcXG4gICAgY2FzZSAnbXMnOlxcbiAgICAgIHJldHVybiBuO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIC8vIE5vIGRlZmF1bHQgY2FzZVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBGb3JtYXQgZm9yIGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gbXNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gZm9ybWF0IChtcykge1xcbiAgaWYgKG1zID49IGQpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcXG4gIH1cXG4gIGlmIChtcyA+PSBoKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XFxuICB9XFxuICBpZiAobXMgPj0gbSkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xcbiAgfVxcbiAgaWYgKG1zID49IHMpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcXG4gIH1cXG4gIHJldHVybiBtcyArICdtcyc7XFxufVxcblxcbn0se31dLDE1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBQZW5kaW5nYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFBlbmRpbmc7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgUGVuZGluZ2AgZXJyb3Igd2l0aCB0aGUgZ2l2ZW4gbWVzc2FnZS5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXFxuICovXFxuZnVuY3Rpb24gUGVuZGluZyAobWVzc2FnZSkge1xcbiAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcXG59XFxuXFxufSx7fV0sMTY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEJhc2VcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciB0dHkgPSByZXF1aXJlKCd0dHknKTtcXG52YXIgZGlmZiA9IHJlcXVpcmUoJ2RpZmYnKTtcXG52YXIgbXMgPSByZXF1aXJlKCcuLi9tcycpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxudmFyIHN1cHBvcnRzQ29sb3IgPSBwcm9jZXNzLmJyb3dzZXIgPyBudWxsIDogcmVxdWlyZSgnc3VwcG9ydHMtY29sb3InKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEJhc2VgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nLlxcbiAqIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL21vY2hhanMvbW9jaGEvaXNzdWVzLzIzN1xcbiAqL1xcblxcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzLCBuby1uYXRpdmUtcmVhc3NpZ24gKi9cXG52YXIgRGF0ZSA9IGdsb2JhbC5EYXRlO1xcbnZhciBzZXRUaW1lb3V0ID0gZ2xvYmFsLnNldFRpbWVvdXQ7XFxudmFyIHNldEludGVydmFsID0gZ2xvYmFsLnNldEludGVydmFsO1xcbnZhciBjbGVhclRpbWVvdXQgPSBnbG9iYWwuY2xlYXJUaW1lb3V0O1xcbnZhciBjbGVhckludGVydmFsID0gZ2xvYmFsLmNsZWFySW50ZXJ2YWw7XFxuLyogZXNsaW50LWVuYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxuXFxuLyoqXFxuICogQ2hlY2sgaWYgYm90aCBzdGRpbyBzdHJlYW1zIGFyZSBhc3NvY2lhdGVkIHdpdGggYSB0dHkuXFxuICovXFxuXFxudmFyIGlzYXR0eSA9IHR0eS5pc2F0dHkoMSkgJiYgdHR5LmlzYXR0eSgyKTtcXG5cXG4vKipcXG4gKiBFbmFibGUgY29sb3JpbmcgYnkgZGVmYXVsdCwgZXhjZXB0IGluIHRoZSBicm93c2VyIGludGVyZmFjZS5cXG4gKi9cXG5cXG5leHBvcnRzLnVzZUNvbG9ycyA9ICFwcm9jZXNzLmJyb3dzZXIgJiYgKHN1cHBvcnRzQ29sb3IgfHwgKHByb2Nlc3MuZW52Lk1PQ0hBX0NPTE9SUyAhPT0gdW5kZWZpbmVkKSk7XFxuXFxuLyoqXFxuICogSW5saW5lIGRpZmZzIGluc3RlYWQgb2YgKy8tXFxuICovXFxuXFxuZXhwb3J0cy5pbmxpbmVEaWZmcyA9IGZhbHNlO1xcblxcbi8qKlxcbiAqIERlZmF1bHQgY29sb3IgbWFwLlxcbiAqL1xcblxcbmV4cG9ydHMuY29sb3JzID0ge1xcbiAgcGFzczogOTAsXFxuICBmYWlsOiAzMSxcXG4gICdicmlnaHQgcGFzcyc6IDkyLFxcbiAgJ2JyaWdodCBmYWlsJzogOTEsXFxuICAnYnJpZ2h0IHllbGxvdyc6IDkzLFxcbiAgcGVuZGluZzogMzYsXFxuICBzdWl0ZTogMCxcXG4gICdlcnJvciB0aXRsZSc6IDAsXFxuICAnZXJyb3IgbWVzc2FnZSc6IDMxLFxcbiAgJ2Vycm9yIHN0YWNrJzogOTAsXFxuICBjaGVja21hcms6IDMyLFxcbiAgZmFzdDogOTAsXFxuICBtZWRpdW06IDMzLFxcbiAgc2xvdzogMzEsXFxuICBncmVlbjogMzIsXFxuICBsaWdodDogOTAsXFxuICAnZGlmZiBndXR0ZXInOiA5MCxcXG4gICdkaWZmIGFkZGVkJzogMzIsXFxuICAnZGlmZiByZW1vdmVkJzogMzFcXG59O1xcblxcbi8qKlxcbiAqIERlZmF1bHQgc3ltYm9sIG1hcC5cXG4gKi9cXG5cXG5leHBvcnRzLnN5bWJvbHMgPSB7XFxuICBvazogJ+KckycsXFxuICBlcnI6ICfinJYnLFxcbiAgZG90OiAn4oCkJyxcXG4gIGNvbW1hOiAnLCcsXFxuICBiYW5nOiAnISdcXG59O1xcblxcbi8vIFdpdGggbm9kZS5qcyBvbiBXaW5kb3dzOiB1c2Ugc3ltYm9scyBhdmFpbGFibGUgaW4gdGVybWluYWwgZGVmYXVsdCBmb250c1xcbmlmIChwcm9jZXNzLnBsYXRmb3JtID09PSAnd2luMzInKSB7XFxuICBleHBvcnRzLnN5bWJvbHMub2sgPSAnXFxcXHUyMjFBJztcXG4gIGV4cG9ydHMuc3ltYm9scy5lcnIgPSAnXFxcXHUwMEQ3JztcXG4gIGV4cG9ydHMuc3ltYm9scy5kb3QgPSAnLic7XFxufVxcblxcbi8qKlxcbiAqIENvbG9yIGBzdHJgIHdpdGggdGhlIGdpdmVuIGB0eXBlYCxcXG4gKiBhbGxvd2luZyBjb2xvcnMgdG8gYmUgZGlzYWJsZWQsXFxuICogYXMgd2VsbCBhcyB1c2VyLWRlZmluZWQgY29sb3JcXG4gKiBzY2hlbWVzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbnZhciBjb2xvciA9IGV4cG9ydHMuY29sb3IgPSBmdW5jdGlvbiAodHlwZSwgc3RyKSB7XFxuICBpZiAoIWV4cG9ydHMudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBTdHJpbmcoc3RyKTtcXG4gIH1cXG4gIHJldHVybiAnXFxcXHUwMDFiWycgKyBleHBvcnRzLmNvbG9yc1t0eXBlXSArICdtJyArIHN0ciArICdcXFxcdTAwMWJbMG0nO1xcbn07XFxuXFxuLyoqXFxuICogRXhwb3NlIHRlcm0gd2luZG93IHNpemUsIHdpdGggc29tZSBkZWZhdWx0cyBmb3Igd2hlbiBzdGRlcnIgaXMgbm90IGEgdHR5LlxcbiAqL1xcblxcbmV4cG9ydHMud2luZG93ID0ge1xcbiAgd2lkdGg6IDc1XFxufTtcXG5cXG5pZiAoaXNhdHR5KSB7XFxuICBleHBvcnRzLndpbmRvdy53aWR0aCA9IHByb2Nlc3Muc3Rkb3V0LmdldFdpbmRvd1NpemVcXG4gICAgPyBwcm9jZXNzLnN0ZG91dC5nZXRXaW5kb3dTaXplKDEpWzBdXFxuICAgIDogdHR5LmdldFdpbmRvd1NpemUoKVsxXTtcXG59XFxuXFxuLyoqXFxuICogRXhwb3NlIHNvbWUgYmFzaWMgY3Vyc29yIGludGVyYWN0aW9ucyB0aGF0IGFyZSBjb21tb24gYW1vbmcgcmVwb3J0ZXJzLlxcbiAqL1xcblxcbmV4cG9ydHMuY3Vyc29yID0ge1xcbiAgaGlkZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVsJyk7XFxuICB9LFxcblxcbiAgc2hvdzogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYls/MjVoJyk7XFxuICB9LFxcblxcbiAgZGVsZXRlTGluZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlsySycpO1xcbiAgfSxcXG5cXG4gIGJlZ2lubmluZ09mTGluZTogZnVuY3Rpb24gKCkge1xcbiAgICBpc2F0dHkgJiYgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFx1MDAxYlswRycpO1xcbiAgfSxcXG5cXG4gIENSOiBmdW5jdGlvbiAoKSB7XFxuICAgIGlmIChpc2F0dHkpIHtcXG4gICAgICBleHBvcnRzLmN1cnNvci5kZWxldGVMaW5lKCk7XFxuICAgICAgZXhwb3J0cy5jdXJzb3IuYmVnaW5uaW5nT2ZMaW5lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxyJyk7XFxuICAgIH1cXG4gIH1cXG59O1xcblxcbmZ1bmN0aW9uIHNob3dEaWZmIChlcnIpIHtcXG4gIHJldHVybiBlcnIgJiYgZXJyLnNob3dEaWZmICE9PSBmYWxzZSAmJiBzYW1lVHlwZShlcnIuYWN0dWFsLCBlcnIuZXhwZWN0ZWQpICYmIGVyci5leHBlY3RlZCAhPT0gdW5kZWZpbmVkO1xcbn1cXG5cXG5mdW5jdGlvbiBzdHJpbmdpZnlEaWZmT2JqcyAoZXJyKSB7XFxuICBpZiAoIXV0aWxzLmlzU3RyaW5nKGVyci5hY3R1YWwpIHx8ICF1dGlscy5pc1N0cmluZyhlcnIuZXhwZWN0ZWQpKSB7XFxuICAgIGVyci5hY3R1YWwgPSB1dGlscy5zdHJpbmdpZnkoZXJyLmFjdHVhbCk7XFxuICAgIGVyci5leHBlY3RlZCA9IHV0aWxzLnN0cmluZ2lmeShlcnIuZXhwZWN0ZWQpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGEgZGlmZiBiZXR3ZWVuIDIgc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxcbiAqXFxuICogVGhlIGRpZmYgd2lsbCBiZSBlaXRoZXIgaW5saW5lIG9yIHVuaWZpZWQgZGVwZW5kYW50IG9uIHRoZSB2YWx1ZVxcbiAqIG9mIGBCYXNlLmlubGluZURpZmZgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGFjdHVhbFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBleHBlY3RlZFxcbiAqIEByZXR1cm4ge3N0cmluZ30gRGlmZlxcbiAqL1xcbnZhciBnZW5lcmF0ZURpZmYgPSBleHBvcnRzLmdlbmVyYXRlRGlmZiA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkKSB7XFxuICByZXR1cm4gZXhwb3J0cy5pbmxpbmVEaWZmc1xcbiAgICA/IGlubGluZURpZmYoYWN0dWFsLCBleHBlY3RlZClcXG4gICAgOiB1bmlmaWVkRGlmZihhY3R1YWwsIGV4cGVjdGVkKTtcXG59O1xcblxcbi8qKlxcbiAqIE91dHB1dCB0aGUgZ2l2ZW4gYGZhaWx1cmVzYCBhcyBhIGxpc3QuXFxuICpcXG4gKiBAcHVibGljXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQHZhcmlhdGlvbiAxXFxuICogQHBhcmFtIHtBcnJheX0gZmFpbHVyZXNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmV4cG9ydHMubGlzdCA9IGZ1bmN0aW9uIChmYWlsdXJlcykge1xcbiAgY29uc29sZS5sb2coKTtcXG4gIGZhaWx1cmVzLmZvckVhY2goZnVuY3Rpb24gKHRlc3QsIGkpIHtcXG4gICAgLy8gZm9ybWF0XFxuICAgIHZhciBmbXQgPSBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxcXG4nKSArXFxuICAgICAgY29sb3IoJ2Vycm9yIG1lc3NhZ2UnLCAnICAgICAlcycpICtcXG4gICAgICBjb2xvcignZXJyb3Igc3RhY2snLCAnXFxcXG4lc1xcXFxuJyk7XFxuXFxuICAgIC8vIG1zZ1xcbiAgICB2YXIgbXNnO1xcbiAgICB2YXIgZXJyID0gdGVzdC5lcnI7XFxuICAgIHZhciBtZXNzYWdlO1xcbiAgICBpZiAoZXJyLm1lc3NhZ2UgJiYgdHlwZW9mIGVyci5tZXNzYWdlLnRvU3RyaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5tZXNzYWdlICsgJyc7XFxuICAgIH0gZWxzZSBpZiAodHlwZW9mIGVyci5pbnNwZWN0ID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgbWVzc2FnZSA9IGVyci5pbnNwZWN0KCkgKyAnJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtZXNzYWdlID0gJyc7XFxuICAgIH1cXG4gICAgdmFyIHN0YWNrID0gZXJyLnN0YWNrIHx8IG1lc3NhZ2U7XFxuICAgIHZhciBpbmRleCA9IG1lc3NhZ2UgPyBzdGFjay5pbmRleE9mKG1lc3NhZ2UpIDogLTE7XFxuXFxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcXG4gICAgICBtc2cgPSBtZXNzYWdlO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGluZGV4ICs9IG1lc3NhZ2UubGVuZ3RoO1xcbiAgICAgIG1zZyA9IHN0YWNrLnNsaWNlKDAsIGluZGV4KTtcXG4gICAgICAvLyByZW1vdmUgbXNnIGZyb20gc3RhY2tcXG4gICAgICBzdGFjayA9IHN0YWNrLnNsaWNlKGluZGV4ICsgMSk7XFxuICAgIH1cXG5cXG4gICAgLy8gdW5jYXVnaHRcXG4gICAgaWYgKGVyci51bmNhdWdodCkge1xcbiAgICAgIG1zZyA9ICdVbmNhdWdodCAnICsgbXNnO1xcbiAgICB9XFxuICAgIC8vIGV4cGxpY2l0bHkgc2hvdyBkaWZmXFxuICAgIGlmICghZXhwb3J0cy5oaWRlRGlmZiAmJiBzaG93RGlmZihlcnIpKSB7XFxuICAgICAgc3RyaW5naWZ5RGlmZk9ianMoZXJyKTtcXG4gICAgICBmbXQgPSBjb2xvcignZXJyb3IgdGl0bGUnLCAnICAlcykgJXM6XFxcXG4lcycpICsgY29sb3IoJ2Vycm9yIHN0YWNrJywgJ1xcXFxuJXNcXFxcbicpO1xcbiAgICAgIHZhciBtYXRjaCA9IG1lc3NhZ2UubWF0Y2goL14oW146XSspOiBleHBlY3RlZC8pO1xcbiAgICAgIG1zZyA9ICdcXFxcbiAgICAgICcgKyBjb2xvcignZXJyb3IgbWVzc2FnZScsIG1hdGNoID8gbWF0Y2hbMV0gOiBtc2cpO1xcblxcbiAgICAgIG1zZyArPSBnZW5lcmF0ZURpZmYoZXJyLmFjdHVhbCwgZXJyLmV4cGVjdGVkKTtcXG4gICAgfVxcblxcbiAgICAvLyBpbmRlbnQgc3RhY2sgdHJhY2VcXG4gICAgc3RhY2sgPSBzdGFjay5yZXBsYWNlKC9eL2dtLCAnICAnKTtcXG5cXG4gICAgLy8gaW5kZW50ZWQgdGVzdCB0aXRsZVxcbiAgICB2YXIgdGVzdFRpdGxlID0gJyc7XFxuICAgIHRlc3QudGl0bGVQYXRoKCkuZm9yRWFjaChmdW5jdGlvbiAoc3RyLCBpbmRleCkge1xcbiAgICAgIGlmIChpbmRleCAhPT0gMCkge1xcbiAgICAgICAgdGVzdFRpdGxlICs9ICdcXFxcbiAgICAgJztcXG4gICAgICB9XFxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKSB7XFxuICAgICAgICB0ZXN0VGl0bGUgKz0gJyAgJztcXG4gICAgICB9XFxuICAgICAgdGVzdFRpdGxlICs9IHN0cjtcXG4gICAgfSk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgKGkgKyAxKSwgdGVzdFRpdGxlLCBtc2csIHN0YWNrKTtcXG4gIH0pO1xcbn07XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgQmFzZWAgcmVwb3J0ZXIuXFxuICpcXG4gKiBBbGwgb3RoZXIgcmVwb3J0ZXJzIGdlbmVyYWxseVxcbiAqIGluaGVyaXQgZnJvbSB0aGlzIHJlcG9ydGVyLCBwcm92aWRpbmdcXG4gKiBzdGF0cyBzdWNoIGFzIHRlc3QgZHVyYXRpb24sIG51bWJlclxcbiAqIG9mIHRlc3RzIHBhc3NlZCAvIGZhaWxlZCBldGMuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIEJhc2UgKHJ1bm5lcikge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cyA9IHsgc3VpdGVzOiAwLCB0ZXN0czogMCwgcGFzc2VzOiAwLCBwZW5kaW5nOiAwLCBmYWlsdXJlczogMCB9O1xcbiAgdmFyIGZhaWx1cmVzID0gdGhpcy5mYWlsdXJlcyA9IFtdO1xcblxcbiAgaWYgKCFydW5uZXIpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5ydW5uZXIgPSBydW5uZXI7XFxuXFxuICBydW5uZXIuc3RhdHMgPSBzdGF0cztcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLnN0YXJ0ID0gbmV3IERhdGUoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZScsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBzdGF0cy5zdWl0ZXMgPSBzdGF0cy5zdWl0ZXMgfHwgMDtcXG4gICAgc3VpdGUucm9vdCB8fCBzdGF0cy5zdWl0ZXMrKztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc3RhdHMudGVzdHMgPSBzdGF0cy50ZXN0cyB8fCAwO1xcbiAgICBzdGF0cy50ZXN0cysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBzdGF0cy5wYXNzZXMgPSBzdGF0cy5wYXNzZXMgfHwgMDtcXG5cXG4gICAgaWYgKHRlc3QuZHVyYXRpb24gPiB0ZXN0LnNsb3coKSkge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnc2xvdyc7XFxuICAgIH0gZWxzZSBpZiAodGVzdC5kdXJhdGlvbiA+IHRlc3Quc2xvdygpIC8gMikge1xcbiAgICAgIHRlc3Quc3BlZWQgPSAnbWVkaXVtJztcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0ZXN0LnNwZWVkID0gJ2Zhc3QnO1xcbiAgICB9XFxuXFxuICAgIHN0YXRzLnBhc3NlcysrO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIHN0YXRzLmZhaWx1cmVzID0gc3RhdHMuZmFpbHVyZXMgfHwgMDtcXG4gICAgc3RhdHMuZmFpbHVyZXMrKztcXG4gICAgaWYgKHNob3dEaWZmKGVycikpIHtcXG4gICAgICBzdHJpbmdpZnlEaWZmT2JqcyhlcnIpO1xcbiAgICB9XFxuICAgIHRlc3QuZXJyID0gZXJyO1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBzdGF0cy5lbmQgPSBuZXcgRGF0ZSgpO1xcbiAgICBzdGF0cy5kdXJhdGlvbiA9IHN0YXRzLmVuZCAtIHN0YXRzLnN0YXJ0O1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0YXRzLnBlbmRpbmcrKztcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBPdXRwdXQgY29tbW9uIGVwaWxvZ3VlIHVzZWQgYnkgbWFueSBvZlxcbiAqIHRoZSBidW5kbGVkIHJlcG9ydGVycy5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcbkJhc2UucHJvdG90eXBlLmVwaWxvZ3VlID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRzID0gdGhpcy5zdGF0cztcXG4gIHZhciBmbXQ7XFxuXFxuICBjb25zb2xlLmxvZygpO1xcblxcbiAgLy8gcGFzc2VzXFxuICBmbXQgPSBjb2xvcignYnJpZ2h0IHBhc3MnLCAnICcpICtcXG4gICAgY29sb3IoJ2dyZWVuJywgJyAlZCBwYXNzaW5nJykgK1xcbiAgICBjb2xvcignbGlnaHQnLCAnICglcyknKTtcXG5cXG4gIGNvbnNvbGUubG9nKGZtdCxcXG4gICAgc3RhdHMucGFzc2VzIHx8IDAsXFxuICAgIG1zKHN0YXRzLmR1cmF0aW9uKSk7XFxuXFxuICAvLyBwZW5kaW5nXFxuICBpZiAoc3RhdHMucGVuZGluZykge1xcbiAgICBmbXQgPSBjb2xvcigncGVuZGluZycsICcgJykgK1xcbiAgICAgIGNvbG9yKCdwZW5kaW5nJywgJyAlZCBwZW5kaW5nJyk7XFxuXFxuICAgIGNvbnNvbGUubG9nKGZtdCwgc3RhdHMucGVuZGluZyk7XFxuICB9XFxuXFxuICAvLyBmYWlsdXJlc1xcbiAgaWYgKHN0YXRzLmZhaWx1cmVzKSB7XFxuICAgIGZtdCA9IGNvbG9yKCdmYWlsJywgJyAgJWQgZmFpbGluZycpO1xcblxcbiAgICBjb25zb2xlLmxvZyhmbXQsIHN0YXRzLmZhaWx1cmVzKTtcXG5cXG4gICAgQmFzZS5saXN0KHRoaXMuZmFpbHVyZXMpO1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfVxcblxcbiAgY29uc29sZS5sb2coKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhZCB0aGUgZ2l2ZW4gYHN0cmAgdG8gYGxlbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHBhcmFtIHtzdHJpbmd9IGxlblxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBwYWQgKHN0ciwgbGVuKSB7XFxuICBzdHIgPSBTdHJpbmcoc3RyKTtcXG4gIHJldHVybiBBcnJheShsZW4gLSBzdHIubGVuZ3RoICsgMSkuam9pbignICcpICsgc3RyO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIGFuIGlubGluZSBkaWZmIGJldHdlZW4gMiBzdHJpbmdzIHdpdGggY29sb3VyZWQgQU5TSSBvdXRwdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSBEaWZmXFxuICovXFxuZnVuY3Rpb24gaW5saW5lRGlmZiAoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgdmFyIG1zZyA9IGVycm9yRGlmZihhY3R1YWwsIGV4cGVjdGVkKTtcXG5cXG4gIC8vIGxpbmVub3NcXG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxcXG4nKTtcXG4gIGlmIChsaW5lcy5sZW5ndGggPiA0KSB7XFxuICAgIHZhciB3aWR0aCA9IFN0cmluZyhsaW5lcy5sZW5ndGgpLmxlbmd0aDtcXG4gICAgbXNnID0gbGluZXMubWFwKGZ1bmN0aW9uIChzdHIsIGkpIHtcXG4gICAgICByZXR1cm4gcGFkKCsraSwgd2lkdGgpICsgJyB8JyArICcgJyArIHN0cjtcXG4gICAgfSkuam9pbignXFxcXG4nKTtcXG4gIH1cXG5cXG4gIC8vIGxlZ2VuZFxcbiAgbXNnID0gJ1xcXFxuJyArXFxuICAgIGNvbG9yKCdkaWZmIHJlbW92ZWQnLCAnYWN0dWFsJykgK1xcbiAgICAnICcgK1xcbiAgICBjb2xvcignZGlmZiBhZGRlZCcsICdleHBlY3RlZCcpICtcXG4gICAgJ1xcXFxuXFxcXG4nICtcXG4gICAgbXNnICtcXG4gICAgJ1xcXFxuJztcXG5cXG4gIC8vIGluZGVudFxcbiAgbXNnID0gbXNnLnJlcGxhY2UoL14vZ20sICcgICAgICAnKTtcXG4gIHJldHVybiBtc2c7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybnMgYSB1bmlmaWVkIGRpZmYgYmV0d2VlbiB0d28gc3RyaW5ncyB3aXRoIGNvbG91cmVkIEFOU0kgb3V0cHV0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdHJpbmd9IGFjdHVhbFxcbiAqIEBwYXJhbSB7U3RyaW5nfSBleHBlY3RlZFxcbiAqIEByZXR1cm4ge3N0cmluZ30gVGhlIGRpZmYuXFxuICovXFxuZnVuY3Rpb24gdW5pZmllZERpZmYgKGFjdHVhbCwgZXhwZWN0ZWQpIHtcXG4gIHZhciBpbmRlbnQgPSAnICAgICAgJztcXG4gIGZ1bmN0aW9uIGNsZWFuVXAgKGxpbmUpIHtcXG4gICAgaWYgKGxpbmVbMF0gPT09ICcrJykge1xcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIGFkZGVkJywgbGluZSk7XFxuICAgIH1cXG4gICAgaWYgKGxpbmVbMF0gPT09ICctJykge1xcbiAgICAgIHJldHVybiBpbmRlbnQgKyBjb2xvckxpbmVzKCdkaWZmIHJlbW92ZWQnLCBsaW5lKTtcXG4gICAgfVxcbiAgICBpZiAobGluZS5tYXRjaCgvQEAvKSkge1xcbiAgICAgIHJldHVybiAnLS0nO1xcbiAgICB9XFxuICAgIGlmIChsaW5lLm1hdGNoKC9cXFxcXFxcXCBObyBuZXdsaW5lLykpIHtcXG4gICAgICByZXR1cm4gbnVsbDtcXG4gICAgfVxcbiAgICByZXR1cm4gaW5kZW50ICsgbGluZTtcXG4gIH1cXG4gIGZ1bmN0aW9uIG5vdEJsYW5rIChsaW5lKSB7XFxuICAgIHJldHVybiB0eXBlb2YgbGluZSAhPT0gJ3VuZGVmaW5lZCcgJiYgbGluZSAhPT0gbnVsbDtcXG4gIH1cXG4gIHZhciBtc2cgPSBkaWZmLmNyZWF0ZVBhdGNoKCdzdHJpbmcnLCBhY3R1YWwsIGV4cGVjdGVkKTtcXG4gIHZhciBsaW5lcyA9IG1zZy5zcGxpdCgnXFxcXG4nKS5zcGxpY2UoNSk7XFxuICByZXR1cm4gJ1xcXFxuICAgICAgJyArXFxuICAgIGNvbG9yTGluZXMoJ2RpZmYgYWRkZWQnLCAnKyBleHBlY3RlZCcpICsgJyAnICtcXG4gICAgY29sb3JMaW5lcygnZGlmZiByZW1vdmVkJywgJy0gYWN0dWFsJykgK1xcbiAgICAnXFxcXG5cXFxcbicgK1xcbiAgICBsaW5lcy5tYXAoY2xlYW5VcCkuZmlsdGVyKG5vdEJsYW5rKS5qb2luKCdcXFxcbicpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBjaGFyYWN0ZXIgZGlmZiBmb3IgYGVycmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gYWN0dWFsXFxuICogQHBhcmFtIHtTdHJpbmd9IGV4cGVjdGVkXFxuICogQHJldHVybiB7c3RyaW5nfSB0aGUgZGlmZlxcbiAqL1xcbmZ1bmN0aW9uIGVycm9yRGlmZiAoYWN0dWFsLCBleHBlY3RlZCkge1xcbiAgcmV0dXJuIGRpZmYuZGlmZldvcmRzV2l0aFNwYWNlKGFjdHVhbCwgZXhwZWN0ZWQpLm1hcChmdW5jdGlvbiAoc3RyKSB7XFxuICAgIGlmIChzdHIuYWRkZWQpIHtcXG4gICAgICByZXR1cm4gY29sb3JMaW5lcygnZGlmZiBhZGRlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgaWYgKHN0ci5yZW1vdmVkKSB7XFxuICAgICAgcmV0dXJuIGNvbG9yTGluZXMoJ2RpZmYgcmVtb3ZlZCcsIHN0ci52YWx1ZSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHN0ci52YWx1ZTtcXG4gIH0pLmpvaW4oJycpO1xcbn1cXG5cXG4vKipcXG4gKiBDb2xvciBsaW5lcyBmb3IgYHN0cmAsIHVzaW5nIHRoZSBjb2xvciBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gY29sb3JMaW5lcyAobmFtZSwgc3RyKSB7XFxuICByZXR1cm4gc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbiAoc3RyKSB7XFxuICAgIHJldHVybiBjb2xvcihuYW1lLCBzdHIpO1xcbiAgfSkuam9pbignXFxcXG4nKTtcXG59XFxuXFxuLyoqXFxuICogT2JqZWN0I3RvU3RyaW5nIHJlZmVyZW5jZS5cXG4gKi9cXG52YXIgb2JqVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIENoZWNrIHRoYXQgYSAvIGIgaGF2ZSB0aGUgc2FtZSB0eXBlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IGFcXG4gKiBAcGFyYW0ge09iamVjdH0gYlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gc2FtZVR5cGUgKGEsIGIpIHtcXG4gIHJldHVybiBvYmpUb1N0cmluZy5jYWxsKGEpID09PSBvYmpUb1N0cmluZy5jYWxsKGIpO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi9tc1xcXCI6MTQsXFxcIi4uL3V0aWxzXFxcIjozNixcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJkaWZmXFxcIjo0NSxcXFwic3VwcG9ydHMtY29sb3JcXFwiOjQwLFxcXCJ0dHlcXFwiOjR9XSwxNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgRG9jXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBEb2NgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IERvYztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBEb2NgIHJlcG9ydGVyLlxcbiAqXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIHtCYXNlfVxcbiAqIEBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5mdW5jdGlvbiBEb2MgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgaW5kZW50cyA9IDI7XFxuXFxuICBmdW5jdGlvbiBpbmRlbnQgKCkge1xcbiAgICByZXR1cm4gQXJyYXkoaW5kZW50cykuam9pbignICAnKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgKytpbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZygnJXM8c2VjdGlvbiBjbGFzcz1cXFwic3VpdGVcXFwiPicsIGluZGVudCgpKTtcXG4gICAgKytpbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZygnJXM8aDE+JXM8L2gxPicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUoc3VpdGUudGl0bGUpKTtcXG4gICAgY29uc29sZS5sb2coJyVzPGRsPicsIGluZGVudCgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdzdWl0ZSBlbmQnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgY29uc29sZS5sb2coJyVzPC9kbD4nLCBpbmRlbnQoKSk7XFxuICAgIC0taW5kZW50cztcXG4gICAgY29uc29sZS5sb2coJyVzPC9zZWN0aW9uPicsIGluZGVudCgpKTtcXG4gICAgLS1pbmRlbnRzO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkdD4lczwvZHQ+JywgaW5kZW50KCksIHV0aWxzLmVzY2FwZSh0ZXN0LnRpdGxlKSk7XFxuICAgIHZhciBjb2RlID0gdXRpbHMuZXNjYXBlKHV0aWxzLmNsZWFuKHRlc3QuYm9keSkpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZD48cHJlPjxjb2RlPiVzPC9jb2RlPjwvcHJlPjwvZGQ+JywgaW5kZW50KCksIGNvZGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIGNvbnNvbGUubG9nKCclcyAgPGR0IGNsYXNzPVxcXCJlcnJvclxcXCI+JXM8L2R0PicsIGluZGVudCgpLCB1dGlscy5lc2NhcGUodGVzdC50aXRsZSkpO1xcbiAgICB2YXIgY29kZSA9IHV0aWxzLmVzY2FwZSh1dGlscy5jbGVhbih0ZXN0LmJvZHkpKTtcXG4gICAgY29uc29sZS5sb2coJyVzICA8ZGQgY2xhc3M9XFxcImVycm9yXFxcIj48cHJlPjxjb2RlPiVzPC9jb2RlPjwvcHJlPjwvZGQ+JywgaW5kZW50KCksIGNvZGUpO1xcbiAgICBjb25zb2xlLmxvZygnJXMgIDxkZCBjbGFzcz1cXFwiZXJyb3JcXFwiPiVzPC9kZD4nLCBpbmRlbnQoKSwgdXRpbHMuZXNjYXBlKGVycikpO1xcbiAgfSk7XFxufVxcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTZ9XSwxODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBEb3RcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG90YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBEb3Q7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgRG90YCBtYXRyaXggdGVzdCByZXBvcnRlci5cXG4gKlxcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBEb3QgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgd2lkdGggPSBCYXNlLndpbmRvdy53aWR0aCAqIDAuNzUgfCAwO1xcbiAgdmFyIG4gPSAtMTtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbicpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGlmICgrK24gJSB3aWR0aCA9PT0gMCkge1xcbiAgICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcbiAgJyk7XFxuICAgIH1cXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ3BlbmRpbmcnLCBCYXNlLnN5bWJvbHMuY29tbWEpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBpZiAodGVzdC5zcGVlZCA9PT0gJ3Nsb3cnKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IoJ2JyaWdodCB5ZWxsb3cnLCBCYXNlLnN5bWJvbHMuZG90KSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoY29sb3IodGVzdC5zcGVlZCwgQmFzZS5zeW1ib2xzLmRvdCkpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgaWYgKCsrbiAlIHdpZHRoID09PSAwKSB7XFxuICAgICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgfVxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcignZmFpbCcsIEJhc2Uuc3ltYm9scy5iYW5nKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhEb3QsIEJhc2UpO1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDE5OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qIGVzbGludC1lbnYgYnJvd3NlciAqL1xcbi8qKlxcbiAqIEBtb2R1bGUgSFRNTFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcbnZhciBQcm9ncmVzcyA9IHJlcXVpcmUoJy4uL2Jyb3dzZXIvcHJvZ3Jlc3MnKTtcXG52YXIgZXNjYXBlUmUgPSByZXF1aXJlKCdlc2NhcGUtc3RyaW5nLXJlZ2V4cCcpO1xcbnZhciBlc2NhcGUgPSB1dGlscy5lc2NhcGU7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgSFRNTGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gSFRNTDtcXG5cXG4vKipcXG4gKiBTdGF0cyB0ZW1wbGF0ZS5cXG4gKi9cXG5cXG52YXIgc3RhdHNUZW1wbGF0ZSA9ICc8dWwgaWQ9XFxcIm1vY2hhLXN0YXRzXFxcIj4nICtcXG4gICc8bGkgY2xhc3M9XFxcInByb2dyZXNzXFxcIj48Y2FudmFzIHdpZHRoPVxcXCI0MFxcXCIgaGVpZ2h0PVxcXCI0MFxcXCI+PC9jYW52YXM+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcInBhc3Nlc1xcXCI+PGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApO1xcXCI+cGFzc2VzOjwvYT4gPGVtPjA8L2VtPjwvbGk+JyArXFxuICAnPGxpIGNsYXNzPVxcXCJmYWlsdXJlc1xcXCI+PGEgaHJlZj1cXFwiamF2YXNjcmlwdDp2b2lkKDApO1xcXCI+ZmFpbHVyZXM6PC9hPiA8ZW0+MDwvZW0+PC9saT4nICtcXG4gICc8bGkgY2xhc3M9XFxcImR1cmF0aW9uXFxcIj5kdXJhdGlvbjogPGVtPjA8L2VtPnM8L2xpPicgK1xcbiAgJzwvdWw+JztcXG5cXG52YXIgcGxheUljb24gPSAnJiN4MjAyMzsnO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEhUTUxgIHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIEhUTUwgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhdHMgPSB0aGlzLnN0YXRzO1xcbiAgdmFyIHN0YXQgPSBmcmFnbWVudChzdGF0c1RlbXBsYXRlKTtcXG4gIHZhciBpdGVtcyA9IHN0YXQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2xpJyk7XFxuICB2YXIgcGFzc2VzID0gaXRlbXNbMV0uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgcGFzc2VzTGluayA9IGl0ZW1zWzFdLmdldEVsZW1lbnRzQnlUYWdOYW1lKCdhJylbMF07XFxuICB2YXIgZmFpbHVyZXMgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnZW0nKVswXTtcXG4gIHZhciBmYWlsdXJlc0xpbmsgPSBpdGVtc1syXS5nZXRFbGVtZW50c0J5VGFnTmFtZSgnYScpWzBdO1xcbiAgdmFyIGR1cmF0aW9uID0gaXRlbXNbM10uZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2VtJylbMF07XFxuICB2YXIgY2FudmFzID0gc3RhdC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnY2FudmFzJylbMF07XFxuICB2YXIgcmVwb3J0ID0gZnJhZ21lbnQoJzx1bCBpZD1cXFwibW9jaGEtcmVwb3J0XFxcIj48L3VsPicpO1xcbiAgdmFyIHN0YWNrID0gW3JlcG9ydF07XFxuICB2YXIgcHJvZ3Jlc3M7XFxuICB2YXIgY3R4O1xcbiAgdmFyIHJvb3QgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnbW9jaGEnKTtcXG5cXG4gIGlmIChjYW52YXMuZ2V0Q29udGV4dCkge1xcbiAgICB2YXIgcmF0aW8gPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxO1xcbiAgICBjYW52YXMuc3R5bGUud2lkdGggPSBjYW52YXMud2lkdGg7XFxuICAgIGNhbnZhcy5zdHlsZS5oZWlnaHQgPSBjYW52YXMuaGVpZ2h0O1xcbiAgICBjYW52YXMud2lkdGggKj0gcmF0aW87XFxuICAgIGNhbnZhcy5oZWlnaHQgKj0gcmF0aW87XFxuICAgIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xcbiAgICBjdHguc2NhbGUocmF0aW8sIHJhdGlvKTtcXG4gICAgcHJvZ3Jlc3MgPSBuZXcgUHJvZ3Jlc3MoKTtcXG4gIH1cXG5cXG4gIGlmICghcm9vdCkge1xcbiAgICByZXR1cm4gZXJyb3IoJyNtb2NoYSBkaXYgbWlzc2luZywgYWRkIGl0IHRvIHlvdXIgZG9jdW1lbnQnKTtcXG4gIH1cXG5cXG4gIC8vIHBhc3MgdG9nZ2xlXFxuICBvbihwYXNzZXNMaW5rLCAnY2xpY2snLCBmdW5jdGlvbiAoZXZ0KSB7XFxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xcbiAgICB1bmhpZGUoKTtcXG4gICAgdmFyIG5hbWUgPSAoL3Bhc3MvKS50ZXN0KHJlcG9ydC5jbGFzc05hbWUpID8gJycgOiAnIHBhc3MnO1xcbiAgICByZXBvcnQuY2xhc3NOYW1lID0gcmVwb3J0LmNsYXNzTmFtZS5yZXBsYWNlKC9mYWlsfHBhc3MvZywgJycpICsgbmFtZTtcXG4gICAgaWYgKHJlcG9ydC5jbGFzc05hbWUudHJpbSgpKSB7XFxuICAgICAgaGlkZVN1aXRlc1dpdGhvdXQoJ3Rlc3QgcGFzcycpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIC8vIGZhaWx1cmUgdG9nZ2xlXFxuICBvbihmYWlsdXJlc0xpbmssICdjbGljaycsIGZ1bmN0aW9uIChldnQpIHtcXG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XFxuICAgIHVuaGlkZSgpO1xcbiAgICB2YXIgbmFtZSA9ICgvZmFpbC8pLnRlc3QocmVwb3J0LmNsYXNzTmFtZSkgPyAnJyA6ICcgZmFpbCc7XFxuICAgIHJlcG9ydC5jbGFzc05hbWUgPSByZXBvcnQuY2xhc3NOYW1lLnJlcGxhY2UoL2ZhaWx8cGFzcy9nLCAnJykgKyBuYW1lO1xcbiAgICBpZiAocmVwb3J0LmNsYXNzTmFtZS50cmltKCkpIHtcXG4gICAgICBoaWRlU3VpdGVzV2l0aG91dCgndGVzdCBmYWlsJyk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcm9vdC5hcHBlbmRDaGlsZChzdGF0KTtcXG4gIHJvb3QuYXBwZW5kQ2hpbGQocmVwb3J0KTtcXG5cXG4gIGlmIChwcm9ncmVzcykge1xcbiAgICBwcm9ncmVzcy5zaXplKDQwKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgaWYgKHN1aXRlLnJvb3QpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gc3VpdGVcXG4gICAgdmFyIHVybCA9IHNlbGYuc3VpdGVVUkwoc3VpdGUpO1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudCgnPGxpIGNsYXNzPVxcXCJzdWl0ZVxcXCI+PGgxPjxhIGhyZWY9XFxcIiVzXFxcIj4lczwvYT48L2gxPjwvbGk+JywgdXJsLCBlc2NhcGUoc3VpdGUudGl0bGUpKTtcXG5cXG4gICAgLy8gY29udGFpbmVyXFxuICAgIHN0YWNrWzBdLmFwcGVuZENoaWxkKGVsKTtcXG4gICAgc3RhY2sudW5zaGlmdChkb2N1bWVudC5jcmVhdGVFbGVtZW50KCd1bCcpKTtcXG4gICAgZWwuYXBwZW5kQ2hpbGQoc3RhY2tbMF0pO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBpZiAoc3VpdGUucm9vdCkge1xcbiAgICAgIHVwZGF0ZVN0YXRzKCk7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHN0YWNrLnNoaWZ0KCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciB1cmwgPSBzZWxmLnRlc3RVUkwodGVzdCk7XFxuICAgIHZhciBtYXJrdXAgPSAnPGxpIGNsYXNzPVxcXCJ0ZXN0IHBhc3MgJWVcXFwiPjxoMj4lZTxzcGFuIGNsYXNzPVxcXCJkdXJhdGlvblxcXCI+JWVtczwvc3Bhbj4gJyArXFxuICAgICAgJzxhIGhyZWY9XFxcIiVzXFxcIiBjbGFzcz1cXFwicmVwbGF5XFxcIj4nICsgcGxheUljb24gKyAnPC9hPjwvaDI+PC9saT4nO1xcbiAgICB2YXIgZWwgPSBmcmFnbWVudChtYXJrdXAsIHRlc3Quc3BlZWQsIHRlc3QudGl0bGUsIHRlc3QuZHVyYXRpb24sIHVybCk7XFxuICAgIHNlbGYuYWRkQ29kZVRvZ2dsZShlbCwgdGVzdC5ib2R5KTtcXG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XFxuICAgIHVwZGF0ZVN0YXRzKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBlbCA9IGZyYWdtZW50KCc8bGkgY2xhc3M9XFxcInRlc3QgZmFpbFxcXCI+PGgyPiVlIDxhIGhyZWY9XFxcIiVlXFxcIiBjbGFzcz1cXFwicmVwbGF5XFxcIj4nICsgcGxheUljb24gKyAnPC9hPjwvaDI+PC9saT4nLFxcbiAgICAgIHRlc3QudGl0bGUsIHNlbGYudGVzdFVSTCh0ZXN0KSk7XFxuICAgIHZhciBzdGFja1N0cmluZzsgLy8gTm90ZTogSW5jbHVkZXMgbGVhZGluZyBuZXdsaW5lXFxuICAgIHZhciBtZXNzYWdlID0gdGVzdC5lcnIudG9TdHJpbmcoKTtcXG5cXG4gICAgLy8gPD1JRTcgc3RyaW5naWZpZXMgdG8gW09iamVjdCBFcnJvcl0uIFNpbmNlIGl0IGNhbiBiZSBvdmVybG9hZGVkLCB3ZVxcbiAgICAvLyBjaGVjayBmb3IgdGhlIHJlc3VsdCBvZiB0aGUgc3RyaW5naWZ5aW5nLlxcbiAgICBpZiAobWVzc2FnZSA9PT0gJ1tvYmplY3QgRXJyb3JdJykge1xcbiAgICAgIG1lc3NhZ2UgPSB0ZXN0LmVyci5tZXNzYWdlO1xcbiAgICB9XFxuXFxuICAgIGlmICh0ZXN0LmVyci5zdGFjaykge1xcbiAgICAgIHZhciBpbmRleE9mTWVzc2FnZSA9IHRlc3QuZXJyLnN0YWNrLmluZGV4T2YodGVzdC5lcnIubWVzc2FnZSk7XFxuICAgICAgaWYgKGluZGV4T2ZNZXNzYWdlID09PSAtMSkge1xcbiAgICAgICAgc3RhY2tTdHJpbmcgPSB0ZXN0LmVyci5zdGFjaztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RhY2tTdHJpbmcgPSB0ZXN0LmVyci5zdGFjay5zdWJzdHIodGVzdC5lcnIubWVzc2FnZS5sZW5ndGggKyBpbmRleE9mTWVzc2FnZSk7XFxuICAgICAgfVxcbiAgICB9IGVsc2UgaWYgKHRlc3QuZXJyLnNvdXJjZVVSTCAmJiB0ZXN0LmVyci5saW5lICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAvLyBTYWZhcmkgZG9lc24ndCBnaXZlIHlvdSBhIHN0YWNrLiBMZXQncyBhdCBsZWFzdCBwcm92aWRlIGEgc291cmNlIGxpbmUuXFxuICAgICAgc3RhY2tTdHJpbmcgPSAnXFxcXG4oJyArIHRlc3QuZXJyLnNvdXJjZVVSTCArICc6JyArIHRlc3QuZXJyLmxpbmUgKyAnKSc7XFxuICAgIH1cXG5cXG4gICAgc3RhY2tTdHJpbmcgPSBzdGFja1N0cmluZyB8fCAnJztcXG5cXG4gICAgaWYgKHRlc3QuZXJyLmh0bWxNZXNzYWdlICYmIHN0YWNrU3RyaW5nKSB7XFxuICAgICAgZWwuYXBwZW5kQ2hpbGQoZnJhZ21lbnQoJzxkaXYgY2xhc3M9XFxcImh0bWwtZXJyb3JcXFwiPiVzXFxcXG48cHJlIGNsYXNzPVxcXCJlcnJvclxcXCI+JWU8L3ByZT48L2Rpdj4nLFxcbiAgICAgICAgdGVzdC5lcnIuaHRtbE1lc3NhZ2UsIHN0YWNrU3RyaW5nKSk7XFxuICAgIH0gZWxzZSBpZiAodGVzdC5lcnIuaHRtbE1lc3NhZ2UpIHtcXG4gICAgICBlbC5hcHBlbmRDaGlsZChmcmFnbWVudCgnPGRpdiBjbGFzcz1cXFwiaHRtbC1lcnJvclxcXCI+JXM8L2Rpdj4nLCB0ZXN0LmVyci5odG1sTWVzc2FnZSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGVsLmFwcGVuZENoaWxkKGZyYWdtZW50KCc8cHJlIGNsYXNzPVxcXCJlcnJvclxcXCI+JWUlZTwvcHJlPicsIG1lc3NhZ2UsIHN0YWNrU3RyaW5nKSk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5hZGRDb2RlVG9nZ2xlKGVsLCB0ZXN0LmJvZHkpO1xcbiAgICBhcHBlbmRUb1N0YWNrKGVsKTtcXG4gICAgdXBkYXRlU3RhdHMoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGVsID0gZnJhZ21lbnQoJzxsaSBjbGFzcz1cXFwidGVzdCBwYXNzIHBlbmRpbmdcXFwiPjxoMj4lZTwvaDI+PC9saT4nLCB0ZXN0LnRpdGxlKTtcXG4gICAgYXBwZW5kVG9TdGFjayhlbCk7XFxuICAgIHVwZGF0ZVN0YXRzKCk7XFxuICB9KTtcXG5cXG4gIGZ1bmN0aW9uIGFwcGVuZFRvU3RhY2sgKGVsKSB7XFxuICAgIC8vIERvbid0IGNhbGwgLmFwcGVuZENoaWxkIGlmICNtb2NoYS1yZXBvcnQgd2FzIGFscmVhZHkgLnNoaWZ0KCknZWQgb2ZmIHRoZSBzdGFjay5cXG4gICAgaWYgKHN0YWNrWzBdKSB7XFxuICAgICAgc3RhY2tbMF0uYXBwZW5kQ2hpbGQoZWwpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiB1cGRhdGVTdGF0cyAoKSB7XFxuICAgIC8vIFRPRE86IGFkZCB0byBzdGF0c1xcbiAgICB2YXIgcGVyY2VudCA9IHN0YXRzLnRlc3RzIC8gcnVubmVyLnRvdGFsICogMTAwIHwgMDtcXG4gICAgaWYgKHByb2dyZXNzKSB7XFxuICAgICAgcHJvZ3Jlc3MudXBkYXRlKHBlcmNlbnQpLmRyYXcoY3R4KTtcXG4gICAgfVxcblxcbiAgICAvLyB1cGRhdGUgc3RhdHNcXG4gICAgdmFyIG1zID0gbmV3IERhdGUoKSAtIHN0YXRzLnN0YXJ0O1xcbiAgICB0ZXh0KHBhc3Nlcywgc3RhdHMucGFzc2VzKTtcXG4gICAgdGV4dChmYWlsdXJlcywgc3RhdHMuZmFpbHVyZXMpO1xcbiAgICB0ZXh0KGR1cmF0aW9uLCAobXMgLyAxMDAwKS50b0ZpeGVkKDIpKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogTWFrZXMgYSBVUkwsIHByZXNlcnZpbmcgcXVlcnlzdHJpbmcgKFxcXCJzZWFyY2hcXFwiKSBwYXJhbWV0ZXJzLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9IEEgbmV3IFVSTC5cXG4gKi9cXG5mdW5jdGlvbiBtYWtlVXJsIChzKSB7XFxuICB2YXIgc2VhcmNoID0gd2luZG93LmxvY2F0aW9uLnNlYXJjaDtcXG5cXG4gIC8vIFJlbW92ZSBwcmV2aW91cyBncmVwIHF1ZXJ5IHBhcmFtZXRlciBpZiBwcmVzZW50XFxuICBpZiAoc2VhcmNoKSB7XFxuICAgIHNlYXJjaCA9IHNlYXJjaC5yZXBsYWNlKC9bPyZdZ3JlcD1bXiZcXFxcc10qL2csICcnKS5yZXBsYWNlKC9eJi8sICc/Jyk7XFxuICB9XFxuXFxuICByZXR1cm4gd2luZG93LmxvY2F0aW9uLnBhdGhuYW1lICsgKHNlYXJjaCA/IHNlYXJjaCArICcmJyA6ICc/JykgKyAnZ3JlcD0nICsgZW5jb2RlVVJJQ29tcG9uZW50KGVzY2FwZVJlKHMpKTtcXG59XFxuXFxuLyoqXFxuICogUHJvdmlkZSBzdWl0ZSBVUkwuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gW3N1aXRlXVxcbiAqL1xcbkhUTUwucHJvdG90eXBlLnN1aXRlVVJMID0gZnVuY3Rpb24gKHN1aXRlKSB7XFxuICByZXR1cm4gbWFrZVVybChzdWl0ZS5mdWxsVGl0bGUoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBQcm92aWRlIHRlc3QgVVJMLlxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IFt0ZXN0XVxcbiAqL1xcbkhUTUwucHJvdG90eXBlLnRlc3RVUkwgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgcmV0dXJuIG1ha2VVcmwodGVzdC5mdWxsVGl0bGUoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBBZGRzIGNvZGUgdG9nZ2xlIGZ1bmN0aW9uYWxpdHkgZm9yIHRoZSBwcm92aWRlZCB0ZXN0J3MgbGlzdCBlbGVtZW50LlxcbiAqXFxuICogQHBhcmFtIHtIVE1MTElFbGVtZW50fSBlbFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xcbiAqL1xcbkhUTUwucHJvdG90eXBlLmFkZENvZGVUb2dnbGUgPSBmdW5jdGlvbiAoZWwsIGNvbnRlbnRzKSB7XFxuICB2YXIgaDIgPSBlbC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaDInKVswXTtcXG5cXG4gIG9uKGgyLCAnY2xpY2snLCBmdW5jdGlvbiAoKSB7XFxuICAgIHByZS5zdHlsZS5kaXNwbGF5ID0gcHJlLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICdibG9jaycgOiAnbm9uZSc7XFxuICB9KTtcXG5cXG4gIHZhciBwcmUgPSBmcmFnbWVudCgnPHByZT48Y29kZT4lZTwvY29kZT48L3ByZT4nLCB1dGlscy5jbGVhbihjb250ZW50cykpO1xcbiAgZWwuYXBwZW5kQ2hpbGQocHJlKTtcXG4gIHByZS5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xcbn07XFxuXFxuLyoqXFxuICogRGlzcGxheSBlcnJvciBgbXNnYC5cXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBtc2dcXG4gKi9cXG5mdW5jdGlvbiBlcnJvciAobXNnKSB7XFxuICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGZyYWdtZW50KCc8ZGl2IGlkPVxcXCJtb2NoYS1lcnJvclxcXCI+JXM8L2Rpdj4nLCBtc2cpKTtcXG59XFxuXFxuLyoqXFxuICogUmV0dXJuIGEgRE9NIGZyYWdtZW50IGZyb20gYGh0bWxgLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGh0bWxcXG4gKi9cXG5mdW5jdGlvbiBmcmFnbWVudCAoaHRtbCkge1xcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICB2YXIgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XFxuICB2YXIgaSA9IDE7XFxuXFxuICBkaXYuaW5uZXJIVE1MID0gaHRtbC5yZXBsYWNlKC8lKFtzZV0pL2csIGZ1bmN0aW9uIChfLCB0eXBlKSB7XFxuICAgIHN3aXRjaCAodHlwZSkge1xcbiAgICAgIGNhc2UgJ3MnOiByZXR1cm4gU3RyaW5nKGFyZ3NbaSsrXSk7XFxuICAgICAgY2FzZSAnZSc6IHJldHVybiBlc2NhcGUoYXJnc1tpKytdKTtcXG4gICAgICAvLyBubyBkZWZhdWx0XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcmV0dXJuIGRpdi5maXJzdENoaWxkO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVjayBmb3Igc3VpdGVzIHRoYXQgZG8gbm90IGhhdmUgZWxlbWVudHNcXG4gKiB3aXRoIGBjbGFzc25hbWVgLCBhbmQgaGlkZSB0aGVtLlxcbiAqXFxuICogQHBhcmFtIHt0ZXh0fSBjbGFzc25hbWVcXG4gKi9cXG5mdW5jdGlvbiBoaWRlU3VpdGVzV2l0aG91dCAoY2xhc3NuYW1lKSB7XFxuICB2YXIgc3VpdGVzID0gZG9jdW1lbnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSgnc3VpdGUnKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc3VpdGVzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBlbHMgPSBzdWl0ZXNbaV0uZ2V0RWxlbWVudHNCeUNsYXNzTmFtZShjbGFzc25hbWUpO1xcbiAgICBpZiAoIWVscy5sZW5ndGgpIHtcXG4gICAgICBzdWl0ZXNbaV0uY2xhc3NOYW1lICs9ICcgaGlkZGVuJztcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBVbmhpZGUgLmhpZGRlbiBzdWl0ZXMuXFxuICovXFxuZnVuY3Rpb24gdW5oaWRlICgpIHtcXG4gIHZhciBlbHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCdzdWl0ZSBoaWRkZW4nKTtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZWxzLmxlbmd0aDsgKytpKSB7XFxuICAgIGVsc1tpXS5jbGFzc05hbWUgPSBlbHNbaV0uY2xhc3NOYW1lLnJlcGxhY2UoJ3N1aXRlIGhpZGRlbicsICdzdWl0ZScpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBTZXQgYW4gZWxlbWVudCdzIHRleHQgY29udGVudHMuXFxuICpcXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbFxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50c1xcbiAqL1xcbmZ1bmN0aW9uIHRleHQgKGVsLCBjb250ZW50cykge1xcbiAgaWYgKGVsLnRleHRDb250ZW50KSB7XFxuICAgIGVsLnRleHRDb250ZW50ID0gY29udGVudHM7XFxuICB9IGVsc2Uge1xcbiAgICBlbC5pbm5lclRleHQgPSBjb250ZW50cztcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogTGlzdGVuIG9uIGBldmVudGAgd2l0aCBjYWxsYmFjayBgZm5gLlxcbiAqL1xcbmZ1bmN0aW9uIG9uIChlbCwgZXZlbnQsIGZuKSB7XFxuICBpZiAoZWwuYWRkRXZlbnRMaXN0ZW5lcikge1xcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBmbiwgZmFsc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgZWwuYXR0YWNoRXZlbnQoJ29uJyArIGV2ZW50LCBmbik7XFxuICB9XFxufVxcblxcbn0pLmNhbGwodGhpcyx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuLi9icm93c2VyL3Byb2dyZXNzXFxcIjozLFxcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcImVzY2FwZS1zdHJpbmctcmVnZXhwXFxcIjo0Nn1dLDIwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLy8gQWxpYXMgZXhwb3J0cyB0byBhIHRoZWlyIG5vcm1hbGl6ZWQgZm9ybWF0IE1vY2hhI3JlcG9ydGVyIHRvIHByZXZlbnQgYSBuZWVkXFxuLy8gZm9yIGR5bmFtaWMgKHRyeS9jYXRjaCkgcmVxdWlyZXMsIHdoaWNoIEJyb3dzZXJpZnkgZG9lc24ndCBoYW5kbGUuXFxuZXhwb3J0cy5CYXNlID0gZXhwb3J0cy5iYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuZXhwb3J0cy5Eb3QgPSBleHBvcnRzLmRvdCA9IHJlcXVpcmUoJy4vZG90Jyk7XFxuZXhwb3J0cy5Eb2MgPSBleHBvcnRzLmRvYyA9IHJlcXVpcmUoJy4vZG9jJyk7XFxuZXhwb3J0cy5UQVAgPSBleHBvcnRzLnRhcCA9IHJlcXVpcmUoJy4vdGFwJyk7XFxuZXhwb3J0cy5KU09OID0gZXhwb3J0cy5qc29uID0gcmVxdWlyZSgnLi9qc29uJyk7XFxuZXhwb3J0cy5IVE1MID0gZXhwb3J0cy5odG1sID0gcmVxdWlyZSgnLi9odG1sJyk7XFxuZXhwb3J0cy5MaXN0ID0gZXhwb3J0cy5saXN0ID0gcmVxdWlyZSgnLi9saXN0Jyk7XFxuZXhwb3J0cy5NaW4gPSBleHBvcnRzLm1pbiA9IHJlcXVpcmUoJy4vbWluJyk7XFxuZXhwb3J0cy5TcGVjID0gZXhwb3J0cy5zcGVjID0gcmVxdWlyZSgnLi9zcGVjJyk7XFxuZXhwb3J0cy5OeWFuID0gZXhwb3J0cy5ueWFuID0gcmVxdWlyZSgnLi9ueWFuJyk7XFxuZXhwb3J0cy5YVW5pdCA9IGV4cG9ydHMueHVuaXQgPSByZXF1aXJlKCcuL3h1bml0Jyk7XFxuZXhwb3J0cy5NYXJrZG93biA9IGV4cG9ydHMubWFya2Rvd24gPSByZXF1aXJlKCcuL21hcmtkb3duJyk7XFxuZXhwb3J0cy5Qcm9ncmVzcyA9IGV4cG9ydHMucHJvZ3Jlc3MgPSByZXF1aXJlKCcuL3Byb2dyZXNzJyk7XFxuZXhwb3J0cy5MYW5kaW5nID0gZXhwb3J0cy5sYW5kaW5nID0gcmVxdWlyZSgnLi9sYW5kaW5nJyk7XFxuZXhwb3J0cy5KU09OU3RyZWFtID0gZXhwb3J0c1snanNvbi1zdHJlYW0nXSA9IHJlcXVpcmUoJy4vanNvbi1zdHJlYW0nKTtcXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxNixcXFwiLi9kb2NcXFwiOjE3LFxcXCIuL2RvdFxcXCI6MTgsXFxcIi4vaHRtbFxcXCI6MTksXFxcIi4vanNvblxcXCI6MjIsXFxcIi4vanNvbi1zdHJlYW1cXFwiOjIxLFxcXCIuL2xhbmRpbmdcXFwiOjIzLFxcXCIuL2xpc3RcXFwiOjI0LFxcXCIuL21hcmtkb3duXFxcIjoyNSxcXFwiLi9taW5cXFwiOjI2LFxcXCIuL255YW5cXFwiOjI3LFxcXCIuL3Byb2dyZXNzXFxcIjoyOCxcXFwiLi9zcGVjXFxcIjoyOSxcXFwiLi90YXBcXFwiOjMwLFxcXCIuL3h1bml0XFxcIjozMX1dLDIxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIEpTT05TdHJlYW1cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMaXN0YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMaXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYEpTT05TdHJlYW1gIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQG5hbWUgSlNPTlN0cmVhbVxcbiAqIEBjbGFzcyBKU09OU3RyZWFtXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTGlzdCAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKEpTT04uc3RyaW5naWZ5KFsnc3RhcnQnLCB7IHRvdGFsOiB0b3RhbCB9XSkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBjb25zb2xlLmxvZyhKU09OLnN0cmluZ2lmeShbJ3Bhc3MnLCBjbGVhbih0ZXN0KV0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QsIGVycikge1xcbiAgICB0ZXN0ID0gY2xlYW4odGVzdCk7XFxuICAgIHRlc3QuZXJyID0gZXJyLm1lc3NhZ2U7XFxuICAgIHRlc3Quc3RhY2sgPSBlcnIuc3RhY2sgfHwgbnVsbDtcXG4gICAgY29uc29sZS5sb2coSlNPTi5zdHJpbmdpZnkoWydmYWlsJywgdGVzdF0pKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoSlNPTi5zdHJpbmdpZnkoWydlbmQnLCBzZWxmLnN0YXRzXSkpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIHBsYWluLW9iamVjdCByZXByZXNlbnRhdGlvbiBvZiBgdGVzdGBcXG4gKiBmcmVlIG9mIGN5Y2xpYyBwcm9wZXJ0aWVzIGV0Yy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0ZXN0XFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuICh0ZXN0KSB7XFxuICByZXR1cm4ge1xcbiAgICB0aXRsZTogdGVzdC50aXRsZSxcXG4gICAgZnVsbFRpdGxlOiB0ZXN0LmZ1bGxUaXRsZSgpLFxcbiAgICBkdXJhdGlvbjogdGVzdC5kdXJhdGlvbixcXG4gICAgY3VycmVudFJldHJ5OiB0ZXN0LmN1cnJlbnRSZXRyeSgpXFxuICB9O1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgSlNPTlxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYEpTT05gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IEpTT05SZXBvcnRlcjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBKU09OYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3MgSlNPTlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIEpTT05SZXBvcnRlciAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0cyA9IFtdO1xcbiAgdmFyIHBlbmRpbmcgPSBbXTtcXG4gIHZhciBmYWlsdXJlcyA9IFtdO1xcbiAgdmFyIHBhc3NlcyA9IFtdO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHRlc3RzLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHBhc3Nlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBmYWlsdXJlcy5wdXNoKHRlc3QpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3BlbmRpbmcnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwZW5kaW5nLnB1c2godGVzdCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHZhciBvYmogPSB7XFxuICAgICAgc3RhdHM6IHNlbGYuc3RhdHMsXFxuICAgICAgdGVzdHM6IHRlc3RzLm1hcChjbGVhbiksXFxuICAgICAgcGVuZGluZzogcGVuZGluZy5tYXAoY2xlYW4pLFxcbiAgICAgIGZhaWx1cmVzOiBmYWlsdXJlcy5tYXAoY2xlYW4pLFxcbiAgICAgIHBhc3NlczogcGFzc2VzLm1hcChjbGVhbilcXG4gICAgfTtcXG5cXG4gICAgcnVubmVyLnRlc3RSZXN1bHRzID0gb2JqO1xcblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShKU09OLnN0cmluZ2lmeShvYmosIG51bGwsIDIpKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm4gYSBwbGFpbi1vYmplY3QgcmVwcmVzZW50YXRpb24gb2YgYHRlc3RgXFxuICogZnJlZSBvZiBjeWNsaWMgcHJvcGVydGllcyBldGMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gdGVzdFxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbiAodGVzdCkge1xcbiAgdmFyIGVyciA9IHRlc3QuZXJyIHx8IHt9O1xcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XFxuICAgIGVyciA9IGVycm9ySlNPTihlcnIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHtcXG4gICAgdGl0bGU6IHRlc3QudGl0bGUsXFxuICAgIGZ1bGxUaXRsZTogdGVzdC5mdWxsVGl0bGUoKSxcXG4gICAgZHVyYXRpb246IHRlc3QuZHVyYXRpb24sXFxuICAgIGN1cnJlbnRSZXRyeTogdGVzdC5jdXJyZW50UmV0cnkoKSxcXG4gICAgZXJyOiBjbGVhbkN5Y2xlcyhlcnIpXFxuICB9O1xcbn1cXG5cXG4vKipcXG4gKiBSZXBsYWNlcyBhbnkgY2lyY3VsYXIgcmVmZXJlbmNlcyBpbnNpZGUgYG9iamAgd2l0aCAnW29iamVjdCBPYmplY3RdJ1xcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IG9ialxcbiAqIEByZXR1cm4ge09iamVjdH1cXG4gKi9cXG5mdW5jdGlvbiBjbGVhbkN5Y2xlcyAob2JqKSB7XFxuICB2YXIgY2FjaGUgPSBbXTtcXG4gIHJldHVybiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KG9iaiwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwpIHtcXG4gICAgICBpZiAoY2FjaGUuaW5kZXhPZih2YWx1ZSkgIT09IC0xKSB7XFxuICAgICAgICAvLyBJbnN0ZWFkIG9mIGdvaW5nIGluIGEgY2lyY2xlLCB3ZSdsbCBwcmludCBbb2JqZWN0IE9iamVjdF1cXG4gICAgICAgIHJldHVybiAnJyArIHZhbHVlO1xcbiAgICAgIH1cXG4gICAgICBjYWNoZS5wdXNoKHZhbHVlKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmFsdWU7XFxuICB9KSk7XFxufVxcblxcbi8qKlxcbiAqIFRyYW5zZm9ybSBhbiBFcnJvciBvYmplY3QgaW50byBhIEpTT04gb2JqZWN0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtFcnJvcn0gZXJyXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbmZ1bmN0aW9uIGVycm9ySlNPTiAoZXJyKSB7XFxuICB2YXIgcmVzID0ge307XFxuICBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhlcnIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICByZXNba2V5XSA9IGVycltrZXldO1xcbiAgfSwgZXJyKTtcXG4gIHJldHVybiByZXM7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuL2Jhc2VcXFwiOjE2LFxcXCJfcHJvY2Vzc1xcXCI6NTZ9XSwyMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBMYW5kaW5nXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBMYW5kaW5nYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBMYW5kaW5nO1xcblxcbi8qKlxcbiAqIEFpcnBsYW5lIGNvbG9yLlxcbiAqL1xcblxcbkJhc2UuY29sb3JzLnBsYW5lID0gMDtcXG5cXG4vKipcXG4gKiBBaXJwbGFuZSBjcmFzaCBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9yc1sncGxhbmUgY3Jhc2gnXSA9IDMxO1xcblxcbi8qKlxcbiAqIFJ1bndheSBjb2xvci5cXG4gKi9cXG5cXG5CYXNlLmNvbG9ycy5ydW53YXkgPSA5MDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBMYW5kaW5nYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBMYW5kaW5nIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjc1IHwgMDtcXG4gIHZhciB0b3RhbCA9IHJ1bm5lci50b3RhbDtcXG4gIHZhciBzdHJlYW0gPSBwcm9jZXNzLnN0ZG91dDtcXG4gIHZhciBwbGFuZSA9IGNvbG9yKCdwbGFuZScsICfinIgnKTtcXG4gIHZhciBjcmFzaGVkID0gLTE7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBmdW5jdGlvbiBydW53YXkgKCkge1xcbiAgICB2YXIgYnVmID0gQXJyYXkod2lkdGgpLmpvaW4oJy0nKTtcXG4gICAgcmV0dXJuICcgICcgKyBjb2xvcigncnVud2F5JywgYnVmKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIHN0cmVhbS53cml0ZSgnXFxcXG5cXFxcblxcXFxuICAnKTtcXG4gICAgY3Vyc29yLmhpZGUoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCd0ZXN0IGVuZCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIC8vIGNoZWNrIGlmIHRoZSBwbGFuZSBjcmFzaGVkXFxuICAgIHZhciBjb2wgPSBjcmFzaGVkID09PSAtMSA/IHdpZHRoICogKytuIC8gdG90YWwgfCAwIDogY3Jhc2hlZDtcXG5cXG4gICAgLy8gc2hvdyB0aGUgY3Jhc2hcXG4gICAgaWYgKHRlc3Quc3RhdGUgPT09ICdmYWlsZWQnKSB7XFxuICAgICAgcGxhbmUgPSBjb2xvcigncGxhbmUgY3Jhc2gnLCAn4pyIJyk7XFxuICAgICAgY3Jhc2hlZCA9IGNvbDtcXG4gICAgfVxcblxcbiAgICAvLyByZW5kZXIgbGFuZGluZyBzdHJpcFxcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFx1MDAxYlsnICsgKHdpZHRoICsgMSkgKyAnRFxcXFx1MDAxYlsyQScpO1xcbiAgICBzdHJlYW0ud3JpdGUocnVud2F5KCkpO1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFxuICAnKTtcXG4gICAgc3RyZWFtLndyaXRlKGNvbG9yKCdydW53YXknLCBBcnJheShjb2wpLmpvaW4oJ+KLhScpKSk7XFxuICAgIHN0cmVhbS53cml0ZShwbGFuZSk7XFxuICAgIHN0cmVhbS53cml0ZShjb2xvcigncnVud2F5JywgQXJyYXkod2lkdGggLSBjb2wpLmpvaW4oJ+KLhScpICsgJ1xcXFxuJykpO1xcbiAgICBzdHJlYW0ud3JpdGUocnVud2F5KCkpO1xcbiAgICBzdHJlYW0ud3JpdGUoJ1xcXFx1MDAxYlswbScpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjdXJzb3Iuc2hvdygpO1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgICBzZWxmLmVwaWxvZ3VlKCk7XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTGFuZGluZywgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgTGlzdFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcbnZhciBjb2xvciA9IEJhc2UuY29sb3I7XFxudmFyIGN1cnNvciA9IEJhc2UuY3Vyc29yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTGlzdGAuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gTGlzdDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBMaXN0YCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIExpc3QgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICBjb25zb2xlLmxvZygpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Rlc3QnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncGFzcycsICcgICAgJyArIHRlc3QuZnVsbFRpdGxlKCkgKyAnOiAnKSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGVuZGluZycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQgPSBjb2xvcignY2hlY2ttYXJrJywgJyAgLScpICtcXG4gICAgICBjb2xvcigncGVuZGluZycsICcgJXMnKTtcXG4gICAgY29uc29sZS5sb2coZm10LCB0ZXN0LmZ1bGxUaXRsZSgpKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGNvbG9yKCdjaGVja21hcmsnLCAnICAnICsgQmFzZS5zeW1ib2xzLm9rKSArXFxuICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzOiAnKSArXFxuICAgICAgY29sb3IodGVzdC5zcGVlZCwgJyVkbXMnKTtcXG4gICAgY3Vyc29yLkNSKCk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC5mdWxsVGl0bGUoKSwgdGVzdC5kdXJhdGlvbik7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGN1cnNvci5DUigpO1xcbiAgICBjb25zb2xlLmxvZyhjb2xvcignZmFpbCcsICcgICVkKSAlcycpLCArK24sIHRlc3QuZnVsbFRpdGxlKCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub25jZSgnZW5kJywgc2VsZi5lcGlsb2d1ZS5iaW5kKHNlbGYpKTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBCYXNlLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoTGlzdCwgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjU6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgTWFya2Rvd25cXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcXG5cXG4vKipcXG4gKiBDb25zdGFudHNcXG4gKi9cXG5cXG52YXIgU1VJVEVfUFJFRklYID0gJyQnO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgTWFya2Rvd25gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1hcmtkb3duO1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYE1hcmtkb3duYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBNYXJrZG93biAocnVubmVyKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBsZXZlbCA9IDA7XFxuICB2YXIgYnVmID0gJyc7XFxuXFxuICBmdW5jdGlvbiB0aXRsZSAoc3RyKSB7XFxuICAgIHJldHVybiBBcnJheShsZXZlbCkuam9pbignIycpICsgJyAnICsgc3RyO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gbWFwVE9DIChzdWl0ZSwgb2JqKSB7XFxuICAgIHZhciByZXQgPSBvYmo7XFxuICAgIHZhciBrZXkgPSBTVUlURV9QUkVGSVggKyBzdWl0ZS50aXRsZTtcXG5cXG4gICAgb2JqID0gb2JqW2tleV0gPSBvYmpba2V5XSB8fCB7IHN1aXRlOiBzdWl0ZSB9O1xcbiAgICBzdWl0ZS5zdWl0ZXMuZm9yRWFjaChmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgICBtYXBUT0Moc3VpdGUsIG9iaik7XFxuICAgIH0pO1xcblxcbiAgICByZXR1cm4gcmV0O1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RyaW5naWZ5VE9DIChvYmosIGxldmVsKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBidWYgPSAnJztcXG4gICAgdmFyIGxpbms7XFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAoa2V5ID09PSAnc3VpdGUnKSB7XFxuICAgICAgICBjb250aW51ZTtcXG4gICAgICB9XFxuICAgICAgaWYgKGtleSAhPT0gU1VJVEVfUFJFRklYKSB7XFxuICAgICAgICBsaW5rID0gJyAtIFsnICsga2V5LnN1YnN0cmluZygxKSArICddJztcXG4gICAgICAgIGxpbmsgKz0gJygjJyArIHV0aWxzLnNsdWcob2JqW2tleV0uc3VpdGUuZnVsbFRpdGxlKCkpICsgJylcXFxcbic7XFxuICAgICAgICBidWYgKz0gQXJyYXkobGV2ZWwpLmpvaW4oJyAgJykgKyBsaW5rO1xcbiAgICAgIH1cXG4gICAgICBidWYgKz0gc3RyaW5naWZ5VE9DKG9ialtrZXldLCBsZXZlbCk7XFxuICAgIH1cXG4gICAgcmV0dXJuIGJ1ZjtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGdlbmVyYXRlVE9DIChzdWl0ZSkge1xcbiAgICB2YXIgb2JqID0gbWFwVE9DKHN1aXRlLCB7fSk7XFxuICAgIHJldHVybiBzdHJpbmdpZnlUT0Mob2JqLCAwKTtcXG4gIH1cXG5cXG4gIGdlbmVyYXRlVE9DKHJ1bm5lci5zdWl0ZSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlJywgZnVuY3Rpb24gKHN1aXRlKSB7XFxuICAgICsrbGV2ZWw7XFxuICAgIHZhciBzbHVnID0gdXRpbHMuc2x1ZyhzdWl0ZS5mdWxsVGl0bGUoKSk7XFxuICAgIGJ1ZiArPSAnPGEgbmFtZT1cXFwiJyArIHNsdWcgKyAnXFxcIj48L2E+JyArICdcXFxcbic7XFxuICAgIGJ1ZiArPSB0aXRsZShzdWl0ZS50aXRsZSkgKyAnXFxcXG4nO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgLS1sZXZlbDtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGNvZGUgPSB1dGlscy5jbGVhbih0ZXN0LmJvZHkpO1xcbiAgICBidWYgKz0gdGVzdC50aXRsZSArICcuXFxcXG4nO1xcbiAgICBidWYgKz0gJ1xcXFxuYGBganNcXFxcbic7XFxuICAgIGJ1ZiArPSBjb2RlICsgJ1xcXFxuJztcXG4gICAgYnVmICs9ICdgYGBcXFxcblxcXFxuJztcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoJyMgVE9DXFxcXG4nKTtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUoZ2VuZXJhdGVUT0MocnVubmVyLnN1aXRlKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKGJ1Zik7XFxuICB9KTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjY6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgTWluXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBNaW5gLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IE1pbjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBNaW5gIG1pbmltYWwgdGVzdCByZXBvcnRlciAoYmVzdCB1c2VkIHdpdGggLS13YXRjaCkuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICovXFxuZnVuY3Rpb24gTWluIChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgLy8gY2xlYXIgc2NyZWVuXFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbMkonKTtcXG4gICAgLy8gc2V0IGN1cnNvciBwb3NpdGlvblxcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZSgnXFxcXHUwMDFiWzE7M0gnKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIHRoaXMuZXBpbG9ndWUuYmluZCh0aGlzKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKE1pbiwgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2Vzcyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgTnlhblxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCcuLi91dGlscycpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgRG90YC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBOeWFuQ2F0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYERvdGAgbWF0cml4IHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQGNsYXNzIE55YW5cXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKi9cXG5cXG5mdW5jdGlvbiBOeWFuQ2F0IChydW5uZXIpIHtcXG4gIEJhc2UuY2FsbCh0aGlzLCBydW5uZXIpO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgdmFyIHdpZHRoID0gQmFzZS53aW5kb3cud2lkdGggKiAwLjc1IHwgMDtcXG4gIHZhciBueWFuQ2F0V2lkdGggPSB0aGlzLm55YW5DYXRXaWR0aCA9IDExO1xcblxcbiAgdGhpcy5jb2xvckluZGV4ID0gMDtcXG4gIHRoaXMubnVtYmVyT2ZMaW5lcyA9IDQ7XFxuICB0aGlzLnJhaW5ib3dDb2xvcnMgPSBzZWxmLmdlbmVyYXRlQ29sb3JzKCk7XFxuICB0aGlzLnNjb3JlYm9hcmRXaWR0aCA9IDU7XFxuICB0aGlzLnRpY2sgPSAwO1xcbiAgdGhpcy50cmFqZWN0b3JpZXMgPSBbW10sIFtdLCBbXSwgW11dO1xcbiAgdGhpcy50cmFqZWN0b3J5V2lkdGhNYXggPSAod2lkdGggLSBueWFuQ2F0V2lkdGgpO1xcblxcbiAgcnVubmVyLm9uKCdzdGFydCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgQmFzZS5jdXJzb3IuaGlkZSgpO1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKCkge1xcbiAgICBzZWxmLmRyYXcoKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgQmFzZS5jdXJzb3Iuc2hvdygpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNlbGYubnVtYmVyT2ZMaW5lczsgaSsrKSB7XFxuICAgICAgd3JpdGUoJ1xcXFxuJyk7XFxuICAgIH1cXG4gICAgc2VsZi5lcGlsb2d1ZSgpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKE55YW5DYXQsIEJhc2UpO1xcblxcbi8qKlxcbiAqIERyYXcgdGhlIG55YW4gY2F0XFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3ID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5hcHBlbmRSYWluYm93KCk7XFxuICB0aGlzLmRyYXdTY29yZWJvYXJkKCk7XFxuICB0aGlzLmRyYXdSYWluYm93KCk7XFxuICB0aGlzLmRyYXdOeWFuQ2F0KCk7XFxuICB0aGlzLnRpY2sgPSAhdGhpcy50aWNrO1xcbn07XFxuXFxuLyoqXFxuICogRHJhdyB0aGUgXFxcInNjb3JlYm9hcmRcXFwiIHNob3dpbmcgdGhlIG51bWJlclxcbiAqIG9mIHBhc3NlcywgZmFpbHVyZXMgYW5kIHBlbmRpbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5OeWFuQ2F0LnByb3RvdHlwZS5kcmF3U2NvcmVib2FyZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuXFxuICBmdW5jdGlvbiBkcmF3ICh0eXBlLCBuKSB7XFxuICAgIHdyaXRlKCcgJyk7XFxuICAgIHdyaXRlKEJhc2UuY29sb3IodHlwZSwgbikpO1xcbiAgICB3cml0ZSgnXFxcXG4nKTtcXG4gIH1cXG5cXG4gIGRyYXcoJ2dyZWVuJywgc3RhdHMucGFzc2VzKTtcXG4gIGRyYXcoJ2ZhaWwnLCBzdGF0cy5mYWlsdXJlcyk7XFxuICBkcmF3KCdwZW5kaW5nJywgc3RhdHMucGVuZGluZyk7XFxuICB3cml0ZSgnXFxcXG4nKTtcXG5cXG4gIHRoaXMuY3Vyc29yVXAodGhpcy5udW1iZXJPZkxpbmVzKTtcXG59O1xcblxcbi8qKlxcbiAqIEFwcGVuZCB0aGUgcmFpbmJvdy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmFwcGVuZFJhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VnbWVudCA9IHRoaXMudGljayA/ICdfJyA6ICctJztcXG4gIHZhciByYWluYm93aWZpZWQgPSB0aGlzLnJhaW5ib3dpZnkoc2VnbWVudCk7XFxuXFxuICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgdGhpcy5udW1iZXJPZkxpbmVzOyBpbmRleCsrKSB7XFxuICAgIHZhciB0cmFqZWN0b3J5ID0gdGhpcy50cmFqZWN0b3JpZXNbaW5kZXhdO1xcbiAgICBpZiAodHJhamVjdG9yeS5sZW5ndGggPj0gdGhpcy50cmFqZWN0b3J5V2lkdGhNYXgpIHtcXG4gICAgICB0cmFqZWN0b3J5LnNoaWZ0KCk7XFxuICAgIH1cXG4gICAgdHJhamVjdG9yeS5wdXNoKHJhaW5ib3dpZmllZCk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSByYWluYm93LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd1JhaW5ib3cgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICB0aGlzLnRyYWplY3Rvcmllcy5mb3JFYWNoKGZ1bmN0aW9uIChsaW5lKSB7XFxuICAgIHdyaXRlKCdcXFxcdTAwMWJbJyArIHNlbGYuc2NvcmVib2FyZFdpZHRoICsgJ0MnKTtcXG4gICAgd3JpdGUobGluZS5qb2luKCcnKSk7XFxuICAgIHdyaXRlKCdcXFxcbicpO1xcbiAgfSk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IHRoZSBueWFuIGNhdFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuTnlhbkNhdC5wcm90b3R5cGUuZHJhd055YW5DYXQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgc3RhcnRXaWR0aCA9IHRoaXMuc2NvcmVib2FyZFdpZHRoICsgdGhpcy50cmFqZWN0b3JpZXNbMF0ubGVuZ3RoO1xcbiAgdmFyIGRpc3QgPSAnXFxcXHUwMDFiWycgKyBzdGFydFdpZHRoICsgJ0MnO1xcbiAgdmFyIHBhZGRpbmcgPSAnJztcXG5cXG4gIHdyaXRlKGRpc3QpO1xcbiAgd3JpdGUoJ18sLS0tLS0tLCcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnICAnIDogJyAgICc7XFxuICB3cml0ZSgnX3wnICsgcGFkZGluZyArICcvXFxcXFxcXFxfL1xcXFxcXFxcICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB3cml0ZShkaXN0KTtcXG4gIHBhZGRpbmcgPSBzZWxmLnRpY2sgPyAnXycgOiAnX18nO1xcbiAgdmFyIHRhaWwgPSBzZWxmLnRpY2sgPyAnficgOiAnXic7XFxuICB3cml0ZSh0YWlsICsgJ3wnICsgcGFkZGluZyArIHRoaXMuZmFjZSgpICsgJyAnKTtcXG4gIHdyaXRlKCdcXFxcbicpO1xcblxcbiAgd3JpdGUoZGlzdCk7XFxuICBwYWRkaW5nID0gc2VsZi50aWNrID8gJyAnIDogJyAgJztcXG4gIHdyaXRlKHBhZGRpbmcgKyAnXFxcIlxcXCIgIFxcXCJcXFwiICcpO1xcbiAgd3JpdGUoJ1xcXFxuJyk7XFxuXFxuICB0aGlzLmN1cnNvclVwKHRoaXMubnVtYmVyT2ZMaW5lcyk7XFxufTtcXG5cXG4vKipcXG4gKiBEcmF3IG55YW4gY2F0IGZhY2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuXFxuTnlhbkNhdC5wcm90b3R5cGUuZmFjZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICBpZiAoc3RhdHMuZmFpbHVyZXMpIHtcXG4gICAgcmV0dXJuICcoIHggLngpJztcXG4gIH0gZWxzZSBpZiAoc3RhdHMucGVuZGluZykge1xcbiAgICByZXR1cm4gJyggbyAubyknO1xcbiAgfSBlbHNlIGlmIChzdGF0cy5wYXNzZXMpIHtcXG4gICAgcmV0dXJuICcoIF4gLl4pJztcXG4gIH1cXG4gIHJldHVybiAnKCAtIC4tKSc7XFxufTtcXG5cXG4vKipcXG4gKiBNb3ZlIGN1cnNvciB1cCBgbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmN1cnNvclVwID0gZnVuY3Rpb24gKG4pIHtcXG4gIHdyaXRlKCdcXFxcdTAwMWJbJyArIG4gKyAnQScpO1xcbn07XFxuXFxuLyoqXFxuICogTW92ZSBjdXJzb3IgZG93biBgbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcn0gblxcbiAqL1xcblxcbk55YW5DYXQucHJvdG90eXBlLmN1cnNvckRvd24gPSBmdW5jdGlvbiAobikge1xcbiAgd3JpdGUoJ1xcXFx1MDAxYlsnICsgbiArICdCJyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSByYWluYm93IGNvbG9ycy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge0FycmF5fVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLmdlbmVyYXRlQ29sb3JzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIGNvbG9ycyA9IFtdO1xcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAoNiAqIDcpOyBpKyspIHtcXG4gICAgdmFyIHBpMyA9IE1hdGguZmxvb3IoTWF0aC5QSSAvIDMpO1xcbiAgICB2YXIgbiA9IChpICogKDEuMCAvIDYpKTtcXG4gICAgdmFyIHIgPSBNYXRoLmZsb29yKDMgKiBNYXRoLnNpbihuKSArIDMpO1xcbiAgICB2YXIgZyA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyAyICogcGkzKSArIDMpO1xcbiAgICB2YXIgYiA9IE1hdGguZmxvb3IoMyAqIE1hdGguc2luKG4gKyA0ICogcGkzKSArIDMpO1xcbiAgICBjb2xvcnMucHVzaCgzNiAqIHIgKyA2ICogZyArIGIgKyAxNik7XFxuICB9XFxuXFxuICByZXR1cm4gY29sb3JzO1xcbn07XFxuXFxuLyoqXFxuICogQXBwbHkgcmFpbmJvdyB0byB0aGUgZ2l2ZW4gYHN0cmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gc3RyXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbk55YW5DYXQucHJvdG90eXBlLnJhaW5ib3dpZnkgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICBpZiAoIUJhc2UudXNlQ29sb3JzKSB7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxuICB2YXIgY29sb3IgPSB0aGlzLnJhaW5ib3dDb2xvcnNbdGhpcy5jb2xvckluZGV4ICUgdGhpcy5yYWluYm93Q29sb3JzLmxlbmd0aF07XFxuICB0aGlzLmNvbG9ySW5kZXggKz0gMTtcXG4gIHJldHVybiAnXFxcXHUwMDFiWzM4OzU7JyArIGNvbG9yICsgJ20nICsgc3RyICsgJ1xcXFx1MDAxYlswbSc7XFxufTtcXG5cXG4vKipcXG4gKiBTdGRvdXQgaGVscGVyLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBBIG1lc3NhZ2UgdG8gd3JpdGUgdG8gc3Rkb3V0LlxcbiAqL1xcbmZ1bmN0aW9uIHdyaXRlIChzdHJpbmcpIHtcXG4gIHByb2Nlc3Muc3Rkb3V0LndyaXRlKHN0cmluZyk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTYsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDI4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFByb2dyZXNzXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJy4uL3V0aWxzJykuaW5oZXJpdHM7XFxudmFyIGNvbG9yID0gQmFzZS5jb2xvcjtcXG52YXIgY3Vyc29yID0gQmFzZS5jdXJzb3I7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBQcm9ncmVzc2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gUHJvZ3Jlc3M7XFxuXFxuLyoqXFxuICogR2VuZXJhbCBwcm9ncmVzcyBiYXIgY29sb3IuXFxuICovXFxuXFxuQmFzZS5jb2xvcnMucHJvZ3Jlc3MgPSA5MDtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBQcm9ncmVzc2AgYmFyIHRlc3QgcmVwb3J0ZXIuXFxuICpcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQG1lbWJlcm9mIE1vY2hhLnJlcG9ydGVyc1xcbiAqIEBleHRlbmRzIE1vY2hhLnJlcG9ydGVycy5CYXNlXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcGFyYW0ge1J1bm5lcn0gcnVubmVyXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcXG4gKi9cXG5mdW5jdGlvbiBQcm9ncmVzcyAocnVubmVyLCBvcHRpb25zKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB3aWR0aCA9IEJhc2Uud2luZG93LndpZHRoICogMC41MCB8IDA7XFxuICB2YXIgdG90YWwgPSBydW5uZXIudG90YWw7XFxuICB2YXIgY29tcGxldGUgPSAwO1xcbiAgdmFyIGxhc3ROID0gLTE7XFxuXFxuICAvLyBkZWZhdWx0IGNoYXJzXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gIHZhciByZXBvcnRlck9wdGlvbnMgPSBvcHRpb25zLnJlcG9ydGVyT3B0aW9ucyB8fCB7fTtcXG5cXG4gIG9wdGlvbnMub3BlbiA9IHJlcG9ydGVyT3B0aW9ucy5vcGVuIHx8ICdbJztcXG4gIG9wdGlvbnMuY29tcGxldGUgPSByZXBvcnRlck9wdGlvbnMuY29tcGxldGUgfHwgJ+KWrCc7XFxuICBvcHRpb25zLmluY29tcGxldGUgPSByZXBvcnRlck9wdGlvbnMuaW5jb21wbGV0ZSB8fCBCYXNlLnN5bWJvbHMuZG90O1xcbiAgb3B0aW9ucy5jbG9zZSA9IHJlcG9ydGVyT3B0aW9ucy5jbG9zZSB8fCAnXSc7XFxuICBvcHRpb25zLnZlcmJvc2UgPSByZXBvcnRlck9wdGlvbnMudmVyYm9zZSB8fCBmYWxzZTtcXG5cXG4gIC8vIHRlc3RzIHN0YXJ0ZWRcXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIGN1cnNvci5oaWRlKCk7XFxuICB9KTtcXG5cXG4gIC8vIHRlc3RzIGNvbXBsZXRlXFxuICBydW5uZXIub24oJ3Rlc3QgZW5kJywgZnVuY3Rpb24gKCkge1xcbiAgICBjb21wbGV0ZSsrO1xcblxcbiAgICB2YXIgcGVyY2VudCA9IGNvbXBsZXRlIC8gdG90YWw7XFxuICAgIHZhciBuID0gd2lkdGggKiBwZXJjZW50IHwgMDtcXG4gICAgdmFyIGkgPSB3aWR0aCAtIG47XFxuXFxuICAgIGlmIChuID09PSBsYXN0TiAmJiAhb3B0aW9ucy52ZXJib3NlKSB7XFxuICAgICAgLy8gRG9uJ3QgcmUtcmVuZGVyIHRoZSBsaW5lIGlmIGl0IGhhc24ndCBjaGFuZ2VkXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGxhc3ROID0gbjtcXG5cXG4gICAgY3Vyc29yLkNSKCk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKCdcXFxcdTAwMWJbSicpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCAnICAnICsgb3B0aW9ucy5vcGVuKSk7XFxuICAgIHByb2Nlc3Muc3Rkb3V0LndyaXRlKEFycmF5KG4pLmpvaW4ob3B0aW9ucy5jb21wbGV0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShBcnJheShpKS5qb2luKG9wdGlvbnMuaW5jb21wbGV0ZSkpO1xcbiAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCBvcHRpb25zLmNsb3NlKSk7XFxuICAgIGlmIChvcHRpb25zLnZlcmJvc2UpIHtcXG4gICAgICBwcm9jZXNzLnN0ZG91dC53cml0ZShjb2xvcigncHJvZ3Jlc3MnLCAnICcgKyBjb21wbGV0ZSArICcgb2YgJyArIHRvdGFsKSk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgLy8gdGVzdHMgYXJlIGNvbXBsZXRlLCBvdXRwdXQgc29tZSBzdGF0c1xcbiAgLy8gYW5kIHRoZSBmYWlsdXJlcyBpZiBhbnlcXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGN1cnNvci5zaG93KCk7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIHNlbGYuZXBpbG9ndWUoKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhQcm9ncmVzcywgQmFzZSk7XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2fV0sMjk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFNwZWNcXG4gKi9cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBCYXNlID0gcmVxdWlyZSgnLi9iYXNlJyk7XFxudmFyIGluaGVyaXRzID0gcmVxdWlyZSgnLi4vdXRpbHMnKS5pbmhlcml0cztcXG52YXIgY29sb3IgPSBCYXNlLmNvbG9yO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgU3BlY2AuXFxuICovXFxuXFxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gU3BlYztcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBTcGVjYCB0ZXN0IHJlcG9ydGVyLlxcbiAqXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5yZXBvcnRlcnNcXG4gKiBAZXh0ZW5kcyBNb2NoYS5yZXBvcnRlcnMuQmFzZVxcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtSdW5uZXJ9IHJ1bm5lclxcbiAqL1xcbmZ1bmN0aW9uIFNwZWMgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgaW5kZW50cyA9IDA7XFxuICB2YXIgbiA9IDA7XFxuXFxuICBmdW5jdGlvbiBpbmRlbnQgKCkge1xcbiAgICByZXR1cm4gQXJyYXkoaW5kZW50cykuam9pbignICAnKTtcXG4gIH1cXG5cXG4gIHJ1bm5lci5vbignc3RhcnQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignc3VpdGUnLCBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gICAgKytpbmRlbnRzO1xcbiAgICBjb25zb2xlLmxvZyhjb2xvcignc3VpdGUnLCAnJXMlcycpLCBpbmRlbnQoKSwgc3VpdGUudGl0bGUpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3N1aXRlIGVuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgLS1pbmRlbnRzO1xcbiAgICBpZiAoaW5kZW50cyA9PT0gMSkge1xcbiAgICAgIGNvbnNvbGUubG9nKCk7XFxuICAgIH1cXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdmFyIGZtdCA9IGluZGVudCgpICsgY29sb3IoJ3BlbmRpbmcnLCAnICAtICVzJyk7XFxuICAgIGNvbnNvbGUubG9nKGZtdCwgdGVzdC50aXRsZSk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigncGFzcycsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIHZhciBmbXQ7XFxuICAgIGlmICh0ZXN0LnNwZWVkID09PSAnZmFzdCcpIHtcXG4gICAgICBmbXQgPSBpbmRlbnQoKSArXFxuICAgICAgICBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xcbiAgICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzJyk7XFxuICAgICAgY29uc29sZS5sb2coZm10LCB0ZXN0LnRpdGxlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBmbXQgPSBpbmRlbnQoKSArXFxuICAgICAgICBjb2xvcignY2hlY2ttYXJrJywgJyAgJyArIEJhc2Uuc3ltYm9scy5vaykgK1xcbiAgICAgICAgY29sb3IoJ3Bhc3MnLCAnICVzJykgK1xcbiAgICAgICAgY29sb3IodGVzdC5zcGVlZCwgJyAoJWRtcyknKTtcXG4gICAgICBjb25zb2xlLmxvZyhmbXQsIHRlc3QudGl0bGUsIHRlc3QuZHVyYXRpb24pO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbignZmFpbCcsIGZ1bmN0aW9uICh0ZXN0KSB7XFxuICAgIGNvbnNvbGUubG9nKGluZGVudCgpICsgY29sb3IoJ2ZhaWwnLCAnICAlZCkgJXMnKSwgKytuLCB0ZXN0LnRpdGxlKTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIHNlbGYuZXBpbG9ndWUuYmluZChzZWxmKSk7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgQmFzZS5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFNwZWMsIEJhc2UpO1xcblxcbn0se1xcXCIuLi91dGlsc1xcXCI6MzYsXFxcIi4vYmFzZVxcXCI6MTZ9XSwzMDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcbi8qKlxcbiAqIEBtb2R1bGUgVEFQXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgQmFzZSA9IHJlcXVpcmUoJy4vYmFzZScpO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVEFQYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBUQVA7XFxuXFxuLyoqXFxuICogSW5pdGlhbGl6ZSBhIG5ldyBgVEFQYCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBUQVAgKHJ1bm5lcikge1xcbiAgQmFzZS5jYWxsKHRoaXMsIHJ1bm5lcik7XFxuXFxuICB2YXIgbiA9IDE7XFxuICB2YXIgcGFzc2VzID0gMDtcXG4gIHZhciBmYWlsdXJlcyA9IDA7XFxuXFxuICBydW5uZXIub24oJ3N0YXJ0JywgZnVuY3Rpb24gKCkge1xcbiAgICB2YXIgdG90YWwgPSBydW5uZXIuZ3JlcFRvdGFsKHJ1bm5lci5zdWl0ZSk7XFxuICAgIGNvbnNvbGUubG9nKCclZC4uJWQnLCAxLCB0b3RhbCk7XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgICsrbjtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzICMgU0tJUCAtJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ3Bhc3MnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBwYXNzZXMrKztcXG4gICAgY29uc29sZS5sb2coJ29rICVkICVzJywgbiwgdGl0bGUodGVzdCkpO1xcbiAgfSk7XFxuXFxuICBydW5uZXIub24oJ2ZhaWwnLCBmdW5jdGlvbiAodGVzdCwgZXJyKSB7XFxuICAgIGZhaWx1cmVzKys7XFxuICAgIGNvbnNvbGUubG9nKCdub3Qgb2sgJWQgJXMnLCBuLCB0aXRsZSh0ZXN0KSk7XFxuICAgIGlmIChlcnIuc3RhY2spIHtcXG4gICAgICBjb25zb2xlLmxvZyhlcnIuc3RhY2sucmVwbGFjZSgvXi9nbSwgJyAgJykpO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJ1bm5lci5vbmNlKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGNvbnNvbGUubG9nKCcjIHRlc3RzICcgKyAocGFzc2VzICsgZmFpbHVyZXMpKTtcXG4gICAgY29uc29sZS5sb2coJyMgcGFzcyAnICsgcGFzc2VzKTtcXG4gICAgY29uc29sZS5sb2coJyMgZmFpbCAnICsgZmFpbHVyZXMpO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIFRBUC1zYWZlIHRpdGxlIG9mIGB0ZXN0YFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHRlc3RcXG4gKiBAcmV0dXJuIHtTdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGl0bGUgKHRlc3QpIHtcXG4gIHJldHVybiB0ZXN0LmZ1bGxUaXRsZSgpLnJlcGxhY2UoLyMvZywgJycpO1xcbn1cXG5cXG59LHtcXFwiLi9iYXNlXFxcIjoxNn1dLDMxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3MsZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBYVW5pdFxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxuXFxudmFyIEJhc2UgPSByZXF1aXJlKCcuL2Jhc2UnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIGVzY2FwZSA9IHV0aWxzLmVzY2FwZTtcXG52YXIgbWtkaXJwID0gcmVxdWlyZSgnbWtkaXJwJyk7XFxudmFyIHBhdGggPSByZXF1aXJlKCdwYXRoJyk7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgWFVuaXRgLlxcbiAqL1xcblxcbmV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IFhVbml0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFhVbml0YCByZXBvcnRlci5cXG4gKlxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAbWVtYmVyb2YgTW9jaGEucmVwb3J0ZXJzXFxuICogQGV4dGVuZHMgTW9jaGEucmVwb3J0ZXJzLkJhc2VcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7UnVubmVyfSBydW5uZXJcXG4gKi9cXG5mdW5jdGlvbiBYVW5pdCAocnVubmVyLCBvcHRpb25zKSB7XFxuICBCYXNlLmNhbGwodGhpcywgcnVubmVyKTtcXG5cXG4gIHZhciBzdGF0cyA9IHRoaXMuc3RhdHM7XFxuICB2YXIgdGVzdHMgPSBbXTtcXG4gIHZhciBzZWxmID0gdGhpcztcXG5cXG4gIC8vIHRoZSBuYW1lIG9mIHRoZSB0ZXN0IHN1aXRlLCBhcyBpdCB3aWxsIGFwcGVhciBpbiB0aGUgcmVzdWx0aW5nIFhNTCBmaWxlXFxuICB2YXIgc3VpdGVOYW1lO1xcblxcbiAgLy8gdGhlIGRlZmF1bHQgbmFtZSBvZiB0aGUgdGVzdCBzdWl0ZSBpZiBub25lIGlzIHByb3ZpZGVkXFxuICB2YXIgREVGQVVMVF9TVUlURV9OQU1FID0gJ01vY2hhIFRlc3RzJztcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zKSB7XFxuICAgIGlmIChvcHRpb25zLnJlcG9ydGVyT3B0aW9ucy5vdXRwdXQpIHtcXG4gICAgICBpZiAoIWZzLmNyZWF0ZVdyaXRlU3RyZWFtKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZpbGUgb3V0cHV0IG5vdCBzdXBwb3J0ZWQgaW4gYnJvd3NlcicpO1xcbiAgICAgIH1cXG5cXG4gICAgICBta2RpcnAuc3luYyhwYXRoLmRpcm5hbWUob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KSk7XFxuICAgICAgc2VsZi5maWxlU3RyZWFtID0gZnMuY3JlYXRlV3JpdGVTdHJlYW0ob3B0aW9ucy5yZXBvcnRlck9wdGlvbnMub3V0cHV0KTtcXG4gICAgfVxcblxcbiAgICAvLyBnZXQgdGhlIHN1aXRlIG5hbWUgZnJvbSB0aGUgcmVwb3J0ZXIgb3B0aW9ucyAoaWYgcHJvdmlkZWQpXFxuICAgIHN1aXRlTmFtZSA9IG9wdGlvbnMucmVwb3J0ZXJPcHRpb25zLnN1aXRlTmFtZTtcXG4gIH1cXG5cXG4gIC8vIGZhbGwgYmFjayB0byB0aGUgZGVmYXVsdCBzdWl0ZSBuYW1lXFxuICBzdWl0ZU5hbWUgPSBzdWl0ZU5hbWUgfHwgREVGQVVMVF9TVUlURV9OQU1FO1xcblxcbiAgcnVubmVyLm9uKCdwZW5kaW5nJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdwYXNzJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uKCdmYWlsJywgZnVuY3Rpb24gKHRlc3QpIHtcXG4gICAgdGVzdHMucHVzaCh0ZXN0KTtcXG4gIH0pO1xcblxcbiAgcnVubmVyLm9uY2UoJ2VuZCcsIGZ1bmN0aW9uICgpIHtcXG4gICAgc2VsZi53cml0ZSh0YWcoJ3Rlc3RzdWl0ZScsIHtcXG4gICAgICBuYW1lOiBzdWl0ZU5hbWUsXFxuICAgICAgdGVzdHM6IHN0YXRzLnRlc3RzLFxcbiAgICAgIGZhaWx1cmVzOiBzdGF0cy5mYWlsdXJlcyxcXG4gICAgICBlcnJvcnM6IHN0YXRzLmZhaWx1cmVzLFxcbiAgICAgIHNraXBwZWQ6IHN0YXRzLnRlc3RzIC0gc3RhdHMuZmFpbHVyZXMgLSBzdGF0cy5wYXNzZXMsXFxuICAgICAgdGltZXN0YW1wOiAobmV3IERhdGUoKSkudG9VVENTdHJpbmcoKSxcXG4gICAgICB0aW1lOiAoc3RhdHMuZHVyYXRpb24gLyAxMDAwKSB8fCAwXFxuICAgIH0sIGZhbHNlKSk7XFxuXFxuICAgIHRlc3RzLmZvckVhY2goZnVuY3Rpb24gKHQpIHtcXG4gICAgICBzZWxmLnRlc3QodCk7XFxuICAgIH0pO1xcblxcbiAgICBzZWxmLndyaXRlKCc8L3Rlc3RzdWl0ZT4nKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEJhc2UucHJvdG90eXBlYC5cXG4gKi9cXG5pbmhlcml0cyhYVW5pdCwgQmFzZSk7XFxuXFxuLyoqXFxuICogT3ZlcnJpZGUgZG9uZSB0byBjbG9zZSB0aGUgc3RyZWFtIChpZiBpdCdzIGEgZmlsZSkuXFxuICpcXG4gKiBAcGFyYW0gZmFpbHVyZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblhVbml0LnByb3RvdHlwZS5kb25lID0gZnVuY3Rpb24gKGZhaWx1cmVzLCBmbikge1xcbiAgaWYgKHRoaXMuZmlsZVN0cmVhbSkge1xcbiAgICB0aGlzLmZpbGVTdHJlYW0uZW5kKGZ1bmN0aW9uICgpIHtcXG4gICAgICBmbihmYWlsdXJlcyk7XFxuICAgIH0pO1xcbiAgfSBlbHNlIHtcXG4gICAgZm4oZmFpbHVyZXMpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogV3JpdGUgb3V0IHRoZSBnaXZlbiBsaW5lLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IGxpbmVcXG4gKi9cXG5YVW5pdC5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAobGluZSkge1xcbiAgaWYgKHRoaXMuZmlsZVN0cmVhbSkge1xcbiAgICB0aGlzLmZpbGVTdHJlYW0ud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy5zdGRvdXQpIHtcXG4gICAgcHJvY2Vzcy5zdGRvdXQud3JpdGUobGluZSArICdcXFxcbicpO1xcbiAgfSBlbHNlIHtcXG4gICAgY29uc29sZS5sb2cobGluZSk7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBPdXRwdXQgdGFnIGZvciB0aGUgZ2l2ZW4gYHRlc3QuYFxcbiAqXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICovXFxuWFVuaXQucHJvdG90eXBlLnRlc3QgPSBmdW5jdGlvbiAodGVzdCkge1xcbiAgdmFyIGF0dHJzID0ge1xcbiAgICBjbGFzc25hbWU6IHRlc3QucGFyZW50LmZ1bGxUaXRsZSgpLFxcbiAgICBuYW1lOiB0ZXN0LnRpdGxlLFxcbiAgICB0aW1lOiAodGVzdC5kdXJhdGlvbiAvIDEwMDApIHx8IDBcXG4gIH07XFxuXFxuICBpZiAodGVzdC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcXG4gICAgdmFyIGVyciA9IHRlc3QuZXJyO1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgZmFsc2UsIHRhZygnZmFpbHVyZScsIHt9LCBmYWxzZSwgZXNjYXBlKGVyci5tZXNzYWdlKSArICdcXFxcbicgKyBlc2NhcGUoZXJyLnN0YWNrKSkpKTtcXG4gIH0gZWxzZSBpZiAodGVzdC5pc1BlbmRpbmcoKSkge1xcbiAgICB0aGlzLndyaXRlKHRhZygndGVzdGNhc2UnLCBhdHRycywgZmFsc2UsIHRhZygnc2tpcHBlZCcsIHt9LCB0cnVlKSkpO1xcbiAgfSBlbHNlIHtcXG4gICAgdGhpcy53cml0ZSh0YWcoJ3Rlc3RjYXNlJywgYXR0cnMsIHRydWUpKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEhUTUwgdGFnIGhlbHBlci5cXG4gKlxcbiAqIEBwYXJhbSBuYW1lXFxuICogQHBhcmFtIGF0dHJzXFxuICogQHBhcmFtIGNsb3NlXFxuICogQHBhcmFtIGNvbnRlbnRcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZnVuY3Rpb24gdGFnIChuYW1lLCBhdHRycywgY2xvc2UsIGNvbnRlbnQpIHtcXG4gIHZhciBlbmQgPSBjbG9zZSA/ICcvPicgOiAnPic7XFxuICB2YXIgcGFpcnMgPSBbXTtcXG4gIHZhciB0YWc7XFxuXFxuICBmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhdHRycywga2V5KSkge1xcbiAgICAgIHBhaXJzLnB1c2goa2V5ICsgJz1cXFwiJyArIGVzY2FwZShhdHRyc1trZXldKSArICdcXFwiJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRhZyA9ICc8JyArIG5hbWUgKyAocGFpcnMubGVuZ3RoID8gJyAnICsgcGFpcnMuam9pbignICcpIDogJycpICsgZW5kO1xcbiAgaWYgKGNvbnRlbnQpIHtcXG4gICAgdGFnICs9IGNvbnRlbnQgKyAnPC8nICsgbmFtZSArIGVuZDtcXG4gIH1cXG4gIHJldHVybiB0YWc7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4uL3V0aWxzXFxcIjozNixcXFwiLi9iYXNlXFxcIjoxNixcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJmc1xcXCI6NDAsXFxcIm1rZGlycFxcXCI6NTMsXFxcInBhdGhcXFwiOjQwfV0sMzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoZ2xvYmFsKXtcXG4ndXNlIHN0cmljdCc7XFxuLyoqXFxuICogQG1vZHVsZSBSdW5uYWJsZVxcbiAqL1xcbi8qKlxcbiAqIE1vZHVsZSBkZXBlbmRlbmNpZXMuXFxuICovXFxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgUGVuZGluZyA9IHJlcXVpcmUoJy4vcGVuZGluZycpO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnJ1bm5hYmxlJyk7XFxudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJy4vbXMnKTtcXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XFxuXFxuLyoqXFxuICogU2F2ZSB0aW1lciByZWZlcmVuY2VzIHRvIGF2b2lkIFNpbm9uIGludGVyZmVyaW5nIChzZWUgR0gtMjM3KS5cXG4gKi9cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycywgbm8tbmF0aXZlLXJlYXNzaWduICovXFxudmFyIERhdGUgPSBnbG9iYWwuRGF0ZTtcXG52YXIgc2V0VGltZW91dCA9IGdsb2JhbC5zZXRUaW1lb3V0O1xcbnZhciBzZXRJbnRlcnZhbCA9IGdsb2JhbC5zZXRJbnRlcnZhbDtcXG52YXIgY2xlYXJUaW1lb3V0ID0gZ2xvYmFsLmNsZWFyVGltZW91dDtcXG52YXIgY2xlYXJJbnRlcnZhbCA9IGdsb2JhbC5jbGVhckludGVydmFsO1xcbi8qIGVzbGludC1lbmFibGUgbm8tdW51c2VkLXZhcnMsIG5vLW5hdGl2ZS1yZWFzc2lnbiAqL1xcblxcbi8qKlxcbiAqIE9iamVjdCN0b1N0cmluZygpLlxcbiAqL1xcblxcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogRXhwb3NlIGBSdW5uYWJsZWAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBSdW5uYWJsZTtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgbmV3IGBSdW5uYWJsZWAgd2l0aCB0aGUgZ2l2ZW4gYHRpdGxlYCBhbmQgY2FsbGJhY2sgYGZuYC4gIERlcml2ZWQgZnJvbSBbRXZlbnRFbWl0dGVyXShodHRwczovL25vZGVqcy5vcmcvYXBpL2V2ZW50cy5odG1sI2V2ZW50c19jbGFzc19ldmVudGVtaXR0ZXIpXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGFcXG4gKiBAcHVibGljXFxuICogQGNsYXNzXFxuICogQHBhcmFtIHtTdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5mdW5jdGlvbiBSdW5uYWJsZSAodGl0bGUsIGZuKSB7XFxuICB0aGlzLnRpdGxlID0gdGl0bGU7XFxuICB0aGlzLmZuID0gZm47XFxuICB0aGlzLmJvZHkgPSAoZm4gfHwgJycpLnRvU3RyaW5nKCk7XFxuICB0aGlzLmFzeW5jID0gZm4gJiYgZm4ubGVuZ3RoO1xcbiAgdGhpcy5zeW5jID0gIXRoaXMuYXN5bmM7XFxuICB0aGlzLl90aW1lb3V0ID0gMjAwMDtcXG4gIHRoaXMuX3Nsb3cgPSA3NTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gdHJ1ZTtcXG4gIHRoaXMudGltZWRPdXQgPSBmYWxzZTtcXG4gIHRoaXMuX3JldHJpZXMgPSAtMTtcXG4gIHRoaXMuX2N1cnJlbnRSZXRyeSA9IDA7XFxuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogSW5oZXJpdCBmcm9tIGBFdmVudEVtaXR0ZXIucHJvdG90eXBlYC5cXG4gKi9cXG51dGlscy5pbmhlcml0cyhSdW5uYWJsZSwgRXZlbnRFbWl0dGVyKTtcXG5cXG4vKipcXG4gKiBTZXQgJiBnZXQgdGltZW91dCBgbXNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBtc1xcbiAqIEByZXR1cm4ge1J1bm5hYmxlfG51bWJlcn0gbXMgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnRpbWVvdXQgPSBmdW5jdGlvbiAobXMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fdGltZW91dDtcXG4gIH1cXG4gIC8vIHNlZSAjMTY1MiBmb3IgcmVhc29uaW5nXFxuICBpZiAobXMgPT09IDAgfHwgbXMgPiBNYXRoLnBvdygyLCAzMSkpIHtcXG4gICAgdGhpcy5fZW5hYmxlVGltZW91dHMgPSBmYWxzZTtcXG4gIH1cXG4gIGlmICh0eXBlb2YgbXMgPT09ICdzdHJpbmcnKSB7XFxuICAgIG1zID0gbWlsbGlzZWNvbmRzKG1zKTtcXG4gIH1cXG4gIGRlYnVnKCd0aW1lb3V0ICVkJywgbXMpO1xcbiAgdGhpcy5fdGltZW91dCA9IG1zO1xcbiAgaWYgKHRoaXMudGltZXIpIHtcXG4gICAgdGhpcy5yZXNldFRpbWVvdXQoKTtcXG4gIH1cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBzbG93IGBtc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7UnVubmFibGV8bnVtYmVyfSBtcyBvciBSdW5uYWJsZSBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoIHx8IHR5cGVvZiBtcyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3Nsb3c7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1Zygnc2xvdyAlZCcsIG1zKTtcXG4gIHRoaXMuX3Nsb3cgPSBtcztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IGFuZCBnZXQgd2hldGhlciB0aW1lb3V0IGlzIGBlbmFibGVkYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAqIEByZXR1cm4ge1J1bm5hYmxlfGJvb2xlYW59IGVuYWJsZWQgb3IgUnVubmFibGUgaW5zdGFuY2UuXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogSGFsdCBhbmQgbWFyayBhcyBwZW5kaW5nLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5hYmxlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnNraXAgPSBmdW5jdGlvbiAoKSB7XFxuICB0aHJvdyBuZXcgUGVuZGluZygnc3luYyBza2lwJyk7XFxufTtcXG5cXG4vKipcXG4gKiBDaGVjayBpZiB0aGlzIHJ1bm5hYmxlIG9yIGl0cyBwYXJlbnQgc3VpdGUgaXMgbWFya2VkIGFzIHBlbmRpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMucGVuZGluZyB8fCAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuaXNQZW5kaW5nKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIGB0cnVlYCBpZiB0aGlzIFJ1bm5hYmxlIGhhcyBmYWlsZWQuXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5pc0ZhaWxlZCA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiAhdGhpcy5pc1BlbmRpbmcoKSAmJiB0aGlzLnN0YXRlID09PSAnZmFpbGVkJztcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBgdHJ1ZWAgaWYgdGhpcyBSdW5uYWJsZSBoYXMgcGFzc2VkLlxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICogQHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuaXNQYXNzZWQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gIXRoaXMuaXNQZW5kaW5nKCkgJiYgdGhpcy5zdGF0ZSA9PT0gJ3Bhc3NlZCc7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiByZXRyaWVzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLnJldHJpZXMgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9yZXRyaWVzO1xcbiAgfVxcbiAgdGhpcy5fcmV0cmllcyA9IG47XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IGN1cnJlbnQgcmV0cnlcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5jdXJyZW50UmV0cnkgPSBmdW5jdGlvbiAobikge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50UmV0cnk7XFxuICB9XFxuICB0aGlzLl9jdXJyZW50UmV0cnkgPSBuO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSBmdWxsIHRpdGxlIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIGZ1bGwgdGl0bGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmFibGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnRpdGxlUGF0aCgpLmpvaW4oJyAnKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgdGl0bGUgcGF0aCBnZW5lcmF0ZWQgYnkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3MgdGl0bGUgcGF0aCB3aXRoIHRoZSB0aXRsZS5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uYWJsZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUudGl0bGVQYXRoID0gZnVuY3Rpb24gKCkge1xcbiAgcmV0dXJuIHRoaXMucGFyZW50LnRpdGxlUGF0aCgpLmNvbmNhdChbdGhpcy50aXRsZV0pO1xcbn07XFxuXFxuLyoqXFxuICogQ2xlYXIgdGhlIHRpbWVvdXQuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uYWJsZS5wcm90b3R5cGUuY2xlYXJUaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xcbiAgY2xlYXJUaW1lb3V0KHRoaXMudGltZXIpO1xcbn07XFxuXFxuLyoqXFxuICogSW5zcGVjdCB0aGUgcnVubmFibGUgdm9pZCBvZiBwcml2YXRlIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuUnVubmFibGUucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcywgZnVuY3Rpb24gKGtleSwgdmFsKSB7XFxuICAgIGlmIChrZXlbMF0gPT09ICdfJykge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICBpZiAoa2V5ID09PSAncGFyZW50Jykge1xcbiAgICAgIHJldHVybiAnIzxTdWl0ZT4nO1xcbiAgICB9XFxuICAgIGlmIChrZXkgPT09ICdjdHgnKSB7XFxuICAgICAgcmV0dXJuICcjPENvbnRleHQ+JztcXG4gICAgfVxcbiAgICByZXR1cm4gdmFsO1xcbiAgfSwgMik7XFxufTtcXG5cXG4vKipcXG4gKiBSZXNldCB0aGUgdGltZW91dC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5yZXNldFRpbWVvdXQgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgbXMgPSB0aGlzLnRpbWVvdXQoKSB8fCAxZTk7XFxuXFxuICBpZiAoIXRoaXMuX2VuYWJsZVRpbWVvdXRzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHRoaXMuY2xlYXJUaW1lb3V0KCk7XFxuICB0aGlzLnRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuICAgIGlmICghc2VsZi5fZW5hYmxlVGltZW91dHMpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG4gICAgc2VsZi5jYWxsYmFjayhzZWxmLl90aW1lb3V0RXJyb3IobXMpKTtcXG4gICAgc2VsZi50aW1lZE91dCA9IHRydWU7XFxuICB9LCBtcyk7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IGEgbGlzdCBvZiB3aGl0ZWxpc3RlZCBnbG9iYWxzIGZvciB0aGlzIHRlc3QgcnVuLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gZ2xvYmFsc1xcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5nbG9iYWxzID0gZnVuY3Rpb24gKGdsb2JhbHMpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fYWxsb3dlZEdsb2JhbHM7XFxuICB9XFxuICB0aGlzLl9hbGxvd2VkR2xvYmFscyA9IGdsb2JhbHM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGhlIHRlc3QgYW5kIGludm9rZSBgZm4oZXJyKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBzdGFydCA9IG5ldyBEYXRlKCk7XFxuICB2YXIgY3R4ID0gdGhpcy5jdHg7XFxuICB2YXIgZmluaXNoZWQ7XFxuICB2YXIgZW1pdHRlZDtcXG5cXG4gIC8vIFNvbWV0aW1lcyB0aGUgY3R4IGV4aXN0cywgYnV0IGl0IGlzIG5vdCBydW5uYWJsZVxcbiAgaWYgKGN0eCAmJiBjdHgucnVubmFibGUpIHtcXG4gICAgY3R4LnJ1bm5hYmxlKHRoaXMpO1xcbiAgfVxcblxcbiAgLy8gY2FsbGVkIG11bHRpcGxlIHRpbWVzXFxuICBmdW5jdGlvbiBtdWx0aXBsZSAoZXJyKSB7XFxuICAgIGlmIChlbWl0dGVkKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGVtaXR0ZWQgPSB0cnVlO1xcbiAgICB2YXIgbXNnID0gJ2RvbmUoKSBjYWxsZWQgbXVsdGlwbGUgdGltZXMnO1xcbiAgICBpZiAoZXJyICYmIGVyci5tZXNzYWdlKSB7XFxuICAgICAgZXJyLm1lc3NhZ2UgKz0gXFxcIiAoYW5kIE1vY2hhJ3MgXFxcIiArIG1zZyArICcpJztcXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKG1zZykpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBmaW5pc2hlZFxcbiAgZnVuY3Rpb24gZG9uZSAoZXJyKSB7XFxuICAgIHZhciBtcyA9IHNlbGYudGltZW91dCgpO1xcbiAgICBpZiAoc2VsZi50aW1lZE91dCkge1xcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICBpZiAoZmluaXNoZWQpIHtcXG4gICAgICByZXR1cm4gbXVsdGlwbGUoZXJyKTtcXG4gICAgfVxcblxcbiAgICBzZWxmLmNsZWFyVGltZW91dCgpO1xcbiAgICBzZWxmLmR1cmF0aW9uID0gbmV3IERhdGUoKSAtIHN0YXJ0O1xcbiAgICBmaW5pc2hlZCA9IHRydWU7XFxuICAgIGlmICghZXJyICYmIHNlbGYuZHVyYXRpb24gPiBtcyAmJiBzZWxmLl9lbmFibGVUaW1lb3V0cykge1xcbiAgICAgIGVyciA9IHNlbGYuX3RpbWVvdXRFcnJvcihtcyk7XFxuICAgIH1cXG4gICAgZm4oZXJyKTtcXG4gIH1cXG5cXG4gIC8vIGZvciAucmVzZXRUaW1lb3V0KClcXG4gIHRoaXMuY2FsbGJhY2sgPSBkb25lO1xcblxcbiAgLy8gZXhwbGljaXQgYXN5bmMgd2l0aCBgZG9uZWAgYXJndW1lbnRcXG4gIGlmICh0aGlzLmFzeW5jKSB7XFxuICAgIHRoaXMucmVzZXRUaW1lb3V0KCk7XFxuXFxuICAgIC8vIGFsbG93cyBza2lwKCkgdG8gYmUgdXNlZCBpbiBhbiBleHBsaWNpdCBhc3luYyBjb250ZXh0XFxuICAgIHRoaXMuc2tpcCA9IGZ1bmN0aW9uIGFzeW5jU2tpcCAoKSB7XFxuICAgICAgZG9uZShuZXcgUGVuZGluZygnYXN5bmMgc2tpcCBjYWxsJykpO1xcbiAgICAgIC8vIGhhbHQgZXhlY3V0aW9uLiAgdGhlIFJ1bm5hYmxlIHdpbGwgYmUgbWFya2VkIHBlbmRpbmdcXG4gICAgICAvLyBieSB0aGUgcHJldmlvdXMgY2FsbCwgYW5kIHRoZSB1bmNhdWdodCBoYW5kbGVyIHdpbGwgaWdub3JlXFxuICAgICAgLy8gdGhlIGZhaWx1cmUuXFxuICAgICAgdGhyb3cgbmV3IFBlbmRpbmcoJ2FzeW5jIHNraXA7IGFib3J0aW5nIGV4ZWN1dGlvbicpO1xcbiAgICB9O1xcblxcbiAgICBpZiAodGhpcy5hbGxvd1VuY2F1Z2h0KSB7XFxuICAgICAgcmV0dXJuIGNhbGxGbkFzeW5jKHRoaXMuZm4pO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgY2FsbEZuQXN5bmModGhpcy5mbik7XFxuICAgIH0gY2F0Y2ggKGVycikge1xcbiAgICAgIGVtaXR0ZWQgPSB0cnVlO1xcbiAgICAgIGRvbmUodXRpbHMuZ2V0RXJyb3IoZXJyKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICAgIGRvbmUoKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBjYWxsRm4odGhpcy5mbik7XFxuICAgIH1cXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgLy8gc3luYyBvciBwcm9taXNlLXJldHVybmluZ1xcbiAgdHJ5IHtcXG4gICAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBkb25lKCk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgY2FsbEZuKHRoaXMuZm4pO1xcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgZW1pdHRlZCA9IHRydWU7XFxuICAgIGRvbmUodXRpbHMuZ2V0RXJyb3IoZXJyKSk7XFxuICB9XFxuXFxuICBmdW5jdGlvbiBjYWxsRm4gKGZuKSB7XFxuICAgIHZhciByZXN1bHQgPSBmbi5jYWxsKGN0eCk7XFxuICAgIGlmIChyZXN1bHQgJiYgdHlwZW9mIHJlc3VsdC50aGVuID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgc2VsZi5yZXNldFRpbWVvdXQoKTtcXG4gICAgICByZXN1bHRcXG4gICAgICAgIC50aGVuKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgICAgZG9uZSgpO1xcbiAgICAgICAgICAvLyBSZXR1cm4gbnVsbCBzbyBsaWJyYXJpZXMgbGlrZSBibHVlYmlyZCBkbyBub3Qgd2FybiBhYm91dFxcbiAgICAgICAgICAvLyBzdWJzZXF1ZW50bHkgY29uc3RydWN0ZWQgUHJvbWlzZXMuXFxuICAgICAgICAgIHJldHVybiBudWxsO1xcbiAgICAgICAgfSxcXG4gICAgICAgIGZ1bmN0aW9uIChyZWFzb24pIHtcXG4gICAgICAgICAgZG9uZShyZWFzb24gfHwgbmV3IEVycm9yKCdQcm9taXNlIHJlamVjdGVkIHdpdGggbm8gb3IgZmFsc3kgcmVhc29uJykpO1xcbiAgICAgICAgfSk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaWYgKHNlbGYuYXN5bmNPbmx5KSB7XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJy0tYXN5bmMtb25seSBvcHRpb24gaW4gdXNlIHdpdGhvdXQgZGVjbGFyaW5nIGBkb25lKClgIG9yIHJldHVybmluZyBhIHByb21pc2UnKSk7XFxuICAgICAgfVxcblxcbiAgICAgIGRvbmUoKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gY2FsbEZuQXN5bmMgKGZuKSB7XFxuICAgIHZhciByZXN1bHQgPSBmbi5jYWxsKGN0eCwgZnVuY3Rpb24gKGVycikge1xcbiAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fCB0b1N0cmluZy5jYWxsKGVycikgPT09ICdbb2JqZWN0IEVycm9yXScpIHtcXG4gICAgICAgIHJldHVybiBkb25lKGVycik7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoZXJyKSA9PT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcXG4gICAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJyArXFxuICAgICAgICAgICAgSlNPTi5zdHJpbmdpZnkoZXJyKSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGRvbmUobmV3IEVycm9yKCdkb25lKCkgaW52b2tlZCB3aXRoIG5vbi1FcnJvcjogJyArIGVycikpO1xcbiAgICAgIH1cXG4gICAgICBpZiAocmVzdWx0ICYmIHV0aWxzLmlzUHJvbWlzZShyZXN1bHQpKSB7XFxuICAgICAgICByZXR1cm4gZG9uZShuZXcgRXJyb3IoJ1Jlc29sdXRpb24gbWV0aG9kIGlzIG92ZXJzcGVjaWZpZWQuIFNwZWNpZnkgYSBjYWxsYmFjayAqb3IqIHJldHVybiBhIFByb21pc2U7IG5vdCBib3RoLicpKTtcXG4gICAgICB9XFxuXFxuICAgICAgZG9uZSgpO1xcbiAgICB9KTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEluc3RhbnRpYXRlcyBhIFxcXCJ0aW1lb3V0XFxcIiBlcnJvclxcbiAqXFxuICogQHBhcmFtIHtudW1iZXJ9IG1zIC0gVGltZW91dCAoaW4gbWlsbGlzZWNvbmRzKVxcbiAqIEByZXR1cm5zIHtFcnJvcn0gYSBcXFwidGltZW91dFxcXCIgZXJyb3JcXG4gKiBAcHJpdmF0ZVxcbiAqL1xcblJ1bm5hYmxlLnByb3RvdHlwZS5fdGltZW91dEVycm9yID0gZnVuY3Rpb24gKG1zKSB7XFxuICB2YXIgbXNnID0gJ1RpbWVvdXQgb2YgJyArIG1zICsgJ21zIGV4Y2VlZGVkLiBGb3IgYXN5bmMgdGVzdHMgYW5kIGhvb2tzLCBlbnN1cmUgXFxcImRvbmUoKVxcXCIgaXMgY2FsbGVkOyBpZiByZXR1cm5pbmcgYSBQcm9taXNlLCBlbnN1cmUgaXQgcmVzb2x2ZXMuJztcXG4gIGlmICh0aGlzLmZpbGUpIHtcXG4gICAgbXNnICs9ICcgKCcgKyB0aGlzLmZpbGUgKyAnKSc7XFxuICB9XFxuICByZXR1cm4gbmV3IEVycm9yKG1zZyk7XFxufTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9tc1xcXCI6MTQsXFxcIi4vcGVuZGluZ1xcXCI6MTUsXFxcIi4vdXRpbHNcXFwiOjM2LFxcXCJkZWJ1Z1xcXCI6NDMsXFxcImV2ZW50c1xcXCI6NDd9XSwzMzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEBtb2R1bGUgUnVubmVyXFxuICovXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBQZW5kaW5nID0gcmVxdWlyZSgnLi9wZW5kaW5nJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnJ1bm5lcicpO1xcbnZhciBSdW5uYWJsZSA9IHJlcXVpcmUoJy4vcnVubmFibGUnKTtcXG52YXIgc3RhY2tGaWx0ZXIgPSB1dGlscy5zdGFja1RyYWNlRmlsdGVyKCk7XFxudmFyIHN0cmluZ2lmeSA9IHV0aWxzLnN0cmluZ2lmeTtcXG52YXIgdHlwZSA9IHV0aWxzLnR5cGU7XFxudmFyIHVuZGVmaW5lZEVycm9yID0gdXRpbHMudW5kZWZpbmVkRXJyb3I7XFxuXFxuLyoqXFxuICogTm9uLWVudW1lcmFibGUgZ2xvYmFscy5cXG4gKi9cXG5cXG52YXIgZ2xvYmFscyA9IFtcXG4gICdzZXRUaW1lb3V0JyxcXG4gICdjbGVhclRpbWVvdXQnLFxcbiAgJ3NldEludGVydmFsJyxcXG4gICdjbGVhckludGVydmFsJyxcXG4gICdYTUxIdHRwUmVxdWVzdCcsXFxuICAnRGF0ZScsXFxuICAnc2V0SW1tZWRpYXRlJyxcXG4gICdjbGVhckltbWVkaWF0ZSdcXG5dO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgUnVubmVyYC5cXG4gKi9cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IFJ1bm5lcjtcXG5cXG4vKipcXG4gKiBJbml0aWFsaXplIGEgYFJ1bm5lcmAgZm9yIHRoZSBnaXZlbiBgc3VpdGVgLiBEZXJpdmVkIGZyb20gW0V2ZW50RW1pdHRlcl0oaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9ldmVudHMuaHRtbCNldmVudHNfY2xhc3NfZXZlbnRlbWl0dGVyKVxcbiAqXFxuICogRXZlbnRzOlxcbiAqXFxuICogICAtIGBzdGFydGAgIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBlbmRgICBleGVjdXRpb24gY29tcGxldGVcXG4gKiAgIC0gYHN1aXRlYCAgKHN1aXRlKSB0ZXN0IHN1aXRlIGV4ZWN1dGlvbiBzdGFydGVkXFxuICogICAtIGBzdWl0ZSBlbmRgICAoc3VpdGUpIGFsbCB0ZXN0cyAoYW5kIHN1Yi1zdWl0ZXMpIGhhdmUgZmluaXNoZWRcXG4gKiAgIC0gYHRlc3RgICAodGVzdCkgdGVzdCBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgdGVzdCBlbmRgICAodGVzdCkgdGVzdCBjb21wbGV0ZWRcXG4gKiAgIC0gYGhvb2tgICAoaG9vaykgaG9vayBleGVjdXRpb24gc3RhcnRlZFxcbiAqICAgLSBgaG9vayBlbmRgICAoaG9vaykgaG9vayBjb21wbGV0ZVxcbiAqICAgLSBgcGFzc2AgICh0ZXN0KSB0ZXN0IHBhc3NlZFxcbiAqICAgLSBgZmFpbGAgICh0ZXN0LCBlcnIpIHRlc3QgZmFpbGVkXFxuICogICAtIGBwZW5kaW5nYCAgKHRlc3QpIHRlc3QgcGVuZGluZ1xcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhXFxuICogQHB1YmxpY1xcbiAqIEBjbGFzc1xcbiAqIEBhcGkgcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gW3N1aXRlXSBSb290IHN1aXRlXFxuICogQHBhcmFtIHtib29sZWFufSBbZGVsYXldIFdoZXRoZXIgb3Igbm90IHRvIGRlbGF5IGV4ZWN1dGlvbiBvZiByb290IHN1aXRlXFxuICogdW50aWwgcmVhZHkuXFxuICovXFxuZnVuY3Rpb24gUnVubmVyIChzdWl0ZSwgZGVsYXkpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHRoaXMuX2dsb2JhbHMgPSBbXTtcXG4gIHRoaXMuX2Fib3J0ID0gZmFsc2U7XFxuICB0aGlzLl9kZWxheSA9IGRlbGF5O1xcbiAgdGhpcy5zdWl0ZSA9IHN1aXRlO1xcbiAgdGhpcy5zdGFydGVkID0gZmFsc2U7XFxuICB0aGlzLnRvdGFsID0gc3VpdGUudG90YWwoKTtcXG4gIHRoaXMuZmFpbHVyZXMgPSAwO1xcbiAgdGhpcy5vbigndGVzdCBlbmQnLCBmdW5jdGlvbiAodGVzdCkge1xcbiAgICBzZWxmLmNoZWNrR2xvYmFscyh0ZXN0KTtcXG4gIH0pO1xcbiAgdGhpcy5vbignaG9vayBlbmQnLCBmdW5jdGlvbiAoaG9vaykge1xcbiAgICBzZWxmLmNoZWNrR2xvYmFscyhob29rKTtcXG4gIH0pO1xcbiAgdGhpcy5fZGVmYXVsdEdyZXAgPSAvLiovO1xcbiAgdGhpcy5ncmVwKHRoaXMuX2RlZmF1bHRHcmVwKTtcXG4gIHRoaXMuZ2xvYmFscyh0aGlzLmdsb2JhbFByb3BzKCkuY29uY2F0KGV4dHJhR2xvYmFscygpKSk7XFxufVxcblxcbi8qKlxcbiAqIFdyYXBwZXIgZm9yIHNldEltbWVkaWF0ZSwgcHJvY2Vzcy5uZXh0VGljaywgb3IgYnJvd3NlciBwb2x5ZmlsbC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLmltbWVkaWF0ZWx5ID0gZ2xvYmFsLnNldEltbWVkaWF0ZSB8fCBwcm9jZXNzLm5leHRUaWNrO1xcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgRXZlbnRFbWl0dGVyLnByb3RvdHlwZWAuXFxuICovXFxuaW5oZXJpdHMoUnVubmVyLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFJ1biB0ZXN0cyB3aXRoIGZ1bGwgdGl0bGVzIG1hdGNoaW5nIGByZWAuIFVwZGF0ZXMgcnVubmVyLnRvdGFsXFxuICogd2l0aCBudW1iZXIgb2YgdGVzdHMgbWF0Y2hlZC5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAcGFyYW0ge1JlZ0V4cH0gcmVcXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGludmVydFxcbiAqIEByZXR1cm4ge1J1bm5lcn0gUnVubmVyIGluc3RhbmNlLlxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZ3JlcCA9IGZ1bmN0aW9uIChyZSwgaW52ZXJ0KSB7XFxuICBkZWJ1ZygnZ3JlcCAlcycsIHJlKTtcXG4gIHRoaXMuX2dyZXAgPSByZTtcXG4gIHRoaXMuX2ludmVydCA9IGludmVydDtcXG4gIHRoaXMudG90YWwgPSB0aGlzLmdyZXBUb3RhbCh0aGlzLnN1aXRlKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyB0aGUgbnVtYmVyIG9mIHRlc3RzIG1hdGNoaW5nIHRoZSBncmVwIHNlYXJjaCBmb3IgdGhlXFxuICogZ2l2ZW4gc3VpdGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuUnVubmVyXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcmV0dXJuIHtudW1iZXJ9XFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ncmVwVG90YWwgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0b3RhbCA9IDA7XFxuXFxuICBzdWl0ZS5lYWNoVGVzdChmdW5jdGlvbiAodGVzdCkge1xcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XFxuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcXG4gICAgICBtYXRjaCA9ICFtYXRjaDtcXG4gICAgfVxcbiAgICBpZiAobWF0Y2gpIHtcXG4gICAgICB0b3RhbCsrO1xcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiB0b3RhbDtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGxpc3Qgb2YgZ2xvYmFsIHByb3BlcnRpZXMuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbFByb3BzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHByb3BzID0gT2JqZWN0LmtleXMoZ2xvYmFsKTtcXG5cXG4gIC8vIG5vbi1lbnVtZXJhYmxlc1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBnbG9iYWxzLmxlbmd0aDsgKytpKSB7XFxuICAgIGlmICh+cHJvcHMuaW5kZXhPZihnbG9iYWxzW2ldKSkge1xcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIHByb3BzLnB1c2goZ2xvYmFsc1tpXSk7XFxuICB9XFxuXFxuICByZXR1cm4gcHJvcHM7XFxufTtcXG5cXG4vKipcXG4gKiBBbGxvdyB0aGUgZ2l2ZW4gYGFycmAgb2YgZ2xvYmFscy5cXG4gKlxcbiAqIEBhcGkgcHVibGljXFxuICogQHB1YmxpY1xcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAcGFyYW0ge0FycmF5fSBhcnJcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmdsb2JhbHMgPSBmdW5jdGlvbiAoYXJyKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2dsb2JhbHM7XFxuICB9XFxuICBkZWJ1ZygnZ2xvYmFscyAlaicsIGFycik7XFxuICB0aGlzLl9nbG9iYWxzID0gdGhpcy5fZ2xvYmFscy5jb25jYXQoYXJyKTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogQ2hlY2sgZm9yIGdsb2JhbCB2YXJpYWJsZSBsZWFrcy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuY2hlY2tHbG9iYWxzID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIGlmICh0aGlzLmlnbm9yZUxlYWtzKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBvayA9IHRoaXMuX2dsb2JhbHM7XFxuXFxuICB2YXIgZ2xvYmFscyA9IHRoaXMuZ2xvYmFsUHJvcHMoKTtcXG4gIHZhciBsZWFrcztcXG5cXG4gIGlmICh0ZXN0KSB7XFxuICAgIG9rID0gb2suY29uY2F0KHRlc3QuX2FsbG93ZWRHbG9iYWxzIHx8IFtdKTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID09PSBnbG9iYWxzLmxlbmd0aCkge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB0aGlzLnByZXZHbG9iYWxzTGVuZ3RoID0gZ2xvYmFscy5sZW5ndGg7XFxuXFxuICBsZWFrcyA9IGZpbHRlckxlYWtzKG9rLCBnbG9iYWxzKTtcXG4gIHRoaXMuX2dsb2JhbHMgPSB0aGlzLl9nbG9iYWxzLmNvbmNhdChsZWFrcyk7XFxuXFxuICBpZiAobGVha3MubGVuZ3RoID4gMSkge1xcbiAgICB0aGlzLmZhaWwodGVzdCwgbmV3IEVycm9yKCdnbG9iYWwgbGVha3MgZGV0ZWN0ZWQ6ICcgKyBsZWFrcy5qb2luKCcsICcpICsgJycpKTtcXG4gIH0gZWxzZSBpZiAobGVha3MubGVuZ3RoKSB7XFxuICAgIHRoaXMuZmFpbCh0ZXN0LCBuZXcgRXJyb3IoJ2dsb2JhbCBsZWFrIGRldGVjdGVkOiAnICsgbGVha3NbMF0pKTtcXG4gIH1cXG59O1xcblxcbi8qKlxcbiAqIEZhaWwgdGhlIGdpdmVuIGB0ZXN0YC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7VGVzdH0gdGVzdFxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuZmFpbCA9IGZ1bmN0aW9uICh0ZXN0LCBlcnIpIHtcXG4gIGlmICh0ZXN0LmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gICsrdGhpcy5mYWlsdXJlcztcXG4gIHRlc3Quc3RhdGUgPSAnZmFpbGVkJztcXG5cXG4gIGlmICghKGVyciBpbnN0YW5jZW9mIEVycm9yIHx8IChlcnIgJiYgdHlwZW9mIGVyci5tZXNzYWdlID09PSAnc3RyaW5nJykpKSB7XFxuICAgIGVyciA9IG5ldyBFcnJvcigndGhlICcgKyB0eXBlKGVycikgKyAnICcgKyBzdHJpbmdpZnkoZXJyKSArICcgd2FzIHRocm93biwgdGhyb3cgYW4gRXJyb3IgOiknKTtcXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIGVyci5zdGFjayA9ICh0aGlzLmZ1bGxTdGFja1RyYWNlIHx8ICFlcnIuc3RhY2spXFxuICAgICAgPyBlcnIuc3RhY2tcXG4gICAgICA6IHN0YWNrRmlsdGVyKGVyci5zdGFjayk7XFxuICB9IGNhdGNoIChpZ25vcmVkKSB7XFxuICAgIC8vIHNvbWUgZW52aXJvbm1lbnRzIGRvIG5vdCB0YWtlIGtpbmRseSB0byBtb25rZXlpbmcgd2l0aCB0aGUgc3RhY2tcXG4gIH1cXG5cXG4gIHRoaXMuZW1pdCgnZmFpbCcsIHRlc3QsIGVycik7XFxufTtcXG5cXG4vKipcXG4gKiBGYWlsIHRoZSBnaXZlbiBgaG9va2Agd2l0aCBgZXJyYC5cXG4gKlxcbiAqIEhvb2sgZmFpbHVyZXMgd29yayBpbiB0aGUgZm9sbG93aW5nIHBhdHRlcm46XFxuICogLSBJZiBiYWlsLCB0aGVuIGV4aXRcXG4gKiAtIEZhaWxlZCBgYmVmb3JlYCBob29rIHNraXBzIGFsbCB0ZXN0cyBpbiBhIHN1aXRlIGFuZCBzdWJzdWl0ZXMsXFxuICogICBidXQganVtcHMgdG8gY29ycmVzcG9uZGluZyBgYWZ0ZXJgIGhvb2tcXG4gKiAtIEZhaWxlZCBgYmVmb3JlIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBqdW1wcyB0byBjb3JyZXNwb25kaW5nIGBhZnRlciBlYWNoYCBob29rLFxcbiAqICAgd2hpY2ggaXMgcnVuIG9ubHkgb25jZVxcbiAqIC0gRmFpbGVkIGBhZnRlcmAgaG9vayBkb2VzIG5vdCBhbHRlclxcbiAqICAgZXhlY3V0aW9uIG9yZGVyXFxuICogLSBGYWlsZWQgYGFmdGVyIGVhY2hgIGhvb2sgc2tpcHMgcmVtYWluaW5nIHRlc3RzIGluIGFcXG4gKiAgIHN1aXRlIGFuZCBzdWJzdWl0ZXMsIGJ1dCBleGVjdXRlcyBvdGhlciBgYWZ0ZXIgZWFjaGBcXG4gKiAgIGhvb2tzXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge0hvb2t9IGhvb2tcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmZhaWxIb29rID0gZnVuY3Rpb24gKGhvb2ssIGVycikge1xcbiAgaWYgKGhvb2suY3R4ICYmIGhvb2suY3R4LmN1cnJlbnRUZXN0KSB7XFxuICAgIGhvb2sub3JpZ2luYWxUaXRsZSA9IGhvb2sub3JpZ2luYWxUaXRsZSB8fCBob29rLnRpdGxlO1xcbiAgICBob29rLnRpdGxlID0gaG9vay5vcmlnaW5hbFRpdGxlICsgJyBmb3IgXFxcIicgKyBob29rLmN0eC5jdXJyZW50VGVzdC50aXRsZSArICdcXFwiJztcXG4gIH1cXG5cXG4gIGlmICh0aGlzLnN1aXRlLmJhaWwoKSkge1xcbiAgICB0aGlzLmVtaXQoJ2VuZCcpO1xcbiAgfVxcbiAgdGhpcy5mYWlsKGhvb2ssIGVycik7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9vayBgbmFtZWAgY2FsbGJhY2tzIGFuZCB0aGVuIGludm9rZSBgZm4oKWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuXFxuUnVubmVyLnByb3RvdHlwZS5ob29rID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGUgPSB0aGlzLnN1aXRlO1xcbiAgdmFyIGhvb2tzID0gc3VpdGVbJ18nICsgbmFtZV07XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBuZXh0IChpKSB7XFxuICAgIHZhciBob29rID0gaG9va3NbaV07XFxuICAgIGlmICghaG9vaykge1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gaG9vaztcXG5cXG4gICAgaG9vay5jdHguY3VycmVudFRlc3QgPSBzZWxmLnRlc3Q7XFxuXFxuICAgIHNlbGYuZW1pdCgnaG9vaycsIGhvb2spO1xcblxcbiAgICBpZiAoIWhvb2subGlzdGVuZXJzKCdlcnJvcicpLmxlbmd0aCkge1xcbiAgICAgIGhvb2sub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xcbiAgICAgICAgc2VsZi5mYWlsSG9vayhob29rLCBlcnIpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuXFxuICAgIGhvb2sucnVuKGZ1bmN0aW9uIChlcnIpIHtcXG4gICAgICB2YXIgdGVzdEVycm9yID0gaG9vay5lcnJvcigpO1xcbiAgICAgIGlmICh0ZXN0RXJyb3IpIHtcXG4gICAgICAgIHNlbGYuZmFpbChzZWxmLnRlc3QsIHRlc3RFcnJvcik7XFxuICAgICAgfVxcbiAgICAgIGlmIChlcnIpIHtcXG4gICAgICAgIGlmIChlcnIgaW5zdGFuY2VvZiBQZW5kaW5nKSB7XFxuICAgICAgICAgIGlmIChuYW1lID09PSAnYmVmb3JlRWFjaCcgfHwgbmFtZSA9PT0gJ2FmdGVyRWFjaCcpIHtcXG4gICAgICAgICAgICBzZWxmLnRlc3QucGVuZGluZyA9IHRydWU7XFxuICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgc3VpdGUudGVzdHMuZm9yRWFjaChmdW5jdGlvbiAodGVzdCkge1xcbiAgICAgICAgICAgICAgdGVzdC5wZW5kaW5nID0gdHJ1ZTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAvLyBhIHBlbmRpbmcgaG9vayB3b24ndCBiZSBleGVjdXRlZCB0d2ljZS5cXG4gICAgICAgICAgICBob29rLnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICB9XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzZWxmLmZhaWxIb29rKGhvb2ssIGVycik7XFxuXFxuICAgICAgICAgIC8vIHN0b3AgZXhlY3V0aW5nIGhvb2tzLCBub3RpZnkgY2FsbGVlIG9mIGhvb2sgZXJyXFxuICAgICAgICAgIHJldHVybiBmbihlcnIpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgICBzZWxmLmVtaXQoJ2hvb2sgZW5kJywgaG9vayk7XFxuICAgICAgZGVsZXRlIGhvb2suY3R4LmN1cnJlbnRUZXN0O1xcbiAgICAgIG5leHQoKytpKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBSdW5uZXIuaW1tZWRpYXRlbHkoZnVuY3Rpb24gKCkge1xcbiAgICBuZXh0KDApO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gaG9vayBgbmFtZWAgZm9yIHRoZSBnaXZlbiBhcnJheSBvZiBgc3VpdGVzYFxcbiAqIGluIG9yZGVyLCBhbmQgY2FsbGJhY2sgYGZuKGVyciwgZXJyU3VpdGUpYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVzXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmhvb2tzID0gZnVuY3Rpb24gKG5hbWUsIHN1aXRlcywgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciBvcmlnID0gdGhpcy5zdWl0ZTtcXG5cXG4gIGZ1bmN0aW9uIG5leHQgKHN1aXRlKSB7XFxuICAgIHNlbGYuc3VpdGUgPSBzdWl0ZTtcXG5cXG4gICAgaWYgKCFzdWl0ZSkge1xcbiAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgIHJldHVybiBmbigpO1xcbiAgICB9XFxuXFxuICAgIHNlbGYuaG9vayhuYW1lLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgaWYgKGVycikge1xcbiAgICAgICAgdmFyIGVyclN1aXRlID0gc2VsZi5zdWl0ZTtcXG4gICAgICAgIHNlbGYuc3VpdGUgPSBvcmlnO1xcbiAgICAgICAgcmV0dXJuIGZuKGVyciwgZXJyU3VpdGUpO1xcbiAgICAgIH1cXG5cXG4gICAgICBuZXh0KHN1aXRlcy5wb3AoKSk7XFxuICAgIH0pO1xcbiAgfVxcblxcbiAgbmV4dChzdWl0ZXMucG9wKCkpO1xcbn07XFxuXFxuLyoqXFxuICogUnVuIGhvb2tzIGZyb20gdGhlIHRvcCBsZXZlbCBkb3duLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUuaG9va1VwID0gZnVuY3Rpb24gKG5hbWUsIGZuKSB7XFxuICB2YXIgc3VpdGVzID0gW3RoaXMuc3VpdGVdLmNvbmNhdCh0aGlzLnBhcmVudHMoKSkucmV2ZXJzZSgpO1xcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBob29rcyBmcm9tIHRoZSBib3R0b20gdXAuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ob29rRG93biA9IGZ1bmN0aW9uIChuYW1lLCBmbikge1xcbiAgdmFyIHN1aXRlcyA9IFt0aGlzLnN1aXRlXS5jb25jYXQodGhpcy5wYXJlbnRzKCkpO1xcbiAgdGhpcy5ob29rcyhuYW1lLCBzdWl0ZXMsIGZuKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiBhbiBhcnJheSBvZiBwYXJlbnQgU3VpdGVzIGZyb21cXG4gKiBjbG9zZXN0IHRvIGZ1cnRoZXN0LlxcbiAqXFxuICogQHJldHVybiB7QXJyYXl9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5wYXJlbnRzID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN1aXRlID0gdGhpcy5zdWl0ZTtcXG4gIHZhciBzdWl0ZXMgPSBbXTtcXG4gIHdoaWxlIChzdWl0ZS5wYXJlbnQpIHtcXG4gICAgc3VpdGUgPSBzdWl0ZS5wYXJlbnQ7XFxuICAgIHN1aXRlcy5wdXNoKHN1aXRlKTtcXG4gIH1cXG4gIHJldHVybiBzdWl0ZXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGhlIGN1cnJlbnQgdGVzdCBhbmQgY2FsbGJhY2sgYGZuKGVycilgLlxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLnJ1blRlc3QgPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0ID0gdGhpcy50ZXN0O1xcblxcbiAgaWYgKCF0ZXN0KSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmICh0aGlzLmZvcmJpZE9ubHkgJiYgaGFzT25seSh0aGlzLnBhcmVudHMoKS5yZXZlcnNlKClbMF0gfHwgdGhpcy5zdWl0ZSkpIHtcXG4gICAgZm4obmV3IEVycm9yKCdgLm9ubHlgIGZvcmJpZGRlbicpKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgaWYgKHRoaXMuYXN5bmNPbmx5KSB7XFxuICAgIHRlc3QuYXN5bmNPbmx5ID0gdHJ1ZTtcXG4gIH1cXG4gIHRlc3Qub24oJ2Vycm9yJywgZnVuY3Rpb24gKGVycikge1xcbiAgICBzZWxmLmZhaWwodGVzdCwgZXJyKTtcXG4gIH0pO1xcbiAgaWYgKHRoaXMuYWxsb3dVbmNhdWdodCkge1xcbiAgICB0ZXN0LmFsbG93VW5jYXVnaHQgPSB0cnVlO1xcbiAgICByZXR1cm4gdGVzdC5ydW4oZm4pO1xcbiAgfVxcbiAgdHJ5IHtcXG4gICAgdGVzdC5ydW4oZm4pO1xcbiAgfSBjYXRjaCAoZXJyKSB7XFxuICAgIGZuKGVycik7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gdGVzdHMgaW4gdGhlIGdpdmVuIGBzdWl0ZWAgYW5kIGludm9rZSB0aGUgY2FsbGJhY2sgYGZuKClgIHdoZW4gY29tcGxldGUuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW5UZXN0cyA9IGZ1bmN0aW9uIChzdWl0ZSwgZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciB0ZXN0cyA9IHN1aXRlLnRlc3RzLnNsaWNlKCk7XFxuICB2YXIgdGVzdDtcXG5cXG4gIGZ1bmN0aW9uIGhvb2tFcnIgKF8sIGVyclN1aXRlLCBhZnRlcikge1xcbiAgICAvLyBiZWZvcmUvYWZ0ZXIgRWFjaCBob29rIGZvciBlcnJTdWl0ZSBmYWlsZWQ6XFxuICAgIHZhciBvcmlnID0gc2VsZi5zdWl0ZTtcXG5cXG4gICAgLy8gZm9yIGZhaWxlZCAnYWZ0ZXIgZWFjaCcgaG9vayBzdGFydCBmcm9tIGVyclN1aXRlIHBhcmVudCxcXG4gICAgLy8gb3RoZXJ3aXNlIHN0YXJ0IGZyb20gZXJyU3VpdGUgaXRzZWxmXFxuICAgIHNlbGYuc3VpdGUgPSBhZnRlciA/IGVyclN1aXRlLnBhcmVudCA6IGVyclN1aXRlO1xcblxcbiAgICBpZiAoc2VsZi5zdWl0ZSkge1xcbiAgICAgIC8vIGNhbGwgaG9va1VwIGFmdGVyRWFjaFxcbiAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBmdW5jdGlvbiAoZXJyMiwgZXJyU3VpdGUyKSB7XFxuICAgICAgICBzZWxmLnN1aXRlID0gb3JpZztcXG4gICAgICAgIC8vIHNvbWUgaG9va3MgbWF5IGZhaWwgZXZlbiBub3dcXG4gICAgICAgIGlmIChlcnIyKSB7XFxuICAgICAgICAgIHJldHVybiBob29rRXJyKGVycjIsIGVyclN1aXRlMiwgdHJ1ZSk7XFxuICAgICAgICB9XFxuICAgICAgICAvLyByZXBvcnQgZXJyb3Igc3VpdGVcXG4gICAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgICB9KTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyB0aGVyZSBpcyBubyBuZWVkIGNhbGxpbmcgb3RoZXIgJ2FmdGVyIGVhY2gnIGhvb2tzXFxuICAgICAgc2VsZi5zdWl0ZSA9IG9yaWc7XFxuICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICB9XFxuICB9XFxuXFxuICBmdW5jdGlvbiBuZXh0IChlcnIsIGVyclN1aXRlKSB7XFxuICAgIC8vIGlmIHdlIGJhaWwgYWZ0ZXIgZmlyc3QgZXJyXFxuICAgIGlmIChzZWxmLmZhaWx1cmVzICYmIHN1aXRlLl9iYWlsKSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHNlbGYuX2Fib3J0KSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGVycikge1xcbiAgICAgIHJldHVybiBob29rRXJyKGVyciwgZXJyU3VpdGUsIHRydWUpO1xcbiAgICB9XFxuXFxuICAgIC8vIG5leHQgdGVzdFxcbiAgICB0ZXN0ID0gdGVzdHMuc2hpZnQoKTtcXG5cXG4gICAgLy8gYWxsIGRvbmVcXG4gICAgaWYgKCF0ZXN0KSB7XFxuICAgICAgcmV0dXJuIGZuKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gZ3JlcFxcbiAgICB2YXIgbWF0Y2ggPSBzZWxmLl9ncmVwLnRlc3QodGVzdC5mdWxsVGl0bGUoKSk7XFxuICAgIGlmIChzZWxmLl9pbnZlcnQpIHtcXG4gICAgICBtYXRjaCA9ICFtYXRjaDtcXG4gICAgfVxcbiAgICBpZiAoIW1hdGNoKSB7XFxuICAgICAgLy8gUnVuIGltbWVkaWF0ZWx5IG9ubHkgaWYgd2UgaGF2ZSBkZWZpbmVkIGEgZ3JlcC4gV2hlbiB3ZVxcbiAgICAgIC8vIGRlZmluZSBhIGdyZXAg4oCUIEl0IGNhbiBjYXVzZSBtYXhpbXVtIGNhbGxzdGFjayBlcnJvciBpZlxcbiAgICAgIC8vIHRoZSBncmVwIGlzIGRvaW5nIGEgbGFyZ2UgcmVjdXJzaXZlIGxvb3AgYnkgbmVnbGVjdGluZ1xcbiAgICAgIC8vIGFsbCB0ZXN0cy4gVGhlIHJ1biBpbW1lZGlhdGVseSBmdW5jdGlvbiBhbHNvIGNvbWVzIHdpdGhcXG4gICAgICAvLyBhIHBlcmZvcm1hbmNlIGNvc3QuIFNvIHdlIGRvbid0IHdhbnQgdG8gcnVuIGltbWVkaWF0ZWx5XFxuICAgICAgLy8gaWYgd2UgcnVuIHRoZSB3aG9sZSB0ZXN0IHN1aXRlLCBiZWNhdXNlIHJ1bm5pbmcgdGhlIHdob2xlXFxuICAgICAgLy8gdGVzdCBzdWl0ZSBkb24ndCBkbyBhbnkgaW1tZWRpYXRlIHJlY3Vyc2l2ZSBsb29wcy4gVGh1cyxcXG4gICAgICAvLyBhbGxvd2luZyBhIEpTIHJ1bnRpbWUgdG8gYnJlYXRoZS5cXG4gICAgICBpZiAoc2VsZi5fZ3JlcCAhPT0gc2VsZi5fZGVmYXVsdEdyZXApIHtcXG4gICAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShuZXh0KTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgbmV4dCgpO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgICBpZiAoc2VsZi5mb3JiaWRQZW5kaW5nKSB7XFxuICAgICAgICB0ZXN0LmlzUGVuZGluZyA9IGFsd2F5c0ZhbHNlO1xcbiAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpKTtcXG4gICAgICAgIGRlbGV0ZSB0ZXN0LmlzUGVuZGluZztcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc2VsZi5lbWl0KCdwZW5kaW5nJywgdGVzdCk7XFxuICAgICAgfVxcbiAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICB9XFxuXFxuICAgIC8vIGV4ZWN1dGUgdGVzdCBhbmQgaG9vayhzKVxcbiAgICBzZWxmLmVtaXQoJ3Rlc3QnLCBzZWxmLnRlc3QgPSB0ZXN0KTtcXG4gICAgc2VsZi5ob29rRG93bignYmVmb3JlRWFjaCcsIGZ1bmN0aW9uIChlcnIsIGVyclN1aXRlKSB7XFxuICAgICAgaWYgKHRlc3QuaXNQZW5kaW5nKCkpIHtcXG4gICAgICAgIGlmIChzZWxmLmZvcmJpZFBlbmRpbmcpIHtcXG4gICAgICAgICAgdGVzdC5pc1BlbmRpbmcgPSBhbHdheXNGYWxzZTtcXG4gICAgICAgICAgc2VsZi5mYWlsKHRlc3QsIG5ldyBFcnJvcignUGVuZGluZyB0ZXN0IGZvcmJpZGRlbicpKTtcXG4gICAgICAgICAgZGVsZXRlIHRlc3QuaXNQZW5kaW5nO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgc2VsZi5lbWl0KCdwZW5kaW5nJywgdGVzdCk7XFxuICAgICAgICB9XFxuICAgICAgICBzZWxmLmVtaXQoJ3Rlc3QgZW5kJywgdGVzdCk7XFxuICAgICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoZXJyKSB7XFxuICAgICAgICByZXR1cm4gaG9va0VycihlcnIsIGVyclN1aXRlLCBmYWxzZSk7XFxuICAgICAgfVxcbiAgICAgIHNlbGYuY3VycmVudFJ1bm5hYmxlID0gc2VsZi50ZXN0O1xcbiAgICAgIHNlbGYucnVuVGVzdChmdW5jdGlvbiAoZXJyKSB7XFxuICAgICAgICB0ZXN0ID0gc2VsZi50ZXN0O1xcbiAgICAgICAgaWYgKGVycikge1xcbiAgICAgICAgICB2YXIgcmV0cnkgPSB0ZXN0LmN1cnJlbnRSZXRyeSgpO1xcbiAgICAgICAgICBpZiAoZXJyIGluc3RhbmNlb2YgUGVuZGluZyAmJiBzZWxmLmZvcmJpZFBlbmRpbmcpIHtcXG4gICAgICAgICAgICBzZWxmLmZhaWwodGVzdCwgbmV3IEVycm9yKCdQZW5kaW5nIHRlc3QgZm9yYmlkZGVuJykpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICB0ZXN0LnBlbmRpbmcgPSB0cnVlO1xcbiAgICAgICAgICAgIHNlbGYuZW1pdCgncGVuZGluZycsIHRlc3QpO1xcbiAgICAgICAgICB9IGVsc2UgaWYgKHJldHJ5IDwgdGVzdC5yZXRyaWVzKCkpIHtcXG4gICAgICAgICAgICB2YXIgY2xvbmVkVGVzdCA9IHRlc3QuY2xvbmUoKTtcXG4gICAgICAgICAgICBjbG9uZWRUZXN0LmN1cnJlbnRSZXRyeShyZXRyeSArIDEpO1xcbiAgICAgICAgICAgIHRlc3RzLnVuc2hpZnQoY2xvbmVkVGVzdCk7XFxuXFxuICAgICAgICAgICAgLy8gRWFybHkgcmV0dXJuICsgaG9vayB0cmlnZ2VyIHNvIHRoYXQgaXQgZG9lc24ndFxcbiAgICAgICAgICAgIC8vIGluY3JlbWVudCB0aGUgY291bnQgd3JvbmdcXG4gICAgICAgICAgICByZXR1cm4gc2VsZi5ob29rVXAoJ2FmdGVyRWFjaCcsIG5leHQpO1xcbiAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIHNlbGYuZmFpbCh0ZXN0LCBlcnIpO1xcbiAgICAgICAgICB9XFxuICAgICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG5cXG4gICAgICAgICAgaWYgKGVyciBpbnN0YW5jZW9mIFBlbmRpbmcpIHtcXG4gICAgICAgICAgICByZXR1cm4gbmV4dCgpO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIHJldHVybiBzZWxmLmhvb2tVcCgnYWZ0ZXJFYWNoJywgbmV4dCk7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB0ZXN0LnN0YXRlID0gJ3Bhc3NlZCc7XFxuICAgICAgICBzZWxmLmVtaXQoJ3Bhc3MnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuZW1pdCgndGVzdCBlbmQnLCB0ZXN0KTtcXG4gICAgICAgIHNlbGYuaG9va1VwKCdhZnRlckVhY2gnLCBuZXh0KTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICB0aGlzLm5leHQgPSBuZXh0O1xcbiAgdGhpcy5ob29rRXJyID0gaG9va0VycjtcXG4gIG5leHQoKTtcXG59O1xcblxcbmZ1bmN0aW9uIGFsd2F5c0ZhbHNlICgpIHtcXG4gIHJldHVybiBmYWxzZTtcXG59XFxuXFxuLyoqXFxuICogUnVuIHRoZSBnaXZlbiBgc3VpdGVgIGFuZCBpbnZva2UgdGhlIGNhbGxiYWNrIGBmbigpYCB3aGVuIGNvbXBsZXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtTdWl0ZX0gc3VpdGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUucnVuU3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUsIGZuKSB7XFxuICB2YXIgaSA9IDA7XFxuICB2YXIgc2VsZiA9IHRoaXM7XFxuICB2YXIgdG90YWwgPSB0aGlzLmdyZXBUb3RhbChzdWl0ZSk7XFxuICB2YXIgYWZ0ZXJBbGxIb29rQ2FsbGVkID0gZmFsc2U7XFxuXFxuICBkZWJ1ZygncnVuIHN1aXRlICVzJywgc3VpdGUuZnVsbFRpdGxlKCkpO1xcblxcbiAgaWYgKCF0b3RhbCB8fCAoc2VsZi5mYWlsdXJlcyAmJiBzdWl0ZS5fYmFpbCkpIHtcXG4gICAgcmV0dXJuIGZuKCk7XFxuICB9XFxuXFxuICB0aGlzLmVtaXQoJ3N1aXRlJywgdGhpcy5zdWl0ZSA9IHN1aXRlKTtcXG5cXG4gIGZ1bmN0aW9uIG5leHQgKGVyclN1aXRlKSB7XFxuICAgIGlmIChlcnJTdWl0ZSkge1xcbiAgICAgIC8vIGN1cnJlbnQgc3VpdGUgZmFpbGVkIG9uIGEgaG9vayBmcm9tIGVyclN1aXRlXFxuICAgICAgaWYgKGVyclN1aXRlID09PSBzdWl0ZSkge1xcbiAgICAgICAgLy8gaWYgZXJyU3VpdGUgaXMgY3VycmVudCBzdWl0ZVxcbiAgICAgICAgLy8gY29udGludWUgdG8gdGhlIG5leHQgc2libGluZyBzdWl0ZVxcbiAgICAgICAgcmV0dXJuIGRvbmUoKTtcXG4gICAgICB9XFxuICAgICAgLy8gZXJyU3VpdGUgaXMgYW1vbmcgdGhlIHBhcmVudHMgb2YgY3VycmVudCBzdWl0ZVxcbiAgICAgIC8vIHN0b3AgZXhlY3V0aW9uIG9mIGVyclN1aXRlIGFuZCBhbGwgc3ViLXN1aXRlc1xcbiAgICAgIHJldHVybiBkb25lKGVyclN1aXRlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc2VsZi5fYWJvcnQpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjdXJyID0gc3VpdGUuc3VpdGVzW2krK107XFxuICAgIGlmICghY3Vycikge1xcbiAgICAgIHJldHVybiBkb25lKCk7XFxuICAgIH1cXG5cXG4gICAgLy8gQXZvaWQgZ3JlcCBuZWdsZWN0aW5nIGxhcmdlIG51bWJlciBvZiB0ZXN0cyBjYXVzaW5nIGFcXG4gICAgLy8gaHVnZSByZWN1cnNpdmUgbG9vcCBhbmQgdGh1cyBhIG1heGltdW0gY2FsbCBzdGFjayBlcnJvci5cXG4gICAgLy8gU2VlIGNvbW1lbnQgaW4gYHRoaXMucnVuVGVzdHMoKWAgZm9yIG1vcmUgaW5mb3JtYXRpb24uXFxuICAgIGlmIChzZWxmLl9ncmVwICE9PSBzZWxmLl9kZWZhdWx0R3JlcCkge1xcbiAgICAgIFJ1bm5lci5pbW1lZGlhdGVseShmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzZWxmLnJ1blN1aXRlKGN1cnIsIG5leHQpO1xcbiAgICAgIH0pO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHNlbGYucnVuU3VpdGUoY3VyciwgbmV4dCk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGRvbmUgKGVyclN1aXRlKSB7XFxuICAgIHNlbGYuc3VpdGUgPSBzdWl0ZTtcXG4gICAgc2VsZi5uZXh0U3VpdGUgPSBuZXh0O1xcblxcbiAgICBpZiAoYWZ0ZXJBbGxIb29rQ2FsbGVkKSB7XFxuICAgICAgZm4oZXJyU3VpdGUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIC8vIG1hcmsgdGhhdCB0aGUgYWZ0ZXJBbGwgYmxvY2sgaGFzIGJlZW4gY2FsbGVkIG9uY2VcXG4gICAgICAvLyBhbmQgc28gY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgaXMgYW4gZXJyb3IgaW4gaXQuXFxuICAgICAgYWZ0ZXJBbGxIb29rQ2FsbGVkID0gdHJ1ZTtcXG5cXG4gICAgICAvLyByZW1vdmUgcmVmZXJlbmNlIHRvIHRlc3RcXG4gICAgICBkZWxldGUgc2VsZi50ZXN0O1xcblxcbiAgICAgIHNlbGYuaG9vaygnYWZ0ZXJBbGwnLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBzZWxmLmVtaXQoJ3N1aXRlIGVuZCcsIHN1aXRlKTtcXG4gICAgICAgIGZuKGVyclN1aXRlKTtcXG4gICAgICB9KTtcXG4gICAgfVxcbiAgfVxcblxcbiAgdGhpcy5uZXh0U3VpdGUgPSBuZXh0O1xcblxcbiAgdGhpcy5ob29rKCdiZWZvcmVBbGwnLCBmdW5jdGlvbiAoZXJyKSB7XFxuICAgIGlmIChlcnIpIHtcXG4gICAgICByZXR1cm4gZG9uZSgpO1xcbiAgICB9XFxuICAgIHNlbGYucnVuVGVzdHMoc3VpdGUsIG5leHQpO1xcbiAgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBIYW5kbGUgdW5jYXVnaHQgZXhjZXB0aW9ucy5cXG4gKlxcbiAqIEBwYXJhbSB7RXJyb3J9IGVyclxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblJ1bm5lci5wcm90b3R5cGUudW5jYXVnaHQgPSBmdW5jdGlvbiAoZXJyKSB7XFxuICBpZiAoZXJyKSB7XFxuICAgIGRlYnVnKCd1bmNhdWdodCBleGNlcHRpb24gJXMnLCBlcnIgPT09IChmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0uY2FsbChlcnIpKSA/IChlcnIubWVzc2FnZSB8fCBlcnIpIDogZXJyKTtcXG4gIH0gZWxzZSB7XFxuICAgIGRlYnVnKCd1bmNhdWdodCB1bmRlZmluZWQgZXhjZXB0aW9uJyk7XFxuICAgIGVyciA9IHVuZGVmaW5lZEVycm9yKCk7XFxuICB9XFxuICBlcnIudW5jYXVnaHQgPSB0cnVlO1xcblxcbiAgdmFyIHJ1bm5hYmxlID0gdGhpcy5jdXJyZW50UnVubmFibGU7XFxuXFxuICBpZiAoIXJ1bm5hYmxlKSB7XFxuICAgIHJ1bm5hYmxlID0gbmV3IFJ1bm5hYmxlKCdVbmNhdWdodCBlcnJvciBvdXRzaWRlIHRlc3Qgc3VpdGUnKTtcXG4gICAgcnVubmFibGUucGFyZW50ID0gdGhpcy5zdWl0ZTtcXG5cXG4gICAgaWYgKHRoaXMuc3RhcnRlZCkge1xcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBDYW4ndCByZWNvdmVyIGZyb20gdGhpcyBmYWlsdXJlXFxuICAgICAgdGhpcy5lbWl0KCdzdGFydCcpO1xcbiAgICAgIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG4gICAgICB0aGlzLmVtaXQoJ2VuZCcpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIHJ1bm5hYmxlLmNsZWFyVGltZW91dCgpO1xcblxcbiAgLy8gSWdub3JlIGVycm9ycyBpZiBhbHJlYWR5IGZhaWxlZCBvciBwZW5kaW5nXFxuICAvLyBTZWUgIzMyMjZcXG4gIGlmIChydW5uYWJsZS5pc0ZhaWxlZCgpIHx8IHJ1bm5hYmxlLmlzUGVuZGluZygpKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIC8vIHdlIGNhbm5vdCByZWNvdmVyIGdyYWNlZnVsbHkgaWYgYSBSdW5uYWJsZSBoYXMgYWxyZWFkeSBwYXNzZWRcXG4gIC8vIHRoZW4gZmFpbHMgYXN5bmNocm9ub3VzbHlcXG4gIHZhciBhbHJlYWR5UGFzc2VkID0gcnVubmFibGUuaXNQYXNzZWQoKTtcXG4gIC8vIHRoaXMgd2lsbCBjaGFuZ2UgdGhlIHN0YXRlIHRvIFxcXCJmYWlsZWRcXFwiIHJlZ2FyZGxlc3Mgb2YgdGhlIGN1cnJlbnQgdmFsdWVcXG4gIHRoaXMuZmFpbChydW5uYWJsZSwgZXJyKTtcXG4gIGlmICghYWxyZWFkeVBhc3NlZCkge1xcbiAgICAvLyByZWNvdmVyIGZyb20gdGVzdFxcbiAgICBpZiAocnVubmFibGUudHlwZSA9PT0gJ3Rlc3QnKSB7XFxuICAgICAgdGhpcy5lbWl0KCd0ZXN0IGVuZCcsIHJ1bm5hYmxlKTtcXG4gICAgICB0aGlzLmhvb2tVcCgnYWZ0ZXJFYWNoJywgdGhpcy5uZXh0KTtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gcmVjb3ZlciBmcm9tIGhvb2tzXFxuICAgIHZhciBlcnJTdWl0ZSA9IHRoaXMuc3VpdGU7XFxuICAgIC8vIGlmIGhvb2sgZmFpbHVyZSBpcyBpbiBhZnRlckVhY2ggYmxvY2tcXG4gICAgaWYgKHJ1bm5hYmxlLmZ1bGxUaXRsZSgpLmluZGV4T2YoJ2FmdGVyIGVhY2gnKSA+IC0xKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuaG9va0VycihlcnIsIGVyclN1aXRlLCB0cnVlKTtcXG4gICAgfVxcbiAgICAvLyBpZiBob29rIGZhaWx1cmUgaXMgaW4gYmVmb3JlRWFjaCBibG9ja1xcbiAgICBpZiAocnVubmFibGUuZnVsbFRpdGxlKCkuaW5kZXhPZignYmVmb3JlIGVhY2gnKSA+IC0xKSB7XFxuICAgICAgcmV0dXJuIHRoaXMuaG9va0VycihlcnIsIGVyclN1aXRlLCBmYWxzZSk7XFxuICAgIH1cXG4gICAgLy8gaWYgaG9vayBmYWlsdXJlIGlzIGluIGFmdGVyIG9yIGJlZm9yZSBibG9ja3NcXG4gICAgcmV0dXJuIHRoaXMubmV4dFN1aXRlKGVyclN1aXRlKTtcXG4gIH1cXG5cXG4gIC8vIGJhaWxcXG4gIHRoaXMuZW1pdCgnZW5kJyk7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbnMgdXAgdGhlIHJlZmVyZW5jZXMgdG8gYWxsIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnNcXG4gKiAoYmVmb3JlL2FmdGVyL2JlZm9yZUVhY2gvYWZ0ZXJFYWNoKSBhbmQgdGVzdHMgb2YgYSBTdWl0ZS5cXG4gKiBUaGVzZSBtdXN0IGJlIGRlbGV0ZWQgb3RoZXJ3aXNlIGEgbWVtb3J5IGxlYWsgY2FuIGhhcHBlbixcXG4gKiBhcyB0aG9zZSBmdW5jdGlvbnMgbWF5IHJlZmVyZW5jZSB2YXJpYWJsZXMgZnJvbSBjbG9zdXJlcyxcXG4gKiB0aHVzIHRob3NlIHZhcmlhYmxlcyBjYW4gbmV2ZXIgYmUgZ2FyYmFnZSBjb2xsZWN0ZWQgYXMgbG9uZ1xcbiAqIGFzIHRoZSBkZWZlcnJlZCBmdW5jdGlvbnMgZXhpc3QuXFxuICpcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqL1xcbmZ1bmN0aW9uIGNsZWFuU3VpdGVSZWZlcmVuY2VzIChzdWl0ZSkge1xcbiAgZnVuY3Rpb24gY2xlYW5BcnJSZWZlcmVuY2VzIChhcnIpIHtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHtcXG4gICAgICBkZWxldGUgYXJyW2ldLmZuO1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheShzdWl0ZS5fYmVmb3JlQWxsKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2JlZm9yZUFsbCk7XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheShzdWl0ZS5fYmVmb3JlRWFjaCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9iZWZvcmVFYWNoKTtcXG4gIH1cXG5cXG4gIGlmIChBcnJheS5pc0FycmF5KHN1aXRlLl9hZnRlckFsbCkpIHtcXG4gICAgY2xlYW5BcnJSZWZlcmVuY2VzKHN1aXRlLl9hZnRlckFsbCk7XFxuICB9XFxuXFxuICBpZiAoQXJyYXkuaXNBcnJheShzdWl0ZS5fYWZ0ZXJFYWNoKSkge1xcbiAgICBjbGVhbkFyclJlZmVyZW5jZXMoc3VpdGUuX2FmdGVyRWFjaCk7XFxuICB9XFxuXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN1aXRlLnRlc3RzLmxlbmd0aDsgaSsrKSB7XFxuICAgIGRlbGV0ZSBzdWl0ZS50ZXN0c1tpXS5mbjtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogUnVuIHRoZSByb290IHN1aXRlIGFuZCBpbnZva2UgYGZuKGZhaWx1cmVzKWBcXG4gKiBvbiBjb21wbGV0aW9uLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcHVibGljXFxuICogQG1lbWJlcm9mIE1vY2hhLlJ1bm5lclxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXFxuICogQHJldHVybiB7UnVubmVyfSBSdW5uZXIgaW5zdGFuY2UuXFxuICovXFxuUnVubmVyLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHZhciBzZWxmID0gdGhpcztcXG4gIHZhciByb290U3VpdGUgPSB0aGlzLnN1aXRlO1xcblxcbiAgZm4gPSBmbiB8fCBmdW5jdGlvbiAoKSB7fTtcXG5cXG4gIGZ1bmN0aW9uIHVuY2F1Z2h0IChlcnIpIHtcXG4gICAgc2VsZi51bmNhdWdodChlcnIpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gc3RhcnQgKCkge1xcbiAgICAvLyBJZiB0aGVyZSBpcyBhbiBgb25seWAgZmlsdGVyXFxuICAgIGlmIChoYXNPbmx5KHJvb3RTdWl0ZSkpIHtcXG4gICAgICBmaWx0ZXJPbmx5KHJvb3RTdWl0ZSk7XFxuICAgIH1cXG4gICAgc2VsZi5zdGFydGVkID0gdHJ1ZTtcXG4gICAgc2VsZi5lbWl0KCdzdGFydCcpO1xcbiAgICBzZWxmLnJ1blN1aXRlKHJvb3RTdWl0ZSwgZnVuY3Rpb24gKCkge1xcbiAgICAgIGRlYnVnKCdmaW5pc2hlZCBydW5uaW5nJyk7XFxuICAgICAgc2VsZi5lbWl0KCdlbmQnKTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBkZWJ1Zygnc3RhcnQnKTtcXG5cXG4gIC8vIHJlZmVyZW5jZXMgY2xlYW51cCB0byBhdm9pZCBtZW1vcnkgbGVha3NcXG4gIHRoaXMub24oJ3N1aXRlIGVuZCcsIGNsZWFuU3VpdGVSZWZlcmVuY2VzKTtcXG5cXG4gIC8vIGNhbGxiYWNrXFxuICB0aGlzLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGRlYnVnKCdlbmQnKTtcXG4gICAgcHJvY2Vzcy5yZW1vdmVMaXN0ZW5lcigndW5jYXVnaHRFeGNlcHRpb24nLCB1bmNhdWdodCk7XFxuICAgIGZuKHNlbGYuZmFpbHVyZXMpO1xcbiAgfSk7XFxuXFxuICAvLyB1bmNhdWdodCBleGNlcHRpb25cXG4gIHByb2Nlc3Mub24oJ3VuY2F1Z2h0RXhjZXB0aW9uJywgdW5jYXVnaHQpO1xcblxcbiAgaWYgKHRoaXMuX2RlbGF5KSB7XFxuICAgIC8vIGZvciByZXBvcnRlcnMsIEkgZ3Vlc3MuXFxuICAgIC8vIG1pZ2h0IGJlIG5pY2UgdG8gZGVib3VuY2Ugc29tZSBkb3RzIHdoaWxlIHdlIHdhaXQuXFxuICAgIHRoaXMuZW1pdCgnd2FpdGluZycsIHJvb3RTdWl0ZSk7XFxuICAgIHJvb3RTdWl0ZS5vbmNlKCdydW4nLCBzdGFydCk7XFxuICB9IGVsc2Uge1xcbiAgICBzdGFydCgpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBDbGVhbmx5IGFib3J0IGV4ZWN1dGlvbi5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5SdW5uZXJcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtSdW5uZXJ9IFJ1bm5lciBpbnN0YW5jZS5cXG4gKi9cXG5SdW5uZXIucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xcbiAgZGVidWcoJ2Fib3J0aW5nJyk7XFxuICB0aGlzLl9hYm9ydCA9IHRydWU7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEZpbHRlciBzdWl0ZXMgYmFzZWQgb24gYGlzT25seWAgbG9naWMuXFxuICpcXG4gKiBAcGFyYW0ge0FycmF5fSBzdWl0ZVxcbiAqIEByZXR1cm5zIHtCb29sZWFufVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGZpbHRlck9ubHkgKHN1aXRlKSB7XFxuICBpZiAoc3VpdGUuX29ubHlUZXN0cy5sZW5ndGgpIHtcXG4gICAgLy8gSWYgdGhlIHN1aXRlIGNvbnRhaW5zIGBvbmx5YCB0ZXN0cywgcnVuIHRob3NlIGFuZCBpZ25vcmUgYW55IG5lc3RlZCBzdWl0ZXMuXFxuICAgIHN1aXRlLnRlc3RzID0gc3VpdGUuX29ubHlUZXN0cztcXG4gICAgc3VpdGUuc3VpdGVzID0gW107XFxuICB9IGVsc2Uge1xcbiAgICAvLyBPdGhlcndpc2UsIGRvIG5vdCBydW4gYW55IG9mIHRoZSB0ZXN0cyBpbiB0aGlzIHN1aXRlLlxcbiAgICBzdWl0ZS50ZXN0cyA9IFtdO1xcbiAgICBzdWl0ZS5fb25seVN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChvbmx5U3VpdGUpIHtcXG4gICAgICAvLyBJZiB0aGVyZSBhcmUgb3RoZXIgYG9ubHlgIHRlc3RzL3N1aXRlcyBuZXN0ZWQgaW4gdGhlIGN1cnJlbnQgYG9ubHlgIHN1aXRlLCB0aGVuIGZpbHRlciB0aGF0IGBvbmx5YCBzdWl0ZS5cXG4gICAgICAvLyBPdGhlcndpc2UsIGFsbCBvZiB0aGUgdGVzdHMgb24gdGhpcyBgb25seWAgc3VpdGUgc2hvdWxkIGJlIHJ1biwgc28gZG9uJ3QgZmlsdGVyIGl0LlxcbiAgICAgIGlmIChoYXNPbmx5KG9ubHlTdWl0ZSkpIHtcXG4gICAgICAgIGZpbHRlck9ubHkob25seVN1aXRlKTtcXG4gICAgICB9XFxuICAgIH0pO1xcbiAgICAvLyBSdW4gdGhlIGBvbmx5YCBzdWl0ZXMsIGFzIHdlbGwgYXMgYW55IG90aGVyIHN1aXRlcyB0aGF0IGhhdmUgYG9ubHlgIHRlc3RzL3N1aXRlcyBhcyBkZXNjZW5kYW50cy5cXG4gICAgc3VpdGUuc3VpdGVzID0gc3VpdGUuc3VpdGVzLmZpbHRlcihmdW5jdGlvbiAoY2hpbGRTdWl0ZSkge1xcbiAgICAgIHJldHVybiBzdWl0ZS5fb25seVN1aXRlcy5pbmRleE9mKGNoaWxkU3VpdGUpICE9PSAtMSB8fCBmaWx0ZXJPbmx5KGNoaWxkU3VpdGUpO1xcbiAgICB9KTtcXG4gIH1cXG4gIC8vIEtlZXAgdGhlIHN1aXRlIG9ubHkgaWYgdGhlcmUgaXMgc29tZXRoaW5nIHRvIHJ1blxcbiAgcmV0dXJuIHN1aXRlLnRlc3RzLmxlbmd0aCB8fCBzdWl0ZS5zdWl0ZXMubGVuZ3RoO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgYSBzdWl0ZSBoYXMgYW4gYG9ubHlgIHRlc3Qgb3Igc3VpdGUgYXMgYSBkZXNjZW5kYW50LlxcbiAqXFxuICogQHBhcmFtIHtBcnJheX0gc3VpdGVcXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBoYXNPbmx5IChzdWl0ZSkge1xcbiAgcmV0dXJuIHN1aXRlLl9vbmx5VGVzdHMubGVuZ3RoIHx8IHN1aXRlLl9vbmx5U3VpdGVzLmxlbmd0aCB8fCBzdWl0ZS5zdWl0ZXMuc29tZShoYXNPbmx5KTtcXG59XFxuXFxuLyoqXFxuICogRmlsdGVyIGxlYWtzIHdpdGggdGhlIGdpdmVuIGdsb2JhbHMgZmxhZ2dlZCBhcyBgb2tgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gb2tcXG4gKiBAcGFyYW0ge0FycmF5fSBnbG9iYWxzXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZnVuY3Rpb24gZmlsdGVyTGVha3MgKG9rLCBnbG9iYWxzKSB7XFxuICByZXR1cm4gZ2xvYmFscy5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xcbiAgICAvLyBGaXJlZm94IGFuZCBDaHJvbWUgZXhwb3NlcyBpZnJhbWVzIGFzIGluZGV4IGluc2lkZSB0aGUgd2luZG93IG9iamVjdFxcbiAgICBpZiAoL15cXFxcZCsvLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICAvLyBpbiBmaXJlZm94XFxuICAgIC8vIGlmIHJ1bm5lciBydW5zIGluIGFuIGlmcmFtZSwgdGhpcyBpZnJhbWUncyB3aW5kb3cuZ2V0SW50ZXJmYWNlIG1ldGhvZFxcbiAgICAvLyBub3QgaW5pdCBhdCBmaXJzdCBpdCBpcyBhc3NpZ25lZCBpbiBzb21lIHNlY29uZHNcXG4gICAgaWYgKGdsb2JhbC5uYXZpZ2F0b3IgJiYgKC9eZ2V0SW50ZXJmYWNlLykudGVzdChrZXkpKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIC8vIGFuIGlmcmFtZSBjb3VsZCBiZSBhcHByb2FjaGVkIGJ5IHdpbmRvd1tpZnJhbWVJbmRleF1cXG4gICAgLy8gaW4gaWU2LDcsOCBhbmQgb3BlcmEsIGlmcmFtZUluZGV4IGlzIGVudW1lcmFibGUsIHRoaXMgY291bGQgY2F1c2UgbGVha1xcbiAgICBpZiAoZ2xvYmFsLm5hdmlnYXRvciAmJiAoL15cXFxcZCsvKS50ZXN0KGtleSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG5cXG4gICAgLy8gT3BlcmEgYW5kIElFIGV4cG9zZSBnbG9iYWwgdmFyaWFibGVzIGZvciBIVE1MIGVsZW1lbnQgSURzIChpc3N1ZSAjMjQzKVxcbiAgICBpZiAoL15tb2NoYS0vLnRlc3Qoa2V5KSkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcblxcbiAgICB2YXIgbWF0Y2hlZCA9IG9rLmZpbHRlcihmdW5jdGlvbiAob2spIHtcXG4gICAgICBpZiAofm9rLmluZGV4T2YoJyonKSkge1xcbiAgICAgICAgcmV0dXJuIGtleS5pbmRleE9mKG9rLnNwbGl0KCcqJylbMF0pID09PSAwO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4ga2V5ID09PSBvaztcXG4gICAgfSk7XFxuICAgIHJldHVybiAhbWF0Y2hlZC5sZW5ndGggJiYgKCFnbG9iYWwubmF2aWdhdG9yIHx8IGtleSAhPT0gJ29uZXJyb3InKTtcXG4gIH0pO1xcbn1cXG5cXG4vKipcXG4gKiBBcnJheSBvZiBnbG9iYWxzIGRlcGVuZGVudCBvbiB0aGUgZW52aXJvbm1lbnQuXFxuICpcXG4gKiBAcmV0dXJuIHtBcnJheX1cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5mdW5jdGlvbiBleHRyYUdsb2JhbHMgKCkge1xcbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgcHJvY2Vzcy52ZXJzaW9uID09PSAnc3RyaW5nJykge1xcbiAgICB2YXIgcGFydHMgPSBwcm9jZXNzLnZlcnNpb24uc3BsaXQoJy4nKTtcXG4gICAgdmFyIG5vZGVWZXJzaW9uID0gcGFydHMucmVkdWNlKGZ1bmN0aW9uIChhLCB2KSB7XFxuICAgICAgcmV0dXJuIGEgPDwgOCB8IHY7XFxuICAgIH0pO1xcblxcbiAgICAvLyAnZXJybm8nIHdhcyByZW5hbWVkIHRvIHByb2Nlc3MuX2Vycm5vIGluIHYwLjkuMTEuXFxuXFxuICAgIGlmIChub2RlVmVyc2lvbiA8IDB4MDAwOTBCKSB7XFxuICAgICAgcmV0dXJuIFsnZXJybm8nXTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIFtdO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL3BlbmRpbmdcXFwiOjE1LFxcXCIuL3J1bm5hYmxlXFxcIjozMixcXFwiLi91dGlsc1xcXCI6MzYsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiZGVidWdcXFwiOjQzLFxcXCJldmVudHNcXFwiOjQ3fV0sMzQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG4vKipcXG4gKiBAbW9kdWxlIFN1aXRlXFxuICovXFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJykuRXZlbnRFbWl0dGVyO1xcbnZhciBIb29rID0gcmVxdWlyZSgnLi9ob29rJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpbmhlcml0cyA9IHV0aWxzLmluaGVyaXRzO1xcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOnN1aXRlJyk7XFxudmFyIG1pbGxpc2Vjb25kcyA9IHJlcXVpcmUoJy4vbXMnKTtcXG5cXG4vKipcXG4gKiBFeHBvc2UgYFN1aXRlYC5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBTdWl0ZTtcXG5cXG4vKipcXG4gKiBDcmVhdGUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBwYXJlbnQgYFN1aXRlYC4gV2hlbiBhIHN1aXRlXFxuICogd2l0aCB0aGUgc2FtZSB0aXRsZSBpcyBhbHJlYWR5IHByZXNlbnQsIHRoYXQgc3VpdGUgaXMgcmV0dXJuZWQgdG8gcHJvdmlkZVxcbiAqIG5pY2VyIHJlcG9ydGVyIGFuZCBtb3JlIGZsZXhpYmxlIG1ldGEtdGVzdGluZy5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7U3VpdGV9IHBhcmVudFxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZVxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcbmV4cG9ydHMuY3JlYXRlID0gZnVuY3Rpb24gKHBhcmVudCwgdGl0bGUpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aXRsZSwgcGFyZW50LmN0eCk7XFxuICBzdWl0ZS5wYXJlbnQgPSBwYXJlbnQ7XFxuICB0aXRsZSA9IHN1aXRlLmZ1bGxUaXRsZSgpO1xcbiAgcGFyZW50LmFkZFN1aXRlKHN1aXRlKTtcXG4gIHJldHVybiBzdWl0ZTtcXG59O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFN1aXRlYCB3aXRoIHRoZSBnaXZlbiBgdGl0bGVgIGFuZCBgY3R4YC4gRGVyaXZlZCBmcm9tIFtFdmVudEVtaXR0ZXJdKGh0dHBzOi8vbm9kZWpzLm9yZy9hcGkvZXZlbnRzLmh0bWwjZXZlbnRzX2NsYXNzX2V2ZW50ZW1pdHRlcilcXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYVxcbiAqIEBwdWJsaWNcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0NvbnRleHR9IHBhcmVudENvbnRleHRcXG4gKi9cXG5mdW5jdGlvbiBTdWl0ZSAodGl0bGUsIHBhcmVudENvbnRleHQpIHtcXG4gIGlmICghdXRpbHMuaXNTdHJpbmcodGl0bGUpKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignU3VpdGUgYHRpdGxlYCBzaG91bGQgYmUgYSBcXFwic3RyaW5nXFxcIiBidXQgXFxcIicgKyB0eXBlb2YgdGl0bGUgKyAnXFxcIiB3YXMgZ2l2ZW4gaW5zdGVhZC4nKTtcXG4gIH1cXG4gIHRoaXMudGl0bGUgPSB0aXRsZTtcXG4gIGZ1bmN0aW9uIENvbnRleHQgKCkge31cXG4gIENvbnRleHQucHJvdG90eXBlID0gcGFyZW50Q29udGV4dDtcXG4gIHRoaXMuY3R4ID0gbmV3IENvbnRleHQoKTtcXG4gIHRoaXMuc3VpdGVzID0gW107XFxuICB0aGlzLnRlc3RzID0gW107XFxuICB0aGlzLnBlbmRpbmcgPSBmYWxzZTtcXG4gIHRoaXMuX2JlZm9yZUVhY2ggPSBbXTtcXG4gIHRoaXMuX2JlZm9yZUFsbCA9IFtdO1xcbiAgdGhpcy5fYWZ0ZXJFYWNoID0gW107XFxuICB0aGlzLl9hZnRlckFsbCA9IFtdO1xcbiAgdGhpcy5yb290ID0gIXRpdGxlO1xcbiAgdGhpcy5fdGltZW91dCA9IDIwMDA7XFxuICB0aGlzLl9lbmFibGVUaW1lb3V0cyA9IHRydWU7XFxuICB0aGlzLl9zbG93ID0gNzU7XFxuICB0aGlzLl9iYWlsID0gZmFsc2U7XFxuICB0aGlzLl9yZXRyaWVzID0gLTE7XFxuICB0aGlzLl9vbmx5VGVzdHMgPSBbXTtcXG4gIHRoaXMuX29ubHlTdWl0ZXMgPSBbXTtcXG4gIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xcbn1cXG5cXG4vKipcXG4gKiBJbmhlcml0IGZyb20gYEV2ZW50RW1pdHRlci5wcm90b3R5cGVgLlxcbiAqL1xcbmluaGVyaXRzKFN1aXRlLCBFdmVudEVtaXR0ZXIpO1xcblxcbi8qKlxcbiAqIFJldHVybiBhIGNsb25lIG9mIHRoaXMgYFN1aXRlYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEByZXR1cm4ge1N1aXRlfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5jbG9uZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdWl0ZSA9IG5ldyBTdWl0ZSh0aGlzLnRpdGxlKTtcXG4gIGRlYnVnKCdjbG9uZScpO1xcbiAgc3VpdGUuY3R4ID0gdGhpcy5jdHg7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICByZXR1cm4gc3VpdGU7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IHRpbWVvdXQgYG1zYCBvciBzaG9ydC1oYW5kIHN1Y2ggYXMgXFxcIjJzXFxcIi5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gbXNcXG4gKiBAcmV0dXJuIHtTdWl0ZXxudW1iZXJ9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50aW1lb3V0ID0gZnVuY3Rpb24gKG1zKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVvdXQ7XFxuICB9XFxuICBpZiAobXMudG9TdHJpbmcoKSA9PT0gJzAnKSB7XFxuICAgIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZmFsc2U7XFxuICB9XFxuICBpZiAodHlwZW9mIG1zID09PSAnc3RyaW5nJykge1xcbiAgICBtcyA9IG1pbGxpc2Vjb25kcyhtcyk7XFxuICB9XFxuICBkZWJ1ZygndGltZW91dCAlZCcsIG1zKTtcXG4gIHRoaXMuX3RpbWVvdXQgPSBwYXJzZUludChtcywgMTApO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBTZXQgb3IgZ2V0IG51bWJlciBvZiB0aW1lcyB0byByZXRyeSBhIGZhaWxlZCB0ZXN0LlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtudW1iZXJ8c3RyaW5nfSBuXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUucmV0cmllcyA9IGZ1bmN0aW9uIChuKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX3JldHJpZXM7XFxuICB9XFxuICBkZWJ1ZygncmV0cmllcyAlZCcsIG4pO1xcbiAgdGhpcy5fcmV0cmllcyA9IHBhcnNlSW50KG4sIDEwKSB8fCAwO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gICogU2V0IG9yIGdldCB0aW1lb3V0IHRvIGBlbmFibGVkYC5cXG4gICpcXG4gICogQGFwaSBwcml2YXRlXFxuICAqIEBwYXJhbSB7Ym9vbGVhbn0gZW5hYmxlZFxcbiAgKiBAcmV0dXJuIHtTdWl0ZXxib29sZWFufSBzZWxmIG9yIGVuYWJsZWRcXG4gICovXFxuU3VpdGUucHJvdG90eXBlLmVuYWJsZVRpbWVvdXRzID0gZnVuY3Rpb24gKGVuYWJsZWQpIHtcXG4gIGlmICghYXJndW1lbnRzLmxlbmd0aCkge1xcbiAgICByZXR1cm4gdGhpcy5fZW5hYmxlVGltZW91dHM7XFxuICB9XFxuICBkZWJ1ZygnZW5hYmxlVGltZW91dHMgJXMnLCBlbmFibGVkKTtcXG4gIHRoaXMuX2VuYWJsZVRpbWVvdXRzID0gZW5hYmxlZDtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogU2V0IG9yIGdldCBzbG93IGBtc2Agb3Igc2hvcnQtaGFuZCBzdWNoIGFzIFxcXCIyc1xcXCIuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IG1zXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuc2xvdyA9IGZ1bmN0aW9uIChtcykge1xcbiAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XFxuICAgIHJldHVybiB0aGlzLl9zbG93O1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBtcyA9PT0gJ3N0cmluZycpIHtcXG4gICAgbXMgPSBtaWxsaXNlY29uZHMobXMpO1xcbiAgfVxcbiAgZGVidWcoJ3Nsb3cgJWQnLCBtcyk7XFxuICB0aGlzLl9zbG93ID0gbXM7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFNldCBvciBnZXQgd2hldGhlciB0byBiYWlsIGFmdGVyIGZpcnN0IGVycm9yLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtib29sZWFufSBiYWlsXFxuICogQHJldHVybiB7U3VpdGV8bnVtYmVyfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmFpbCA9IGZ1bmN0aW9uIChiYWlsKSB7XFxuICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgcmV0dXJuIHRoaXMuX2JhaWw7XFxuICB9XFxuICBkZWJ1ZygnYmFpbCAlcycsIGJhaWwpO1xcbiAgdGhpcy5fYmFpbCA9IGJhaWw7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIENoZWNrIGlmIHRoaXMgc3VpdGUgb3IgaXRzIHBhcmVudCBzdWl0ZSBpcyBtYXJrZWQgYXMgcGVuZGluZy5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5pc1BlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5wZW5kaW5nIHx8ICh0aGlzLnBhcmVudCAmJiB0aGlzLnBhcmVudC5pc1BlbmRpbmcoKSk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmljIGhvb2stY3JlYXRvci5cXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSB0aXRsZSAtIFRpdGxlIG9mIGhvb2tcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIEhvb2sgY2FsbGJhY2tcXG4gKiBAcmV0dXJucyB7SG9va30gQSBuZXcgaG9va1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5fY3JlYXRlSG9vayA9IGZ1bmN0aW9uICh0aXRsZSwgZm4pIHtcXG4gIHZhciBob29rID0gbmV3IEhvb2sodGl0bGUsIGZuKTtcXG4gIGhvb2sucGFyZW50ID0gdGhpcztcXG4gIGhvb2sudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICBob29rLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgaG9vay5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgaG9vay5zbG93KHRoaXMuc2xvdygpKTtcXG4gIGhvb2suY3R4ID0gdGhpcy5jdHg7XFxuICBob29rLmZpbGUgPSB0aGlzLmZpbGU7XFxuICByZXR1cm4gaG9vaztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIHJ1bm5pbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYmVmb3JlQWxsID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJiZWZvcmUgYWxsXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xcbiAgdGhpcy5fYmVmb3JlQWxsLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2JlZm9yZUFsbCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBSdW4gYGZuKHRlc3RbLCBkb25lXSlgIGFmdGVyIHJ1bm5pbmcgdGVzdHMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJBbGwgPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImFmdGVyIGFsbFxcXCIgaG9vaycgKyAodGl0bGUgPyAnOiAnICsgdGl0bGUgOiAnJyk7XFxuXFxuICB2YXIgaG9vayA9IHRoaXMuX2NyZWF0ZUhvb2sodGl0bGUsIGZuKTtcXG4gIHRoaXMuX2FmdGVyQWxsLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2FmdGVyQWxsJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYmVmb3JlIGVhY2ggdGVzdCBjYXNlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IHRpdGxlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX0gZm9yIGNoYWluaW5nXFxuICovXFxuU3VpdGUucHJvdG90eXBlLmJlZm9yZUVhY2ggPSBmdW5jdGlvbiAodGl0bGUsIGZuKSB7XFxuICBpZiAodGhpcy5pc1BlbmRpbmcoKSkge1xcbiAgICByZXR1cm4gdGhpcztcXG4gIH1cXG4gIGlmICh0eXBlb2YgdGl0bGUgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgZm4gPSB0aXRsZTtcXG4gICAgdGl0bGUgPSBmbi5uYW1lO1xcbiAgfVxcbiAgdGl0bGUgPSAnXFxcImJlZm9yZSBlYWNoXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xcbiAgdGhpcy5fYmVmb3JlRWFjaC5wdXNoKGhvb2spO1xcbiAgdGhpcy5lbWl0KCdiZWZvcmVFYWNoJywgaG9vayk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIFJ1biBgZm4odGVzdFssIGRvbmVdKWAgYWZ0ZXIgZWFjaCB0ZXN0IGNhc2UuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWZ0ZXJFYWNoID0gZnVuY3Rpb24gKHRpdGxlLCBmbikge1xcbiAgaWYgKHRoaXMuaXNQZW5kaW5nKCkpIHtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuICBpZiAodHlwZW9mIHRpdGxlID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGZuID0gdGl0bGU7XFxuICAgIHRpdGxlID0gZm4ubmFtZTtcXG4gIH1cXG4gIHRpdGxlID0gJ1xcXCJhZnRlciBlYWNoXFxcIiBob29rJyArICh0aXRsZSA/ICc6ICcgKyB0aXRsZSA6ICcnKTtcXG5cXG4gIHZhciBob29rID0gdGhpcy5fY3JlYXRlSG9vayh0aXRsZSwgZm4pO1xcbiAgdGhpcy5fYWZ0ZXJFYWNoLnB1c2goaG9vayk7XFxuICB0aGlzLmVtaXQoJ2FmdGVyRWFjaCcsIGhvb2spO1xcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG4vKipcXG4gKiBBZGQgYSB0ZXN0IGBzdWl0ZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N1aXRlfSBzdWl0ZVxcbiAqIEByZXR1cm4ge1N1aXRlfSBmb3IgY2hhaW5pbmdcXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuYWRkU3VpdGUgPSBmdW5jdGlvbiAoc3VpdGUpIHtcXG4gIHN1aXRlLnBhcmVudCA9IHRoaXM7XFxuICBzdWl0ZS50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHN1aXRlLnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgc3VpdGUuZW5hYmxlVGltZW91dHModGhpcy5lbmFibGVUaW1lb3V0cygpKTtcXG4gIHN1aXRlLnNsb3codGhpcy5zbG93KCkpO1xcbiAgc3VpdGUuYmFpbCh0aGlzLmJhaWwoKSk7XFxuICB0aGlzLnN1aXRlcy5wdXNoKHN1aXRlKTtcXG4gIHRoaXMuZW1pdCgnc3VpdGUnLCBzdWl0ZSk7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8qKlxcbiAqIEFkZCBhIGB0ZXN0YCB0byB0aGlzIHN1aXRlLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtUZXN0fSB0ZXN0XFxuICogQHJldHVybiB7U3VpdGV9IGZvciBjaGFpbmluZ1xcbiAqL1xcblN1aXRlLnByb3RvdHlwZS5hZGRUZXN0ID0gZnVuY3Rpb24gKHRlc3QpIHtcXG4gIHRlc3QucGFyZW50ID0gdGhpcztcXG4gIHRlc3QudGltZW91dCh0aGlzLnRpbWVvdXQoKSk7XFxuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgdGVzdC5lbmFibGVUaW1lb3V0cyh0aGlzLmVuYWJsZVRpbWVvdXRzKCkpO1xcbiAgdGVzdC5zbG93KHRoaXMuc2xvdygpKTtcXG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XFxuICB0aGlzLnRlc3RzLnB1c2godGVzdCk7XFxuICB0aGlzLmVtaXQoJ3Rlc3QnLCB0ZXN0KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogUmV0dXJuIHRoZSBmdWxsIHRpdGxlIGdlbmVyYXRlZCBieSByZWN1cnNpdmVseSBjb25jYXRlbmF0aW5nIHRoZSBwYXJlbnQnc1xcbiAqIGZ1bGwgdGl0bGUuXFxuICpcXG4gKiBAbWVtYmVyb2YgTW9jaGEuU3VpdGVcXG4gKiBAcHVibGljXFxuICogQGFwaSBwdWJsaWNcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuU3VpdGUucHJvdG90eXBlLmZ1bGxUaXRsZSA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiB0aGlzLnRpdGxlUGF0aCgpLmpvaW4oJyAnKTtcXG59O1xcblxcbi8qKlxcbiAqIFJldHVybiB0aGUgdGl0bGUgcGF0aCBnZW5lcmF0ZWQgYnkgcmVjdXJzaXZlbHkgY29uY2F0ZW5hdGluZyB0aGUgcGFyZW50J3NcXG4gKiB0aXRsZSBwYXRoLlxcbiAqXFxuICogQG1lbWJlcm9mIE1vY2hhLlN1aXRlXFxuICogQHB1YmxpY1xcbiAqIEBhcGkgcHVibGljXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcblN1aXRlLnByb3RvdHlwZS50aXRsZVBhdGggPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgcmVzdWx0ID0gW107XFxuICBpZiAodGhpcy5wYXJlbnQpIHtcXG4gICAgcmVzdWx0ID0gcmVzdWx0LmNvbmNhdCh0aGlzLnBhcmVudC50aXRsZVBhdGgoKSk7XFxuICB9XFxuICBpZiAoIXRoaXMucm9vdCkge1xcbiAgICByZXN1bHQucHVzaCh0aGlzLnRpdGxlKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufTtcXG5cXG4vKipcXG4gKiBSZXR1cm4gdGhlIHRvdGFsIG51bWJlciBvZiB0ZXN0cy5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS5TdWl0ZVxcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEByZXR1cm4ge251bWJlcn1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUudG90YWwgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5zdWl0ZXMucmVkdWNlKGZ1bmN0aW9uIChzdW0sIHN1aXRlKSB7XFxuICAgIHJldHVybiBzdW0gKyBzdWl0ZS50b3RhbCgpO1xcbiAgfSwgMCkgKyB0aGlzLnRlc3RzLmxlbmd0aDtcXG59O1xcblxcbi8qKlxcbiAqIEl0ZXJhdGVzIHRocm91Z2ggZWFjaCBzdWl0ZSByZWN1cnNpdmVseSB0byBmaW5kIGFsbCB0ZXN0cy4gQXBwbGllcyBhXFxuICogZnVuY3Rpb24gaW4gdGhlIGZvcm1hdCBgZm4odGVzdClgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cXG4gKiBAcmV0dXJuIHtTdWl0ZX1cXG4gKi9cXG5TdWl0ZS5wcm90b3R5cGUuZWFjaFRlc3QgPSBmdW5jdGlvbiAoZm4pIHtcXG4gIHRoaXMudGVzdHMuZm9yRWFjaChmbik7XFxuICB0aGlzLnN1aXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChzdWl0ZSkge1xcbiAgICBzdWl0ZS5lYWNoVGVzdChmbik7XFxuICB9KTtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLyoqXFxuICogVGhpcyB3aWxsIHJ1biB0aGUgcm9vdCBzdWl0ZSBpZiB3ZSBoYXBwZW4gdG8gYmUgcnVubmluZyBpbiBkZWxheWVkIG1vZGUuXFxuICovXFxuU3VpdGUucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uIHJ1biAoKSB7XFxuICBpZiAodGhpcy5yb290KSB7XFxuICAgIHRoaXMuZW1pdCgncnVuJyk7XFxuICB9XFxufTtcXG5cXG59LHtcXFwiLi9ob29rXFxcIjo2LFxcXCIuL21zXFxcIjoxNCxcXFwiLi91dGlsc1xcXCI6MzYsXFxcImRlYnVnXFxcIjo0MyxcXFwiZXZlbnRzXFxcIjo0N31dLDM1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuLyoqXFxuICogTW9kdWxlIGRlcGVuZGVuY2llcy5cXG4gKi9cXG5cXG52YXIgUnVubmFibGUgPSByZXF1aXJlKCcuL3J1bm5hYmxlJyk7XFxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xcbnZhciBpc1N0cmluZyA9IHV0aWxzLmlzU3RyaW5nO1xcblxcbi8qKlxcbiAqIEV4cG9zZSBgVGVzdGAuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUZXN0O1xcblxcbi8qKlxcbiAqIEluaXRpYWxpemUgYSBuZXcgYFRlc3RgIHdpdGggdGhlIGdpdmVuIGB0aXRsZWAgYW5kIGNhbGxiYWNrIGBmbmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gdGl0bGVcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmZ1bmN0aW9uIFRlc3QgKHRpdGxlLCBmbikge1xcbiAgaWYgKCFpc1N0cmluZyh0aXRsZSkpIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdUZXN0IGB0aXRsZWAgc2hvdWxkIGJlIGEgXFxcInN0cmluZ1xcXCIgYnV0IFxcXCInICsgdHlwZW9mIHRpdGxlICsgJ1xcXCIgd2FzIGdpdmVuIGluc3RlYWQuJyk7XFxuICB9XFxuICBSdW5uYWJsZS5jYWxsKHRoaXMsIHRpdGxlLCBmbik7XFxuICB0aGlzLnBlbmRpbmcgPSAhZm47XFxuICB0aGlzLnR5cGUgPSAndGVzdCc7XFxufVxcblxcbi8qKlxcbiAqIEluaGVyaXQgZnJvbSBgUnVubmFibGUucHJvdG90eXBlYC5cXG4gKi9cXG51dGlscy5pbmhlcml0cyhUZXN0LCBSdW5uYWJsZSk7XFxuXFxuVGVzdC5wcm90b3R5cGUuY2xvbmUgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgdGVzdCA9IG5ldyBUZXN0KHRoaXMudGl0bGUsIHRoaXMuZm4pO1xcbiAgdGVzdC50aW1lb3V0KHRoaXMudGltZW91dCgpKTtcXG4gIHRlc3Quc2xvdyh0aGlzLnNsb3coKSk7XFxuICB0ZXN0LmVuYWJsZVRpbWVvdXRzKHRoaXMuZW5hYmxlVGltZW91dHMoKSk7XFxuICB0ZXN0LnJldHJpZXModGhpcy5yZXRyaWVzKCkpO1xcbiAgdGVzdC5jdXJyZW50UmV0cnkodGhpcy5jdXJyZW50UmV0cnkoKSk7XFxuICB0ZXN0Lmdsb2JhbHModGhpcy5nbG9iYWxzKCkpO1xcbiAgdGVzdC5wYXJlbnQgPSB0aGlzLnBhcmVudDtcXG4gIHRlc3QuZmlsZSA9IHRoaXMuZmlsZTtcXG4gIHRlc3QuY3R4ID0gdGhpcy5jdHg7XFxuICByZXR1cm4gdGVzdDtcXG59O1xcblxcbn0se1xcXCIuL3J1bm5hYmxlXFxcIjozMixcXFwiLi91dGlsc1xcXCI6MzZ9XSwzNjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLEJ1ZmZlcil7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qKlxcbiAqIEBtb2R1bGVcXG4gKi9cXG5cXG4vKipcXG4gKiBNb2R1bGUgZGVwZW5kZW5jaWVzLlxcbiAqL1xcblxcbnZhciBkZWJ1ZyA9IHJlcXVpcmUoJ2RlYnVnJykoJ21vY2hhOndhdGNoJyk7XFxudmFyIGZzID0gcmVxdWlyZSgnZnMnKTtcXG52YXIgZ2xvYiA9IHJlcXVpcmUoJ2dsb2InKTtcXG52YXIgcGF0aCA9IHJlcXVpcmUoJ3BhdGgnKTtcXG52YXIgam9pbiA9IHBhdGguam9pbjtcXG52YXIgaGUgPSByZXF1aXJlKCdoZScpO1xcblxcbi8qKlxcbiAqIElnbm9yZWQgZGlyZWN0b3JpZXMuXFxuICovXFxuXFxudmFyIGlnbm9yZSA9IFsnbm9kZV9tb2R1bGVzJywgJy5naXQnXTtcXG5cXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xcblxcbi8qKlxcbiAqIEVzY2FwZSBzcGVjaWFsIGNoYXJhY3RlcnMgaW4gdGhlIGdpdmVuIHN0cmluZyBvZiBodG1sLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtICB7c3RyaW5nfSBodG1sXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmV4cG9ydHMuZXNjYXBlID0gZnVuY3Rpb24gKGh0bWwpIHtcXG4gIHJldHVybiBoZS5lbmNvZGUoU3RyaW5nKGh0bWwpLCB7IHVzZU5hbWVkUmVmZXJlbmNlczogZmFsc2UgfSk7XFxufTtcXG5cXG4vKipcXG4gKiBUZXN0IGlmIHRoZSBnaXZlbiBvYmogaXMgdHlwZSBvZiBzdHJpbmcuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqXFxuICogQHJldHVybiB7Ym9vbGVhbn1cXG4gKi9cXG5leHBvcnRzLmlzU3RyaW5nID0gZnVuY3Rpb24gKG9iaikge1xcbiAgcmV0dXJuIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xcbn07XFxuXFxuLyoqXFxuICogV2F0Y2ggdGhlIGdpdmVuIGBmaWxlc2AgZm9yIGNoYW5nZXNcXG4gKiBhbmQgaW52b2tlIGBmbihmaWxlKWAgb24gbW9kaWZpY2F0aW9uLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtBcnJheX0gZmlsZXNcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxcbiAqL1xcbmV4cG9ydHMud2F0Y2ggPSBmdW5jdGlvbiAoZmlsZXMsIGZuKSB7XFxuICB2YXIgb3B0aW9ucyA9IHsgaW50ZXJ2YWw6IDEwMCB9O1xcbiAgZmlsZXMuZm9yRWFjaChmdW5jdGlvbiAoZmlsZSkge1xcbiAgICBkZWJ1ZygnZmlsZSAlcycsIGZpbGUpO1xcbiAgICBmcy53YXRjaEZpbGUoZmlsZSwgb3B0aW9ucywgZnVuY3Rpb24gKGN1cnIsIHByZXYpIHtcXG4gICAgICBpZiAocHJldi5tdGltZSA8IGN1cnIubXRpbWUpIHtcXG4gICAgICAgIGZuKGZpbGUpO1xcbiAgICAgIH1cXG4gICAgfSk7XFxuICB9KTtcXG59O1xcblxcbi8qKlxcbiAqIElnbm9yZWQgZmlsZXMuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gcGF0aFxcbiAqIEByZXR1cm4ge2Jvb2xlYW59XFxuICovXFxuZnVuY3Rpb24gaWdub3JlZCAocGF0aCkge1xcbiAgcmV0dXJuICF+aWdub3JlLmluZGV4T2YocGF0aCk7XFxufVxcblxcbi8qKlxcbiAqIExvb2t1cCBmaWxlcyBpbiB0aGUgZ2l2ZW4gYGRpcmAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gZGlyXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gW2V4dD1bJy5qcyddXVxcbiAqIEBwYXJhbSB7QXJyYXl9IFtyZXQ9W11dXFxuICogQHJldHVybiB7QXJyYXl9XFxuICovXFxuZXhwb3J0cy5maWxlcyA9IGZ1bmN0aW9uIChkaXIsIGV4dCwgcmV0KSB7XFxuICByZXQgPSByZXQgfHwgW107XFxuICBleHQgPSBleHQgfHwgWydqcyddO1xcblxcbiAgdmFyIHJlID0gbmV3IFJlZ0V4cCgnXFxcXFxcXFwuKCcgKyBleHQuam9pbignfCcpICsgJykkJyk7XFxuXFxuICBmcy5yZWFkZGlyU3luYyhkaXIpXFxuICAgIC5maWx0ZXIoaWdub3JlZClcXG4gICAgLmZvckVhY2goZnVuY3Rpb24gKHBhdGgpIHtcXG4gICAgICBwYXRoID0gam9pbihkaXIsIHBhdGgpO1xcbiAgICAgIGlmIChmcy5sc3RhdFN5bmMocGF0aCkuaXNEaXJlY3RvcnkoKSkge1xcbiAgICAgICAgZXhwb3J0cy5maWxlcyhwYXRoLCBleHQsIHJldCk7XFxuICAgICAgfSBlbHNlIGlmIChwYXRoLm1hdGNoKHJlKSkge1xcbiAgICAgICAgcmV0LnB1c2gocGF0aCk7XFxuICAgICAgfVxcbiAgICB9KTtcXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG4vKipcXG4gKiBDb21wdXRlIGEgc2x1ZyBmcm9tIHRoZSBnaXZlbiBgc3RyYC5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zbHVnID0gZnVuY3Rpb24gKHN0cikge1xcbiAgcmV0dXJuIHN0clxcbiAgICAudG9Mb3dlckNhc2UoKVxcbiAgICAucmVwbGFjZSgvICsvZywgJy0nKVxcbiAgICAucmVwbGFjZSgvW14tXFxcXHddL2csICcnKTtcXG59O1xcblxcbi8qKlxcbiAqIFN0cmlwIHRoZSBmdW5jdGlvbiBkZWZpbml0aW9uIGZyb20gYHN0cmAsIGFuZCByZS1pbmRlbnQgZm9yIHByZSB3aGl0ZXNwYWNlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IHN0clxcbiAqIEByZXR1cm4ge3N0cmluZ31cXG4gKi9cXG5leHBvcnRzLmNsZWFuID0gZnVuY3Rpb24gKHN0cikge1xcbiAgc3RyID0gc3RyXFxuICAgIC5yZXBsYWNlKC9cXFxcclxcXFxuP3xbXFxcXG5cXFxcdTIwMjhcXFxcdTIwMjldL2csICdcXFxcbicpLnJlcGxhY2UoL15cXFxcdUZFRkYvLCAnJylcXG4gICAgLy8gKHRyYWRpdGlvbmFsKS0+ICBzcGFjZS9uYW1lICAgICBwYXJhbWV0ZXJzICAgIGJvZHkgICAgIChsYW1iZGEpLT4gcGFyYW1ldGVycyAgICAgICBib2R5ICAgbXVsdGktc3RhdGVtZW50L3NpbmdsZSAgICAgICAgICBrZWVwIGJvZHkgY29udGVudFxcbiAgICAucmVwbGFjZSgvXmZ1bmN0aW9uKD86XFxcXHMqfFxcXFxzK1teKF0qKVxcXFwoW14pXSpcXFxcKVxcXFxzKlxcXFx7KCg/Oi58XFxcXG4pKj8pXFxcXHMqXFxcXH0kfF5cXFxcKFteKV0qXFxcXClcXFxccyo9PlxcXFxzKig/OlxcXFx7KCg/Oi58XFxcXG4pKj8pXFxcXHMqXFxcXH18KCg/Oi58XFxcXG4pKikpJC8sICckMSQyJDMnKTtcXG5cXG4gIHZhciBzcGFjZXMgPSBzdHIubWF0Y2goL15cXFxcbj8oICopLylbMV0ubGVuZ3RoO1xcbiAgdmFyIHRhYnMgPSBzdHIubWF0Y2goL15cXFxcbj8oXFxcXHQqKS8pWzFdLmxlbmd0aDtcXG4gIHZhciByZSA9IG5ldyBSZWdFeHAoJ15cXFxcbj8nICsgKHRhYnMgPyAnXFxcXHQnIDogJyAnKSArICd7JyArICh0YWJzIHx8IHNwYWNlcykgKyAnfScsICdnbScpO1xcblxcbiAgc3RyID0gc3RyLnJlcGxhY2UocmUsICcnKTtcXG5cXG4gIHJldHVybiBzdHIudHJpbSgpO1xcbn07XFxuXFxuLyoqXFxuICogUGFyc2UgdGhlIGdpdmVuIGBxc2AuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gcXNcXG4gKiBAcmV0dXJuIHtPYmplY3R9XFxuICovXFxuZXhwb3J0cy5wYXJzZVF1ZXJ5ID0gZnVuY3Rpb24gKHFzKSB7XFxuICByZXR1cm4gcXMucmVwbGFjZSgnPycsICcnKS5zcGxpdCgnJicpLnJlZHVjZShmdW5jdGlvbiAob2JqLCBwYWlyKSB7XFxuICAgIHZhciBpID0gcGFpci5pbmRleE9mKCc9Jyk7XFxuICAgIHZhciBrZXkgPSBwYWlyLnNsaWNlKDAsIGkpO1xcbiAgICB2YXIgdmFsID0gcGFpci5zbGljZSgrK2kpO1xcblxcbiAgICAvLyBEdWUgdG8gaG93IHRoZSBVUkxTZWFyY2hQYXJhbXMgQVBJIHRyZWF0cyBzcGFjZXNcXG4gICAgb2JqW2tleV0gPSBkZWNvZGVVUklDb21wb25lbnQodmFsLnJlcGxhY2UoL1xcXFwrL2csICclMjAnKSk7XFxuXFxuICAgIHJldHVybiBvYmo7XFxuICB9LCB7fSk7XFxufTtcXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGdpdmVuIHN0cmluZyBvZiBganNgLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHtzdHJpbmd9IGpzXFxuICogQHJldHVybiB7c3RyaW5nfVxcbiAqL1xcbmZ1bmN0aW9uIGhpZ2hsaWdodCAoanMpIHtcXG4gIHJldHVybiBqc1xcbiAgICAucmVwbGFjZSgvPC9nLCAnJmx0OycpXFxuICAgIC5yZXBsYWNlKC8+L2csICcmZ3Q7JylcXG4gICAgLnJlcGxhY2UoL1xcXFwvXFxcXC8oLiopL2dtLCAnPHNwYW4gY2xhc3M9XFxcImNvbW1lbnRcXFwiPi8vJDE8L3NwYW4+JylcXG4gICAgLnJlcGxhY2UoLygnLio/JykvZ20sICc8c3BhbiBjbGFzcz1cXFwic3RyaW5nXFxcIj4kMTwvc3Bhbj4nKVxcbiAgICAucmVwbGFjZSgvKFxcXFxkK1xcXFwuXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC8oXFxcXGQrKS9nbSwgJzxzcGFuIGNsYXNzPVxcXCJudW1iZXJcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcYm5ld1sgXFxcXHRdKyhcXFxcdyspL2dtLCAnPHNwYW4gY2xhc3M9XFxcImtleXdvcmRcXFwiPm5ldzwvc3Bhbj4gPHNwYW4gY2xhc3M9XFxcImluaXRcXFwiPiQxPC9zcGFuPicpXFxuICAgIC5yZXBsYWNlKC9cXFxcYihmdW5jdGlvbnxuZXd8dGhyb3d8cmV0dXJufHZhcnxpZnxlbHNlKVxcXFxiL2dtLCAnPHNwYW4gY2xhc3M9XFxcImtleXdvcmRcXFwiPiQxPC9zcGFuPicpO1xcbn1cXG5cXG4vKipcXG4gKiBIaWdobGlnaHQgdGhlIGNvbnRlbnRzIG9mIHRhZyBgbmFtZWAuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxcbiAqL1xcbmV4cG9ydHMuaGlnaGxpZ2h0VGFncyA9IGZ1bmN0aW9uIChuYW1lKSB7XFxuICB2YXIgY29kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCdtb2NoYScpLmdldEVsZW1lbnRzQnlUYWdOYW1lKG5hbWUpO1xcbiAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGNvZGUubGVuZ3RoOyBpIDwgbGVuOyArK2kpIHtcXG4gICAgY29kZVtpXS5pbm5lckhUTUwgPSBoaWdobGlnaHQoY29kZVtpXS5pbm5lckhUTUwpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogSWYgYSB2YWx1ZSBjb3VsZCBoYXZlIHByb3BlcnRpZXMsIGFuZCBoYXMgbm9uZSwgdGhpcyBmdW5jdGlvbiBpcyBjYWxsZWQsXFxuICogd2hpY2ggcmV0dXJucyBhIHN0cmluZyByZXByZXNlbnRhdGlvbiBvZiB0aGUgZW1wdHkgdmFsdWUuXFxuICpcXG4gKiBGdW5jdGlvbnMgdy8gbm8gcHJvcGVydGllcyByZXR1cm4gYCdbRnVuY3Rpb25dJ2BcXG4gKiBBcnJheXMgdy8gbGVuZ3RoID09PSAwIHJldHVybiBgJ1tdJ2BcXG4gKiBPYmplY3RzIHcvIG5vIHByb3BlcnRpZXMgcmV0dXJuIGAne30nYFxcbiAqIEFsbCBlbHNlOiByZXR1cm4gcmVzdWx0IG9mIGB2YWx1ZS50b1N0cmluZygpYFxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZUhpbnQgVGhlIHR5cGUgb2YgdGhlIHZhbHVlXFxuICogQHJldHVybnMge3N0cmluZ31cXG4gKi9cXG5mdW5jdGlvbiBlbXB0eVJlcHJlc2VudGF0aW9uICh2YWx1ZSwgdHlwZUhpbnQpIHtcXG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxcbiAgICAgIHJldHVybiAnW0Z1bmN0aW9uXSc7XFxuICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgcmV0dXJuICd7fSc7XFxuICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICByZXR1cm4gJ1tdJztcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoKTtcXG4gIH1cXG59XFxuXFxuLyoqXFxuICogVGFrZXMgc29tZSB2YXJpYWJsZSBhbmQgYXNrcyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZygpYCB3aGF0IGl0IHRoaW5rcyBpdFxcbiAqIGlzLlxcbiAqXFxuICogQGFwaSBwcml2YXRlXFxuICogQHNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9KYXZhU2NyaXB0L1JlZmVyZW5jZS9HbG9iYWxfT2JqZWN0cy9PYmplY3QvdG9TdHJpbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB0ZXN0LlxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IENvbXB1dGVkIHR5cGVcXG4gKiBAZXhhbXBsZVxcbiAqIHR5cGUoe30pIC8vICdvYmplY3QnXFxuICogdHlwZShbXSkgLy8gJ2FycmF5J1xcbiAqIHR5cGUoMSkgLy8gJ251bWJlcidcXG4gKiB0eXBlKGZhbHNlKSAvLyAnYm9vbGVhbidcXG4gKiB0eXBlKEluZmluaXR5KSAvLyAnbnVtYmVyJ1xcbiAqIHR5cGUobnVsbCkgLy8gJ251bGwnXFxuICogdHlwZShuZXcgRGF0ZSgpKSAvLyAnZGF0ZSdcXG4gKiB0eXBlKC9mb28vKSAvLyAncmVnZXhwJ1xcbiAqIHR5cGUoJ3R5cGUnKSAvLyAnc3RyaW5nJ1xcbiAqIHR5cGUoZ2xvYmFsKSAvLyAnZ2xvYmFsJ1xcbiAqIHR5cGUobmV3IFN0cmluZygnZm9vJykgLy8gJ29iamVjdCdcXG4gKi9cXG52YXIgdHlwZSA9IGV4cG9ydHMudHlwZSA9IGZ1bmN0aW9uIHR5cGUgKHZhbHVlKSB7XFxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xcbiAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XFxuICB9IGVsc2UgaWYgKHZhbHVlID09PSBudWxsKSB7XFxuICAgIHJldHVybiAnbnVsbCc7XFxuICB9IGVsc2UgaWYgKEJ1ZmZlci5pc0J1ZmZlcih2YWx1ZSkpIHtcXG4gICAgcmV0dXJuICdidWZmZXInO1xcbiAgfVxcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSlcXG4gICAgLnJlcGxhY2UoL15cXFxcWy4rXFxcXHMoLis/KV0kLywgJyQxJylcXG4gICAgLnRvTG93ZXJDYXNlKCk7XFxufTtcXG5cXG4vKipcXG4gKiBTdHJpbmdpZnkgYHZhbHVlYC4gRGlmZmVyZW50IGJlaGF2aW9yIGRlcGVuZGluZyBvbiB0eXBlIG9mIHZhbHVlOlxcbiAqXFxuICogLSBJZiBgdmFsdWVgIGlzIHVuZGVmaW5lZCBvciBudWxsLCByZXR1cm4gYCdbdW5kZWZpbmVkXSdgIG9yIGAnW251bGxdJ2AsIHJlc3BlY3RpdmVseS5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgbm90IGFuIG9iamVjdCwgZnVuY3Rpb24gb3IgYXJyYXksIHJldHVybiByZXN1bHQgb2YgYHZhbHVlLnRvU3RyaW5nKClgIHdyYXBwZWQgaW4gZG91YmxlLXF1b3Rlcy5cXG4gKiAtIElmIGB2YWx1ZWAgaXMgYW4gKmVtcHR5KiBvYmplY3QsIGZ1bmN0aW9uLCBvciBhcnJheSwgcmV0dXJuIHJlc3VsdCBvZiBmdW5jdGlvblxcbiAqICAge0BsaW5rIGVtcHR5UmVwcmVzZW50YXRpb259LlxcbiAqIC0gSWYgYHZhbHVlYCBoYXMgcHJvcGVydGllcywgY2FsbCB7QGxpbmsgZXhwb3J0cy5jYW5vbmljYWxpemV9IG9uIGl0LCB0aGVuIHJldHVybiByZXN1bHQgb2ZcXG4gKiAgIEpTT04uc3RyaW5naWZ5KCkuXFxuICpcXG4gKiBAYXBpIHByaXZhdGVcXG4gKiBAc2VlIGV4cG9ydHMudHlwZVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWVcXG4gKiBAcmV0dXJuIHtzdHJpbmd9XFxuICovXFxuZXhwb3J0cy5zdHJpbmdpZnkgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG4gIHZhciB0eXBlSGludCA9IHR5cGUodmFsdWUpO1xcblxcbiAgaWYgKCF+WydvYmplY3QnLCAnYXJyYXknLCAnZnVuY3Rpb24nXS5pbmRleE9mKHR5cGVIaW50KSkge1xcbiAgICBpZiAodHlwZUhpbnQgPT09ICdidWZmZXInKSB7XFxuICAgICAgdmFyIGpzb24gPSBCdWZmZXIucHJvdG90eXBlLnRvSlNPTi5jYWxsKHZhbHVlKTtcXG4gICAgICAvLyBCYXNlZCBvbiB0aGUgdG9KU09OIHJlc3VsdFxcbiAgICAgIHJldHVybiBqc29uU3RyaW5naWZ5KGpzb24uZGF0YSAmJiBqc29uLnR5cGUgPyBqc29uLmRhdGEgOiBqc29uLCAyKVxcbiAgICAgICAgLnJlcGxhY2UoLywoXFxcXG58JCkvZywgJyQxJyk7XFxuICAgIH1cXG5cXG4gICAgLy8gSUU3L0lFOCBoYXMgYSBiaXphcnJlIFN0cmluZyBjb25zdHJ1Y3RvcjsgbmVlZHMgdG8gYmUgY29lcmNlZFxcbiAgICAvLyBpbnRvIGFuIGFycmF5IGFuZCBiYWNrIHRvIG9iai5cXG4gICAgaWYgKHR5cGVIaW50ID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XFxuICAgICAgdmFsdWUgPSB2YWx1ZS5zcGxpdCgnJykucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGNoYXIsIGlkeCkge1xcbiAgICAgICAgYWNjW2lkeF0gPSBjaGFyO1xcbiAgICAgICAgcmV0dXJuIGFjYztcXG4gICAgICB9LCB7fSk7XFxuICAgICAgdHlwZUhpbnQgPSAnb2JqZWN0JztcXG4gICAgfSBlbHNlIHtcXG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeSh2YWx1ZSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAodmFyIHByb3AgaW4gdmFsdWUpIHtcXG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgcHJvcCkpIHtcXG4gICAgICByZXR1cm4ganNvblN0cmluZ2lmeShleHBvcnRzLmNhbm9uaWNhbGl6ZSh2YWx1ZSwgbnVsbCwgdHlwZUhpbnQpLCAyKS5yZXBsYWNlKC8sKFxcXFxufCQpL2csICckMScpO1xcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xcbn07XFxuXFxuLyoqXFxuICogbGlrZSBKU09OLnN0cmluZ2lmeSBidXQgbW9yZSBzZW5zZS5cXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBwYXJhbSB7T2JqZWN0fSAgb2JqZWN0XFxuICogQHBhcmFtIHtudW1iZXI9fSBzcGFjZXNcXG4gKiBAcGFyYW0ge251bWJlcj19IGRlcHRoXFxuICogQHJldHVybnMgeyp9XFxuICovXFxuZnVuY3Rpb24ganNvblN0cmluZ2lmeSAob2JqZWN0LCBzcGFjZXMsIGRlcHRoKSB7XFxuICBpZiAodHlwZW9mIHNwYWNlcyA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgLy8gcHJpbWl0aXZlIHR5cGVzXFxuICAgIHJldHVybiBfc3RyaW5naWZ5KG9iamVjdCk7XFxuICB9XFxuXFxuICBkZXB0aCA9IGRlcHRoIHx8IDE7XFxuICB2YXIgc3BhY2UgPSBzcGFjZXMgKiBkZXB0aDtcXG4gIHZhciBzdHIgPSBBcnJheS5pc0FycmF5KG9iamVjdCkgPyAnWycgOiAneyc7XFxuICB2YXIgZW5kID0gQXJyYXkuaXNBcnJheShvYmplY3QpID8gJ10nIDogJ30nO1xcbiAgdmFyIGxlbmd0aCA9IHR5cGVvZiBvYmplY3QubGVuZ3RoID09PSAnbnVtYmVyJyA/IG9iamVjdC5sZW5ndGggOiBPYmplY3Qua2V5cyhvYmplY3QpLmxlbmd0aDtcXG4gIC8vIGAucmVwZWF0KClgIHBvbHlmaWxsXFxuICBmdW5jdGlvbiByZXBlYXQgKHMsIG4pIHtcXG4gICAgcmV0dXJuIG5ldyBBcnJheShuKS5qb2luKHMpO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gX3N0cmluZ2lmeSAodmFsKSB7XFxuICAgIHN3aXRjaCAodHlwZSh2YWwpKSB7XFxuICAgICAgY2FzZSAnbnVsbCc6XFxuICAgICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgICAgIHZhbCA9ICdbJyArIHZhbCArICddJztcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2FycmF5JzpcXG4gICAgICBjYXNlICdvYmplY3QnOlxcbiAgICAgICAgdmFsID0ganNvblN0cmluZ2lmeSh2YWwsIHNwYWNlcywgZGVwdGggKyAxKTtcXG4gICAgICAgIGJyZWFrO1xcbiAgICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgICAgY2FzZSAnc3ltYm9sJzpcXG4gICAgICBjYXNlICdudW1iZXInOlxcbiAgICAgICAgdmFsID0gdmFsID09PSAwICYmICgxIC8gdmFsKSA9PT0gLUluZmluaXR5IC8vIGAtMGBcXG4gICAgICAgICAgPyAnLTAnXFxuICAgICAgICAgIDogdmFsLnRvU3RyaW5nKCk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlICdkYXRlJzpcXG4gICAgICAgIHZhciBzRGF0ZSA9IGlzTmFOKHZhbC5nZXRUaW1lKCkpID8gdmFsLnRvU3RyaW5nKCkgOiB2YWwudG9JU09TdHJpbmcoKTtcXG4gICAgICAgIHZhbCA9ICdbRGF0ZTogJyArIHNEYXRlICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAnYnVmZmVyJzpcXG4gICAgICAgIHZhciBqc29uID0gdmFsLnRvSlNPTigpO1xcbiAgICAgICAgLy8gQmFzZWQgb24gdGhlIHRvSlNPTiByZXN1bHRcXG4gICAgICAgIGpzb24gPSBqc29uLmRhdGEgJiYganNvbi50eXBlID8ganNvbi5kYXRhIDoganNvbjtcXG4gICAgICAgIHZhbCA9ICdbQnVmZmVyOiAnICsganNvblN0cmluZ2lmeShqc29uLCAyLCBkZXB0aCArIDEpICsgJ10nO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIHZhbCA9ICh2YWwgPT09ICdbRnVuY3Rpb25dJyB8fCB2YWwgPT09ICdbQ2lyY3VsYXJdJylcXG4gICAgICAgICAgPyB2YWxcXG4gICAgICAgICAgOiBKU09OLnN0cmluZ2lmeSh2YWwpOyAvLyBzdHJpbmdcXG4gICAgfVxcbiAgICByZXR1cm4gdmFsO1xcbiAgfVxcblxcbiAgZm9yICh2YXIgaSBpbiBvYmplY3QpIHtcXG4gICAgaWYgKCFPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBpKSkge1xcbiAgICAgIGNvbnRpbnVlOyAvLyBub3QgbXkgYnVzaW5lc3NcXG4gICAgfVxcbiAgICAtLWxlbmd0aDtcXG4gICAgc3RyICs9ICdcXFxcbiAnICsgcmVwZWF0KCcgJywgc3BhY2UpICtcXG4gICAgICAoQXJyYXkuaXNBcnJheShvYmplY3QpID8gJycgOiAnXFxcIicgKyBpICsgJ1xcXCI6ICcpICsgLy8ga2V5XFxuICAgICAgX3N0cmluZ2lmeShvYmplY3RbaV0pICsgLy8gdmFsdWVcXG4gICAgICAobGVuZ3RoID8gJywnIDogJycpOyAvLyBjb21tYVxcbiAgfVxcblxcbiAgcmV0dXJuIHN0ciArXFxuICAgIC8vIFtdLCB7fVxcbiAgICAoc3RyLmxlbmd0aCAhPT0gMSA/ICdcXFxcbicgKyByZXBlYXQoJyAnLCAtLXNwYWNlKSArIGVuZCA6IGVuZCk7XFxufVxcblxcbi8qKlxcbiAqIFJldHVybiBhIG5ldyBUaGluZyB0aGF0IGhhcyB0aGUga2V5cyBpbiBzb3J0ZWQgb3JkZXIuIFJlY3Vyc2l2ZS5cXG4gKlxcbiAqIElmIHRoZSBUaGluZy4uLlxcbiAqIC0gaGFzIGFscmVhZHkgYmVlbiBzZWVuLCByZXR1cm4gc3RyaW5nIGAnW0NpcmN1bGFyXSdgXFxuICogLSBpcyBgdW5kZWZpbmVkYCwgcmV0dXJuIHN0cmluZyBgJ1t1bmRlZmluZWRdJ2BcXG4gKiAtIGlzIGBudWxsYCwgcmV0dXJuIHZhbHVlIGBudWxsYFxcbiAqIC0gaXMgc29tZSBvdGhlciBwcmltaXRpdmUsIHJldHVybiB0aGUgdmFsdWVcXG4gKiAtIGlzIG5vdCBhIHByaW1pdGl2ZSBvciBhbiBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgVGhpbmcncyBgdG9TdHJpbmcoKWAgbWV0aG9kXFxuICogLSBpcyBhIG5vbi1lbXB0eSBgQXJyYXlgLCBgT2JqZWN0YCwgb3IgYEZ1bmN0aW9uYCwgcmV0dXJuIHRoZSByZXN1bHQgb2YgY2FsbGluZyB0aGlzIGZ1bmN0aW9uIGFnYWluLlxcbiAqIC0gaXMgYW4gZW1wdHkgYEFycmF5YCwgYE9iamVjdGAsIG9yIGBGdW5jdGlvbmAsIHJldHVybiB0aGUgcmVzdWx0IG9mIGNhbGxpbmcgYGVtcHR5UmVwcmVzZW50YXRpb24oKWBcXG4gKlxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqIEBzZWUge0BsaW5rIGV4cG9ydHMuc3RyaW5naWZ5fVxcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhpbmcgdG8gaW5zcGVjdC4gIE1heSBvciBtYXkgbm90IGhhdmUgcHJvcGVydGllcy5cXG4gKiBAcGFyYW0ge0FycmF5fSBbc3RhY2s9W11dIFN0YWNrIG9mIHNlZW4gdmFsdWVzXFxuICogQHBhcmFtIHtzdHJpbmd9IFt0eXBlSGludF0gVHlwZSBoaW50XFxuICogQHJldHVybiB7KE9iamVjdHxBcnJheXxGdW5jdGlvbnxzdHJpbmd8dW5kZWZpbmVkKX1cXG4gKi9cXG5leHBvcnRzLmNhbm9uaWNhbGl6ZSA9IGZ1bmN0aW9uIGNhbm9uaWNhbGl6ZSAodmFsdWUsIHN0YWNrLCB0eXBlSGludCkge1xcbiAgdmFyIGNhbm9uaWNhbGl6ZWRPYmo7XFxuICAvKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xcbiAgdmFyIHByb3A7XFxuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXVudXNlZC12YXJzICovXFxuICB0eXBlSGludCA9IHR5cGVIaW50IHx8IHR5cGUodmFsdWUpO1xcbiAgZnVuY3Rpb24gd2l0aFN0YWNrICh2YWx1ZSwgZm4pIHtcXG4gICAgc3RhY2sucHVzaCh2YWx1ZSk7XFxuICAgIGZuKCk7XFxuICAgIHN0YWNrLnBvcCgpO1xcbiAgfVxcblxcbiAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG5cXG4gIGlmIChzdGFjay5pbmRleE9mKHZhbHVlKSAhPT0gLTEpIHtcXG4gICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcXG4gIH1cXG5cXG4gIHN3aXRjaCAodHlwZUhpbnQpIHtcXG4gICAgY2FzZSAndW5kZWZpbmVkJzpcXG4gICAgY2FzZSAnYnVmZmVyJzpcXG4gICAgY2FzZSAnbnVsbCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHZhbHVlO1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICdhcnJheSc6XFxuICAgICAgd2l0aFN0YWNrKHZhbHVlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUubWFwKGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgICAgICAgIHJldHVybiBleHBvcnRzLmNhbm9uaWNhbGl6ZShpdGVtLCBzdGFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnZnVuY3Rpb24nOlxcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIGd1YXJkLWZvci1pbiAqL1xcbiAgICAgIGZvciAocHJvcCBpbiB2YWx1ZSkge1xcbiAgICAgICAgY2Fub25pY2FsaXplZE9iaiA9IHt9O1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAgIC8qIGVzbGludC1lbmFibGUgZ3VhcmQtZm9yLWluICovXFxuICAgICAgaWYgKCFjYW5vbmljYWxpemVkT2JqKSB7XFxuICAgICAgICBjYW5vbmljYWxpemVkT2JqID0gZW1wdHlSZXByZXNlbnRhdGlvbih2YWx1ZSwgdHlwZUhpbnQpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICAvKiBmYWxscyB0aHJvdWdoICovXFxuICAgIGNhc2UgJ29iamVjdCc6XFxuICAgICAgY2Fub25pY2FsaXplZE9iaiA9IGNhbm9uaWNhbGl6ZWRPYmogfHwge307XFxuICAgICAgd2l0aFN0YWNrKHZhbHVlLCBmdW5jdGlvbiAoKSB7XFxuICAgICAgICBPYmplY3Qua2V5cyh2YWx1ZSkuc29ydCgpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICBjYW5vbmljYWxpemVkT2JqW2tleV0gPSBleHBvcnRzLmNhbm9uaWNhbGl6ZSh2YWx1ZVtrZXldLCBzdGFjayk7XFxuICAgICAgICB9KTtcXG4gICAgICB9KTtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnZGF0ZSc6XFxuICAgIGNhc2UgJ251bWJlcic6XFxuICAgIGNhc2UgJ3JlZ2V4cCc6XFxuICAgIGNhc2UgJ2Jvb2xlYW4nOlxcbiAgICBjYXNlICdzeW1ib2wnOlxcbiAgICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB2YWx1ZTtcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICBjYW5vbmljYWxpemVkT2JqID0gdmFsdWUgKyAnJztcXG4gIH1cXG5cXG4gIHJldHVybiBjYW5vbmljYWxpemVkT2JqO1xcbn07XFxuXFxuLyoqXFxuICogTG9va3VwIGZpbGUgbmFtZXMgYXQgdGhlIGdpdmVuIGBwYXRoYC5cXG4gKlxcbiAqIEBtZW1iZXJvZiBNb2NoYS51dGlsc1xcbiAqIEBwdWJsaWNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqIEBwYXJhbSB7c3RyaW5nfSBmaWxlcGF0aCBCYXNlIHBhdGggdG8gc3RhcnQgc2VhcmNoaW5nIGZyb20uXFxuICogQHBhcmFtIHtzdHJpbmdbXX0gZXh0ZW5zaW9ucyBGaWxlIGV4dGVuc2lvbnMgdG8gbG9vayBmb3IuXFxuICogQHBhcmFtIHtib29sZWFufSByZWN1cnNpdmUgV2hldGhlciBvciBub3QgdG8gcmVjdXJzZSBpbnRvIHN1YmRpcmVjdG9yaWVzLlxcbiAqIEByZXR1cm4ge3N0cmluZ1tdfSBBbiBhcnJheSBvZiBwYXRocy5cXG4gKi9cXG5leHBvcnRzLmxvb2t1cEZpbGVzID0gZnVuY3Rpb24gbG9va3VwRmlsZXMgKGZpbGVwYXRoLCBleHRlbnNpb25zLCByZWN1cnNpdmUpIHtcXG4gIHZhciBmaWxlcyA9IFtdO1xcblxcbiAgaWYgKCFmcy5leGlzdHNTeW5jKGZpbGVwYXRoKSkge1xcbiAgICBpZiAoZnMuZXhpc3RzU3luYyhmaWxlcGF0aCArICcuanMnKSkge1xcbiAgICAgIGZpbGVwYXRoICs9ICcuanMnO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGZpbGVzID0gZ2xvYi5zeW5jKGZpbGVwYXRoKTtcXG4gICAgICBpZiAoIWZpbGVzLmxlbmd0aCkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxcXCJjYW5ub3QgcmVzb2x2ZSBwYXRoIChvciBwYXR0ZXJuKSAnXFxcIiArIGZpbGVwYXRoICsgXFxcIidcXFwiKTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIGZpbGVzO1xcbiAgICB9XFxuICB9XFxuXFxuICB0cnkge1xcbiAgICB2YXIgc3RhdCA9IGZzLnN0YXRTeW5jKGZpbGVwYXRoKTtcXG4gICAgaWYgKHN0YXQuaXNGaWxlKCkpIHtcXG4gICAgICByZXR1cm4gZmlsZXBhdGg7XFxuICAgIH1cXG4gIH0gY2F0Y2ggKGVycikge1xcbiAgICAvLyBpZ25vcmUgZXJyb3JcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgZnMucmVhZGRpclN5bmMoZmlsZXBhdGgpLmZvckVhY2goZnVuY3Rpb24gKGZpbGUpIHtcXG4gICAgZmlsZSA9IHBhdGguam9pbihmaWxlcGF0aCwgZmlsZSk7XFxuICAgIHRyeSB7XFxuICAgICAgdmFyIHN0YXQgPSBmcy5zdGF0U3luYyhmaWxlKTtcXG4gICAgICBpZiAoc3RhdC5pc0RpcmVjdG9yeSgpKSB7XFxuICAgICAgICBpZiAocmVjdXJzaXZlKSB7XFxuICAgICAgICAgIGZpbGVzID0gZmlsZXMuY29uY2F0KGxvb2t1cEZpbGVzKGZpbGUsIGV4dGVuc2lvbnMsIHJlY3Vyc2l2ZSkpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgfSBjYXRjaCAoZXJyKSB7XFxuICAgICAgLy8gaWdub3JlIGVycm9yXFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIHZhciByZSA9IG5ldyBSZWdFeHAoJ1xcXFxcXFxcLig/OicgKyBleHRlbnNpb25zLmpvaW4oJ3wnKSArICcpJCcpO1xcbiAgICBpZiAoIXN0YXQuaXNGaWxlKCkgfHwgIXJlLnRlc3QoZmlsZSkgfHwgcGF0aC5iYXNlbmFtZShmaWxlKVswXSA9PT0gJy4nKSB7XFxuICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGZpbGVzLnB1c2goZmlsZSk7XFxuICB9KTtcXG5cXG4gIHJldHVybiBmaWxlcztcXG59O1xcblxcbi8qKlxcbiAqIEdlbmVyYXRlIGFuIHVuZGVmaW5lZCBlcnJvciB3aXRoIGEgbWVzc2FnZSB3YXJuaW5nIHRoZSB1c2VyLlxcbiAqXFxuICogQHJldHVybiB7RXJyb3J9XFxuICovXFxuXFxuZXhwb3J0cy51bmRlZmluZWRFcnJvciA9IGZ1bmN0aW9uICgpIHtcXG4gIHJldHVybiBuZXcgRXJyb3IoJ0NhdWdodCB1bmRlZmluZWQgZXJyb3IsIGRpZCB5b3UgdGhyb3cgd2l0aG91dCBzcGVjaWZ5aW5nIHdoYXQ/Jyk7XFxufTtcXG5cXG4vKipcXG4gKiBHZW5lcmF0ZSBhbiB1bmRlZmluZWQgZXJyb3IgaWYgYGVycmAgaXMgbm90IGRlZmluZWQuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJcXG4gKiBAcmV0dXJuIHtFcnJvcn1cXG4gKi9cXG5cXG5leHBvcnRzLmdldEVycm9yID0gZnVuY3Rpb24gKGVycikge1xcbiAgcmV0dXJuIGVyciB8fCBleHBvcnRzLnVuZGVmaW5lZEVycm9yKCk7XFxufTtcXG5cXG4vKipcXG4gKiBAc3VtbWFyeVxcbiAqIFRoaXMgRmlsdGVyIGJhc2VkIG9uIGBtb2NoYS1jbGVhbmAgbW9kdWxlLihzZWU6IGBnaXRodWIuY29tL3JzdGFjcnV6L21vY2hhLWNsZWFuYClcXG4gKiBAZGVzY3JpcHRpb25cXG4gKiBXaGVuIGludm9raW5nIHRoaXMgZnVuY3Rpb24geW91IGdldCBhIGZpbHRlciBmdW5jdGlvbiB0aGF0IGdldCB0aGUgRXJyb3Iuc3RhY2sgYXMgYW4gaW5wdXQsXFxuICogYW5kIHJldHVybiBhIHByZXR0aWZ5IG91dHB1dC5cXG4gKiAoaS5lOiBzdHJpcCBNb2NoYSBhbmQgaW50ZXJuYWwgbm9kZSBmdW5jdGlvbnMgZnJvbSBzdGFjayB0cmFjZSkuXFxuICogQHJldHVybnMge0Z1bmN0aW9ufVxcbiAqL1xcbmV4cG9ydHMuc3RhY2tUcmFjZUZpbHRlciA9IGZ1bmN0aW9uICgpIHtcXG4gIC8vIFRPRE86IFJlcGxhY2Ugd2l0aCBgcHJvY2Vzcy5icm93c2VyYFxcbiAgdmFyIGlzID0gdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJyA/IHsgbm9kZTogdHJ1ZSB9IDogeyBicm93c2VyOiB0cnVlIH07XFxuICB2YXIgc2xhc2ggPSBwYXRoLnNlcDtcXG4gIHZhciBjd2Q7XFxuICBpZiAoaXMubm9kZSkge1xcbiAgICBjd2QgPSBwcm9jZXNzLmN3ZCgpICsgc2xhc2g7XFxuICB9IGVsc2Uge1xcbiAgICBjd2QgPSAodHlwZW9mIGxvY2F0aW9uID09PSAndW5kZWZpbmVkJ1xcbiAgICAgID8gd2luZG93LmxvY2F0aW9uXFxuICAgICAgOiBsb2NhdGlvbikuaHJlZi5yZXBsYWNlKC9cXFxcL1teL10qJC8sICcvJyk7XFxuICAgIHNsYXNoID0gJy8nO1xcbiAgfVxcblxcbiAgZnVuY3Rpb24gaXNNb2NoYUludGVybmFsIChsaW5lKSB7XFxuICAgIHJldHVybiAofmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhJyArIHNsYXNoKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignbm9kZV9tb2R1bGVzJyArIHNsYXNoICsgJ21vY2hhLmpzJykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJ2Jvd2VyX2NvbXBvbmVudHMnICsgc2xhc2ggKyAnbW9jaGEuanMnKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZihzbGFzaCArICdtb2NoYS5qcycpKTtcXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIGlzTm9kZUludGVybmFsIChsaW5lKSB7XFxuICAgIHJldHVybiAofmxpbmUuaW5kZXhPZignKHRpbWVycy5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignKGV2ZW50cy5qczonKSkgfHxcXG4gICAgICAofmxpbmUuaW5kZXhPZignKG5vZGUuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJyhtb2R1bGUuanM6JykpIHx8XFxuICAgICAgKH5saW5lLmluZGV4T2YoJ0dlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLm5leHQgKG5hdGl2ZSknKSkgfHxcXG4gICAgICBmYWxzZTtcXG4gIH1cXG5cXG4gIHJldHVybiBmdW5jdGlvbiAoc3RhY2spIHtcXG4gICAgc3RhY2sgPSBzdGFjay5zcGxpdCgnXFxcXG4nKTtcXG5cXG4gICAgc3RhY2sgPSBzdGFjay5yZWR1Y2UoZnVuY3Rpb24gKGxpc3QsIGxpbmUpIHtcXG4gICAgICBpZiAoaXNNb2NoYUludGVybmFsKGxpbmUpKSB7XFxuICAgICAgICByZXR1cm4gbGlzdDtcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKGlzLm5vZGUgJiYgaXNOb2RlSW50ZXJuYWwobGluZSkpIHtcXG4gICAgICAgIHJldHVybiBsaXN0O1xcbiAgICAgIH1cXG5cXG4gICAgICAvLyBDbGVhbiB1cCBjd2QoYWJzb2x1dGUpXFxuICAgICAgaWYgKC9cXFxcKD8uKzpcXFxcZCs6XFxcXGQrXFxcXCk/JC8udGVzdChsaW5lKSkge1xcbiAgICAgICAgbGluZSA9IGxpbmUucmVwbGFjZSgnKCcgKyBjd2QsICcoJyk7XFxuICAgICAgfVxcblxcbiAgICAgIGxpc3QucHVzaChsaW5lKTtcXG4gICAgICByZXR1cm4gbGlzdDtcXG4gICAgfSwgW10pO1xcblxcbiAgICByZXR1cm4gc3RhY2suam9pbignXFxcXG4nKTtcXG4gIH07XFxufTtcXG5cXG4vKipcXG4gKiBDcnVkZSwgYnV0IGVmZmVjdGl2ZS5cXG4gKiBAYXBpXFxuICogQHBhcmFtIHsqfSB2YWx1ZVxcbiAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCBgdmFsdWVgIGlzIGEgUHJvbWlzZVxcbiAqL1xcbmV4cG9ydHMuaXNQcm9taXNlID0gZnVuY3Rpb24gaXNQcm9taXNlICh2YWx1ZSkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlLnRoZW4gPT09ICdmdW5jdGlvbic7XFxufTtcXG5cXG4vKipcXG4gKiBJdCdzIGEgbm9vcC5cXG4gKiBAYXBpXFxuICovXFxuZXhwb3J0cy5ub29wID0gZnVuY3Rpb24gKCkge307XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykscmVxdWlyZShcXFwiYnVmZmVyXFxcIikuQnVmZmVyKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImJ1ZmZlclxcXCI6NDEsXFxcImRlYnVnXFxcIjo0MyxcXFwiZnNcXFwiOjQwLFxcXCJnbG9iXFxcIjo0MCxcXFwiaGVcXFwiOjQ4LFxcXCJwYXRoXFxcIjo0MCxcXFwidXRpbFxcXCI6NzZ9XSwzNzpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnXFxuXFxuZXhwb3J0cy5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxcbmV4cG9ydHMudG9CeXRlQXJyYXkgPSB0b0J5dGVBcnJheVxcbmV4cG9ydHMuZnJvbUJ5dGVBcnJheSA9IGZyb21CeXRlQXJyYXlcXG5cXG52YXIgbG9va3VwID0gW11cXG52YXIgcmV2TG9va3VwID0gW11cXG52YXIgQXJyID0gdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnID8gVWludDhBcnJheSA6IEFycmF5XFxuXFxudmFyIGNvZGUgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLydcXG5mb3IgKHZhciBpID0gMCwgbGVuID0gY29kZS5sZW5ndGg7IGkgPCBsZW47ICsraSkge1xcbiAgbG9va3VwW2ldID0gY29kZVtpXVxcbiAgcmV2TG9va3VwW2NvZGUuY2hhckNvZGVBdChpKV0gPSBpXFxufVxcblxcbnJldkxvb2t1cFsnLScuY2hhckNvZGVBdCgwKV0gPSA2MlxcbnJldkxvb2t1cFsnXycuY2hhckNvZGVBdCgwKV0gPSA2M1xcblxcbmZ1bmN0aW9uIHBsYWNlSG9sZGVyc0NvdW50IChiNjQpIHtcXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXFxuICBpZiAobGVuICUgNCA+IDApIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHN0cmluZy4gTGVuZ3RoIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA0JylcXG4gIH1cXG5cXG4gIC8vIHRoZSBudW1iZXIgb2YgZXF1YWwgc2lnbnMgKHBsYWNlIGhvbGRlcnMpXFxuICAvLyBpZiB0aGVyZSBhcmUgdHdvIHBsYWNlaG9sZGVycywgdGhhbiB0aGUgdHdvIGNoYXJhY3RlcnMgYmVmb3JlIGl0XFxuICAvLyByZXByZXNlbnQgb25lIGJ5dGVcXG4gIC8vIGlmIHRoZXJlIGlzIG9ubHkgb25lLCB0aGVuIHRoZSB0aHJlZSBjaGFyYWN0ZXJzIGJlZm9yZSBpdCByZXByZXNlbnQgMiBieXRlc1xcbiAgLy8gdGhpcyBpcyBqdXN0IGEgY2hlYXAgaGFjayB0byBub3QgZG8gaW5kZXhPZiB0d2ljZVxcbiAgcmV0dXJuIGI2NFtsZW4gLSAyXSA9PT0gJz0nID8gMiA6IGI2NFtsZW4gLSAxXSA9PT0gJz0nID8gMSA6IDBcXG59XFxuXFxuZnVuY3Rpb24gYnl0ZUxlbmd0aCAoYjY0KSB7XFxuICAvLyBiYXNlNjQgaXMgNC8zICsgdXAgdG8gdHdvIGNoYXJhY3RlcnMgb2YgdGhlIG9yaWdpbmFsIGRhdGFcXG4gIHJldHVybiAoYjY0Lmxlbmd0aCAqIDMgLyA0KSAtIHBsYWNlSG9sZGVyc0NvdW50KGI2NClcXG59XFxuXFxuZnVuY3Rpb24gdG9CeXRlQXJyYXkgKGI2NCkge1xcbiAgdmFyIGksIGwsIHRtcCwgcGxhY2VIb2xkZXJzLCBhcnJcXG4gIHZhciBsZW4gPSBiNjQubGVuZ3RoXFxuICBwbGFjZUhvbGRlcnMgPSBwbGFjZUhvbGRlcnNDb3VudChiNjQpXFxuXFxuICBhcnIgPSBuZXcgQXJyKChsZW4gKiAzIC8gNCkgLSBwbGFjZUhvbGRlcnMpXFxuXFxuICAvLyBpZiB0aGVyZSBhcmUgcGxhY2Vob2xkZXJzLCBvbmx5IGdldCB1cCB0byB0aGUgbGFzdCBjb21wbGV0ZSA0IGNoYXJzXFxuICBsID0gcGxhY2VIb2xkZXJzID4gMCA/IGxlbiAtIDQgOiBsZW5cXG5cXG4gIHZhciBMID0gMFxcblxcbiAgZm9yIChpID0gMDsgaSA8IGw7IGkgKz0gNCkge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxOCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgMTIpIHwgKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpICsgMildIDw8IDYpIHwgcmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAzKV1cXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDE2KSAmIDB4RkZcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIGlmIChwbGFjZUhvbGRlcnMgPT09IDIpIHtcXG4gICAgdG1wID0gKHJldkxvb2t1cFtiNjQuY2hhckNvZGVBdChpKV0gPDwgMikgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPj4gNClcXG4gICAgYXJyW0wrK10gPSB0bXAgJiAweEZGXFxuICB9IGVsc2UgaWYgKHBsYWNlSG9sZGVycyA9PT0gMSkge1xcbiAgICB0bXAgPSAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkpXSA8PCAxMCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAxKV0gPDwgNCkgfCAocmV2TG9va3VwW2I2NC5jaGFyQ29kZUF0KGkgKyAyKV0gPj4gMilcXG4gICAgYXJyW0wrK10gPSAodG1wID4+IDgpICYgMHhGRlxcbiAgICBhcnJbTCsrXSA9IHRtcCAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBhcnJcXG59XFxuXFxuZnVuY3Rpb24gdHJpcGxldFRvQmFzZTY0IChudW0pIHtcXG4gIHJldHVybiBsb29rdXBbbnVtID4+IDE4ICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDEyICYgMHgzRl0gKyBsb29rdXBbbnVtID4+IDYgJiAweDNGXSArIGxvb2t1cFtudW0gJiAweDNGXVxcbn1cXG5cXG5mdW5jdGlvbiBlbmNvZGVDaHVuayAodWludDgsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBvdXRwdXQgPSBbXVxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IDMpIHtcXG4gICAgdG1wID0gKHVpbnQ4W2ldIDw8IDE2KSArICh1aW50OFtpICsgMV0gPDwgOCkgKyAodWludDhbaSArIDJdKVxcbiAgICBvdXRwdXQucHVzaCh0cmlwbGV0VG9CYXNlNjQodG1wKSlcXG4gIH1cXG4gIHJldHVybiBvdXRwdXQuam9pbignJylcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUJ5dGVBcnJheSAodWludDgpIHtcXG4gIHZhciB0bXBcXG4gIHZhciBsZW4gPSB1aW50OC5sZW5ndGhcXG4gIHZhciBleHRyYUJ5dGVzID0gbGVuICUgMyAvLyBpZiB3ZSBoYXZlIDEgYnl0ZSBsZWZ0LCBwYWQgMiBieXRlc1xcbiAgdmFyIG91dHB1dCA9ICcnXFxuICB2YXIgcGFydHMgPSBbXVxcbiAgdmFyIG1heENodW5rTGVuZ3RoID0gMTYzODMgLy8gbXVzdCBiZSBtdWx0aXBsZSBvZiAzXFxuXFxuICAvLyBnbyB0aHJvdWdoIHRoZSBhcnJheSBldmVyeSB0aHJlZSBieXRlcywgd2UnbGwgZGVhbCB3aXRoIHRyYWlsaW5nIHN0dWZmIGxhdGVyXFxuICBmb3IgKHZhciBpID0gMCwgbGVuMiA9IGxlbiAtIGV4dHJhQnl0ZXM7IGkgPCBsZW4yOyBpICs9IG1heENodW5rTGVuZ3RoKSB7XFxuICAgIHBhcnRzLnB1c2goZW5jb2RlQ2h1bmsodWludDgsIGksIChpICsgbWF4Q2h1bmtMZW5ndGgpID4gbGVuMiA/IGxlbjIgOiAoaSArIG1heENodW5rTGVuZ3RoKSkpXFxuICB9XFxuXFxuICAvLyBwYWQgdGhlIGVuZCB3aXRoIHplcm9zLCBidXQgbWFrZSBzdXJlIHRvIG5vdCBmb3JnZXQgdGhlIGV4dHJhIGJ5dGVzXFxuICBpZiAoZXh0cmFCeXRlcyA9PT0gMSkge1xcbiAgICB0bXAgPSB1aW50OFtsZW4gLSAxXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwW3RtcCA+PiAyXVxcbiAgICBvdXRwdXQgKz0gbG9va3VwWyh0bXAgPDwgNCkgJiAweDNGXVxcbiAgICBvdXRwdXQgKz0gJz09J1xcbiAgfSBlbHNlIGlmIChleHRyYUJ5dGVzID09PSAyKSB7XFxuICAgIHRtcCA9ICh1aW50OFtsZW4gLSAyXSA8PCA4KSArICh1aW50OFtsZW4gLSAxXSlcXG4gICAgb3V0cHV0ICs9IGxvb2t1cFt0bXAgPj4gMTBdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA+PiA0KSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSBsb29rdXBbKHRtcCA8PCAyKSAmIDB4M0ZdXFxuICAgIG91dHB1dCArPSAnPSdcXG4gIH1cXG5cXG4gIHBhcnRzLnB1c2gob3V0cHV0KVxcblxcbiAgcmV0dXJuIHBhcnRzLmpvaW4oJycpXFxufVxcblxcbn0se31dLDM4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG59LHt9XSwzOTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG52YXIgV3JpdGFibGVTdHJlYW0gPSByZXF1aXJlKCdzdHJlYW0nKS5Xcml0YWJsZVxcbnZhciBpbmhlcml0cyA9IHJlcXVpcmUoJ3V0aWwnKS5pbmhlcml0c1xcblxcbm1vZHVsZS5leHBvcnRzID0gQnJvd3NlclN0ZG91dFxcblxcblxcbmluaGVyaXRzKEJyb3dzZXJTdGRvdXQsIFdyaXRhYmxlU3RyZWFtKVxcblxcbmZ1bmN0aW9uIEJyb3dzZXJTdGRvdXQob3B0cykge1xcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEJyb3dzZXJTdGRvdXQpKSByZXR1cm4gbmV3IEJyb3dzZXJTdGRvdXQob3B0cylcXG5cXG4gIG9wdHMgPSBvcHRzIHx8IHt9XFxuICBXcml0YWJsZVN0cmVhbS5jYWxsKHRoaXMsIG9wdHMpXFxuICB0aGlzLmxhYmVsID0gKG9wdHMubGFiZWwgIT09IHVuZGVmaW5lZCkgPyBvcHRzLmxhYmVsIDogJ3N0ZG91dCdcXG59XFxuXFxuQnJvd3NlclN0ZG91dC5wcm90b3R5cGUuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmtzLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBvdXRwdXQgPSBjaHVua3MudG9TdHJpbmcgPyBjaHVua3MudG9TdHJpbmcoKSA6IGNodW5rc1xcbiAgaWYgKHRoaXMubGFiZWwgPT09IGZhbHNlKSB7XFxuICAgIGNvbnNvbGUubG9nKG91dHB1dClcXG4gIH0gZWxzZSB7XFxuICAgIGNvbnNvbGUubG9nKHRoaXMubGFiZWwrJzonLCBvdXRwdXQpXFxuICB9XFxuICBwcm9jZXNzLm5leHRUaWNrKGNiKVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiX3Byb2Nlc3NcXFwiOjU2LFxcXCJzdHJlYW1cXFwiOjcxLFxcXCJ1dGlsXFxcIjo3Nn1dLDQwOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5hcmd1bWVudHNbNF1bMzhdWzBdLmFwcGx5KGV4cG9ydHMsYXJndW1lbnRzKVxcbn0se1xcXCJkdXBcXFwiOjM4fV0sNDE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIVxcbiAqIFRoZSBidWZmZXIgbW9kdWxlIGZyb20gbm9kZS5qcywgZm9yIHRoZSBicm93c2VyLlxcbiAqXFxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGZlcm9zc0BmZXJvc3Mub3JnPiA8aHR0cDovL2Zlcm9zcy5vcmc+XFxuICogQGxpY2Vuc2UgIE1JVFxcbiAqL1xcbi8qIGVzbGludC1kaXNhYmxlIG5vLXByb3RvICovXFxuXFxuJ3VzZSBzdHJpY3QnXFxuXFxudmFyIGJhc2U2NCA9IHJlcXVpcmUoJ2Jhc2U2NC1qcycpXFxudmFyIGllZWU3NTQgPSByZXF1aXJlKCdpZWVlNzU0JylcXG5cXG5leHBvcnRzLkJ1ZmZlciA9IEJ1ZmZlclxcbmV4cG9ydHMuU2xvd0J1ZmZlciA9IFNsb3dCdWZmZXJcXG5leHBvcnRzLklOU1BFQ1RfTUFYX0JZVEVTID0gNTBcXG5cXG52YXIgS19NQVhfTEVOR1RIID0gMHg3ZmZmZmZmZlxcbmV4cG9ydHMua01heExlbmd0aCA9IEtfTUFYX0xFTkdUSFxcblxcbi8qKlxcbiAqIElmIGBCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVGA6XFxuICogICA9PT0gdHJ1ZSAgICBVc2UgVWludDhBcnJheSBpbXBsZW1lbnRhdGlvbiAoZmFzdGVzdClcXG4gKiAgID09PSBmYWxzZSAgIFByaW50IHdhcm5pbmcgYW5kIHJlY29tbWVuZCB1c2luZyBgYnVmZmVyYCB2NC54IHdoaWNoIGhhcyBhbiBPYmplY3RcXG4gKiAgICAgICAgICAgICAgIGltcGxlbWVudGF0aW9uIChtb3N0IGNvbXBhdGlibGUsIGV2ZW4gSUU2KVxcbiAqXFxuICogQnJvd3NlcnMgdGhhdCBzdXBwb3J0IHR5cGVkIGFycmF5cyBhcmUgSUUgMTArLCBGaXJlZm94IDQrLCBDaHJvbWUgNyssIFNhZmFyaSA1LjErLFxcbiAqIE9wZXJhIDExLjYrLCBpT1MgNC4yKy5cXG4gKlxcbiAqIFdlIHJlcG9ydCB0aGF0IHRoZSBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgdHlwZWQgYXJyYXlzIGlmIHRoZSBhcmUgbm90IHN1YmNsYXNzYWJsZVxcbiAqIHVzaW5nIF9fcHJvdG9fXy4gRmlyZWZveCA0LTI5IGxhY2tzIHN1cHBvcnQgZm9yIGFkZGluZyBuZXcgcHJvcGVydGllcyB0byBgVWludDhBcnJheWBcXG4gKiAoU2VlOiBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02OTU0MzgpLiBJRSAxMCBsYWNrcyBzdXBwb3J0XFxuICogZm9yIF9fcHJvdG9fXyBhbmQgaGFzIGEgYnVnZ3kgdHlwZWQgYXJyYXkgaW1wbGVtZW50YXRpb24uXFxuICovXFxuQnVmZmVyLlRZUEVEX0FSUkFZX1NVUFBPUlQgPSB0eXBlZEFycmF5U3VwcG9ydCgpXFxuXFxuaWYgKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcgJiZcXG4gICAgdHlwZW9mIGNvbnNvbGUuZXJyb3IgPT09ICdmdW5jdGlvbicpIHtcXG4gIGNvbnNvbGUuZXJyb3IoXFxuICAgICdUaGlzIGJyb3dzZXIgbGFja3MgdHlwZWQgYXJyYXkgKFVpbnQ4QXJyYXkpIHN1cHBvcnQgd2hpY2ggaXMgcmVxdWlyZWQgYnkgJyArXFxuICAgICdgYnVmZmVyYCB2NS54LiBVc2UgYGJ1ZmZlcmAgdjQueCBpZiB5b3UgcmVxdWlyZSBvbGQgYnJvd3NlciBzdXBwb3J0LidcXG4gIClcXG59XFxuXFxuZnVuY3Rpb24gdHlwZWRBcnJheVN1cHBvcnQgKCkge1xcbiAgLy8gQ2FuIHR5cGVkIGFycmF5IGluc3RhbmNlcyBjYW4gYmUgYXVnbWVudGVkP1xcbiAgdHJ5IHtcXG4gICAgdmFyIGFyciA9IG5ldyBVaW50OEFycmF5KDEpXFxuICAgIGFyci5fX3Byb3RvX18gPSB7X19wcm90b19fOiBVaW50OEFycmF5LnByb3RvdHlwZSwgZm9vOiBmdW5jdGlvbiAoKSB7IHJldHVybiA0MiB9fVxcbiAgICByZXR1cm4gYXJyLmZvbygpID09PSA0MlxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICByZXR1cm4gZmFsc2VcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gY3JlYXRlQnVmZmVyIChsZW5ndGgpIHtcXG4gIGlmIChsZW5ndGggPiBLX01BWF9MRU5HVEgpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ0ludmFsaWQgdHlwZWQgYXJyYXkgbGVuZ3RoJylcXG4gIH1cXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXFxuICB2YXIgYnVmID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKVxcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBidWZcXG59XFxuXFxuLyoqXFxuICogVGhlIEJ1ZmZlciBjb25zdHJ1Y3RvciByZXR1cm5zIGluc3RhbmNlcyBvZiBgVWludDhBcnJheWAgdGhhdCBoYXZlIHRoZWlyXFxuICogcHJvdG90eXBlIGNoYW5nZWQgdG8gYEJ1ZmZlci5wcm90b3R5cGVgLiBGdXJ0aGVybW9yZSwgYEJ1ZmZlcmAgaXMgYSBzdWJjbGFzcyBvZlxcbiAqIGBVaW50OEFycmF5YCwgc28gdGhlIHJldHVybmVkIGluc3RhbmNlcyB3aWxsIGhhdmUgYWxsIHRoZSBub2RlIGBCdWZmZXJgIG1ldGhvZHNcXG4gKiBhbmQgdGhlIGBVaW50OEFycmF5YCBtZXRob2RzLiBTcXVhcmUgYnJhY2tldCBub3RhdGlvbiB3b3JrcyBhcyBleHBlY3RlZCAtLSBpdFxcbiAqIHJldHVybnMgYSBzaW5nbGUgb2N0ZXQuXFxuICpcXG4gKiBUaGUgYFVpbnQ4QXJyYXlgIHByb3RvdHlwZSByZW1haW5zIHVubW9kaWZpZWQuXFxuICovXFxuXFxuZnVuY3Rpb24gQnVmZmVyIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgLy8gQ29tbW9uIGNhc2UuXFxuICBpZiAodHlwZW9mIGFyZyA9PT0gJ251bWJlcicpIHtcXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZ09yT2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICAgIHRocm93IG5ldyBFcnJvcihcXG4gICAgICAgICdJZiBlbmNvZGluZyBpcyBzcGVjaWZpZWQgdGhlbiB0aGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBhIHN0cmluZydcXG4gICAgICApXFxuICAgIH1cXG4gICAgcmV0dXJuIGFsbG9jVW5zYWZlKGFyZylcXG4gIH1cXG4gIHJldHVybiBmcm9tKGFyZywgZW5jb2RpbmdPck9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG4vLyBGaXggc3ViYXJyYXkoKSBpbiBFUzIwMTYuIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2Zlcm9zcy9idWZmZXIvcHVsbC85N1xcbmlmICh0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wuc3BlY2llcyAmJlxcbiAgICBCdWZmZXJbU3ltYm9sLnNwZWNpZXNdID09PSBCdWZmZXIpIHtcXG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIsIFN5bWJvbC5zcGVjaWVzLCB7XFxuICAgIHZhbHVlOiBudWxsLFxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICB3cml0YWJsZTogZmFsc2VcXG4gIH0pXFxufVxcblxcbkJ1ZmZlci5wb29sU2l6ZSA9IDgxOTIgLy8gbm90IHVzZWQgYnkgdGhpcyBpbXBsZW1lbnRhdGlvblxcblxcbmZ1bmN0aW9uIGZyb20gKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJ2YWx1ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgYSBudW1iZXInKVxcbiAgfVxcblxcbiAgaWYgKGlzQXJyYXlCdWZmZXIodmFsdWUpKSB7XFxuICAgIHJldHVybiBmcm9tQXJyYXlCdWZmZXIodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG4gIH1cXG5cXG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XFxuICAgIHJldHVybiBmcm9tU3RyaW5nKHZhbHVlLCBlbmNvZGluZ09yT2Zmc2V0KVxcbiAgfVxcblxcbiAgcmV0dXJuIGZyb21PYmplY3QodmFsdWUpXFxufVxcblxcbi8qKlxcbiAqIEZ1bmN0aW9uYWxseSBlcXVpdmFsZW50IHRvIEJ1ZmZlcihhcmcsIGVuY29kaW5nKSBidXQgdGhyb3dzIGEgVHlwZUVycm9yXFxuICogaWYgdmFsdWUgaXMgYSBudW1iZXIuXFxuICogQnVmZmVyLmZyb20oc3RyWywgZW5jb2RpbmddKVxcbiAqIEJ1ZmZlci5mcm9tKGFycmF5KVxcbiAqIEJ1ZmZlci5mcm9tKGJ1ZmZlcilcXG4gKiBCdWZmZXIuZnJvbShhcnJheUJ1ZmZlclssIGJ5dGVPZmZzZXRbLCBsZW5ndGhdXSlcXG4gKiovXFxuQnVmZmVyLmZyb20gPSBmdW5jdGlvbiAodmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgcmV0dXJuIGZyb20odmFsdWUsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuLy8gTm90ZTogQ2hhbmdlIHByb3RvdHlwZSAqYWZ0ZXIqIEJ1ZmZlci5mcm9tIGlzIGRlZmluZWQgdG8gd29ya2Fyb3VuZCBDaHJvbWUgYnVnOlxcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL3B1bGwvMTQ4XFxuQnVmZmVyLnByb3RvdHlwZS5fX3Byb3RvX18gPSBVaW50OEFycmF5LnByb3RvdHlwZVxcbkJ1ZmZlci5fX3Byb3RvX18gPSBVaW50OEFycmF5XFxuXFxuZnVuY3Rpb24gYXNzZXJ0U2l6ZSAoc2l6ZSkge1xcbiAgaWYgKHR5cGVvZiBzaXplICE9PSAnbnVtYmVyJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwic2l6ZVxcXCIgYXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9IGVsc2UgaWYgKHNpemUgPCAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdcXFwic2l6ZVxcXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgbmVnYXRpdmUnKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhbGxvYyAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIGFzc2VydFNpemUoc2l6ZSlcXG4gIGlmIChzaXplIDw9IDApIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUJ1ZmZlcihzaXplKVxcbiAgfVxcbiAgaWYgKGZpbGwgIT09IHVuZGVmaW5lZCkge1xcbiAgICAvLyBPbmx5IHBheSBhdHRlbnRpb24gdG8gZW5jb2RpbmcgaWYgaXQncyBhIHN0cmluZy4gVGhpc1xcbiAgICAvLyBwcmV2ZW50cyBhY2NpZGVudGFsbHkgc2VuZGluZyBpbiBhIG51bWJlciB0aGF0IHdvdWxkXFxuICAgIC8vIGJlIGludGVycHJldHRlZCBhcyBhIHN0YXJ0IG9mZnNldC5cXG4gICAgcmV0dXJuIHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZydcXG4gICAgICA/IGNyZWF0ZUJ1ZmZlcihzaXplKS5maWxsKGZpbGwsIGVuY29kaW5nKVxcbiAgICAgIDogY3JlYXRlQnVmZmVyKHNpemUpLmZpbGwoZmlsbClcXG4gIH1cXG4gIHJldHVybiBjcmVhdGVCdWZmZXIoc2l6ZSlcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlcyBhIG5ldyBmaWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqIGFsbG9jKHNpemVbLCBmaWxsWywgZW5jb2RpbmddXSlcXG4gKiovXFxuQnVmZmVyLmFsbG9jID0gZnVuY3Rpb24gKHNpemUsIGZpbGwsIGVuY29kaW5nKSB7XFxuICByZXR1cm4gYWxsb2Moc2l6ZSwgZmlsbCwgZW5jb2RpbmcpXFxufVxcblxcbmZ1bmN0aW9uIGFsbG9jVW5zYWZlIChzaXplKSB7XFxuICBhc3NlcnRTaXplKHNpemUpXFxuICByZXR1cm4gY3JlYXRlQnVmZmVyKHNpemUgPCAwID8gMCA6IGNoZWNrZWQoc2l6ZSkgfCAwKVxcbn1cXG5cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIEJ1ZmZlcihudW0pLCBieSBkZWZhdWx0IGNyZWF0ZXMgYSBub24temVyby1maWxsZWQgQnVmZmVyIGluc3RhbmNlLlxcbiAqICovXFxuQnVmZmVyLmFsbG9jVW5zYWZlID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxcbn1cXG4vKipcXG4gKiBFcXVpdmFsZW50IHRvIFNsb3dCdWZmZXIobnVtKSwgYnkgZGVmYXVsdCBjcmVhdGVzIGEgbm9uLXplcm8tZmlsbGVkIEJ1ZmZlciBpbnN0YW5jZS5cXG4gKi9cXG5CdWZmZXIuYWxsb2NVbnNhZmVTbG93ID0gZnVuY3Rpb24gKHNpemUpIHtcXG4gIHJldHVybiBhbGxvY1Vuc2FmZShzaXplKVxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tU3RyaW5nIChzdHJpbmcsIGVuY29kaW5nKSB7XFxuICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnc3RyaW5nJyB8fCBlbmNvZGluZyA9PT0gJycpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gIH1cXG5cXG4gIGlmICghQnVmZmVyLmlzRW5jb2RpbmcoZW5jb2RpbmcpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJlbmNvZGluZ1xcXCIgbXVzdCBiZSBhIHZhbGlkIHN0cmluZyBlbmNvZGluZycpXFxuICB9XFxuXFxuICB2YXIgbGVuZ3RoID0gYnl0ZUxlbmd0aChzdHJpbmcsIGVuY29kaW5nKSB8IDBcXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxcblxcbiAgdmFyIGFjdHVhbCA9IGJ1Zi53cml0ZShzdHJpbmcsIGVuY29kaW5nKVxcblxcbiAgaWYgKGFjdHVhbCAhPT0gbGVuZ3RoKSB7XFxuICAgIC8vIFdyaXRpbmcgYSBoZXggc3RyaW5nLCBmb3IgZXhhbXBsZSwgdGhhdCBjb250YWlucyBpbnZhbGlkIGNoYXJhY3RlcnMgd2lsbFxcbiAgICAvLyBjYXVzZSBldmVyeXRoaW5nIGFmdGVyIHRoZSBmaXJzdCBpbnZhbGlkIGNoYXJhY3RlciB0byBiZSBpZ25vcmVkLiAoZS5nLlxcbiAgICAvLyAnYWJ4eGNkJyB3aWxsIGJlIHRyZWF0ZWQgYXMgJ2FiJylcXG4gICAgYnVmID0gYnVmLnNsaWNlKDAsIGFjdHVhbClcXG4gIH1cXG5cXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gZnJvbUFycmF5TGlrZSAoYXJyYXkpIHtcXG4gIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGggPCAwID8gMCA6IGNoZWNrZWQoYXJyYXkubGVuZ3RoKSB8IDBcXG4gIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuZ3RoKVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkgKz0gMSkge1xcbiAgICBidWZbaV0gPSBhcnJheVtpXSAmIDI1NVxcbiAgfVxcbiAgcmV0dXJuIGJ1Zlxcbn1cXG5cXG5mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIgKGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGlmIChieXRlT2Zmc2V0IDwgMCB8fCBhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcXCdvZmZzZXRcXFxcJyBpcyBvdXQgb2YgYm91bmRzJylcXG4gIH1cXG5cXG4gIGlmIChhcnJheS5ieXRlTGVuZ3RoIDwgYnl0ZU9mZnNldCArIChsZW5ndGggfHwgMCkpIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1xcXFwnbGVuZ3RoXFxcXCcgaXMgb3V0IG9mIGJvdW5kcycpXFxuICB9XFxuXFxuICB2YXIgYnVmXFxuICBpZiAoYnl0ZU9mZnNldCA9PT0gdW5kZWZpbmVkICYmIGxlbmd0aCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5KVxcbiAgfSBlbHNlIGlmIChsZW5ndGggPT09IHVuZGVmaW5lZCkge1xcbiAgICBidWYgPSBuZXcgVWludDhBcnJheShhcnJheSwgYnl0ZU9mZnNldClcXG4gIH0gZWxzZSB7XFxuICAgIGJ1ZiA9IG5ldyBVaW50OEFycmF5KGFycmF5LCBieXRlT2Zmc2V0LCBsZW5ndGgpXFxuICB9XFxuXFxuICAvLyBSZXR1cm4gYW4gYXVnbWVudGVkIGBVaW50OEFycmF5YCBpbnN0YW5jZVxcbiAgYnVmLl9fcHJvdG9fXyA9IEJ1ZmZlci5wcm90b3R5cGVcXG4gIHJldHVybiBidWZcXG59XFxuXFxuZnVuY3Rpb24gZnJvbU9iamVjdCAob2JqKSB7XFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKG9iaikpIHtcXG4gICAgdmFyIGxlbiA9IGNoZWNrZWQob2JqLmxlbmd0aCkgfCAwXFxuICAgIHZhciBidWYgPSBjcmVhdGVCdWZmZXIobGVuKVxcblxcbiAgICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiBidWZcXG4gICAgfVxcblxcbiAgICBvYmouY29weShidWYsIDAsIDAsIGxlbilcXG4gICAgcmV0dXJuIGJ1ZlxcbiAgfVxcblxcbiAgaWYgKG9iaikge1xcbiAgICBpZiAoaXNBcnJheUJ1ZmZlclZpZXcob2JqKSB8fCAnbGVuZ3RoJyBpbiBvYmopIHtcXG4gICAgICBpZiAodHlwZW9mIG9iai5sZW5ndGggIT09ICdudW1iZXInIHx8IG51bWJlcklzTmFOKG9iai5sZW5ndGgpKSB7XFxuICAgICAgICByZXR1cm4gY3JlYXRlQnVmZmVyKDApXFxuICAgICAgfVxcbiAgICAgIHJldHVybiBmcm9tQXJyYXlMaWtlKG9iailcXG4gICAgfVxcblxcbiAgICBpZiAob2JqLnR5cGUgPT09ICdCdWZmZXInICYmIEFycmF5LmlzQXJyYXkob2JqLmRhdGEpKSB7XFxuICAgICAgcmV0dXJuIGZyb21BcnJheUxpa2Uob2JqLmRhdGEpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ZpcnN0IGFyZ3VtZW50IG11c3QgYmUgYSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBvciBhcnJheS1saWtlIG9iamVjdC4nKVxcbn1cXG5cXG5mdW5jdGlvbiBjaGVja2VkIChsZW5ndGgpIHtcXG4gIC8vIE5vdGU6IGNhbm5vdCB1c2UgYGxlbmd0aCA8IEtfTUFYX0xFTkdUSGAgaGVyZSBiZWNhdXNlIHRoYXQgZmFpbHMgd2hlblxcbiAgLy8gbGVuZ3RoIGlzIE5hTiAod2hpY2ggaXMgb3RoZXJ3aXNlIGNvZXJjZWQgdG8gemVyby4pXFxuICBpZiAobGVuZ3RoID49IEtfTUFYX0xFTkdUSCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQXR0ZW1wdCB0byBhbGxvY2F0ZSBCdWZmZXIgbGFyZ2VyIHRoYW4gbWF4aW11bSAnICtcXG4gICAgICAgICAgICAgICAgICAgICAgICAgJ3NpemU6IDB4JyArIEtfTUFYX0xFTkdUSC50b1N0cmluZygxNikgKyAnIGJ5dGVzJylcXG4gIH1cXG4gIHJldHVybiBsZW5ndGggfCAwXFxufVxcblxcbmZ1bmN0aW9uIFNsb3dCdWZmZXIgKGxlbmd0aCkge1xcbiAgaWYgKCtsZW5ndGggIT0gbGVuZ3RoKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZXFlcWVxXFxuICAgIGxlbmd0aCA9IDBcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIuYWxsb2MoK2xlbmd0aClcXG59XFxuXFxuQnVmZmVyLmlzQnVmZmVyID0gZnVuY3Rpb24gaXNCdWZmZXIgKGIpIHtcXG4gIHJldHVybiBiICE9IG51bGwgJiYgYi5faXNCdWZmZXIgPT09IHRydWVcXG59XFxuXFxuQnVmZmVyLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlIChhLCBiKSB7XFxuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihhKSB8fCAhQnVmZmVyLmlzQnVmZmVyKGIpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyBtdXN0IGJlIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGEgPT09IGIpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IGEubGVuZ3RoXFxuICB2YXIgeSA9IGIubGVuZ3RoXFxuXFxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gTWF0aC5taW4oeCwgeSk7IGkgPCBsZW47ICsraSkge1xcbiAgICBpZiAoYVtpXSAhPT0gYltpXSkge1xcbiAgICAgIHggPSBhW2ldXFxuICAgICAgeSA9IGJbaV1cXG4gICAgICBicmVha1xcbiAgICB9XFxuICB9XFxuXFxuICBpZiAoeCA8IHkpIHJldHVybiAtMVxcbiAgaWYgKHkgPCB4KSByZXR1cm4gMVxcbiAgcmV0dXJuIDBcXG59XFxuXFxuQnVmZmVyLmlzRW5jb2RpbmcgPSBmdW5jdGlvbiBpc0VuY29kaW5nIChlbmNvZGluZykge1xcbiAgc3dpdGNoIChTdHJpbmcoZW5jb2RpbmcpLnRvTG93ZXJDYXNlKCkpIHtcXG4gICAgY2FzZSAnaGV4JzpcXG4gICAgY2FzZSAndXRmOCc6XFxuICAgIGNhc2UgJ3V0Zi04JzpcXG4gICAgY2FzZSAnYXNjaWknOlxcbiAgICBjYXNlICdsYXRpbjEnOlxcbiAgICBjYXNlICdiaW5hcnknOlxcbiAgICBjYXNlICdiYXNlNjQnOlxcbiAgICBjYXNlICd1Y3MyJzpcXG4gICAgY2FzZSAndWNzLTInOlxcbiAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgY2FzZSAndXRmLTE2bGUnOlxcbiAgICAgIHJldHVybiB0cnVlXFxuICAgIGRlZmF1bHQ6XFxuICAgICAgcmV0dXJuIGZhbHNlXFxuICB9XFxufVxcblxcbkJ1ZmZlci5jb25jYXQgPSBmdW5jdGlvbiBjb25jYXQgKGxpc3QsIGxlbmd0aCkge1xcbiAgaWYgKCFBcnJheS5pc0FycmF5KGxpc3QpKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJsaXN0XFxcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKVxcbiAgfVxcblxcbiAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XFxuICAgIHJldHVybiBCdWZmZXIuYWxsb2MoMClcXG4gIH1cXG5cXG4gIHZhciBpXFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQpIHtcXG4gICAgbGVuZ3RoID0gMFxcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICAgIGxlbmd0aCArPSBsaXN0W2ldLmxlbmd0aFxcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jVW5zYWZlKGxlbmd0aClcXG4gIHZhciBwb3MgPSAwXFxuICBmb3IgKGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7ICsraSkge1xcbiAgICB2YXIgYnVmID0gbGlzdFtpXVxcbiAgICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcihidWYpKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXFxcImxpc3RcXFwiIGFyZ3VtZW50IG11c3QgYmUgYW4gQXJyYXkgb2YgQnVmZmVycycpXFxuICAgIH1cXG4gICAgYnVmLmNvcHkoYnVmZmVyLCBwb3MpXFxuICAgIHBvcyArPSBidWYubGVuZ3RoXFxuICB9XFxuICByZXR1cm4gYnVmZmVyXFxufVxcblxcbmZ1bmN0aW9uIGJ5dGVMZW5ndGggKHN0cmluZywgZW5jb2RpbmcpIHtcXG4gIGlmIChCdWZmZXIuaXNCdWZmZXIoc3RyaW5nKSkge1xcbiAgICByZXR1cm4gc3RyaW5nLmxlbmd0aFxcbiAgfVxcbiAgaWYgKGlzQXJyYXlCdWZmZXJWaWV3KHN0cmluZykgfHwgaXNBcnJheUJ1ZmZlcihzdHJpbmcpKSB7XFxuICAgIHJldHVybiBzdHJpbmcuYnl0ZUxlbmd0aFxcbiAgfVxcbiAgaWYgKHR5cGVvZiBzdHJpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgIHN0cmluZyA9ICcnICsgc3RyaW5nXFxuICB9XFxuXFxuICB2YXIgbGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKGxlbiA9PT0gMCkgcmV0dXJuIDBcXG5cXG4gIC8vIFVzZSBhIGZvciBsb29wIHRvIGF2b2lkIHJlY3Vyc2lvblxcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG4gIGZvciAoOzspIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGVuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgIGNhc2UgdW5kZWZpbmVkOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhUb0J5dGVzKHN0cmluZykubGVuZ3RoXFxuICAgICAgY2FzZSAndWNzMic6XFxuICAgICAgY2FzZSAndWNzLTInOlxcbiAgICAgIGNhc2UgJ3V0ZjE2bGUnOlxcbiAgICAgIGNhc2UgJ3V0Zi0xNmxlJzpcXG4gICAgICAgIHJldHVybiBsZW4gKiAyXFxuICAgICAgY2FzZSAnaGV4JzpcXG4gICAgICAgIHJldHVybiBsZW4gPj4+IDFcXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgcmV0dXJuIGJhc2U2NFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGhcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKGxvd2VyZWRDYXNlKSByZXR1cm4gdXRmOFRvQnl0ZXMoc3RyaW5nKS5sZW5ndGggLy8gYXNzdW1lIHV0ZjhcXG4gICAgICAgIGVuY29kaW5nID0gKCcnICsgZW5jb2RpbmcpLnRvTG93ZXJDYXNlKClcXG4gICAgICAgIGxvd2VyZWRDYXNlID0gdHJ1ZVxcbiAgICB9XFxuICB9XFxufVxcbkJ1ZmZlci5ieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aFxcblxcbmZ1bmN0aW9uIHNsb3dUb1N0cmluZyAoZW5jb2RpbmcsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsb3dlcmVkQ2FzZSA9IGZhbHNlXFxuXFxuICAvLyBObyBuZWVkIHRvIHZlcmlmeSB0aGF0IFxcXCJ0aGlzLmxlbmd0aCA8PSBNQVhfVUlOVDMyXFxcIiBzaW5jZSBpdCdzIGEgcmVhZC1vbmx5XFxuICAvLyBwcm9wZXJ0eSBvZiBhIHR5cGVkIGFycmF5LlxcblxcbiAgLy8gVGhpcyBiZWhhdmVzIG5laXRoZXIgbGlrZSBTdHJpbmcgbm9yIFVpbnQ4QXJyYXkgaW4gdGhhdCB3ZSBzZXQgc3RhcnQvZW5kXFxuICAvLyB0byB0aGVpciB1cHBlci9sb3dlciBib3VuZHMgaWYgdGhlIHZhbHVlIHBhc3NlZCBpcyBvdXQgb2YgcmFuZ2UuXFxuICAvLyB1bmRlZmluZWQgaXMgaGFuZGxlZCBzcGVjaWFsbHkgYXMgcGVyIEVDTUEtMjYyIDZ0aCBFZGl0aW9uLFxcbiAgLy8gU2VjdGlvbiAxMy4zLjMuNyBSdW50aW1lIFNlbWFudGljczogS2V5ZWRCaW5kaW5nSW5pdGlhbGl6YXRpb24uXFxuICBpZiAoc3RhcnQgPT09IHVuZGVmaW5lZCB8fCBzdGFydCA8IDApIHtcXG4gICAgc3RhcnQgPSAwXFxuICB9XFxuICAvLyBSZXR1cm4gZWFybHkgaWYgc3RhcnQgPiB0aGlzLmxlbmd0aC4gRG9uZSBoZXJlIHRvIHByZXZlbnQgcG90ZW50aWFsIHVpbnQzMlxcbiAgLy8gY29lcmNpb24gZmFpbCBiZWxvdy5cXG4gIGlmIChzdGFydCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkIHx8IGVuZCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIGVuZCA9IHRoaXMubGVuZ3RoXFxuICB9XFxuXFxuICBpZiAoZW5kIDw9IDApIHtcXG4gICAgcmV0dXJuICcnXFxuICB9XFxuXFxuICAvLyBGb3JjZSBjb2Vyc2lvbiB0byB1aW50MzIuIFRoaXMgd2lsbCBhbHNvIGNvZXJjZSBmYWxzZXkvTmFOIHZhbHVlcyB0byAwLlxcbiAgZW5kID4+Pj0gMFxcbiAgc3RhcnQgPj4+PSAwXFxuXFxuICBpZiAoZW5kIDw9IHN0YXJ0KSB7XFxuICAgIHJldHVybiAnJ1xcbiAgfVxcblxcbiAgaWYgKCFlbmNvZGluZykgZW5jb2RpbmcgPSAndXRmOCdcXG5cXG4gIHdoaWxlICh0cnVlKSB7XFxuICAgIHN3aXRjaCAoZW5jb2RpbmcpIHtcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGhleFNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAndXRmOCc6XFxuICAgICAgY2FzZSAndXRmLTgnOlxcbiAgICAgICAgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICAgIHJldHVybiBhc2NpaVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnbGF0aW4xJzpcXG4gICAgICBjYXNlICdiaW5hcnknOlxcbiAgICAgICAgcmV0dXJuIGxhdGluMVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICAgIHJldHVybiBiYXNlNjRTbGljZSh0aGlzLCBzdGFydCwgZW5kKVxcblxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gdXRmMTZsZVNsaWNlKHRoaXMsIHN0YXJ0LCBlbmQpXFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICAgICAgZW5jb2RpbmcgPSAoZW5jb2RpbmcgKyAnJykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuLy8gVGhpcyBwcm9wZXJ0eSBpcyB1c2VkIGJ5IGBCdWZmZXIuaXNCdWZmZXJgIChhbmQgdGhlIGBpcy1idWZmZXJgIG5wbSBwYWNrYWdlKVxcbi8vIHRvIGRldGVjdCBhIEJ1ZmZlciBpbnN0YW5jZS4gSXQncyBub3QgcG9zc2libGUgdG8gdXNlIGBpbnN0YW5jZW9mIEJ1ZmZlcmBcXG4vLyByZWxpYWJseSBpbiBhIGJyb3dzZXJpZnkgY29udGV4dCBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIGRpZmZlcmVudFxcbi8vIGNvcGllcyBvZiB0aGUgJ2J1ZmZlcicgcGFja2FnZSBpbiB1c2UuIFRoaXMgbWV0aG9kIHdvcmtzIGV2ZW4gZm9yIEJ1ZmZlclxcbi8vIGluc3RhbmNlcyB0aGF0IHdlcmUgY3JlYXRlZCBmcm9tIGFub3RoZXIgY29weSBvZiB0aGUgYGJ1ZmZlcmAgcGFja2FnZS5cXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9mZXJvc3MvYnVmZmVyL2lzc3Vlcy8xNTRcXG5CdWZmZXIucHJvdG90eXBlLl9pc0J1ZmZlciA9IHRydWVcXG5cXG5mdW5jdGlvbiBzd2FwIChiLCBuLCBtKSB7XFxuICB2YXIgaSA9IGJbbl1cXG4gIGJbbl0gPSBiW21dXFxuICBiW21dID0gaVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXAxNiA9IGZ1bmN0aW9uIHN3YXAxNiAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSAyICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMTYtYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSAyKSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDEpXFxuICB9XFxuICByZXR1cm4gdGhpc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnN3YXAzMiA9IGZ1bmN0aW9uIHN3YXAzMiAoKSB7XFxuICB2YXIgbGVuID0gdGhpcy5sZW5ndGhcXG4gIGlmIChsZW4gJSA0ICE9PSAwKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdCdWZmZXIgc2l6ZSBtdXN0IGJlIGEgbXVsdGlwbGUgb2YgMzItYml0cycpXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSArPSA0KSB7XFxuICAgIHN3YXAodGhpcywgaSwgaSArIDMpXFxuICAgIHN3YXAodGhpcywgaSArIDEsIGkgKyAyKVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5zd2FwNjQgPSBmdW5jdGlvbiBzd2FwNjQgKCkge1xcbiAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoXFxuICBpZiAobGVuICUgOCAhPT0gMCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDY0LWJpdHMnKVxcbiAgfVxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkgKz0gOCkge1xcbiAgICBzd2FwKHRoaXMsIGksIGkgKyA3KVxcbiAgICBzd2FwKHRoaXMsIGkgKyAxLCBpICsgNilcXG4gICAgc3dhcCh0aGlzLCBpICsgMiwgaSArIDUpXFxuICAgIHN3YXAodGhpcywgaSArIDMsIGkgKyA0KVxcbiAgfVxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nICgpIHtcXG4gIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aFxcbiAgaWYgKGxlbmd0aCA9PT0gMCkgcmV0dXJuICcnXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHV0ZjhTbGljZSh0aGlzLCAwLCBsZW5ndGgpXFxuICByZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsIGFyZ3VtZW50cylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5lcXVhbHMgPSBmdW5jdGlvbiBlcXVhbHMgKGIpIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGIpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcXG4gIGlmICh0aGlzID09PSBiKSByZXR1cm4gdHJ1ZVxcbiAgcmV0dXJuIEJ1ZmZlci5jb21wYXJlKHRoaXMsIGIpID09PSAwXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xcbiAgdmFyIHN0ciA9ICcnXFxuICB2YXIgbWF4ID0gZXhwb3J0cy5JTlNQRUNUX01BWF9CWVRFU1xcbiAgaWYgKHRoaXMubGVuZ3RoID4gMCkge1xcbiAgICBzdHIgPSB0aGlzLnRvU3RyaW5nKCdoZXgnLCAwLCBtYXgpLm1hdGNoKC8uezJ9L2cpLmpvaW4oJyAnKVxcbiAgICBpZiAodGhpcy5sZW5ndGggPiBtYXgpIHN0ciArPSAnIC4uLiAnXFxuICB9XFxuICByZXR1cm4gJzxCdWZmZXIgJyArIHN0ciArICc+J1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLmNvbXBhcmUgPSBmdW5jdGlvbiBjb21wYXJlICh0YXJnZXQsIHN0YXJ0LCBlbmQsIHRoaXNTdGFydCwgdGhpc0VuZCkge1xcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodGFyZ2V0KSkge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyJylcXG4gIH1cXG5cXG4gIGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIHN0YXJ0ID0gMFxcbiAgfVxcbiAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XFxuICAgIGVuZCA9IHRhcmdldCA/IHRhcmdldC5sZW5ndGggOiAwXFxuICB9XFxuICBpZiAodGhpc1N0YXJ0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgdGhpc1N0YXJ0ID0gMFxcbiAgfVxcbiAgaWYgKHRoaXNFbmQgPT09IHVuZGVmaW5lZCkge1xcbiAgICB0aGlzRW5kID0gdGhpcy5sZW5ndGhcXG4gIH1cXG5cXG4gIGlmIChzdGFydCA8IDAgfHwgZW5kID4gdGFyZ2V0Lmxlbmd0aCB8fCB0aGlzU3RhcnQgPCAwIHx8IHRoaXNFbmQgPiB0aGlzLmxlbmd0aCkge1xcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignb3V0IG9mIHJhbmdlIGluZGV4JylcXG4gIH1cXG5cXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCAmJiBzdGFydCA+PSBlbmQpIHtcXG4gICAgcmV0dXJuIDBcXG4gIH1cXG4gIGlmICh0aGlzU3RhcnQgPj0gdGhpc0VuZCkge1xcbiAgICByZXR1cm4gLTFcXG4gIH1cXG4gIGlmIChzdGFydCA+PSBlbmQpIHtcXG4gICAgcmV0dXJuIDFcXG4gIH1cXG5cXG4gIHN0YXJ0ID4+Pj0gMFxcbiAgZW5kID4+Pj0gMFxcbiAgdGhpc1N0YXJ0ID4+Pj0gMFxcbiAgdGhpc0VuZCA+Pj49IDBcXG5cXG4gIGlmICh0aGlzID09PSB0YXJnZXQpIHJldHVybiAwXFxuXFxuICB2YXIgeCA9IHRoaXNFbmQgLSB0aGlzU3RhcnRcXG4gIHZhciB5ID0gZW5kIC0gc3RhcnRcXG4gIHZhciBsZW4gPSBNYXRoLm1pbih4LCB5KVxcblxcbiAgdmFyIHRoaXNDb3B5ID0gdGhpcy5zbGljZSh0aGlzU3RhcnQsIHRoaXNFbmQpXFxuICB2YXIgdGFyZ2V0Q29weSA9IHRhcmdldC5zbGljZShzdGFydCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSkge1xcbiAgICBpZiAodGhpc0NvcHlbaV0gIT09IHRhcmdldENvcHlbaV0pIHtcXG4gICAgICB4ID0gdGhpc0NvcHlbaV1cXG4gICAgICB5ID0gdGFyZ2V0Q29weVtpXVxcbiAgICAgIGJyZWFrXFxuICAgIH1cXG4gIH1cXG5cXG4gIGlmICh4IDwgeSkgcmV0dXJuIC0xXFxuICBpZiAoeSA8IHgpIHJldHVybiAxXFxuICByZXR1cm4gMFxcbn1cXG5cXG4vLyBGaW5kcyBlaXRoZXIgdGhlIGZpcnN0IGluZGV4IG9mIGB2YWxgIGluIGBidWZmZXJgIGF0IG9mZnNldCA+PSBgYnl0ZU9mZnNldGAsXFxuLy8gT1IgdGhlIGxhc3QgaW5kZXggb2YgYHZhbGAgaW4gYGJ1ZmZlcmAgYXQgb2Zmc2V0IDw9IGBieXRlT2Zmc2V0YC5cXG4vL1xcbi8vIEFyZ3VtZW50czpcXG4vLyAtIGJ1ZmZlciAtIGEgQnVmZmVyIHRvIHNlYXJjaFxcbi8vIC0gdmFsIC0gYSBzdHJpbmcsIEJ1ZmZlciwgb3IgbnVtYmVyXFxuLy8gLSBieXRlT2Zmc2V0IC0gYW4gaW5kZXggaW50byBgYnVmZmVyYDsgd2lsbCBiZSBjbGFtcGVkIHRvIGFuIGludDMyXFxuLy8gLSBlbmNvZGluZyAtIGFuIG9wdGlvbmFsIGVuY29kaW5nLCByZWxldmFudCBpcyB2YWwgaXMgYSBzdHJpbmdcXG4vLyAtIGRpciAtIHRydWUgZm9yIGluZGV4T2YsIGZhbHNlIGZvciBsYXN0SW5kZXhPZlxcbmZ1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mIChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGRpcikge1xcbiAgLy8gRW1wdHkgYnVmZmVyIG1lYW5zIG5vIG1hdGNoXFxuICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkgcmV0dXJuIC0xXFxuXFxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldFxcbiAgaWYgKHR5cGVvZiBieXRlT2Zmc2V0ID09PSAnc3RyaW5nJykge1xcbiAgICBlbmNvZGluZyA9IGJ5dGVPZmZzZXRcXG4gICAgYnl0ZU9mZnNldCA9IDBcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA+IDB4N2ZmZmZmZmYpIHtcXG4gICAgYnl0ZU9mZnNldCA9IDB4N2ZmZmZmZmZcXG4gIH0gZWxzZSBpZiAoYnl0ZU9mZnNldCA8IC0weDgwMDAwMDAwKSB7XFxuICAgIGJ5dGVPZmZzZXQgPSAtMHg4MDAwMDAwMFxcbiAgfVxcbiAgYnl0ZU9mZnNldCA9ICtieXRlT2Zmc2V0ICAvLyBDb2VyY2UgdG8gTnVtYmVyLlxcbiAgaWYgKG51bWJlcklzTmFOKGJ5dGVPZmZzZXQpKSB7XFxuICAgIC8vIGJ5dGVPZmZzZXQ6IGl0IGl0J3MgdW5kZWZpbmVkLCBudWxsLCBOYU4sIFxcXCJmb29cXFwiLCBldGMsIHNlYXJjaCB3aG9sZSBidWZmZXJcXG4gICAgYnl0ZU9mZnNldCA9IGRpciA/IDAgOiAoYnVmZmVyLmxlbmd0aCAtIDEpXFxuICB9XFxuXFxuICAvLyBOb3JtYWxpemUgYnl0ZU9mZnNldDogbmVnYXRpdmUgb2Zmc2V0cyBzdGFydCBmcm9tIHRoZSBlbmQgb2YgdGhlIGJ1ZmZlclxcbiAgaWYgKGJ5dGVPZmZzZXQgPCAwKSBieXRlT2Zmc2V0ID0gYnVmZmVyLmxlbmd0aCArIGJ5dGVPZmZzZXRcXG4gIGlmIChieXRlT2Zmc2V0ID49IGJ1ZmZlci5sZW5ndGgpIHtcXG4gICAgaWYgKGRpcikgcmV0dXJuIC0xXFxuICAgIGVsc2UgYnl0ZU9mZnNldCA9IGJ1ZmZlci5sZW5ndGggLSAxXFxuICB9IGVsc2UgaWYgKGJ5dGVPZmZzZXQgPCAwKSB7XFxuICAgIGlmIChkaXIpIGJ5dGVPZmZzZXQgPSAwXFxuICAgIGVsc2UgcmV0dXJuIC0xXFxuICB9XFxuXFxuICAvLyBOb3JtYWxpemUgdmFsXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgdmFsID0gQnVmZmVyLmZyb20odmFsLCBlbmNvZGluZylcXG4gIH1cXG5cXG4gIC8vIEZpbmFsbHksIHNlYXJjaCBlaXRoZXIgaW5kZXhPZiAoaWYgZGlyIGlzIHRydWUpIG9yIGxhc3RJbmRleE9mXFxuICBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcXG4gICAgLy8gU3BlY2lhbCBjYXNlOiBsb29raW5nIGZvciBlbXB0eSBzdHJpbmcvYnVmZmVyIGFsd2F5cyBmYWlsc1xcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgIHJldHVybiAtMVxcbiAgICB9XFxuICAgIHJldHVybiBhcnJheUluZGV4T2YoYnVmZmVyLCB2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXFxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XFxuICAgIHZhbCA9IHZhbCAmIDB4RkYgLy8gU2VhcmNoIGZvciBhIGJ5dGUgdmFsdWUgWzAtMjU1XVxcbiAgICBpZiAodHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBpZiAoZGlyKSB7XFxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZi5jYWxsKGJ1ZmZlciwgdmFsLCBieXRlT2Zmc2V0KVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICByZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChidWZmZXIsIHZhbCwgYnl0ZU9mZnNldClcXG4gICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIGFycmF5SW5kZXhPZihidWZmZXIsIFsgdmFsIF0sIGJ5dGVPZmZzZXQsIGVuY29kaW5nLCBkaXIpXFxuICB9XFxuXFxuICB0aHJvdyBuZXcgVHlwZUVycm9yKCd2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXInKVxcbn1cXG5cXG5mdW5jdGlvbiBhcnJheUluZGV4T2YgKGFyciwgdmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZywgZGlyKSB7XFxuICB2YXIgaW5kZXhTaXplID0gMVxcbiAgdmFyIGFyckxlbmd0aCA9IGFyci5sZW5ndGhcXG4gIHZhciB2YWxMZW5ndGggPSB2YWwubGVuZ3RoXFxuXFxuICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCkge1xcbiAgICBlbmNvZGluZyA9IFN0cmluZyhlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICBpZiAoZW5jb2RpbmcgPT09ICd1Y3MyJyB8fCBlbmNvZGluZyA9PT0gJ3Vjcy0yJyB8fFxcbiAgICAgICAgZW5jb2RpbmcgPT09ICd1dGYxNmxlJyB8fCBlbmNvZGluZyA9PT0gJ3V0Zi0xNmxlJykge1xcbiAgICAgIGlmIChhcnIubGVuZ3RoIDwgMiB8fCB2YWwubGVuZ3RoIDwgMikge1xcbiAgICAgICAgcmV0dXJuIC0xXFxuICAgICAgfVxcbiAgICAgIGluZGV4U2l6ZSA9IDJcXG4gICAgICBhcnJMZW5ndGggLz0gMlxcbiAgICAgIHZhbExlbmd0aCAvPSAyXFxuICAgICAgYnl0ZU9mZnNldCAvPSAyXFxuICAgIH1cXG4gIH1cXG5cXG4gIGZ1bmN0aW9uIHJlYWQgKGJ1ZiwgaSkge1xcbiAgICBpZiAoaW5kZXhTaXplID09PSAxKSB7XFxuICAgICAgcmV0dXJuIGJ1ZltpXVxcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJldHVybiBidWYucmVhZFVJbnQxNkJFKGkgKiBpbmRleFNpemUpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHZhciBpXFxuICBpZiAoZGlyKSB7XFxuICAgIHZhciBmb3VuZEluZGV4ID0gLTFcXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA8IGFyckxlbmd0aDsgaSsrKSB7XFxuICAgICAgaWYgKHJlYWQoYXJyLCBpKSA9PT0gcmVhZCh2YWwsIGZvdW5kSW5kZXggPT09IC0xID8gMCA6IGkgLSBmb3VuZEluZGV4KSkge1xcbiAgICAgICAgaWYgKGZvdW5kSW5kZXggPT09IC0xKSBmb3VuZEluZGV4ID0gaVxcbiAgICAgICAgaWYgKGkgLSBmb3VuZEluZGV4ICsgMSA9PT0gdmFsTGVuZ3RoKSByZXR1cm4gZm91bmRJbmRleCAqIGluZGV4U2l6ZVxcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBpZiAoZm91bmRJbmRleCAhPT0gLTEpIGkgLT0gaSAtIGZvdW5kSW5kZXhcXG4gICAgICAgIGZvdW5kSW5kZXggPSAtMVxcbiAgICAgIH1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGJ5dGVPZmZzZXQgKyB2YWxMZW5ndGggPiBhcnJMZW5ndGgpIGJ5dGVPZmZzZXQgPSBhcnJMZW5ndGggLSB2YWxMZW5ndGhcXG4gICAgZm9yIChpID0gYnl0ZU9mZnNldDsgaSA+PSAwOyBpLS0pIHtcXG4gICAgICB2YXIgZm91bmQgPSB0cnVlXFxuICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB2YWxMZW5ndGg7IGorKykge1xcbiAgICAgICAgaWYgKHJlYWQoYXJyLCBpICsgaikgIT09IHJlYWQodmFsLCBqKSkge1xcbiAgICAgICAgICBmb3VuZCA9IGZhbHNlXFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICB9XFxuICAgICAgfVxcbiAgICAgIGlmIChmb3VuZCkgcmV0dXJuIGlcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIC0xXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUuaW5jbHVkZXMgPSBmdW5jdGlvbiBpbmNsdWRlcyAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIHRoaXMuaW5kZXhPZih2YWwsIGJ5dGVPZmZzZXQsIGVuY29kaW5nKSAhPT0gLTFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5pbmRleE9mID0gZnVuY3Rpb24gaW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIHRydWUpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUubGFzdEluZGV4T2YgPSBmdW5jdGlvbiBsYXN0SW5kZXhPZiAodmFsLCBieXRlT2Zmc2V0LCBlbmNvZGluZykge1xcbiAgcmV0dXJuIGJpZGlyZWN0aW9uYWxJbmRleE9mKHRoaXMsIHZhbCwgYnl0ZU9mZnNldCwgZW5jb2RpbmcsIGZhbHNlKVxcbn1cXG5cXG5mdW5jdGlvbiBoZXhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICBvZmZzZXQgPSBOdW1iZXIob2Zmc2V0KSB8fCAwXFxuICB2YXIgcmVtYWluaW5nID0gYnVmLmxlbmd0aCAtIG9mZnNldFxcbiAgaWYgKCFsZW5ndGgpIHtcXG4gICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICB9IGVsc2Uge1xcbiAgICBsZW5ndGggPSBOdW1iZXIobGVuZ3RoKVxcbiAgICBpZiAobGVuZ3RoID4gcmVtYWluaW5nKSB7XFxuICAgICAgbGVuZ3RoID0gcmVtYWluaW5nXFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIG11c3QgYmUgYW4gZXZlbiBudW1iZXIgb2YgZGlnaXRzXFxuICB2YXIgc3RyTGVuID0gc3RyaW5nLmxlbmd0aFxcbiAgaWYgKHN0ckxlbiAlIDIgIT09IDApIHRocm93IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgaGV4IHN0cmluZycpXFxuXFxuICBpZiAobGVuZ3RoID4gc3RyTGVuIC8gMikge1xcbiAgICBsZW5ndGggPSBzdHJMZW4gLyAyXFxuICB9XFxuICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XFxuICAgIHZhciBwYXJzZWQgPSBwYXJzZUludChzdHJpbmcuc3Vic3RyKGkgKiAyLCAyKSwgMTYpXFxuICAgIGlmIChudW1iZXJJc05hTihwYXJzZWQpKSByZXR1cm4gaVxcbiAgICBidWZbb2Zmc2V0ICsgaV0gPSBwYXJzZWRcXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYmxpdEJ1ZmZlcih1dGY4VG9CeXRlcyhzdHJpbmcsIGJ1Zi5sZW5ndGggLSBvZmZzZXQpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGFzY2lpVG9CeXRlcyhzdHJpbmcpLCBidWYsIG9mZnNldCwgbGVuZ3RoKVxcbn1cXG5cXG5mdW5jdGlvbiBsYXRpbjFXcml0ZSAoYnVmLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKSB7XFxuICByZXR1cm4gYXNjaWlXcml0ZShidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFdyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMoc3RyaW5nKSwgYnVmLCBvZmZzZXQsIGxlbmd0aClcXG59XFxuXFxuZnVuY3Rpb24gdWNzMldyaXRlIChidWYsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBibGl0QnVmZmVyKHV0ZjE2bGVUb0J5dGVzKHN0cmluZywgYnVmLmxlbmd0aCAtIG9mZnNldCksIGJ1Ziwgb2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiB3cml0ZSAoc3RyaW5nLCBvZmZzZXQsIGxlbmd0aCwgZW5jb2RpbmcpIHtcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcpXFxuICBpZiAob2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcXG4gICAgZW5jb2RpbmcgPSAndXRmOCdcXG4gICAgbGVuZ3RoID0gdGhpcy5sZW5ndGhcXG4gICAgb2Zmc2V0ID0gMFxcbiAgLy8gQnVmZmVyI3dyaXRlKHN0cmluZywgZW5jb2RpbmcpXFxuICB9IGVsc2UgaWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiBvZmZzZXQgPT09ICdzdHJpbmcnKSB7XFxuICAgIGVuY29kaW5nID0gb2Zmc2V0XFxuICAgIGxlbmd0aCA9IHRoaXMubGVuZ3RoXFxuICAgIG9mZnNldCA9IDBcXG4gIC8vIEJ1ZmZlciN3cml0ZShzdHJpbmcsIG9mZnNldFssIGxlbmd0aF1bLCBlbmNvZGluZ10pXFxuICB9IGVsc2UgaWYgKGlzRmluaXRlKG9mZnNldCkpIHtcXG4gICAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICAgIGlmIChpc0Zpbml0ZShsZW5ndGgpKSB7XFxuICAgICAgbGVuZ3RoID0gbGVuZ3RoID4+PiAwXFxuICAgICAgaWYgKGVuY29kaW5nID09PSB1bmRlZmluZWQpIGVuY29kaW5nID0gJ3V0ZjgnXFxuICAgIH0gZWxzZSB7XFxuICAgICAgZW5jb2RpbmcgPSBsZW5ndGhcXG4gICAgICBsZW5ndGggPSB1bmRlZmluZWRcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdGhyb3cgbmV3IEVycm9yKFxcbiAgICAgICdCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZCdcXG4gICAgKVxcbiAgfVxcblxcbiAgdmFyIHJlbWFpbmluZyA9IHRoaXMubGVuZ3RoIC0gb2Zmc2V0XFxuICBpZiAobGVuZ3RoID09PSB1bmRlZmluZWQgfHwgbGVuZ3RoID4gcmVtYWluaW5nKSBsZW5ndGggPSByZW1haW5pbmdcXG5cXG4gIGlmICgoc3RyaW5nLmxlbmd0aCA+IDAgJiYgKGxlbmd0aCA8IDAgfHwgb2Zmc2V0IDwgMCkpIHx8IG9mZnNldCA+IHRoaXMubGVuZ3RoKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kcycpXFxuICB9XFxuXFxuICBpZiAoIWVuY29kaW5nKSBlbmNvZGluZyA9ICd1dGY4J1xcblxcbiAgdmFyIGxvd2VyZWRDYXNlID0gZmFsc2VcXG4gIGZvciAoOzspIHtcXG4gICAgc3dpdGNoIChlbmNvZGluZykge1xcbiAgICAgIGNhc2UgJ2hleCc6XFxuICAgICAgICByZXR1cm4gaGV4V3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gdXRmOFdyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgY2FzZSAnYXNjaWknOlxcbiAgICAgICAgcmV0dXJuIGFzY2lpV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdsYXRpbjEnOlxcbiAgICAgIGNhc2UgJ2JpbmFyeSc6XFxuICAgICAgICByZXR1cm4gbGF0aW4xV3JpdGUodGhpcywgc3RyaW5nLCBvZmZzZXQsIGxlbmd0aClcXG5cXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgICAgLy8gV2FybmluZzogbWF4TGVuZ3RoIG5vdCB0YWtlbiBpbnRvIGFjY291bnQgaW4gYmFzZTY0V3JpdGVcXG4gICAgICAgIHJldHVybiBiYXNlNjRXcml0ZSh0aGlzLCBzdHJpbmcsIG9mZnNldCwgbGVuZ3RoKVxcblxcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gdWNzMldyaXRlKHRoaXMsIHN0cmluZywgb2Zmc2V0LCBsZW5ndGgpXFxuXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGlmIChsb3dlcmVkQ2FzZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKVxcbiAgICAgICAgZW5jb2RpbmcgPSAoJycgKyBlbmNvZGluZykudG9Mb3dlckNhc2UoKVxcbiAgICAgICAgbG93ZXJlZENhc2UgPSB0cnVlXFxuICAgIH1cXG4gIH1cXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04gKCkge1xcbiAgcmV0dXJuIHtcXG4gICAgdHlwZTogJ0J1ZmZlcicsXFxuICAgIGRhdGE6IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHRoaXMuX2FyciB8fCB0aGlzLCAwKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBiYXNlNjRTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICBpZiAoc3RhcnQgPT09IDAgJiYgZW5kID09PSBidWYubGVuZ3RoKSB7XFxuICAgIHJldHVybiBiYXNlNjQuZnJvbUJ5dGVBcnJheShidWYpXFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gYmFzZTY0LmZyb21CeXRlQXJyYXkoYnVmLnNsaWNlKHN0YXJ0LCBlbmQpKVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiB1dGY4U2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcbiAgdmFyIHJlcyA9IFtdXFxuXFxuICB2YXIgaSA9IHN0YXJ0XFxuICB3aGlsZSAoaSA8IGVuZCkge1xcbiAgICB2YXIgZmlyc3RCeXRlID0gYnVmW2ldXFxuICAgIHZhciBjb2RlUG9pbnQgPSBudWxsXFxuICAgIHZhciBieXRlc1BlclNlcXVlbmNlID0gKGZpcnN0Qnl0ZSA+IDB4RUYpID8gNFxcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4REYpID8gM1xcbiAgICAgIDogKGZpcnN0Qnl0ZSA+IDB4QkYpID8gMlxcbiAgICAgIDogMVxcblxcbiAgICBpZiAoaSArIGJ5dGVzUGVyU2VxdWVuY2UgPD0gZW5kKSB7XFxuICAgICAgdmFyIHNlY29uZEJ5dGUsIHRoaXJkQnl0ZSwgZm91cnRoQnl0ZSwgdGVtcENvZGVQb2ludFxcblxcbiAgICAgIHN3aXRjaCAoYnl0ZXNQZXJTZXF1ZW5jZSkge1xcbiAgICAgICAgY2FzZSAxOlxcbiAgICAgICAgICBpZiAoZmlyc3RCeXRlIDwgMHg4MCkge1xcbiAgICAgICAgICAgIGNvZGVQb2ludCA9IGZpcnN0Qnl0ZVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDI6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweDFGKSA8PCAweDYgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgICAgIGJyZWFrXFxuICAgICAgICBjYXNlIDM6XFxuICAgICAgICAgIHNlY29uZEJ5dGUgPSBidWZbaSArIDFdXFxuICAgICAgICAgIHRoaXJkQnl0ZSA9IGJ1ZltpICsgMl1cXG4gICAgICAgICAgaWYgKChzZWNvbmRCeXRlICYgMHhDMCkgPT09IDB4ODAgJiYgKHRoaXJkQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4QyB8IChzZWNvbmRCeXRlICYgMHgzRikgPDwgMHg2IHwgKHRoaXJkQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweDdGRiAmJiAodGVtcENvZGVQb2ludCA8IDB4RDgwMCB8fCB0ZW1wQ29kZVBvaW50ID4gMHhERkZGKSkge1xcbiAgICAgICAgICAgICAgY29kZVBvaW50ID0gdGVtcENvZGVQb2ludFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgfVxcbiAgICAgICAgICBicmVha1xcbiAgICAgICAgY2FzZSA0OlxcbiAgICAgICAgICBzZWNvbmRCeXRlID0gYnVmW2kgKyAxXVxcbiAgICAgICAgICB0aGlyZEJ5dGUgPSBidWZbaSArIDJdXFxuICAgICAgICAgIGZvdXJ0aEJ5dGUgPSBidWZbaSArIDNdXFxuICAgICAgICAgIGlmICgoc2Vjb25kQnl0ZSAmIDB4QzApID09PSAweDgwICYmICh0aGlyZEJ5dGUgJiAweEMwKSA9PT0gMHg4MCAmJiAoZm91cnRoQnl0ZSAmIDB4QzApID09PSAweDgwKSB7XFxuICAgICAgICAgICAgdGVtcENvZGVQb2ludCA9IChmaXJzdEJ5dGUgJiAweEYpIDw8IDB4MTIgfCAoc2Vjb25kQnl0ZSAmIDB4M0YpIDw8IDB4QyB8ICh0aGlyZEJ5dGUgJiAweDNGKSA8PCAweDYgfCAoZm91cnRoQnl0ZSAmIDB4M0YpXFxuICAgICAgICAgICAgaWYgKHRlbXBDb2RlUG9pbnQgPiAweEZGRkYgJiYgdGVtcENvZGVQb2ludCA8IDB4MTEwMDAwKSB7XFxuICAgICAgICAgICAgICBjb2RlUG9pbnQgPSB0ZW1wQ29kZVBvaW50XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICB9XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChjb2RlUG9pbnQgPT09IG51bGwpIHtcXG4gICAgICAvLyB3ZSBkaWQgbm90IGdlbmVyYXRlIGEgdmFsaWQgY29kZVBvaW50IHNvIGluc2VydCBhXFxuICAgICAgLy8gcmVwbGFjZW1lbnQgY2hhciAoVStGRkZEKSBhbmQgYWR2YW5jZSBvbmx5IDEgYnl0ZVxcbiAgICAgIGNvZGVQb2ludCA9IDB4RkZGRFxcbiAgICAgIGJ5dGVzUGVyU2VxdWVuY2UgPSAxXFxuICAgIH0gZWxzZSBpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XFxuICAgICAgLy8gZW5jb2RlIHRvIHV0ZjE2IChzdXJyb2dhdGUgcGFpciBkYW5jZSlcXG4gICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMFxcbiAgICAgIHJlcy5wdXNoKGNvZGVQb2ludCA+Pj4gMTAgJiAweDNGRiB8IDB4RDgwMClcXG4gICAgICBjb2RlUG9pbnQgPSAweERDMDAgfCBjb2RlUG9pbnQgJiAweDNGRlxcbiAgICB9XFxuXFxuICAgIHJlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgaSArPSBieXRlc1BlclNlcXVlbmNlXFxuICB9XFxuXFxuICByZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KHJlcylcXG59XFxuXFxuLy8gQmFzZWQgb24gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjI3NDcyNzIvNjgwNzQyLCB0aGUgYnJvd3NlciB3aXRoXFxuLy8gdGhlIGxvd2VzdCBsaW1pdCBpcyBDaHJvbWUsIHdpdGggMHgxMDAwMCBhcmdzLlxcbi8vIFdlIGdvIDEgbWFnbml0dWRlIGxlc3MsIGZvciBzYWZldHlcXG52YXIgTUFYX0FSR1VNRU5UU19MRU5HVEggPSAweDEwMDBcXG5cXG5mdW5jdGlvbiBkZWNvZGVDb2RlUG9pbnRzQXJyYXkgKGNvZGVQb2ludHMpIHtcXG4gIHZhciBsZW4gPSBjb2RlUG9pbnRzLmxlbmd0aFxcbiAgaWYgKGxlbiA8PSBNQVhfQVJHVU1FTlRTX0xFTkdUSCkge1xcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShTdHJpbmcsIGNvZGVQb2ludHMpIC8vIGF2b2lkIGV4dHJhIHNsaWNlKClcXG4gIH1cXG5cXG4gIC8vIERlY29kZSBpbiBjaHVua3MgdG8gYXZvaWQgXFxcImNhbGwgc3RhY2sgc2l6ZSBleGNlZWRlZFxcXCIuXFxuICB2YXIgcmVzID0gJydcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKGkgPCBsZW4pIHtcXG4gICAgcmVzICs9IFN0cmluZy5mcm9tQ2hhckNvZGUuYXBwbHkoXFxuICAgICAgU3RyaW5nLFxcbiAgICAgIGNvZGVQb2ludHMuc2xpY2UoaSwgaSArPSBNQVhfQVJHVU1FTlRTX0xFTkdUSClcXG4gICAgKVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciByZXQgPSAnJ1xcbiAgZW5kID0gTWF0aC5taW4oYnVmLmxlbmd0aCwgZW5kKVxcblxcbiAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyArK2kpIHtcXG4gICAgcmV0ICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoYnVmW2ldICYgMHg3RilcXG4gIH1cXG4gIHJldHVybiByZXRcXG59XFxuXFxuZnVuY3Rpb24gbGF0aW4xU2xpY2UgKGJ1Ziwgc3RhcnQsIGVuZCkge1xcbiAgdmFyIHJldCA9ICcnXFxuICBlbmQgPSBNYXRoLm1pbihidWYubGVuZ3RoLCBlbmQpXFxuXFxuICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICByZXQgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZbaV0pXFxuICB9XFxuICByZXR1cm4gcmV0XFxufVxcblxcbmZ1bmN0aW9uIGhleFNsaWNlIChidWYsIHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSBidWYubGVuZ3RoXFxuXFxuICBpZiAoIXN0YXJ0IHx8IHN0YXJ0IDwgMCkgc3RhcnQgPSAwXFxuICBpZiAoIWVuZCB8fCBlbmQgPCAwIHx8IGVuZCA+IGxlbikgZW5kID0gbGVuXFxuXFxuICB2YXIgb3V0ID0gJydcXG4gIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgKytpKSB7XFxuICAgIG91dCArPSB0b0hleChidWZbaV0pXFxuICB9XFxuICByZXR1cm4gb3V0XFxufVxcblxcbmZ1bmN0aW9uIHV0ZjE2bGVTbGljZSAoYnVmLCBzdGFydCwgZW5kKSB7XFxuICB2YXIgYnl0ZXMgPSBidWYuc2xpY2Uoc3RhcnQsIGVuZClcXG4gIHZhciByZXMgPSAnJ1xcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gMikge1xcbiAgICByZXMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShieXRlc1tpXSArIChieXRlc1tpICsgMV0gKiAyNTYpKVxcbiAgfVxcbiAgcmV0dXJuIHJlc1xcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnNsaWNlID0gZnVuY3Rpb24gc2xpY2UgKHN0YXJ0LCBlbmQpIHtcXG4gIHZhciBsZW4gPSB0aGlzLmxlbmd0aFxcbiAgc3RhcnQgPSB+fnN0YXJ0XFxuICBlbmQgPSBlbmQgPT09IHVuZGVmaW5lZCA/IGxlbiA6IH5+ZW5kXFxuXFxuICBpZiAoc3RhcnQgPCAwKSB7XFxuICAgIHN0YXJ0ICs9IGxlblxcbiAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IDBcXG4gIH0gZWxzZSBpZiAoc3RhcnQgPiBsZW4pIHtcXG4gICAgc3RhcnQgPSBsZW5cXG4gIH1cXG5cXG4gIGlmIChlbmQgPCAwKSB7XFxuICAgIGVuZCArPSBsZW5cXG4gICAgaWYgKGVuZCA8IDApIGVuZCA9IDBcXG4gIH0gZWxzZSBpZiAoZW5kID4gbGVuKSB7XFxuICAgIGVuZCA9IGxlblxcbiAgfVxcblxcbiAgaWYgKGVuZCA8IHN0YXJ0KSBlbmQgPSBzdGFydFxcblxcbiAgdmFyIG5ld0J1ZiA9IHRoaXMuc3ViYXJyYXkoc3RhcnQsIGVuZClcXG4gIC8vIFJldHVybiBhbiBhdWdtZW50ZWQgYFVpbnQ4QXJyYXlgIGluc3RhbmNlXFxuICBuZXdCdWYuX19wcm90b19fID0gQnVmZmVyLnByb3RvdHlwZVxcbiAgcmV0dXJuIG5ld0J1Zlxcbn1cXG5cXG4vKlxcbiAqIE5lZWQgdG8gbWFrZSBzdXJlIHRoYXQgYnVmZmVyIGlzbid0IHRyeWluZyB0byB3cml0ZSBvdXQgb2YgYm91bmRzLlxcbiAqL1xcbmZ1bmN0aW9uIGNoZWNrT2Zmc2V0IChvZmZzZXQsIGV4dCwgbGVuZ3RoKSB7XFxuICBpZiAoKG9mZnNldCAlIDEpICE9PSAwIHx8IG9mZnNldCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdvZmZzZXQgaXMgbm90IHVpbnQnKVxcbiAgaWYgKG9mZnNldCArIGV4dCA+IGxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1RyeWluZyB0byBhY2Nlc3MgYmV5b25kIGJ1ZmZlciBsZW5ndGgnKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50TEUgPSBmdW5jdGlvbiByZWFkVUludExFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0XVxcbiAgdmFyIG11bCA9IDFcXG4gIHZhciBpID0gMFxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdmFsICs9IHRoaXNbb2Zmc2V0ICsgaV0gKiBtdWxcXG4gIH1cXG5cXG4gIHJldHVybiB2YWxcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludEJFID0gZnVuY3Rpb24gcmVhZFVJbnRCRSAob2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcbiAgfVxcblxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1ieXRlTGVuZ3RoXVxcbiAgdmFyIG11bCA9IDFcXG4gIHdoaWxlIChieXRlTGVuZ3RoID4gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyAtLWJ5dGVMZW5ndGhdICogbXVsXFxuICB9XFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQ4ID0gZnVuY3Rpb24gcmVhZFVJbnQ4IChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMSwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gdGhpc1tvZmZzZXRdXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnQxNkxFID0gZnVuY3Rpb24gcmVhZFVJbnQxNkxFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgMiwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gdGhpc1tvZmZzZXRdIHwgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDE2QkUgPSBmdW5jdGlvbiByZWFkVUludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiAodGhpc1tvZmZzZXRdIDw8IDgpIHwgdGhpc1tvZmZzZXQgKyAxXVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJMRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICgodGhpc1tvZmZzZXRdKSB8XFxuICAgICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgOCkgfFxcbiAgICAgICh0aGlzW29mZnNldCArIDJdIDw8IDE2KSkgK1xcbiAgICAgICh0aGlzW29mZnNldCArIDNdICogMHgxMDAwMDAwKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJCRSA9IGZ1bmN0aW9uIHJlYWRVSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gKiAweDEwMDAwMDApICtcXG4gICAgKCh0aGlzW29mZnNldCArIDFdIDw8IDE2KSB8XFxuICAgICh0aGlzW29mZnNldCArIDJdIDw8IDgpIHxcXG4gICAgdGhpc1tvZmZzZXQgKyAzXSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkSW50TEUgPSBmdW5jdGlvbiByZWFkSW50TEUgKG9mZnNldCwgYnl0ZUxlbmd0aCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgYnl0ZUxlbmd0aCwgdGhpcy5sZW5ndGgpXFxuXFxuICB2YXIgdmFsID0gdGhpc1tvZmZzZXRdXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIGkgPSAwXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB2YWwgKz0gdGhpc1tvZmZzZXQgKyBpXSAqIG11bFxcbiAgfVxcbiAgbXVsICo9IDB4ODBcXG5cXG4gIGlmICh2YWwgPj0gbXVsKSB2YWwgLT0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpXFxuXFxuICByZXR1cm4gdmFsXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludEJFID0gZnVuY3Rpb24gcmVhZEludEJFIChvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGJ5dGVMZW5ndGggPSBieXRlTGVuZ3RoID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIGJ5dGVMZW5ndGgsIHRoaXMubGVuZ3RoKVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHZhbCA9IHRoaXNbb2Zmc2V0ICsgLS1pXVxcbiAgd2hpbGUgKGkgPiAwICYmIChtdWwgKj0gMHgxMDApKSB7XFxuICAgIHZhbCArPSB0aGlzW29mZnNldCArIC0taV0gKiBtdWxcXG4gIH1cXG4gIG11bCAqPSAweDgwXFxuXFxuICBpZiAodmFsID49IG11bCkgdmFsIC09IE1hdGgucG93KDIsIDggKiBieXRlTGVuZ3RoKVxcblxcbiAgcmV0dXJuIHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQ4ID0gZnVuY3Rpb24gcmVhZEludDggKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAxLCB0aGlzLmxlbmd0aClcXG4gIGlmICghKHRoaXNbb2Zmc2V0XSAmIDB4ODApKSByZXR1cm4gKHRoaXNbb2Zmc2V0XSlcXG4gIHJldHVybiAoKDB4ZmYgLSB0aGlzW29mZnNldF0gKyAxKSAqIC0xKVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkxFID0gZnVuY3Rpb24gcmVhZEludDE2TEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldF0gfCAodGhpc1tvZmZzZXQgKyAxXSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQxNkJFID0gZnVuY3Rpb24gcmVhZEludDE2QkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCAyLCB0aGlzLmxlbmd0aClcXG4gIHZhciB2YWwgPSB0aGlzW29mZnNldCArIDFdIHwgKHRoaXNbb2Zmc2V0XSA8PCA4KVxcbiAgcmV0dXJuICh2YWwgJiAweDgwMDApID8gdmFsIHwgMHhGRkZGMDAwMCA6IHZhbFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLnJlYWRJbnQzMkxFID0gZnVuY3Rpb24gcmVhZEludDMyTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA0LCB0aGlzLmxlbmd0aClcXG5cXG4gIHJldHVybiAodGhpc1tvZmZzZXRdKSB8XFxuICAgICh0aGlzW29mZnNldCArIDFdIDw8IDgpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgM10gPDwgMjQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEludDMyQkUgPSBmdW5jdGlvbiByZWFkSW50MzJCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcblxcbiAgcmV0dXJuICh0aGlzW29mZnNldF0gPDwgMjQpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMV0gPDwgMTYpIHxcXG4gICAgKHRoaXNbb2Zmc2V0ICsgMl0gPDwgOCkgfFxcbiAgICAodGhpc1tvZmZzZXQgKyAzXSlcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRmxvYXRMRSA9IGZ1bmN0aW9uIHJlYWRGbG9hdExFIChvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrT2Zmc2V0KG9mZnNldCwgNCwgdGhpcy5sZW5ndGgpXFxuICByZXR1cm4gaWVlZTc1NC5yZWFkKHRoaXMsIG9mZnNldCwgdHJ1ZSwgMjMsIDQpXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkUgPSBmdW5jdGlvbiByZWFkRmxvYXRCRSAob2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja09mZnNldChvZmZzZXQsIDQsIHRoaXMubGVuZ3RoKVxcbiAgcmV0dXJuIGllZWU3NTQucmVhZCh0aGlzLCBvZmZzZXQsIGZhbHNlLCAyMywgNClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlTEUgPSBmdW5jdGlvbiByZWFkRG91YmxlTEUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCB0cnVlLCA1MiwgOClcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS5yZWFkRG91YmxlQkUgPSBmdW5jdGlvbiByZWFkRG91YmxlQkUgKG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tPZmZzZXQob2Zmc2V0LCA4LCB0aGlzLmxlbmd0aClcXG4gIHJldHVybiBpZWVlNzU0LnJlYWQodGhpcywgb2Zmc2V0LCBmYWxzZSwgNTIsIDgpXFxufVxcblxcbmZ1bmN0aW9uIGNoZWNrSW50IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKGJ1ZikpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1xcXCJidWZmZXJcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBCdWZmZXIgaW5zdGFuY2UnKVxcbiAgaWYgKHZhbHVlID4gbWF4IHx8IHZhbHVlIDwgbWluKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignXFxcInZhbHVlXFxcIiBhcmd1bWVudCBpcyBvdXQgb2YgYm91bmRzJylcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnRMRSA9IGZ1bmN0aW9uIHdyaXRlVUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgYnl0ZUxlbmd0aCA9IGJ5dGVMZW5ndGggPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIHtcXG4gICAgdmFyIG1heEJ5dGVzID0gTWF0aC5wb3coMiwgOCAqIGJ5dGVMZW5ndGgpIC0gMVxcbiAgICBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBtYXhCeXRlcywgMClcXG4gIH1cXG5cXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgaSA9IDBcXG4gIHRoaXNbb2Zmc2V0XSA9IHZhbHVlICYgMHhGRlxcbiAgd2hpbGUgKCsraSA8IGJ5dGVMZW5ndGggJiYgKG11bCAqPSAweDEwMCkpIHtcXG4gICAgdGhpc1tvZmZzZXQgKyBpXSA9ICh2YWx1ZSAvIG11bCkgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFID0gZnVuY3Rpb24gd3JpdGVVSW50QkUgKHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBieXRlTGVuZ3RoID0gYnl0ZUxlbmd0aCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbWF4Qnl0ZXMgPSBNYXRoLnBvdygyLCA4ICogYnl0ZUxlbmd0aCkgLSAxXFxuICAgIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGJ5dGVMZW5ndGgsIG1heEJ5dGVzLCAwKVxcbiAgfVxcblxcbiAgdmFyIGkgPSBieXRlTGVuZ3RoIC0gMVxcbiAgdmFyIG11bCA9IDFcXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICB0aGlzW29mZnNldCArIGldID0gKHZhbHVlIC8gbXVsKSAmIDB4RkZcXG4gIH1cXG5cXG4gIHJldHVybiBvZmZzZXQgKyBieXRlTGVuZ3RoXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OCA9IGZ1bmN0aW9uIHdyaXRlVUludDggKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAxLCAweGZmLCAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAxXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MTZCRSA9IGZ1bmN0aW9uIHdyaXRlVUludDE2QkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweGZmZmYsIDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDFdID0gKHZhbHVlICYgMHhmZilcXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlVUludDMyTEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweGZmZmZmZmZmLCAwKVxcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSA+Pj4gMjQpXFxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQzMkJFID0gZnVuY3Rpb24gd3JpdGVVSW50MzJCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4ZmZmZmZmZmYsIDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgPj4+IDI0KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gMTYpXFxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAzXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50TEUgPSBmdW5jdGlvbiB3cml0ZUludExFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcXG5cXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXFxuICB9XFxuXFxuICB2YXIgaSA9IDBcXG4gIHZhciBtdWwgPSAxXFxuICB2YXIgc3ViID0gMFxcbiAgdGhpc1tvZmZzZXRdID0gdmFsdWUgJiAweEZGXFxuICB3aGlsZSAoKytpIDwgYnl0ZUxlbmd0aCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgLSAxXSAhPT0gMCkge1xcbiAgICAgIHN1YiA9IDFcXG4gICAgfVxcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkUgPSBmdW5jdGlvbiB3cml0ZUludEJFICh2YWx1ZSwgb2Zmc2V0LCBieXRlTGVuZ3RoLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICB2YXIgbGltaXQgPSBNYXRoLnBvdygyLCAoOCAqIGJ5dGVMZW5ndGgpIC0gMSlcXG5cXG4gICAgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgYnl0ZUxlbmd0aCwgbGltaXQgLSAxLCAtbGltaXQpXFxuICB9XFxuXFxuICB2YXIgaSA9IGJ5dGVMZW5ndGggLSAxXFxuICB2YXIgbXVsID0gMVxcbiAgdmFyIHN1YiA9IDBcXG4gIHRoaXNbb2Zmc2V0ICsgaV0gPSB2YWx1ZSAmIDB4RkZcXG4gIHdoaWxlICgtLWkgPj0gMCAmJiAobXVsICo9IDB4MTAwKSkge1xcbiAgICBpZiAodmFsdWUgPCAwICYmIHN1YiA9PT0gMCAmJiB0aGlzW29mZnNldCArIGkgKyAxXSAhPT0gMCkge1xcbiAgICAgIHN1YiA9IDFcXG4gICAgfVxcbiAgICB0aGlzW29mZnNldCArIGldID0gKCh2YWx1ZSAvIG11bCkgPj4gMCkgLSBzdWIgJiAweEZGXFxuICB9XFxuXFxuICByZXR1cm4gb2Zmc2V0ICsgYnl0ZUxlbmd0aFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50OCA9IGZ1bmN0aW9uIHdyaXRlSW50OCAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDEsIDB4N2YsIC0weDgwKVxcbiAgaWYgKHZhbHVlIDwgMCkgdmFsdWUgPSAweGZmICsgdmFsdWUgKyAxXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDFcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDE2TEUgPSBmdW5jdGlvbiB3cml0ZUludDE2TEUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCAyLCAweDdmZmYsIC0weDgwMDApXFxuICB0aGlzW29mZnNldF0gPSAodmFsdWUgJiAweGZmKVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHJldHVybiBvZmZzZXQgKyAyXFxufVxcblxcbkJ1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkJFID0gZnVuY3Rpb24gd3JpdGVJbnQxNkJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkgY2hlY2tJbnQodGhpcywgdmFsdWUsIG9mZnNldCwgMiwgMHg3ZmZmLCAtMHg4MDAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiA4KVxcbiAgdGhpc1tvZmZzZXQgKyAxXSA9ICh2YWx1ZSAmIDB4ZmYpXFxuICByZXR1cm4gb2Zmc2V0ICsgMlxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlSW50MzJMRSA9IGZ1bmN0aW9uIHdyaXRlSW50MzJMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHZhbHVlID0gK3ZhbHVlXFxuICBvZmZzZXQgPSBvZmZzZXQgPj4+IDBcXG4gIGlmICghbm9Bc3NlcnQpIGNoZWNrSW50KHRoaXMsIHZhbHVlLCBvZmZzZXQsIDQsIDB4N2ZmZmZmZmYsIC0weDgwMDAwMDAwKVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlICYgMHhmZilcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDgpXFxuICB0aGlzW29mZnNldCArIDJdID0gKHZhbHVlID4+PiAxNilcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgPj4+IDI0KVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuQnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkUgPSBmdW5jdGlvbiB3cml0ZUludDMyQkUgKHZhbHVlLCBvZmZzZXQsIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSBjaGVja0ludCh0aGlzLCB2YWx1ZSwgb2Zmc2V0LCA0LCAweDdmZmZmZmZmLCAtMHg4MDAwMDAwMClcXG4gIGlmICh2YWx1ZSA8IDApIHZhbHVlID0gMHhmZmZmZmZmZiArIHZhbHVlICsgMVxcbiAgdGhpc1tvZmZzZXRdID0gKHZhbHVlID4+PiAyNClcXG4gIHRoaXNbb2Zmc2V0ICsgMV0gPSAodmFsdWUgPj4+IDE2KVxcbiAgdGhpc1tvZmZzZXQgKyAyXSA9ICh2YWx1ZSA+Pj4gOClcXG4gIHRoaXNbb2Zmc2V0ICsgM10gPSAodmFsdWUgJiAweGZmKVxcbiAgcmV0dXJuIG9mZnNldCArIDRcXG59XFxuXFxuZnVuY3Rpb24gY2hlY2tJRUVFNzU0IChidWYsIHZhbHVlLCBvZmZzZXQsIGV4dCwgbWF4LCBtaW4pIHtcXG4gIGlmIChvZmZzZXQgKyBleHQgPiBidWYubGVuZ3RoKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG4gIGlmIChvZmZzZXQgPCAwKSB0aHJvdyBuZXcgUmFuZ2VFcnJvcignSW5kZXggb3V0IG9mIHJhbmdlJylcXG59XFxuXFxuZnVuY3Rpb24gd3JpdGVGbG9hdCAoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBsaXR0bGVFbmRpYW4sIG5vQXNzZXJ0KSB7XFxuICB2YWx1ZSA9ICt2YWx1ZVxcbiAgb2Zmc2V0ID0gb2Zmc2V0ID4+PiAwXFxuICBpZiAoIW5vQXNzZXJ0KSB7XFxuICAgIGNoZWNrSUVFRTc1NChidWYsIHZhbHVlLCBvZmZzZXQsIDQsIDMuNDAyODIzNDY2Mzg1Mjg4NmUrMzgsIC0zLjQwMjgyMzQ2NjM4NTI4ODZlKzM4KVxcbiAgfVxcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgMjMsIDQpXFxuICByZXR1cm4gb2Zmc2V0ICsgNFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRMRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRMRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRSA9IGZ1bmN0aW9uIHdyaXRlRmxvYXRCRSAodmFsdWUsIG9mZnNldCwgbm9Bc3NlcnQpIHtcXG4gIHJldHVybiB3cml0ZUZsb2F0KHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcXG59XFxuXFxuZnVuY3Rpb24gd3JpdGVEb3VibGUgKGJ1ZiwgdmFsdWUsIG9mZnNldCwgbGl0dGxlRW5kaWFuLCBub0Fzc2VydCkge1xcbiAgdmFsdWUgPSArdmFsdWVcXG4gIG9mZnNldCA9IG9mZnNldCA+Pj4gMFxcbiAgaWYgKCFub0Fzc2VydCkge1xcbiAgICBjaGVja0lFRUU3NTQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCA4LCAxLjc5NzY5MzEzNDg2MjMxNTdFKzMwOCwgLTEuNzk3NjkzMTM0ODYyMzE1N0UrMzA4KVxcbiAgfVxcbiAgaWVlZTc1NC53cml0ZShidWYsIHZhbHVlLCBvZmZzZXQsIGxpdHRsZUVuZGlhbiwgNTIsIDgpXFxuICByZXR1cm4gb2Zmc2V0ICsgOFxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlTEUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUxFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIHRydWUsIG5vQXNzZXJ0KVxcbn1cXG5cXG5CdWZmZXIucHJvdG90eXBlLndyaXRlRG91YmxlQkUgPSBmdW5jdGlvbiB3cml0ZURvdWJsZUJFICh2YWx1ZSwgb2Zmc2V0LCBub0Fzc2VydCkge1xcbiAgcmV0dXJuIHdyaXRlRG91YmxlKHRoaXMsIHZhbHVlLCBvZmZzZXQsIGZhbHNlLCBub0Fzc2VydClcXG59XFxuXFxuLy8gY29weSh0YXJnZXRCdWZmZXIsIHRhcmdldFN0YXJ0PTAsIHNvdXJjZVN0YXJ0PTAsIHNvdXJjZUVuZD1idWZmZXIubGVuZ3RoKVxcbkJ1ZmZlci5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKHRhcmdldCwgdGFyZ2V0U3RhcnQsIHN0YXJ0LCBlbmQpIHtcXG4gIGlmICghc3RhcnQpIHN0YXJ0ID0gMFxcbiAgaWYgKCFlbmQgJiYgZW5kICE9PSAwKSBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgaWYgKHRhcmdldFN0YXJ0ID49IHRhcmdldC5sZW5ndGgpIHRhcmdldFN0YXJ0ID0gdGFyZ2V0Lmxlbmd0aFxcbiAgaWYgKCF0YXJnZXRTdGFydCkgdGFyZ2V0U3RhcnQgPSAwXFxuICBpZiAoZW5kID4gMCAmJiBlbmQgPCBzdGFydCkgZW5kID0gc3RhcnRcXG5cXG4gIC8vIENvcHkgMCBieXRlczsgd2UncmUgZG9uZVxcbiAgaWYgKGVuZCA9PT0gc3RhcnQpIHJldHVybiAwXFxuICBpZiAodGFyZ2V0Lmxlbmd0aCA9PT0gMCB8fCB0aGlzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIDBcXG5cXG4gIC8vIEZhdGFsIGVycm9yIGNvbmRpdGlvbnNcXG4gIGlmICh0YXJnZXRTdGFydCA8IDApIHtcXG4gICAgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3RhcmdldFN0YXJ0IG91dCBvZiBib3VuZHMnKVxcbiAgfVxcbiAgaWYgKHN0YXJ0IDwgMCB8fCBzdGFydCA+PSB0aGlzLmxlbmd0aCkgdGhyb3cgbmV3IFJhbmdlRXJyb3IoJ3NvdXJjZVN0YXJ0IG91dCBvZiBib3VuZHMnKVxcbiAgaWYgKGVuZCA8IDApIHRocm93IG5ldyBSYW5nZUVycm9yKCdzb3VyY2VFbmQgb3V0IG9mIGJvdW5kcycpXFxuXFxuICAvLyBBcmUgd2Ugb29iP1xcbiAgaWYgKGVuZCA+IHRoaXMubGVuZ3RoKSBlbmQgPSB0aGlzLmxlbmd0aFxcbiAgaWYgKHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCA8IGVuZCAtIHN0YXJ0KSB7XFxuICAgIGVuZCA9IHRhcmdldC5sZW5ndGggLSB0YXJnZXRTdGFydCArIHN0YXJ0XFxuICB9XFxuXFxuICB2YXIgbGVuID0gZW5kIC0gc3RhcnRcXG4gIHZhciBpXFxuXFxuICBpZiAodGhpcyA9PT0gdGFyZ2V0ICYmIHN0YXJ0IDwgdGFyZ2V0U3RhcnQgJiYgdGFyZ2V0U3RhcnQgPCBlbmQpIHtcXG4gICAgLy8gZGVzY2VuZGluZyBjb3B5IGZyb20gZW5kXFxuICAgIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMDsgLS1pKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIGlmIChsZW4gPCAxMDAwKSB7XFxuICAgIC8vIGFzY2VuZGluZyBjb3B5IGZyb20gc3RhcnRcXG4gICAgZm9yIChpID0gMDsgaSA8IGxlbjsgKytpKSB7XFxuICAgICAgdGFyZ2V0W2kgKyB0YXJnZXRTdGFydF0gPSB0aGlzW2kgKyBzdGFydF1cXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgVWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoXFxuICAgICAgdGFyZ2V0LFxcbiAgICAgIHRoaXMuc3ViYXJyYXkoc3RhcnQsIHN0YXJ0ICsgbGVuKSxcXG4gICAgICB0YXJnZXRTdGFydFxcbiAgICApXFxuICB9XFxuXFxuICByZXR1cm4gbGVuXFxufVxcblxcbi8vIFVzYWdlOlxcbi8vICAgIGJ1ZmZlci5maWxsKG51bWJlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKGJ1ZmZlclssIG9mZnNldFssIGVuZF1dKVxcbi8vICAgIGJ1ZmZlci5maWxsKHN0cmluZ1ssIG9mZnNldFssIGVuZF1dWywgZW5jb2RpbmddKVxcbkJ1ZmZlci5wcm90b3R5cGUuZmlsbCA9IGZ1bmN0aW9uIGZpbGwgKHZhbCwgc3RhcnQsIGVuZCwgZW5jb2RpbmcpIHtcXG4gIC8vIEhhbmRsZSBzdHJpbmcgY2FzZXM6XFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcXG4gICAgaWYgKHR5cGVvZiBzdGFydCA9PT0gJ3N0cmluZycpIHtcXG4gICAgICBlbmNvZGluZyA9IHN0YXJ0XFxuICAgICAgc3RhcnQgPSAwXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfSBlbHNlIGlmICh0eXBlb2YgZW5kID09PSAnc3RyaW5nJykge1xcbiAgICAgIGVuY29kaW5nID0gZW5kXFxuICAgICAgZW5kID0gdGhpcy5sZW5ndGhcXG4gICAgfVxcbiAgICBpZiAodmFsLmxlbmd0aCA9PT0gMSkge1xcbiAgICAgIHZhciBjb2RlID0gdmFsLmNoYXJDb2RlQXQoMClcXG4gICAgICBpZiAoY29kZSA8IDI1Nikge1xcbiAgICAgICAgdmFsID0gY29kZVxcbiAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoZW5jb2RpbmcgIT09IHVuZGVmaW5lZCAmJiB0eXBlb2YgZW5jb2RpbmcgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgbXVzdCBiZSBhIHN0cmluZycpXFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBlbmNvZGluZyA9PT0gJ3N0cmluZycgJiYgIUJ1ZmZlci5pc0VuY29kaW5nKGVuY29kaW5nKSkge1xcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmNvZGluZylcXG4gICAgfVxcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnbnVtYmVyJykge1xcbiAgICB2YWwgPSB2YWwgJiAyNTVcXG4gIH1cXG5cXG4gIC8vIEludmFsaWQgcmFuZ2VzIGFyZSBub3Qgc2V0IHRvIGEgZGVmYXVsdCwgc28gY2FuIHJhbmdlIGNoZWNrIGVhcmx5LlxcbiAgaWYgKHN0YXJ0IDwgMCB8fCB0aGlzLmxlbmd0aCA8IHN0YXJ0IHx8IHRoaXMubGVuZ3RoIDwgZW5kKSB7XFxuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdPdXQgb2YgcmFuZ2UgaW5kZXgnKVxcbiAgfVxcblxcbiAgaWYgKGVuZCA8PSBzdGFydCkge1xcbiAgICByZXR1cm4gdGhpc1xcbiAgfVxcblxcbiAgc3RhcnQgPSBzdGFydCA+Pj4gMFxcbiAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyB0aGlzLmxlbmd0aCA6IGVuZCA+Pj4gMFxcblxcbiAgaWYgKCF2YWwpIHZhbCA9IDBcXG5cXG4gIHZhciBpXFxuICBpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpIHtcXG4gICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xcbiAgICAgIHRoaXNbaV0gPSB2YWxcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgdmFyIGJ5dGVzID0gQnVmZmVyLmlzQnVmZmVyKHZhbClcXG4gICAgICA/IHZhbFxcbiAgICAgIDogbmV3IEJ1ZmZlcih2YWwsIGVuY29kaW5nKVxcbiAgICB2YXIgbGVuID0gYnl0ZXMubGVuZ3RoXFxuICAgIGZvciAoaSA9IDA7IGkgPCBlbmQgLSBzdGFydDsgKytpKSB7XFxuICAgICAgdGhpc1tpICsgc3RhcnRdID0gYnl0ZXNbaSAlIGxlbl1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHRoaXNcXG59XFxuXFxuLy8gSEVMUEVSIEZVTkNUSU9OU1xcbi8vID09PT09PT09PT09PT09PT1cXG5cXG52YXIgSU5WQUxJRF9CQVNFNjRfUkUgPSAvW14rLzAtOUEtWmEtei1fXS9nXFxuXFxuZnVuY3Rpb24gYmFzZTY0Y2xlYW4gKHN0cikge1xcbiAgLy8gTm9kZSBzdHJpcHMgb3V0IGludmFsaWQgY2hhcmFjdGVycyBsaWtlIFxcXFxuIGFuZCBcXFxcdCBmcm9tIHRoZSBzdHJpbmcsIGJhc2U2NC1qcyBkb2VzIG5vdFxcbiAgc3RyID0gc3RyLnRyaW0oKS5yZXBsYWNlKElOVkFMSURfQkFTRTY0X1JFLCAnJylcXG4gIC8vIE5vZGUgY29udmVydHMgc3RyaW5ncyB3aXRoIGxlbmd0aCA8IDIgdG8gJydcXG4gIGlmIChzdHIubGVuZ3RoIDwgMikgcmV0dXJuICcnXFxuICAvLyBOb2RlIGFsbG93cyBmb3Igbm9uLXBhZGRlZCBiYXNlNjQgc3RyaW5ncyAobWlzc2luZyB0cmFpbGluZyA9PT0pLCBiYXNlNjQtanMgZG9lcyBub3RcXG4gIHdoaWxlIChzdHIubGVuZ3RoICUgNCAhPT0gMCkge1xcbiAgICBzdHIgPSBzdHIgKyAnPSdcXG4gIH1cXG4gIHJldHVybiBzdHJcXG59XFxuXFxuZnVuY3Rpb24gdG9IZXggKG4pIHtcXG4gIGlmIChuIDwgMTYpIHJldHVybiAnMCcgKyBuLnRvU3RyaW5nKDE2KVxcbiAgcmV0dXJuIG4udG9TdHJpbmcoMTYpXFxufVxcblxcbmZ1bmN0aW9uIHV0ZjhUb0J5dGVzIChzdHJpbmcsIHVuaXRzKSB7XFxuICB1bml0cyA9IHVuaXRzIHx8IEluZmluaXR5XFxuICB2YXIgY29kZVBvaW50XFxuICB2YXIgbGVuZ3RoID0gc3RyaW5nLmxlbmd0aFxcbiAgdmFyIGxlYWRTdXJyb2dhdGUgPSBudWxsXFxuICB2YXIgYnl0ZXMgPSBbXVxcblxcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xcbiAgICBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKVxcblxcbiAgICAvLyBpcyBzdXJyb2dhdGUgY29tcG9uZW50XFxuICAgIGlmIChjb2RlUG9pbnQgPiAweEQ3RkYgJiYgY29kZVBvaW50IDwgMHhFMDAwKSB7XFxuICAgICAgLy8gbGFzdCBjaGFyIHdhcyBhIGxlYWRcXG4gICAgICBpZiAoIWxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAgIC8vIG5vIGxlYWQgeWV0XFxuICAgICAgICBpZiAoY29kZVBvaW50ID4gMHhEQkZGKSB7XFxuICAgICAgICAgIC8vIHVuZXhwZWN0ZWQgdHJhaWxcXG4gICAgICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgICAgICAgIGNvbnRpbnVlXFxuICAgICAgICB9IGVsc2UgaWYgKGkgKyAxID09PSBsZW5ndGgpIHtcXG4gICAgICAgICAgLy8gdW5wYWlyZWQgbGVhZFxcbiAgICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgICAgY29udGludWVcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIC8vIHZhbGlkIGxlYWRcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG5cXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIDIgbGVhZHMgaW4gYSByb3dcXG4gICAgICBpZiAoY29kZVBvaW50IDwgMHhEQzAwKSB7XFxuICAgICAgICBpZiAoKHVuaXRzIC09IDMpID4gLTEpIGJ5dGVzLnB1c2goMHhFRiwgMHhCRiwgMHhCRClcXG4gICAgICAgIGxlYWRTdXJyb2dhdGUgPSBjb2RlUG9pbnRcXG4gICAgICAgIGNvbnRpbnVlXFxuICAgICAgfVxcblxcbiAgICAgIC8vIHZhbGlkIHN1cnJvZ2F0ZSBwYWlyXFxuICAgICAgY29kZVBvaW50ID0gKGxlYWRTdXJyb2dhdGUgLSAweEQ4MDAgPDwgMTAgfCBjb2RlUG9pbnQgLSAweERDMDApICsgMHgxMDAwMFxcbiAgICB9IGVsc2UgaWYgKGxlYWRTdXJyb2dhdGUpIHtcXG4gICAgICAvLyB2YWxpZCBibXAgY2hhciwgYnV0IGxhc3QgY2hhciB3YXMgYSBsZWFkXFxuICAgICAgaWYgKCh1bml0cyAtPSAzKSA+IC0xKSBieXRlcy5wdXNoKDB4RUYsIDB4QkYsIDB4QkQpXFxuICAgIH1cXG5cXG4gICAgbGVhZFN1cnJvZ2F0ZSA9IG51bGxcXG5cXG4gICAgLy8gZW5jb2RlIHV0ZjhcXG4gICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDEpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKGNvZGVQb2ludClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gMikgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2IHwgMHhDMCxcXG4gICAgICAgIGNvZGVQb2ludCAmIDB4M0YgfCAweDgwXFxuICAgICAgKVxcbiAgICB9IGVsc2UgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcXG4gICAgICBpZiAoKHVuaXRzIC09IDMpIDwgMCkgYnJlYWtcXG4gICAgICBieXRlcy5wdXNoKFxcbiAgICAgICAgY29kZVBvaW50ID4+IDB4QyB8IDB4RTAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xcbiAgICAgIGlmICgodW5pdHMgLT0gNCkgPCAwKSBicmVha1xcbiAgICAgIGJ5dGVzLnB1c2goXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHgxMiB8IDB4RjAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHhDICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgPj4gMHg2ICYgMHgzRiB8IDB4ODAsXFxuICAgICAgICBjb2RlUG9pbnQgJiAweDNGIHwgMHg4MFxcbiAgICAgIClcXG4gICAgfSBlbHNlIHtcXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgY29kZSBwb2ludCcpXFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiBieXRlc1xcbn1cXG5cXG5mdW5jdGlvbiBhc2NpaVRvQnl0ZXMgKHN0cikge1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICAvLyBOb2RlJ3MgY29kZSBzZWVtcyB0byBiZSBkb2luZyB0aGlzIGFuZCBub3QgJiAweDdGLi5cXG4gICAgYnl0ZUFycmF5LnB1c2goc3RyLmNoYXJDb2RlQXQoaSkgJiAweEZGKVxcbiAgfVxcbiAgcmV0dXJuIGJ5dGVBcnJheVxcbn1cXG5cXG5mdW5jdGlvbiB1dGYxNmxlVG9CeXRlcyAoc3RyLCB1bml0cykge1xcbiAgdmFyIGMsIGhpLCBsb1xcbiAgdmFyIGJ5dGVBcnJheSA9IFtdXFxuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0ci5sZW5ndGg7ICsraSkge1xcbiAgICBpZiAoKHVuaXRzIC09IDIpIDwgMCkgYnJlYWtcXG5cXG4gICAgYyA9IHN0ci5jaGFyQ29kZUF0KGkpXFxuICAgIGhpID0gYyA+PiA4XFxuICAgIGxvID0gYyAlIDI1NlxcbiAgICBieXRlQXJyYXkucHVzaChsbylcXG4gICAgYnl0ZUFycmF5LnB1c2goaGkpXFxuICB9XFxuXFxuICByZXR1cm4gYnl0ZUFycmF5XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFRvQnl0ZXMgKHN0cikge1xcbiAgcmV0dXJuIGJhc2U2NC50b0J5dGVBcnJheShiYXNlNjRjbGVhbihzdHIpKVxcbn1cXG5cXG5mdW5jdGlvbiBibGl0QnVmZmVyIChzcmMsIGRzdCwgb2Zmc2V0LCBsZW5ndGgpIHtcXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyArK2kpIHtcXG4gICAgaWYgKChpICsgb2Zmc2V0ID49IGRzdC5sZW5ndGgpIHx8IChpID49IHNyYy5sZW5ndGgpKSBicmVha1xcbiAgICBkc3RbaSArIG9mZnNldF0gPSBzcmNbaV1cXG4gIH1cXG4gIHJldHVybiBpXFxufVxcblxcbi8vIEFycmF5QnVmZmVycyBmcm9tIGFub3RoZXIgY29udGV4dCAoaS5lLiBhbiBpZnJhbWUpIGRvIG5vdCBwYXNzIHRoZSBgaW5zdGFuY2VvZmAgY2hlY2tcXG4vLyBidXQgdGhleSBzaG91bGQgYmUgdHJlYXRlZCBhcyB2YWxpZC4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZmVyb3NzL2J1ZmZlci9pc3N1ZXMvMTY2XFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlciAob2JqKSB7XFxuICByZXR1cm4gb2JqIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIgfHxcXG4gICAgKG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3RvciAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvci5uYW1lID09PSAnQXJyYXlCdWZmZXInICYmXFxuICAgICAgdHlwZW9mIG9iai5ieXRlTGVuZ3RoID09PSAnbnVtYmVyJylcXG59XFxuXFxuLy8gTm9kZSAwLjEwIHN1cHBvcnRzIGBBcnJheUJ1ZmZlcmAgYnV0IGxhY2tzIGBBcnJheUJ1ZmZlci5pc1ZpZXdgXFxuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcgKG9iaikge1xcbiAgcmV0dXJuICh0eXBlb2YgQXJyYXlCdWZmZXIuaXNWaWV3ID09PSAnZnVuY3Rpb24nKSAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2JqKVxcbn1cXG5cXG5mdW5jdGlvbiBudW1iZXJJc05hTiAob2JqKSB7XFxuICByZXR1cm4gb2JqICE9PSBvYmogLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zZWxmLWNvbXBhcmVcXG59XFxuXFxufSx7XFxcImJhc2U2NC1qc1xcXCI6MzcsXFxcImllZWU3NTRcXFwiOjQ5fV0sNDI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAoQnVmZmVyKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBOT1RFOiBUaGVzZSB0eXBlIGNoZWNraW5nIGZ1bmN0aW9ucyBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBgaW5zdGFuY2VvZmBcXG4vLyBiZWNhdXNlIGl0IGlzIGZyYWdpbGUgYW5kIGNhbiBiZSBlYXNpbHkgZmFrZWQgd2l0aCBgT2JqZWN0LmNyZWF0ZSgpYC5cXG5cXG5mdW5jdGlvbiBpc0FycmF5KGFyZykge1xcbiAgaWYgKEFycmF5LmlzQXJyYXkpIHtcXG4gICAgcmV0dXJuIEFycmF5LmlzQXJyYXkoYXJnKTtcXG4gIH1cXG4gIHJldHVybiBvYmplY3RUb1N0cmluZyhhcmcpID09PSAnW29iamVjdCBBcnJheV0nO1xcbn1cXG5leHBvcnRzLmlzQXJyYXkgPSBpc0FycmF5O1xcblxcbmZ1bmN0aW9uIGlzQm9vbGVhbihhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnYm9vbGVhbic7XFxufVxcbmV4cG9ydHMuaXNCb29sZWFuID0gaXNCb29sZWFuO1xcblxcbmZ1bmN0aW9uIGlzTnVsbChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNOdWxsID0gaXNOdWxsO1xcblxcbmZ1bmN0aW9uIGlzTnVsbE9yVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbE9yVW5kZWZpbmVkID0gaXNOdWxsT3JVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNOdW1iZXIoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ251bWJlcic7XFxufVxcbmV4cG9ydHMuaXNOdW1iZXIgPSBpc051bWJlcjtcXG5cXG5mdW5jdGlvbiBpc1N0cmluZyhhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3RyaW5nJztcXG59XFxuZXhwb3J0cy5pc1N0cmluZyA9IGlzU3RyaW5nO1xcblxcbmZ1bmN0aW9uIGlzU3ltYm9sKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnO1xcbn1cXG5leHBvcnRzLmlzU3ltYm9sID0gaXNTeW1ib2w7XFxuXFxuZnVuY3Rpb24gaXNVbmRlZmluZWQoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSB2b2lkIDA7XFxufVxcbmV4cG9ydHMuaXNVbmRlZmluZWQgPSBpc1VuZGVmaW5lZDtcXG5cXG5mdW5jdGlvbiBpc1JlZ0V4cChyZSkge1xcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKHJlKSA9PT0gJ1tvYmplY3QgUmVnRXhwXSc7XFxufVxcbmV4cG9ydHMuaXNSZWdFeHAgPSBpc1JlZ0V4cDtcXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcbmV4cG9ydHMuaXNPYmplY3QgPSBpc09iamVjdDtcXG5cXG5mdW5jdGlvbiBpc0RhdGUoZCkge1xcbiAgcmV0dXJuIG9iamVjdFRvU3RyaW5nKGQpID09PSAnW29iamVjdCBEYXRlXSc7XFxufVxcbmV4cG9ydHMuaXNEYXRlID0gaXNEYXRlO1xcblxcbmZ1bmN0aW9uIGlzRXJyb3IoZSkge1xcbiAgcmV0dXJuIChvYmplY3RUb1N0cmluZyhlKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyB8fCBlIGluc3RhbmNlb2YgRXJyb3IpO1xcbn1cXG5leHBvcnRzLmlzRXJyb3IgPSBpc0Vycm9yO1xcblxcbmZ1bmN0aW9uIGlzRnVuY3Rpb24oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Z1bmN0aW9uJztcXG59XFxuZXhwb3J0cy5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcXG5cXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZShhcmcpIHtcXG4gIHJldHVybiBhcmcgPT09IG51bGwgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnYm9vbGVhbicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnbnVtYmVyJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3N5bWJvbCcgfHwgIC8vIEVTNiBzeW1ib2xcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAndW5kZWZpbmVkJztcXG59XFxuZXhwb3J0cy5pc1ByaW1pdGl2ZSA9IGlzUHJpbWl0aXZlO1xcblxcbmV4cG9ydHMuaXNCdWZmZXIgPSBCdWZmZXIuaXNCdWZmZXI7XFxuXFxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcXG59XFxuXFxufSkuY2FsbCh0aGlzLHtcXFwiaXNCdWZmZXJcXFwiOnJlcXVpcmUoXFxcIi4uLy4uL2lzLWJ1ZmZlci9pbmRleC5qc1xcXCIpfSlcXG59LHtcXFwiLi4vLi4vaXMtYnVmZmVyL2luZGV4LmpzXFxcIjo1MX1dLDQzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbi8qKlxcbiAqIFRoaXMgaXMgdGhlIHdlYiBicm93c2VyIGltcGxlbWVudGF0aW9uIG9mIGBkZWJ1ZygpYC5cXG4gKlxcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2RlYnVnJyk7XFxuZXhwb3J0cy5sb2cgPSBsb2c7XFxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcXG5leHBvcnRzLnNhdmUgPSBzYXZlO1xcbmV4cG9ydHMubG9hZCA9IGxvYWQ7XFxuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XFxuZXhwb3J0cy5zdG9yYWdlID0gJ3VuZGVmaW5lZCcgIT0gdHlwZW9mIGNocm9tZVxcbiAgICAgICAgICAgICAgICYmICd1bmRlZmluZWQnICE9IHR5cGVvZiBjaHJvbWUuc3RvcmFnZVxcbiAgICAgICAgICAgICAgICAgID8gY2hyb21lLnN0b3JhZ2UubG9jYWxcXG4gICAgICAgICAgICAgICAgICA6IGxvY2Fsc3RvcmFnZSgpO1xcblxcbi8qKlxcbiAqIENvbG9ycy5cXG4gKi9cXG5cXG5leHBvcnRzLmNvbG9ycyA9IFtcXG4gICcjMDAwMENDJywgJyMwMDAwRkYnLCAnIzAwMzNDQycsICcjMDAzM0ZGJywgJyMwMDY2Q0MnLCAnIzAwNjZGRicsICcjMDA5OUNDJyxcXG4gICcjMDA5OUZGJywgJyMwMENDMDAnLCAnIzAwQ0MzMycsICcjMDBDQzY2JywgJyMwMENDOTknLCAnIzAwQ0NDQycsICcjMDBDQ0ZGJyxcXG4gICcjMzMwMENDJywgJyMzMzAwRkYnLCAnIzMzMzNDQycsICcjMzMzM0ZGJywgJyMzMzY2Q0MnLCAnIzMzNjZGRicsICcjMzM5OUNDJyxcXG4gICcjMzM5OUZGJywgJyMzM0NDMDAnLCAnIzMzQ0MzMycsICcjMzNDQzY2JywgJyMzM0NDOTknLCAnIzMzQ0NDQycsICcjMzNDQ0ZGJyxcXG4gICcjNjYwMENDJywgJyM2NjAwRkYnLCAnIzY2MzNDQycsICcjNjYzM0ZGJywgJyM2NkNDMDAnLCAnIzY2Q0MzMycsICcjOTkwMENDJyxcXG4gICcjOTkwMEZGJywgJyM5OTMzQ0MnLCAnIzk5MzNGRicsICcjOTlDQzAwJywgJyM5OUNDMzMnLCAnI0NDMDAwMCcsICcjQ0MwMDMzJyxcXG4gICcjQ0MwMDY2JywgJyNDQzAwOTknLCAnI0NDMDBDQycsICcjQ0MwMEZGJywgJyNDQzMzMDAnLCAnI0NDMzMzMycsICcjQ0MzMzY2JyxcXG4gICcjQ0MzMzk5JywgJyNDQzMzQ0MnLCAnI0NDMzNGRicsICcjQ0M2NjAwJywgJyNDQzY2MzMnLCAnI0NDOTkwMCcsICcjQ0M5OTMzJyxcXG4gICcjQ0NDQzAwJywgJyNDQ0NDMzMnLCAnI0ZGMDAwMCcsICcjRkYwMDMzJywgJyNGRjAwNjYnLCAnI0ZGMDA5OScsICcjRkYwMENDJyxcXG4gICcjRkYwMEZGJywgJyNGRjMzMDAnLCAnI0ZGMzMzMycsICcjRkYzMzY2JywgJyNGRjMzOTknLCAnI0ZGMzNDQycsICcjRkYzM0ZGJyxcXG4gICcjRkY2NjAwJywgJyNGRjY2MzMnLCAnI0ZGOTkwMCcsICcjRkY5OTMzJywgJyNGRkNDMDAnLCAnI0ZGQ0MzMydcXG5dO1xcblxcbi8qKlxcbiAqIEN1cnJlbnRseSBvbmx5IFdlYktpdC1iYXNlZCBXZWIgSW5zcGVjdG9ycywgRmlyZWZveCA+PSB2MzEsXFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXFxuICogdG8gc3VwcG9ydCBcXFwiJWNcXFwiIENTUyBjdXN0b21pemF0aW9ucy5cXG4gKlxcbiAqIFRPRE86IGFkZCBhIGBsb2NhbFN0b3JhZ2VgIHZhcmlhYmxlIHRvIGV4cGxpY2l0bHkgZW5hYmxlL2Rpc2FibGUgY29sb3JzXFxuICovXFxuXFxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xcbiAgLy8gTkI6IEluIGFuIEVsZWN0cm9uIHByZWxvYWQgc2NyaXB0LCBkb2N1bWVudCB3aWxsIGJlIGRlZmluZWQgYnV0IG5vdCBmdWxseVxcbiAgLy8gaW5pdGlhbGl6ZWQuIFNpbmNlIHdlIGtub3cgd2UncmUgaW4gQ2hyb21lLCB3ZSdsbCBqdXN0IGRldGVjdCB0aGlzIGNhc2VcXG4gIC8vIGV4cGxpY2l0bHlcXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cucHJvY2VzcyAmJiB3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcblxcbiAgLy8gSW50ZXJuZXQgRXhwbG9yZXIgYW5kIEVkZ2UgZG8gbm90IHN1cHBvcnQgY29sb3JzLlxcbiAgaWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcXFwvKFxcXFxkKykvKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuXFxuICAvLyBpcyB3ZWJraXQ/IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2NDU5NjA2LzM3Njc3M1xcbiAgLy8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcXG4gIHJldHVybiAodHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zdHlsZS5XZWJraXRBcHBlYXJhbmNlKSB8fFxcbiAgICAvLyBpcyBmaXJlYnVnPyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zOTgxMjAvMzc2NzczXFxuICAgICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XFxuICAgIC8vIGlzIGZpcmVmb3ggPj0gdjMxP1xcbiAgICAvLyBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1Rvb2xzL1dlYl9Db25zb2xlI1N0eWxpbmdfbWVzc2FnZXNcXG4gICAgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFxcXC8oXFxcXGQrKS8pICYmIHBhcnNlSW50KFJlZ0V4cC4kMSwgMTApID49IDMxKSB8fFxcbiAgICAvLyBkb3VibGUgY2hlY2sgd2Via2l0IGluIHVzZXJBZ2VudCBqdXN0IGluIGNhc2Ugd2UgYXJlIGluIGEgd29ya2VyXFxuICAgICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXFxcLyhcXFxcZCspLykpO1xcbn1cXG5cXG4vKipcXG4gKiBNYXAgJWogdG8gYEpTT04uc3RyaW5naWZ5KClgLCBzaW5jZSBubyBXZWIgSW5zcGVjdG9ycyBkbyB0aGF0IGJ5IGRlZmF1bHQuXFxuICovXFxuXFxuZXhwb3J0cy5mb3JtYXR0ZXJzLmogPSBmdW5jdGlvbih2KSB7XFxuICB0cnkge1xcbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodik7XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgcmV0dXJuICdbVW5leHBlY3RlZEpTT05QYXJzZUVycm9yXTogJyArIGVyci5tZXNzYWdlO1xcbiAgfVxcbn07XFxuXFxuXFxuLyoqXFxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBmb3JtYXRBcmdzKGFyZ3MpIHtcXG4gIHZhciB1c2VDb2xvcnMgPSB0aGlzLnVzZUNvbG9ycztcXG5cXG4gIGFyZ3NbMF0gPSAodXNlQ29sb3JzID8gJyVjJyA6ICcnKVxcbiAgICArIHRoaXMubmFtZXNwYWNlXFxuICAgICsgKHVzZUNvbG9ycyA/ICcgJWMnIDogJyAnKVxcbiAgICArIGFyZ3NbMF1cXG4gICAgKyAodXNlQ29sb3JzID8gJyVjICcgOiAnICcpXFxuICAgICsgJysnICsgZXhwb3J0cy5odW1hbml6ZSh0aGlzLmRpZmYpO1xcblxcbiAgaWYgKCF1c2VDb2xvcnMpIHJldHVybjtcXG5cXG4gIHZhciBjID0gJ2NvbG9yOiAnICsgdGhpcy5jb2xvcjtcXG4gIGFyZ3Muc3BsaWNlKDEsIDAsIGMsICdjb2xvcjogaW5oZXJpdCcpXFxuXFxuICAvLyB0aGUgZmluYWwgXFxcIiVjXFxcIiBpcyBzb21ld2hhdCB0cmlja3ksIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb3RoZXJcXG4gIC8vIGFyZ3VtZW50cyBwYXNzZWQgZWl0aGVyIGJlZm9yZSBvciBhZnRlciB0aGUgJWMsIHNvIHdlIG5lZWQgdG9cXG4gIC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xcbiAgdmFyIGluZGV4ID0gMDtcXG4gIHZhciBsYXN0QyA9IDA7XFxuICBhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgZnVuY3Rpb24obWF0Y2gpIHtcXG4gICAgaWYgKCclJScgPT09IG1hdGNoKSByZXR1cm47XFxuICAgIGluZGV4Kys7XFxuICAgIGlmICgnJWMnID09PSBtYXRjaCkge1xcbiAgICAgIC8vIHdlIG9ubHkgYXJlIGludGVyZXN0ZWQgaW4gdGhlICpsYXN0KiAlY1xcbiAgICAgIC8vICh0aGUgdXNlciBtYXkgaGF2ZSBwcm92aWRlZCB0aGVpciBvd24pXFxuICAgICAgbGFzdEMgPSBpbmRleDtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICBhcmdzLnNwbGljZShsYXN0QywgMCwgYyk7XFxufVxcblxcbi8qKlxcbiAqIEludm9rZXMgYGNvbnNvbGUubG9nKClgIHdoZW4gYXZhaWxhYmxlLlxcbiAqIE5vLW9wIHdoZW4gYGNvbnNvbGUubG9nYCBpcyBub3QgYSBcXFwiZnVuY3Rpb25cXFwiLlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBsb2coKSB7XFxuICAvLyB0aGlzIGhhY2tlcnkgaXMgcmVxdWlyZWQgZm9yIElFOC85LCB3aGVyZVxcbiAgLy8gdGhlIGBjb25zb2xlLmxvZ2AgZnVuY3Rpb24gZG9lc24ndCBoYXZlICdhcHBseSdcXG4gIHJldHVybiAnb2JqZWN0JyA9PT0gdHlwZW9mIGNvbnNvbGVcXG4gICAgJiYgY29uc29sZS5sb2dcXG4gICAgJiYgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZS5sb2csIGNvbnNvbGUsIGFyZ3VtZW50cyk7XFxufVxcblxcbi8qKlxcbiAqIFNhdmUgYG5hbWVzcGFjZXNgLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcXG4gIHRyeSB7XFxuICAgIGlmIChudWxsID09IG5hbWVzcGFjZXMpIHtcXG4gICAgICBleHBvcnRzLnN0b3JhZ2UucmVtb3ZlSXRlbSgnZGVidWcnKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBleHBvcnRzLnN0b3JhZ2UuZGVidWcgPSBuYW1lc3BhY2VzO1xcbiAgICB9XFxuICB9IGNhdGNoKGUpIHt9XFxufVxcblxcbi8qKlxcbiAqIExvYWQgYG5hbWVzcGFjZXNgLlxcbiAqXFxuICogQHJldHVybiB7U3RyaW5nfSByZXR1cm5zIHRoZSBwcmV2aW91c2x5IHBlcnNpc3RlZCBkZWJ1ZyBtb2Rlc1xcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGxvYWQoKSB7XFxuICB2YXIgcjtcXG4gIHRyeSB7XFxuICAgIHIgPSBleHBvcnRzLnN0b3JhZ2UuZGVidWc7XFxuICB9IGNhdGNoKGUpIHt9XFxuXFxuICAvLyBJZiBkZWJ1ZyBpc24ndCBzZXQgaW4gTFMsIGFuZCB3ZSdyZSBpbiBFbGVjdHJvbiwgdHJ5IHRvIGxvYWQgJERFQlVHXFxuICBpZiAoIXIgJiYgdHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmICdlbnYnIGluIHByb2Nlc3MpIHtcXG4gICAgciA9IHByb2Nlc3MuZW52LkRFQlVHO1xcbiAgfVxcblxcbiAgcmV0dXJuIHI7XFxufVxcblxcbi8qKlxcbiAqIEVuYWJsZSBuYW1lc3BhY2VzIGxpc3RlZCBpbiBgbG9jYWxTdG9yYWdlLmRlYnVnYCBpbml0aWFsbHkuXFxuICovXFxuXFxuZXhwb3J0cy5lbmFibGUobG9hZCgpKTtcXG5cXG4vKipcXG4gKiBMb2NhbHN0b3JhZ2UgYXR0ZW1wdHMgdG8gcmV0dXJuIHRoZSBsb2NhbHN0b3JhZ2UuXFxuICpcXG4gKiBUaGlzIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHNhZmFyaSB0aHJvd3NcXG4gKiB3aGVuIGEgdXNlciBkaXNhYmxlcyBjb29raWVzL2xvY2Fsc3RvcmFnZVxcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXFxuICpcXG4gKiBAcmV0dXJuIHtMb2NhbFN0b3JhZ2V9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xcbiAgdHJ5IHtcXG4gICAgcmV0dXJuIHdpbmRvdy5sb2NhbFN0b3JhZ2U7XFxuICB9IGNhdGNoIChlKSB7fVxcbn1cXG5cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSlcXG59LHtcXFwiLi9kZWJ1Z1xcXCI6NDQsXFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDQ0OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5cXG4vKipcXG4gKiBUaGlzIGlzIHRoZSBjb21tb24gbG9naWMgZm9yIGJvdGggdGhlIE5vZGUuanMgYW5kIHdlYiBicm93c2VyXFxuICogaW1wbGVtZW50YXRpb25zIG9mIGBkZWJ1ZygpYC5cXG4gKlxcbiAqIEV4cG9zZSBgZGVidWcoKWAgYXMgdGhlIG1vZHVsZS5cXG4gKi9cXG5cXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBjcmVhdGVEZWJ1Zy5kZWJ1ZyA9IGNyZWF0ZURlYnVnWydkZWZhdWx0J10gPSBjcmVhdGVEZWJ1ZztcXG5leHBvcnRzLmNvZXJjZSA9IGNvZXJjZTtcXG5leHBvcnRzLmRpc2FibGUgPSBkaXNhYmxlO1xcbmV4cG9ydHMuZW5hYmxlID0gZW5hYmxlO1xcbmV4cG9ydHMuZW5hYmxlZCA9IGVuYWJsZWQ7XFxuZXhwb3J0cy5odW1hbml6ZSA9IHJlcXVpcmUoJ21zJyk7XFxuXFxuLyoqXFxuICogQWN0aXZlIGBkZWJ1Z2AgaW5zdGFuY2VzLlxcbiAqL1xcbmV4cG9ydHMuaW5zdGFuY2VzID0gW107XFxuXFxuLyoqXFxuICogVGhlIGN1cnJlbnRseSBhY3RpdmUgZGVidWcgbW9kZSBuYW1lcywgYW5kIG5hbWVzIHRvIHNraXAuXFxuICovXFxuXFxuZXhwb3J0cy5uYW1lcyA9IFtdO1xcbmV4cG9ydHMuc2tpcHMgPSBbXTtcXG5cXG4vKipcXG4gKiBNYXAgb2Ygc3BlY2lhbCBcXFwiJW5cXFwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcXFwiZm9ybWF0XFxcIiBhcmd1bWVudC5cXG4gKlxcbiAqIFZhbGlkIGtleSBuYW1lcyBhcmUgYSBzaW5nbGUsIGxvd2VyIG9yIHVwcGVyLWNhc2UgbGV0dGVyLCBpLmUuIFxcXCJuXFxcIiBhbmQgXFxcIk5cXFwiLlxcbiAqL1xcblxcbmV4cG9ydHMuZm9ybWF0dGVycyA9IHt9O1xcblxcbi8qKlxcbiAqIFNlbGVjdCBhIGNvbG9yLlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VcXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XFxuICB2YXIgaGFzaCA9IDAsIGk7XFxuXFxuICBmb3IgKGkgaW4gbmFtZXNwYWNlKSB7XFxuICAgIGhhc2ggID0gKChoYXNoIDw8IDUpIC0gaGFzaCkgKyBuYW1lc3BhY2UuY2hhckNvZGVBdChpKTtcXG4gICAgaGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcXG4gIH1cXG5cXG4gIHJldHVybiBleHBvcnRzLmNvbG9yc1tNYXRoLmFicyhoYXNoKSAlIGV4cG9ydHMuY29sb3JzLmxlbmd0aF07XFxufVxcblxcbi8qKlxcbiAqIENyZWF0ZSBhIGRlYnVnZ2VyIHdpdGggdGhlIGdpdmVuIGBuYW1lc3BhY2VgLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZVxcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gY3JlYXRlRGVidWcobmFtZXNwYWNlKSB7XFxuXFxuICB2YXIgcHJldlRpbWU7XFxuXFxuICBmdW5jdGlvbiBkZWJ1ZygpIHtcXG4gICAgLy8gZGlzYWJsZWQ/XFxuICAgIGlmICghZGVidWcuZW5hYmxlZCkgcmV0dXJuO1xcblxcbiAgICB2YXIgc2VsZiA9IGRlYnVnO1xcblxcbiAgICAvLyBzZXQgYGRpZmZgIHRpbWVzdGFtcFxcbiAgICB2YXIgY3VyciA9ICtuZXcgRGF0ZSgpO1xcbiAgICB2YXIgbXMgPSBjdXJyIC0gKHByZXZUaW1lIHx8IGN1cnIpO1xcbiAgICBzZWxmLmRpZmYgPSBtcztcXG4gICAgc2VsZi5wcmV2ID0gcHJldlRpbWU7XFxuICAgIHNlbGYuY3VyciA9IGN1cnI7XFxuICAgIHByZXZUaW1lID0gY3VycjtcXG5cXG4gICAgLy8gdHVybiB0aGUgYGFyZ3VtZW50c2AgaW50byBhIHByb3BlciBBcnJheVxcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgfVxcblxcbiAgICBhcmdzWzBdID0gZXhwb3J0cy5jb2VyY2UoYXJnc1swXSk7XFxuXFxuICAgIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIGFyZ3NbMF0pIHtcXG4gICAgICAvLyBhbnl0aGluZyBlbHNlIGxldCdzIGluc3BlY3Qgd2l0aCAlT1xcbiAgICAgIGFyZ3MudW5zaGlmdCgnJU8nKTtcXG4gICAgfVxcblxcbiAgICAvLyBhcHBseSBhbnkgYGZvcm1hdHRlcnNgIHRyYW5zZm9ybWF0aW9uc1xcbiAgICB2YXIgaW5kZXggPSAwO1xcbiAgICBhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgZnVuY3Rpb24obWF0Y2gsIGZvcm1hdCkge1xcbiAgICAgIC8vIGlmIHdlIGVuY291bnRlciBhbiBlc2NhcGVkICUgdGhlbiBkb24ndCBpbmNyZWFzZSB0aGUgYXJyYXkgaW5kZXhcXG4gICAgICBpZiAobWF0Y2ggPT09ICclJScpIHJldHVybiBtYXRjaDtcXG4gICAgICBpbmRleCsrO1xcbiAgICAgIHZhciBmb3JtYXR0ZXIgPSBleHBvcnRzLmZvcm1hdHRlcnNbZm9ybWF0XTtcXG4gICAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGZvcm1hdHRlcikge1xcbiAgICAgICAgdmFyIHZhbCA9IGFyZ3NbaW5kZXhdO1xcbiAgICAgICAgbWF0Y2ggPSBmb3JtYXR0ZXIuY2FsbChzZWxmLCB2YWwpO1xcblxcbiAgICAgICAgLy8gbm93IHdlIG5lZWQgdG8gcmVtb3ZlIGBhcmdzW2luZGV4XWAgc2luY2UgaXQncyBpbmxpbmVkIGluIHRoZSBgZm9ybWF0YFxcbiAgICAgICAgYXJncy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgICAgICAgaW5kZXgtLTtcXG4gICAgICB9XFxuICAgICAgcmV0dXJuIG1hdGNoO1xcbiAgICB9KTtcXG5cXG4gICAgLy8gYXBwbHkgZW52LXNwZWNpZmljIGZvcm1hdHRpbmcgKGNvbG9ycywgZXRjLilcXG4gICAgZXhwb3J0cy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XFxuXFxuICAgIHZhciBsb2dGbiA9IGRlYnVnLmxvZyB8fCBleHBvcnRzLmxvZyB8fCBjb25zb2xlLmxvZy5iaW5kKGNvbnNvbGUpO1xcbiAgICBsb2dGbi5hcHBseShzZWxmLCBhcmdzKTtcXG4gIH1cXG5cXG4gIGRlYnVnLm5hbWVzcGFjZSA9IG5hbWVzcGFjZTtcXG4gIGRlYnVnLmVuYWJsZWQgPSBleHBvcnRzLmVuYWJsZWQobmFtZXNwYWNlKTtcXG4gIGRlYnVnLnVzZUNvbG9ycyA9IGV4cG9ydHMudXNlQ29sb3JzKCk7XFxuICBkZWJ1Zy5jb2xvciA9IHNlbGVjdENvbG9yKG5hbWVzcGFjZSk7XFxuICBkZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcXG5cXG4gIC8vIGVudi1zcGVjaWZpYyBpbml0aWFsaXphdGlvbiBsb2dpYyBmb3IgZGVidWcgaW5zdGFuY2VzXFxuICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIGV4cG9ydHMuaW5pdCkge1xcbiAgICBleHBvcnRzLmluaXQoZGVidWcpO1xcbiAgfVxcblxcbiAgZXhwb3J0cy5pbnN0YW5jZXMucHVzaChkZWJ1Zyk7XFxuXFxuICByZXR1cm4gZGVidWc7XFxufVxcblxcbmZ1bmN0aW9uIGRlc3Ryb3kgKCkge1xcbiAgdmFyIGluZGV4ID0gZXhwb3J0cy5pbnN0YW5jZXMuaW5kZXhPZih0aGlzKTtcXG4gIGlmIChpbmRleCAhPT0gLTEpIHtcXG4gICAgZXhwb3J0cy5pbnN0YW5jZXMuc3BsaWNlKGluZGV4LCAxKTtcXG4gICAgcmV0dXJuIHRydWU7XFxuICB9IGVsc2Uge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIEVuYWJsZXMgYSBkZWJ1ZyBtb2RlIGJ5IG5hbWVzcGFjZXMuIFRoaXMgY2FuIGluY2x1ZGUgbW9kZXNcXG4gKiBzZXBhcmF0ZWQgYnkgYSBjb2xvbiBhbmQgd2lsZGNhcmRzLlxcbiAqXFxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcXG4gKiBAYXBpIHB1YmxpY1xcbiAqL1xcblxcbmZ1bmN0aW9uIGVuYWJsZShuYW1lc3BhY2VzKSB7XFxuICBleHBvcnRzLnNhdmUobmFtZXNwYWNlcyk7XFxuXFxuICBleHBvcnRzLm5hbWVzID0gW107XFxuICBleHBvcnRzLnNraXBzID0gW107XFxuXFxuICB2YXIgaTtcXG4gIHZhciBzcGxpdCA9ICh0eXBlb2YgbmFtZXNwYWNlcyA9PT0gJ3N0cmluZycgPyBuYW1lc3BhY2VzIDogJycpLnNwbGl0KC9bXFxcXHMsXSsvKTtcXG4gIHZhciBsZW4gPSBzcGxpdC5sZW5ndGg7XFxuXFxuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgaWYgKCFzcGxpdFtpXSkgY29udGludWU7IC8vIGlnbm9yZSBlbXB0eSBzdHJpbmdzXFxuICAgIG5hbWVzcGFjZXMgPSBzcGxpdFtpXS5yZXBsYWNlKC9cXFxcKi9nLCAnLio/Jyk7XFxuICAgIGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcXG4gICAgICBleHBvcnRzLnNraXBzLnB1c2gobmV3IFJlZ0V4cCgnXicgKyBuYW1lc3BhY2VzLnN1YnN0cigxKSArICckJykpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGV4cG9ydHMubmFtZXMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMgKyAnJCcpKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZm9yIChpID0gMDsgaSA8IGV4cG9ydHMuaW5zdGFuY2VzLmxlbmd0aDsgaSsrKSB7XFxuICAgIHZhciBpbnN0YW5jZSA9IGV4cG9ydHMuaW5zdGFuY2VzW2ldO1xcbiAgICBpbnN0YW5jZS5lbmFibGVkID0gZXhwb3J0cy5lbmFibGVkKGluc3RhbmNlLm5hbWVzcGFjZSk7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIERpc2FibGUgZGVidWcgb3V0cHV0LlxcbiAqXFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBkaXNhYmxlKCkge1xcbiAgZXhwb3J0cy5lbmFibGUoJycpO1xcbn1cXG5cXG4vKipcXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIGdpdmVuIG1vZGUgbmFtZSBpcyBlbmFibGVkLCBmYWxzZSBvdGhlcndpc2UuXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZVxcbiAqIEByZXR1cm4ge0Jvb2xlYW59XFxuICogQGFwaSBwdWJsaWNcXG4gKi9cXG5cXG5mdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcXG4gIGlmIChuYW1lW25hbWUubGVuZ3RoIC0gMV0gPT09ICcqJykge1xcbiAgICByZXR1cm4gdHJ1ZTtcXG4gIH1cXG4gIHZhciBpLCBsZW47XFxuICBmb3IgKGkgPSAwLCBsZW4gPSBleHBvcnRzLnNraXBzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XFxuICAgIGlmIChleHBvcnRzLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gIH1cXG4gIGZvciAoaSA9IDAsIGxlbiA9IGV4cG9ydHMubmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcXG4gICAgaWYgKGV4cG9ydHMubmFtZXNbaV0udGVzdChuYW1lKSkge1xcbiAgICAgIHJldHVybiB0cnVlO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gZmFsc2U7XFxufVxcblxcbi8qKlxcbiAqIENvZXJjZSBgdmFsYC5cXG4gKlxcbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbFxcbiAqIEByZXR1cm4ge01peGVkfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGNvZXJjZSh2YWwpIHtcXG4gIGlmICh2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuIHZhbC5zdGFjayB8fCB2YWwubWVzc2FnZTtcXG4gIHJldHVybiB2YWw7XFxufVxcblxcbn0se1xcXCJtc1xcXCI6NTR9XSw0NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyohXFxuXFxuIGRpZmYgdjMuNS4wXFxuXFxuU29mdHdhcmUgTGljZW5zZSBBZ3JlZW1lbnQgKEJTRCBMaWNlbnNlKVxcblxcbkNvcHlyaWdodCAoYykgMjAwOS0yMDE1LCBLZXZpbiBEZWNrZXIgPGtwZGVja2VyQGdtYWlsLmNvbT5cXG5cXG5BbGwgcmlnaHRzIHJlc2VydmVkLlxcblxcblJlZGlzdHJpYnV0aW9uIGFuZCB1c2Ugb2YgdGhpcyBzb2Z0d2FyZSBpbiBzb3VyY2UgYW5kIGJpbmFyeSBmb3Jtcywgd2l0aCBvciB3aXRob3V0IG1vZGlmaWNhdGlvbixcXG5hcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XFxuXFxuKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlXFxuICBjb3B5cmlnaHQgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlXFxuICBmb2xsb3dpbmcgZGlzY2xhaW1lci5cXG5cXG4qIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmVcXG4gIGNvcHlyaWdodCBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGVcXG4gIGZvbGxvd2luZyBkaXNjbGFpbWVyIGluIHRoZSBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlclxcbiAgbWF0ZXJpYWxzIHByb3ZpZGVkIHdpdGggdGhlIGRpc3RyaWJ1dGlvbi5cXG5cXG4qIE5laXRoZXIgdGhlIG5hbWUgb2YgS2V2aW4gRGVja2VyIG5vciB0aGUgbmFtZXMgb2YgaXRzXFxuICBjb250cmlidXRvcnMgbWF5IGJlIHVzZWQgdG8gZW5kb3JzZSBvciBwcm9tb3RlIHByb2R1Y3RzXFxuICBkZXJpdmVkIGZyb20gdGhpcyBzb2Z0d2FyZSB3aXRob3V0IHNwZWNpZmljIHByaW9yXFxuICB3cml0dGVuIHBlcm1pc3Npb24uXFxuXFxuVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcXFwiQVMgSVNcXFwiIEFORCBBTlkgRVhQUkVTUyBPUlxcbklNUExJRUQgV0FSUkFOVElFUywgSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORFxcbkZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFSRSBESVNDTEFJTUVELiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQ09QWVJJR0hUIE9XTkVSIE9SXFxuQ09OVFJJQlVUT1JTIEJFIExJQUJMRSBGT1IgQU5ZIERJUkVDVCwgSU5ESVJFQ1QsIElOQ0lERU5UQUwsIFNQRUNJQUwsIEVYRU1QTEFSWSwgT1IgQ09OU0VRVUVOVElBTFxcbkRBTUFHRVMgKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTOyBMT1NTIE9GIFVTRSxcXG5EQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORCBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUlxcbklOIENPTlRSQUNULCBTVFJJQ1QgTElBQklMSVRZLCBPUiBUT1JUIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVRcXG5PRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIEVWRU4gSUYgQURWSVNFRCBPRiBUSEUgUE9TU0lCSUxJVFkgT0YgU1VDSCBEQU1BR0UuXFxuQGxpY2Vuc2VcXG4qL1xcbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XFxuXFx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxcblxcdFxcdG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpO1xcblxcdGVsc2UgaWYoZmFsc2UpXFxuXFx0XFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcXG5cXHRlbHNlIGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JylcXG5cXHRcXHRleHBvcnRzW1xcXCJKc0RpZmZcXFwiXSA9IGZhY3RvcnkoKTtcXG5cXHRlbHNlXFxuXFx0XFx0cm9vdFtcXFwiSnNEaWZmXFxcIl0gPSBmYWN0b3J5KCk7XFxufSkodGhpcywgZnVuY3Rpb24oKSB7XFxucmV0dXJuIC8qKioqKiovIChmdW5jdGlvbihtb2R1bGVzKSB7IC8vIHdlYnBhY2tCb290c3RyYXBcXG4vKioqKioqLyBcXHQvLyBUaGUgbW9kdWxlIGNhY2hlXFxuLyoqKioqKi8gXFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcXG5cXG4vKioqKioqLyBcXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxcbi8qKioqKiovIFxcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcXG4vKioqKioqLyBcXHRcXHRpZihpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSlcXG4vKioqKioqLyBcXHRcXHRcXHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcXG5cXG4vKioqKioqLyBcXHRcXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxcbi8qKioqKiovIFxcdFxcdHZhciBtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSA9IHtcXG4vKioqKioqLyBcXHRcXHRcXHRleHBvcnRzOiB7fSxcXG4vKioqKioqLyBcXHRcXHRcXHRpZDogbW9kdWxlSWQsXFxuLyoqKioqKi8gXFx0XFx0XFx0bG9hZGVkOiBmYWxzZVxcbi8qKioqKiovIFxcdFxcdH07XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXFxuLyoqKioqKi8gXFx0XFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XFxuXFxuLyoqKioqKi8gXFx0XFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxcbi8qKioqKiovIFxcdFxcdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xcblxcbi8qKioqKiovIFxcdFxcdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXFxuLyoqKioqKi8gXFx0XFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xcbi8qKioqKiovIFxcdH1cXG5cXG5cXG4vKioqKioqLyBcXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxcbi8qKioqKiovIFxcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XFxuXFxuLyoqKioqKi8gXFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcXG4vKioqKioqLyBcXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xcblxcbi8qKioqKiovIFxcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXFxuLyoqKioqKi8gXFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXFxcIlxcXCI7XFxuXFxuLyoqKioqKi8gXFx0Ly8gTG9hZCBlbnRyeSBtb2R1bGUgYW5kIHJldHVybiBleHBvcnRzXFxuLyoqKioqKi8gXFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oMCk7XFxuLyoqKioqKi8gfSlcXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xcbi8qKioqKiovIChbXFxuLyogMCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5jYW5vbmljYWxpemUgPSBleHBvcnRzLmNvbnZlcnRDaGFuZ2VzVG9YTUwgPSBleHBvcnRzLmNvbnZlcnRDaGFuZ2VzVG9ETVAgPSBleHBvcnRzLm1lcmdlID0gZXhwb3J0cy5wYXJzZVBhdGNoID0gZXhwb3J0cy5hcHBseVBhdGNoZXMgPSBleHBvcnRzLmFwcGx5UGF0Y2ggPSBleHBvcnRzLmNyZWF0ZVBhdGNoID0gZXhwb3J0cy5jcmVhdGVUd29GaWxlc1BhdGNoID0gZXhwb3J0cy5zdHJ1Y3R1cmVkUGF0Y2ggPSBleHBvcnRzLmRpZmZBcnJheXMgPSBleHBvcnRzLmRpZmZKc29uID0gZXhwb3J0cy5kaWZmQ3NzID0gZXhwb3J0cy5kaWZmU2VudGVuY2VzID0gZXhwb3J0cy5kaWZmVHJpbW1lZExpbmVzID0gZXhwb3J0cy5kaWZmTGluZXMgPSBleHBvcnRzLmRpZmZXb3Jkc1dpdGhTcGFjZSA9IGV4cG9ydHMuZGlmZldvcmRzID0gZXhwb3J0cy5kaWZmQ2hhcnMgPSBleHBvcnRzLkRpZmYgPSB1bmRlZmluZWQ7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY2hhcmFjdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygyKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL193b3JkID0gX193ZWJwYWNrX3JlcXVpcmVfXygzKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19saW5lID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19zZW50ZW5jZSA9IF9fd2VicGFja19yZXF1aXJlX18oNikgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3NzID0gX193ZWJwYWNrX3JlcXVpcmVfXyg3KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19qc29uID0gX193ZWJwYWNrX3JlcXVpcmVfXyg4KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19hcnJheSA9IF9fd2VicGFja19yZXF1aXJlX18oOSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYXBwbHkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX21lcmdlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3JlYXRlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fZG1wID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNikgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9feG1sID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKiBTZWUgTElDRU5TRSBmaWxlIGZvciB0ZXJtcyBvZiB1c2UgKi9cXG5cXG5cXHQvKlxcblxcdCAqIFRleHQgZGlmZiBpbXBsZW1lbnRhdGlvbi5cXG5cXHQgKlxcblxcdCAqIFRoaXMgbGlicmFyeSBzdXBwb3J0cyB0aGUgZm9sbG93aW5nIEFQSVM6XFxuXFx0ICogSnNEaWZmLmRpZmZDaGFyczogQ2hhcmFjdGVyIGJ5IGNoYXJhY3RlciBkaWZmXFxuXFx0ICogSnNEaWZmLmRpZmZXb3JkczogV29yZCAoYXMgZGVmaW5lZCBieSBcXFxcYiByZWdleCkgZGlmZiB3aGljaCBpZ25vcmVzIHdoaXRlc3BhY2VcXG5cXHQgKiBKc0RpZmYuZGlmZkxpbmVzOiBMaW5lIGJhc2VkIGRpZmZcXG5cXHQgKlxcblxcdCAqIEpzRGlmZi5kaWZmQ3NzOiBEaWZmIHRhcmdldGVkIGF0IENTUyBjb250ZW50XFxuXFx0ICpcXG5cXHQgKiBUaGVzZSBtZXRob2RzIGFyZSBiYXNlZCBvbiB0aGUgaW1wbGVtZW50YXRpb24gcHJvcG9zZWQgaW5cXG5cXHQgKiBcXFwiQW4gTyhORCkgRGlmZmVyZW5jZSBBbGdvcml0aG0gYW5kIGl0cyBWYXJpYXRpb25zXFxcIiAoTXllcnMsIDE5ODYpLlxcblxcdCAqIGh0dHA6Ly9jaXRlc2VlcnguaXN0LnBzdS5lZHUvdmlld2RvYy9zdW1tYXJ5P2RvaT0xMC4xLjEuNC42OTI3XFxuXFx0ICovXFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9EaWZmID0gX2Jhc2UyWydkZWZhdWx0J107XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkNoYXJzID0gX2NoYXJhY3Rlci5kaWZmQ2hhcnM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZldvcmRzID0gX3dvcmQuZGlmZldvcmRzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3Jkc1dpdGhTcGFjZSA9IF93b3JkLmRpZmZXb3Jkc1dpdGhTcGFjZTtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmTGluZXMgPSBfbGluZS5kaWZmTGluZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlRyaW1tZWRMaW5lcyA9IF9saW5lLmRpZmZUcmltbWVkTGluZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZlNlbnRlbmNlcyA9IF9zZW50ZW5jZS5kaWZmU2VudGVuY2VzO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDc3MgPSBfY3NzLmRpZmZDc3M7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkpzb24gPSBfanNvbi5kaWZmSnNvbjtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQXJyYXlzID0gX2FycmF5LmRpZmZBcnJheXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc3RydWN0dXJlZFBhdGNoID0gX2NyZWF0ZS5zdHJ1Y3R1cmVkUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3JlYXRlVHdvRmlsZXNQYXRjaCA9IF9jcmVhdGUuY3JlYXRlVHdvRmlsZXNQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jcmVhdGVQYXRjaCA9IF9jcmVhdGUuY3JlYXRlUGF0Y2g7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXBwbHlQYXRjaCA9IF9hcHBseS5hcHBseVBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FwcGx5UGF0Y2hlcyA9IF9hcHBseS5hcHBseVBhdGNoZXM7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovcGFyc2VQYXRjaCA9IF9wYXJzZS5wYXJzZVBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL21lcmdlID0gX21lcmdlLm1lcmdlO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnZlcnRDaGFuZ2VzVG9ETVAgPSBfZG1wLmNvbnZlcnRDaGFuZ2VzVG9ETVA7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udmVydENoYW5nZXNUb1hNTCA9IF94bWwuY29udmVydENoYW5nZXNUb1hNTDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYW5vbmljYWxpemUgPSBfanNvbi5jYW5vbmljYWxpemU7XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0c1snZGVmYXVsdCddID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9EaWZmO1xcblxcdGZ1bmN0aW9uIERpZmYoKSB7fVxcblxcblxcdERpZmYucHJvdG90eXBlID0ge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmY6IGZ1bmN0aW9uIGRpZmYob2xkU3RyaW5nLCBuZXdTdHJpbmcpIHtcXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xcblxcblxcdCAgICB2YXIgY2FsbGJhY2sgPSBvcHRpb25zLmNhbGxiYWNrO1xcblxcdCAgICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcXG5cXHQgICAgICBjYWxsYmFjayA9IG9wdGlvbnM7XFxuXFx0ICAgICAgb3B0aW9ucyA9IHt9O1xcblxcdCAgICB9XFxuXFx0ICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XFxuXFxuXFx0ICAgIHZhciBzZWxmID0gdGhpcztcXG5cXG5cXHQgICAgZnVuY3Rpb24gZG9uZSh2YWx1ZSkge1xcblxcdCAgICAgIGlmIChjYWxsYmFjaykge1xcblxcdCAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XFxuXFx0ICAgICAgICAgIGNhbGxiYWNrKHVuZGVmaW5lZCwgdmFsdWUpO1xcblxcdCAgICAgICAgfSwgMCk7XFxuXFx0ICAgICAgICByZXR1cm4gdHJ1ZTtcXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgcmV0dXJuIHZhbHVlO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBBbGxvdyBzdWJjbGFzc2VzIHRvIG1hc3NhZ2UgdGhlIGlucHV0IHByaW9yIHRvIHJ1bm5pbmdcXG5cXHQgICAgb2xkU3RyaW5nID0gdGhpcy5jYXN0SW5wdXQob2xkU3RyaW5nKTtcXG5cXHQgICAgbmV3U3RyaW5nID0gdGhpcy5jYXN0SW5wdXQobmV3U3RyaW5nKTtcXG5cXG5cXHQgICAgb2xkU3RyaW5nID0gdGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKG9sZFN0cmluZykpO1xcblxcdCAgICBuZXdTdHJpbmcgPSB0aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobmV3U3RyaW5nKSk7XFxuXFxuXFx0ICAgIHZhciBuZXdMZW4gPSBuZXdTdHJpbmcubGVuZ3RoLFxcblxcdCAgICAgICAgb2xkTGVuID0gb2xkU3RyaW5nLmxlbmd0aDtcXG5cXHQgICAgdmFyIGVkaXRMZW5ndGggPSAxO1xcblxcdCAgICB2YXIgbWF4RWRpdExlbmd0aCA9IG5ld0xlbiArIG9sZExlbjtcXG5cXHQgICAgdmFyIGJlc3RQYXRoID0gW3sgbmV3UG9zOiAtMSwgY29tcG9uZW50czogW10gfV07XFxuXFxuXFx0ICAgIC8vIFNlZWQgZWRpdExlbmd0aCA9IDAsIGkuZS4gdGhlIGNvbnRlbnQgc3RhcnRzIHdpdGggdGhlIHNhbWUgdmFsdWVzXFxuXFx0ICAgIHZhciBvbGRQb3MgPSB0aGlzLmV4dHJhY3RDb21tb24oYmVzdFBhdGhbMF0sIG5ld1N0cmluZywgb2xkU3RyaW5nLCAwKTtcXG5cXHQgICAgaWYgKGJlc3RQYXRoWzBdLm5ld1BvcyArIDEgPj0gbmV3TGVuICYmIG9sZFBvcyArIDEgPj0gb2xkTGVuKSB7XFxuXFx0ICAgICAgLy8gSWRlbnRpdHkgcGVyIHRoZSBlcXVhbGl0eSBhbmQgdG9rZW5pemVyXFxuXFx0ICAgICAgcmV0dXJuIGRvbmUoW3sgdmFsdWU6IHRoaXMuam9pbihuZXdTdHJpbmcpLCBjb3VudDogbmV3U3RyaW5nLmxlbmd0aCB9XSk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gTWFpbiB3b3JrZXIgbWV0aG9kLiBjaGVja3MgYWxsIHBlcm11dGF0aW9ucyBvZiBhIGdpdmVuIGVkaXQgbGVuZ3RoIGZvciBhY2NlcHRhbmNlLlxcblxcdCAgICBmdW5jdGlvbiBleGVjRWRpdExlbmd0aCgpIHtcXG5cXHQgICAgICBmb3IgKHZhciBkaWFnb25hbFBhdGggPSAtMSAqIGVkaXRMZW5ndGg7IGRpYWdvbmFsUGF0aCA8PSBlZGl0TGVuZ3RoOyBkaWFnb25hbFBhdGggKz0gMikge1xcblxcdCAgICAgICAgdmFyIGJhc2VQYXRoID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXHQgICAgICAgIHZhciBhZGRQYXRoID0gYmVzdFBhdGhbZGlhZ29uYWxQYXRoIC0gMV0sXFxuXFx0ICAgICAgICAgICAgcmVtb3ZlUGF0aCA9IGJlc3RQYXRoW2RpYWdvbmFsUGF0aCArIDFdLFxcblxcdCAgICAgICAgICAgIF9vbGRQb3MgPSAocmVtb3ZlUGF0aCA/IHJlbW92ZVBhdGgubmV3UG9zIDogMCkgLSBkaWFnb25hbFBhdGg7XFxuXFx0ICAgICAgICBpZiAoYWRkUGF0aCkge1xcblxcdCAgICAgICAgICAvLyBObyBvbmUgZWxzZSBpcyBnb2luZyB0byBhdHRlbXB0IHRvIHVzZSB0aGlzIHZhbHVlLCBjbGVhciBpdFxcblxcdCAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGggLSAxXSA9IHVuZGVmaW5lZDtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHZhciBjYW5BZGQgPSBhZGRQYXRoICYmIGFkZFBhdGgubmV3UG9zICsgMSA8IG5ld0xlbixcXG5cXHQgICAgICAgICAgICBjYW5SZW1vdmUgPSByZW1vdmVQYXRoICYmIDAgPD0gX29sZFBvcyAmJiBfb2xkUG9zIDwgb2xkTGVuO1xcblxcdCAgICAgICAgaWYgKCFjYW5BZGQgJiYgIWNhblJlbW92ZSkge1xcblxcdCAgICAgICAgICAvLyBJZiB0aGlzIHBhdGggaXMgYSB0ZXJtaW5hbCB0aGVuIHBydW5lXFxuXFx0ICAgICAgICAgIGJlc3RQYXRoW2RpYWdvbmFsUGF0aF0gPSB1bmRlZmluZWQ7XFxuXFx0ICAgICAgICAgIGNvbnRpbnVlO1xcblxcdCAgICAgICAgfVxcblxcblxcdCAgICAgICAgLy8gU2VsZWN0IHRoZSBkaWFnb25hbCB0aGF0IHdlIHdhbnQgdG8gYnJhbmNoIGZyb20uIFdlIHNlbGVjdCB0aGUgcHJpb3JcXG5cXHQgICAgICAgIC8vIHBhdGggd2hvc2UgcG9zaXRpb24gaW4gdGhlIG5ldyBzdHJpbmcgaXMgdGhlIGZhcnRoZXN0IGZyb20gdGhlIG9yaWdpblxcblxcdCAgICAgICAgLy8gYW5kIGRvZXMgbm90IHBhc3MgdGhlIGJvdW5kcyBvZiB0aGUgZGlmZiBncmFwaFxcblxcdCAgICAgICAgaWYgKCFjYW5BZGQgfHwgY2FuUmVtb3ZlICYmIGFkZFBhdGgubmV3UG9zIDwgcmVtb3ZlUGF0aC5uZXdQb3MpIHtcXG5cXHQgICAgICAgICAgYmFzZVBhdGggPSBjbG9uZVBhdGgocmVtb3ZlUGF0aCk7XFxuXFx0ICAgICAgICAgIHNlbGYucHVzaENvbXBvbmVudChiYXNlUGF0aC5jb21wb25lbnRzLCB1bmRlZmluZWQsIHRydWUpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgYmFzZVBhdGggPSBhZGRQYXRoOyAvLyBObyBuZWVkIHRvIGNsb25lLCB3ZSd2ZSBwdWxsZWQgaXQgZnJvbSB0aGUgbGlzdFxcblxcdCAgICAgICAgICBiYXNlUGF0aC5uZXdQb3MrKztcXG5cXHQgICAgICAgICAgc2VsZi5wdXNoQ29tcG9uZW50KGJhc2VQYXRoLmNvbXBvbmVudHMsIHRydWUsIHVuZGVmaW5lZCk7XFxuXFx0ICAgICAgICB9XFxuXFxuXFx0ICAgICAgICBfb2xkUG9zID0gc2VsZi5leHRyYWN0Q29tbW9uKGJhc2VQYXRoLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgZGlhZ29uYWxQYXRoKTtcXG5cXG5cXHQgICAgICAgIC8vIElmIHdlIGhhdmUgaGl0IHRoZSBlbmQgb2YgYm90aCBzdHJpbmdzLCB0aGVuIHdlIGFyZSBkb25lXFxuXFx0ICAgICAgICBpZiAoYmFzZVBhdGgubmV3UG9zICsgMSA+PSBuZXdMZW4gJiYgX29sZFBvcyArIDEgPj0gb2xkTGVuKSB7XFxuXFx0ICAgICAgICAgIHJldHVybiBkb25lKGJ1aWxkVmFsdWVzKHNlbGYsIGJhc2VQYXRoLmNvbXBvbmVudHMsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBzZWxmLnVzZUxvbmdlc3RUb2tlbikpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgLy8gT3RoZXJ3aXNlIHRyYWNrIHRoaXMgcGF0aCBhcyBhIHBvdGVudGlhbCBjYW5kaWRhdGUgYW5kIGNvbnRpbnVlLlxcblxcdCAgICAgICAgICBiZXN0UGF0aFtkaWFnb25hbFBhdGhdID0gYmFzZVBhdGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGVkaXRMZW5ndGgrKztcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBQZXJmb3JtcyB0aGUgbGVuZ3RoIG9mIGVkaXQgaXRlcmF0aW9uLiBJcyBhIGJpdCBmdWdseSBhcyB0aGlzIGhhcyB0byBzdXBwb3J0IHRoZVxcblxcdCAgICAvLyBzeW5jIGFuZCBhc3luYyBtb2RlIHdoaWNoIGlzIG5ldmVyIGZ1bi4gTG9vcHMgb3ZlciBleGVjRWRpdExlbmd0aCB1bnRpbCBhIHZhbHVlXFxuXFx0ICAgIC8vIGlzIHByb2R1Y2VkLlxcblxcdCAgICBpZiAoY2FsbGJhY2spIHtcXG5cXHQgICAgICAoZnVuY3Rpb24gZXhlYygpIHtcXG5cXHQgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xcblxcdCAgICAgICAgICAvLyBUaGlzIHNob3VsZCBub3QgaGFwcGVuLCBidXQgd2Ugd2FudCB0byBiZSBzYWZlLlxcblxcdCAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xcblxcdCAgICAgICAgICBpZiAoZWRpdExlbmd0aCA+IG1heEVkaXRMZW5ndGgpIHtcXG5cXHQgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcXG5cXHQgICAgICAgICAgfVxcblxcblxcdCAgICAgICAgICBpZiAoIWV4ZWNFZGl0TGVuZ3RoKCkpIHtcXG5cXHQgICAgICAgICAgICBleGVjKCk7XFxuXFx0ICAgICAgICAgIH1cXG5cXHQgICAgICAgIH0sIDApO1xcblxcdCAgICAgIH0pKCk7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgd2hpbGUgKGVkaXRMZW5ndGggPD0gbWF4RWRpdExlbmd0aCkge1xcblxcdCAgICAgICAgdmFyIHJldCA9IGV4ZWNFZGl0TGVuZ3RoKCk7XFxuXFx0ICAgICAgICBpZiAocmV0KSB7XFxuXFx0ICAgICAgICAgIHJldHVybiByZXQ7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3B1c2hDb21wb25lbnQ6IGZ1bmN0aW9uIHB1c2hDb21wb25lbnQoY29tcG9uZW50cywgYWRkZWQsIHJlbW92ZWQpIHtcXG5cXHQgICAgdmFyIGxhc3QgPSBjb21wb25lbnRzW2NvbXBvbmVudHMubGVuZ3RoIC0gMV07XFxuXFx0ICAgIGlmIChsYXN0ICYmIGxhc3QuYWRkZWQgPT09IGFkZGVkICYmIGxhc3QucmVtb3ZlZCA9PT0gcmVtb3ZlZCkge1xcblxcdCAgICAgIC8vIFdlIG5lZWQgdG8gY2xvbmUgaGVyZSBhcyB0aGUgY29tcG9uZW50IGNsb25lIG9wZXJhdGlvbiBpcyBqdXN0XFxuXFx0ICAgICAgLy8gYXMgc2hhbGxvdyBhcnJheSBjbG9uZVxcblxcdCAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50cy5sZW5ndGggLSAxXSA9IHsgY291bnQ6IGxhc3QuY291bnQgKyAxLCBhZGRlZDogYWRkZWQsIHJlbW92ZWQ6IHJlbW92ZWQgfTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBjb21wb25lbnRzLnB1c2goeyBjb3VudDogMSwgYWRkZWQ6IGFkZGVkLCByZW1vdmVkOiByZW1vdmVkIH0pO1xcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2V4dHJhY3RDb21tb246IGZ1bmN0aW9uIGV4dHJhY3RDb21tb24oYmFzZVBhdGgsIG5ld1N0cmluZywgb2xkU3RyaW5nLCBkaWFnb25hbFBhdGgpIHtcXG5cXHQgICAgdmFyIG5ld0xlbiA9IG5ld1N0cmluZy5sZW5ndGgsXFxuXFx0ICAgICAgICBvbGRMZW4gPSBvbGRTdHJpbmcubGVuZ3RoLFxcblxcdCAgICAgICAgbmV3UG9zID0gYmFzZVBhdGgubmV3UG9zLFxcblxcdCAgICAgICAgb2xkUG9zID0gbmV3UG9zIC0gZGlhZ29uYWxQYXRoLFxcblxcdCAgICAgICAgY29tbW9uQ291bnQgPSAwO1xcblxcdCAgICB3aGlsZSAobmV3UG9zICsgMSA8IG5ld0xlbiAmJiBvbGRQb3MgKyAxIDwgb2xkTGVuICYmIHRoaXMuZXF1YWxzKG5ld1N0cmluZ1tuZXdQb3MgKyAxXSwgb2xkU3RyaW5nW29sZFBvcyArIDFdKSkge1xcblxcdCAgICAgIG5ld1BvcysrO1xcblxcdCAgICAgIG9sZFBvcysrO1xcblxcdCAgICAgIGNvbW1vbkNvdW50Kys7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKGNvbW1vbkNvdW50KSB7XFxuXFx0ICAgICAgYmFzZVBhdGguY29tcG9uZW50cy5wdXNoKHsgY291bnQ6IGNvbW1vbkNvdW50IH0pO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGJhc2VQYXRoLm5ld1BvcyA9IG5ld1BvcztcXG5cXHQgICAgcmV0dXJuIG9sZFBvcztcXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZXF1YWxzOiBmdW5jdGlvbiBlcXVhbHMobGVmdCwgcmlnaHQpIHtcXG5cXHQgICAgaWYgKHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKSB7XFxuXFx0ICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yKGxlZnQsIHJpZ2h0KTtcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICByZXR1cm4gbGVmdCA9PT0gcmlnaHQgfHwgdGhpcy5vcHRpb25zLmlnbm9yZUNhc2UgJiYgbGVmdC50b0xvd2VyQ2FzZSgpID09PSByaWdodC50b0xvd2VyQ2FzZSgpO1xcblxcdCAgICB9XFxuXFx0ICB9LFxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3JlbW92ZUVtcHR5OiBmdW5jdGlvbiByZW1vdmVFbXB0eShhcnJheSkge1xcblxcdCAgICB2YXIgcmV0ID0gW107XFxuXFx0ICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICBpZiAoYXJyYXlbaV0pIHtcXG5cXHQgICAgICAgIHJldC5wdXNoKGFycmF5W2ldKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgcmV0dXJuIHJldDtcXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2FzdElucHV0OiBmdW5jdGlvbiBjYXN0SW5wdXQodmFsdWUpIHtcXG5cXHQgICAgcmV0dXJuIHZhbHVlO1xcblxcdCAgfSxcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90b2tlbml6ZTogZnVuY3Rpb24gdG9rZW5pemUodmFsdWUpIHtcXG5cXHQgICAgcmV0dXJuIHZhbHVlLnNwbGl0KCcnKTtcXG5cXHQgIH0sXFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovIC8qaXN0YW5idWwgaWdub3JlIGVuZCovam9pbjogZnVuY3Rpb24gam9pbihjaGFycykge1xcblxcdCAgICByZXR1cm4gY2hhcnMuam9pbignJyk7XFxuXFx0ICB9XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBidWlsZFZhbHVlcyhkaWZmLCBjb21wb25lbnRzLCBuZXdTdHJpbmcsIG9sZFN0cmluZywgdXNlTG9uZ2VzdFRva2VuKSB7XFxuXFx0ICB2YXIgY29tcG9uZW50UG9zID0gMCxcXG5cXHQgICAgICBjb21wb25lbnRMZW4gPSBjb21wb25lbnRzLmxlbmd0aCxcXG5cXHQgICAgICBuZXdQb3MgPSAwLFxcblxcdCAgICAgIG9sZFBvcyA9IDA7XFxuXFxuXFx0ICBmb3IgKDsgY29tcG9uZW50UG9zIDwgY29tcG9uZW50TGVuOyBjb21wb25lbnRQb3MrKykge1xcblxcdCAgICB2YXIgY29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRQb3NdO1xcblxcdCAgICBpZiAoIWNvbXBvbmVudC5yZW1vdmVkKSB7XFxuXFx0ICAgICAgaWYgKCFjb21wb25lbnQuYWRkZWQgJiYgdXNlTG9uZ2VzdFRva2VuKSB7XFxuXFx0ICAgICAgICB2YXIgdmFsdWUgPSBuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpO1xcblxcdCAgICAgICAgdmFsdWUgPSB2YWx1ZS5tYXAoZnVuY3Rpb24gKHZhbHVlLCBpKSB7XFxuXFx0ICAgICAgICAgIHZhciBvbGRWYWx1ZSA9IG9sZFN0cmluZ1tvbGRQb3MgKyBpXTtcXG5cXHQgICAgICAgICAgcmV0dXJuIG9sZFZhbHVlLmxlbmd0aCA+IHZhbHVlLmxlbmd0aCA/IG9sZFZhbHVlIDogdmFsdWU7XFxuXFx0ICAgICAgICB9KTtcXG5cXG5cXHQgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbih2YWx1ZSk7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIGNvbXBvbmVudC52YWx1ZSA9IGRpZmYuam9pbihuZXdTdHJpbmcuc2xpY2UobmV3UG9zLCBuZXdQb3MgKyBjb21wb25lbnQuY291bnQpKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgbmV3UG9zICs9IGNvbXBvbmVudC5jb3VudDtcXG5cXG5cXHQgICAgICAvLyBDb21tb24gY2FzZVxcblxcdCAgICAgIGlmICghY29tcG9uZW50LmFkZGVkKSB7XFxuXFx0ICAgICAgICBvbGRQb3MgKz0gY29tcG9uZW50LmNvdW50O1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBjb21wb25lbnQudmFsdWUgPSBkaWZmLmpvaW4ob2xkU3RyaW5nLnNsaWNlKG9sZFBvcywgb2xkUG9zICsgY29tcG9uZW50LmNvdW50KSk7XFxuXFx0ICAgICAgb2xkUG9zICs9IGNvbXBvbmVudC5jb3VudDtcXG5cXG5cXHQgICAgICAvLyBSZXZlcnNlIGFkZCBhbmQgcmVtb3ZlIHNvIHJlbW92ZXMgYXJlIG91dHB1dCBmaXJzdCB0byBtYXRjaCBjb21tb24gY29udmVudGlvblxcblxcdCAgICAgIC8vIFRoZSBkaWZmaW5nIGFsZ29yaXRobSBpcyB0aWVkIHRvIGFkZCB0aGVuIHJlbW92ZSBvdXRwdXQgYW5kIHRoaXMgaXMgdGhlIHNpbXBsZXN0XFxuXFx0ICAgICAgLy8gcm91dGUgdG8gZ2V0IHRoZSBkZXNpcmVkIG91dHB1dCB3aXRoIG1pbmltYWwgb3ZlcmhlYWQuXFxuXFx0ICAgICAgaWYgKGNvbXBvbmVudFBvcyAmJiBjb21wb25lbnRzW2NvbXBvbmVudFBvcyAtIDFdLmFkZGVkKSB7XFxuXFx0ICAgICAgICB2YXIgdG1wID0gY29tcG9uZW50c1tjb21wb25lbnRQb3MgLSAxXTtcXG5cXHQgICAgICAgIGNvbXBvbmVudHNbY29tcG9uZW50UG9zIC0gMV0gPSBjb21wb25lbnRzW2NvbXBvbmVudFBvc107XFxuXFx0ICAgICAgICBjb21wb25lbnRzW2NvbXBvbmVudFBvc10gPSB0bXA7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBTcGVjaWFsIGNhc2UgaGFuZGxlIGZvciB3aGVuIG9uZSB0ZXJtaW5hbCBpcyBpZ25vcmVkIChpLmUuIHdoaXRlc3BhY2UpLlxcblxcdCAgLy8gRm9yIHRoaXMgY2FzZSB3ZSBtZXJnZSB0aGUgdGVybWluYWwgaW50byB0aGUgcHJpb3Igc3RyaW5nIGFuZCBkcm9wIHRoZSBjaGFuZ2UuXFxuXFx0ICAvLyBUaGlzIGlzIG9ubHkgYXZhaWxhYmxlIGZvciBzdHJpbmcgbW9kZS5cXG5cXHQgIHZhciBsYXN0Q29tcG9uZW50ID0gY29tcG9uZW50c1tjb21wb25lbnRMZW4gLSAxXTtcXG5cXHQgIGlmIChjb21wb25lbnRMZW4gPiAxICYmIHR5cGVvZiBsYXN0Q29tcG9uZW50LnZhbHVlID09PSAnc3RyaW5nJyAmJiAobGFzdENvbXBvbmVudC5hZGRlZCB8fCBsYXN0Q29tcG9uZW50LnJlbW92ZWQpICYmIGRpZmYuZXF1YWxzKCcnLCBsYXN0Q29tcG9uZW50LnZhbHVlKSkge1xcblxcdCAgICBjb21wb25lbnRzW2NvbXBvbmVudExlbiAtIDJdLnZhbHVlICs9IGxhc3RDb21wb25lbnQudmFsdWU7XFxuXFx0ICAgIGNvbXBvbmVudHMucG9wKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gY29tcG9uZW50cztcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY2xvbmVQYXRoKHBhdGgpIHtcXG5cXHQgIHJldHVybiB7IG5ld1BvczogcGF0aC5uZXdQb3MsIGNvbXBvbmVudHM6IHBhdGguY29tcG9uZW50cy5zbGljZSgwKSB9O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAyICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLmNoYXJhY3RlckRpZmYgPSB1bmRlZmluZWQ7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmQ2hhcnMgPSBkaWZmQ2hhcnM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgY2hhcmFjdGVyRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NoYXJhY3RlckRpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0ZnVuY3Rpb24gZGlmZkNoYXJzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XFxuXFx0ICByZXR1cm4gY2hhcmFjdGVyRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy53b3JkRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZXb3JkcyA9IGRpZmZXb3JkcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmV29yZHNXaXRoU3BhY2UgPSBkaWZmV29yZHNXaXRoU3BhY2U7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3BhcmFtcyA9IF9fd2VicGFja19yZXF1aXJlX18oNCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF9pbnRlcm9wUmVxdWlyZURlZmF1bHQob2JqKSB7IHJldHVybiBvYmogJiYgb2JqLl9fZXNNb2R1bGUgPyBvYmogOiB7ICdkZWZhdWx0Jzogb2JqIH07IH1cXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBCYXNlZCBvbiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbl9zY3JpcHRfaW5fVW5pY29kZVxcblxcdC8vXFxuXFx0Ly8gUmFuZ2VzIGFuZCBleGNlcHRpb25zOlxcblxcdC8vIExhdGluLTEgU3VwcGxlbWVudCwgMDA4MOKAkzAwRkZcXG5cXHQvLyAgLSBVKzAwRDcgIMOXIE11bHRpcGxpY2F0aW9uIHNpZ25cXG5cXHQvLyAgLSBVKzAwRjcgIMO3IERpdmlzaW9uIHNpZ25cXG5cXHQvLyBMYXRpbiBFeHRlbmRlZC1BLCAwMTAw4oCTMDE3RlxcblxcdC8vIExhdGluIEV4dGVuZGVkLUIsIDAxODDigJMwMjRGXFxuXFx0Ly8gSVBBIEV4dGVuc2lvbnMsIDAyNTDigJMwMkFGXFxuXFx0Ly8gU3BhY2luZyBNb2RpZmllciBMZXR0ZXJzLCAwMkIw4oCTMDJGRlxcblxcdC8vICAtIFUrMDJDNyAgy4cgJiM3MTE7ICBDYXJvblxcblxcdC8vICAtIFUrMDJEOCAgy5ggJiM3Mjg7ICBCcmV2ZVxcblxcdC8vICAtIFUrMDJEOSAgy5kgJiM3Mjk7ICBEb3QgQWJvdmVcXG5cXHQvLyAgLSBVKzAyREEgIMuaICYjNzMwOyAgUmluZyBBYm92ZVxcblxcdC8vICAtIFUrMDJEQiAgy5sgJiM3MzE7ICBPZ29uZWtcXG5cXHQvLyAgLSBVKzAyREMgIMucICYjNzMyOyAgU21hbGwgVGlsZGVcXG5cXHQvLyAgLSBVKzAyREQgIMudICYjNzMzOyAgRG91YmxlIEFjdXRlIEFjY2VudFxcblxcdC8vIExhdGluIEV4dGVuZGVkIEFkZGl0aW9uYWwsIDFFMDDigJMxRUZGXFxuXFx0dmFyIGV4dGVuZGVkV29yZENoYXJzID0gL15bQS1aYS16XFxcXHhDMC1cXFxcdTAyQzZcXFxcdTAyQzgtXFxcXHUwMkQ3XFxcXHUwMkRFLVxcXFx1MDJGRlxcXFx1MUUwMC1cXFxcdTFFRkZdKyQvO1xcblxcblxcdHZhciByZVdoaXRlc3BhY2UgPSAvXFxcXFMvO1xcblxcblxcdHZhciB3b3JkRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3dvcmREaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdHdvcmREaWZmLmVxdWFscyA9IGZ1bmN0aW9uIChsZWZ0LCByaWdodCkge1xcblxcdCAgaWYgKHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlKSB7XFxuXFx0ICAgIGxlZnQgPSBsZWZ0LnRvTG93ZXJDYXNlKCk7XFxuXFx0ICAgIHJpZ2h0ID0gcmlnaHQudG9Mb3dlckNhc2UoKTtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiBsZWZ0ID09PSByaWdodCB8fCB0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSAmJiAhcmVXaGl0ZXNwYWNlLnRlc3QobGVmdCkgJiYgIXJlV2hpdGVzcGFjZS50ZXN0KHJpZ2h0KTtcXG5cXHR9O1xcblxcdHdvcmREaWZmLnRva2VuaXplID0gZnVuY3Rpb24gKHZhbHVlKSB7XFxuXFx0ICB2YXIgdG9rZW5zID0gdmFsdWUuc3BsaXQoLyhcXFxccyt8XFxcXGIpLyk7XFxuXFxuXFx0ICAvLyBKb2luIHRoZSBib3VuZGFyeSBzcGxpdHMgdGhhdCB3ZSBkbyBub3QgY29uc2lkZXIgdG8gYmUgYm91bmRhcmllcy4gVGhpcyBpcyBwcmltYXJpbHkgdGhlIGV4dGVuZGVkIExhdGluIGNoYXJhY3RlciBzZXQuXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHRva2Vucy5sZW5ndGggLSAxOyBpKyspIHtcXG5cXHQgICAgLy8gSWYgd2UgaGF2ZSBhbiBlbXB0eSBzdHJpbmcgaW4gdGhlIG5leHQgZmllbGQgYW5kIHdlIGhhdmUgb25seSB3b3JkIGNoYXJzIGJlZm9yZSBhbmQgYWZ0ZXIsIG1lcmdlXFxuXFx0ICAgIGlmICghdG9rZW5zW2kgKyAxXSAmJiB0b2tlbnNbaSArIDJdICYmIGV4dGVuZGVkV29yZENoYXJzLnRlc3QodG9rZW5zW2ldKSAmJiBleHRlbmRlZFdvcmRDaGFycy50ZXN0KHRva2Vuc1tpICsgMl0pKSB7XFxuXFx0ICAgICAgdG9rZW5zW2ldICs9IHRva2Vuc1tpICsgMl07XFxuXFx0ICAgICAgdG9rZW5zLnNwbGljZShpICsgMSwgMik7XFxuXFx0ICAgICAgaS0tO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gdG9rZW5zO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZldvcmRzKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKSB7XFxuXFx0ICBvcHRpb25zID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyYW1zLmdlbmVyYXRlT3B0aW9ucykgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8ob3B0aW9ucywgeyBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlIH0pO1xcblxcdCAgcmV0dXJuIHdvcmREaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBkaWZmV29yZHNXaXRoU3BhY2Uob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiB3b3JkRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9nZW5lcmF0ZU9wdGlvbnMgPSBnZW5lcmF0ZU9wdGlvbnM7XFxuXFx0ZnVuY3Rpb24gZ2VuZXJhdGVPcHRpb25zKG9wdGlvbnMsIGRlZmF1bHRzKSB7XFxuXFx0ICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcXG5cXHQgICAgZGVmYXVsdHMuY2FsbGJhY2sgPSBvcHRpb25zO1xcblxcdCAgfSBlbHNlIGlmIChvcHRpb25zKSB7XFxuXFx0ICAgIGZvciAodmFyIG5hbWUgaW4gb3B0aW9ucykge1xcblxcdCAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBlbHNlICovXFxuXFx0ICAgICAgaWYgKG9wdGlvbnMuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXG5cXHQgICAgICAgIGRlZmF1bHRzW25hbWVdID0gb3B0aW9uc1tuYW1lXTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXHQgIHJldHVybiBkZWZhdWx0cztcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogNSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5saW5lRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZMaW5lcyA9IGRpZmZMaW5lcztcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9kaWZmVHJpbW1lZExpbmVzID0gZGlmZlRyaW1tZWRMaW5lcztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlID0gX193ZWJwYWNrX3JlcXVpcmVfXygxKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9iYXNlMiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX2Jhc2UpO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyYW1zID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGxpbmVEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbGluZURpZmYgPSBuZXcgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19iYXNlMlsnZGVmYXVsdCddIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCk7XFxuXFx0bGluZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHZhciByZXRMaW5lcyA9IFtdLFxcblxcdCAgICAgIGxpbmVzQW5kTmV3bGluZXMgPSB2YWx1ZS5zcGxpdCgvKFxcXFxufFxcXFxyXFxcXG4pLyk7XFxuXFxuXFx0ICAvLyBJZ25vcmUgdGhlIGZpbmFsIGVtcHR5IHRva2VuIHRoYXQgb2NjdXJzIGlmIHRoZSBzdHJpbmcgZW5kcyB3aXRoIGEgbmV3IGxpbmVcXG5cXHQgIGlmICghbGluZXNBbmROZXdsaW5lc1tsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aCAtIDFdKSB7XFxuXFx0ICAgIGxpbmVzQW5kTmV3bGluZXMucG9wKCk7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBNZXJnZSB0aGUgY29udGVudCBhbmQgbGluZSBzZXBhcmF0b3JzIGludG8gc2luZ2xlIHRva2Vuc1xcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaW5lc0FuZE5ld2xpbmVzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIHZhciBsaW5lID0gbGluZXNBbmROZXdsaW5lc1tpXTtcXG5cXG5cXHQgICAgaWYgKGkgJSAyICYmICF0aGlzLm9wdGlvbnMubmV3bGluZUlzVG9rZW4pIHtcXG5cXHQgICAgICByZXRMaW5lc1tyZXRMaW5lcy5sZW5ndGggLSAxXSArPSBsaW5lO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGlmICh0aGlzLm9wdGlvbnMuaWdub3JlV2hpdGVzcGFjZSkge1xcblxcdCAgICAgICAgbGluZSA9IGxpbmUudHJpbSgpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICByZXRMaW5lcy5wdXNoKGxpbmUpO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmV0TGluZXM7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmTGluZXMob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKSB7XFxuXFx0ICByZXR1cm4gbGluZURpZmYuZGlmZihvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spO1xcblxcdH1cXG5cXHRmdW5jdGlvbiBkaWZmVHJpbW1lZExpbmVzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcblxcdCAgdmFyIG9wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJhbXMuZ2VuZXJhdGVPcHRpb25zKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhjYWxsYmFjaywgeyBpZ25vcmVXaGl0ZXNwYWNlOiB0cnVlIH0pO1xcblxcdCAgcmV0dXJuIGxpbmVEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIG9wdGlvbnMpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiA2ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8ndXNlIHN0cmljdCc7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLnNlbnRlbmNlRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZTZW50ZW5jZXMgPSBkaWZmU2VudGVuY2VzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIHNlbnRlbmNlRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3NlbnRlbmNlRGlmZiA9IG5ldyAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UyWydkZWZhdWx0J10gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oKTtcXG5cXHRzZW50ZW5jZURpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHJldHVybiB2YWx1ZS5zcGxpdCgvKFxcXFxTLis/Wy4hP10pKD89XFxcXHMrfCQpLyk7XFxuXFx0fTtcXG5cXG5cXHRmdW5jdGlvbiBkaWZmU2VudGVuY2VzKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjaykge1xcblxcdCAgcmV0dXJuIHNlbnRlbmNlRGlmZi5kaWZmKG9sZFN0ciwgbmV3U3RyLCBjYWxsYmFjayk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDcgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuY3NzRGlmZiA9IHVuZGVmaW5lZDtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2RpZmZDc3MgPSBkaWZmQ3NzO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2Jhc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2Jhc2UyID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChfYmFzZSk7XFxuXFxuXFx0ZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHsgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHsgJ2RlZmF1bHQnOiBvYmogfTsgfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovdmFyIGNzc0RpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jc3NEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdGNzc0RpZmYudG9rZW5pemUgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIHJldHVybiB2YWx1ZS5zcGxpdCgvKFt7fTo7LF18XFxcXHMrKS8pO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZkNzcyhvbGRTdHIsIG5ld1N0ciwgY2FsbGJhY2spIHtcXG5cXHQgIHJldHVybiBjc3NEaWZmLmRpZmYob2xkU3RyLCBuZXdTdHIsIGNhbGxiYWNrKTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogOCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy5qc29uRGlmZiA9IHVuZGVmaW5lZDtcXG5cXG5cXHR2YXIgX3R5cGVvZiA9IHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXFxcInN5bWJvbFxcXCIgPyBmdW5jdGlvbiAob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9IDogZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gb2JqICYmIHR5cGVvZiBTeW1ib2wgPT09IFxcXCJmdW5jdGlvblxcXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXFxcInN5bWJvbFxcXCIgOiB0eXBlb2Ygb2JqOyB9O1xcblxcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkpzb24gPSBkaWZmSnNvbjtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYW5vbmljYWxpemUgPSBjYW5vbmljYWxpemU7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2xpbmUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDUpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nO1xcblxcblxcdHZhciBqc29uRGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2pzb25EaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdC8vIERpc2NyaW1pbmF0ZSBiZXR3ZWVuIHR3byBsaW5lcyBvZiBwcmV0dHktcHJpbnRlZCwgc2VyaWFsaXplZCBKU09OIHdoZXJlIG9uZSBvZiB0aGVtIGhhcyBhXFxuXFx0Ly8gZGFuZ2xpbmcgY29tbWEgYW5kIHRoZSBvdGhlciBkb2Vzbid0LiBUdXJucyBvdXQgaW5jbHVkaW5nIHRoZSBkYW5nbGluZyBjb21tYSB5aWVsZHMgdGhlIG5pY2VzdCBvdXRwdXQ6XFxuXFx0anNvbkRpZmYudXNlTG9uZ2VzdFRva2VuID0gdHJ1ZTtcXG5cXG5cXHRqc29uRGlmZi50b2tlbml6ZSA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZS5saW5lRGlmZiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLy50b2tlbml6ZTtcXG5cXHRqc29uRGlmZi5jYXN0SW5wdXQgPSBmdW5jdGlvbiAodmFsdWUpIHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX29wdGlvbnMgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3RoaXMub3B0aW9ucyxcXG5cXHQgICAgICB1bmRlZmluZWRSZXBsYWNlbWVudCA9IF9vcHRpb25zLnVuZGVmaW5lZFJlcGxhY2VtZW50LFxcblxcdCAgICAgIF9vcHRpb25zJHN0cmluZ2lmeVJlcCA9IF9vcHRpb25zLnN0cmluZ2lmeVJlcGxhY2VyLFxcblxcdCAgICAgIHN0cmluZ2lmeVJlcGxhY2VyID0gX29wdGlvbnMkc3RyaW5naWZ5UmVwID09PSB1bmRlZmluZWQgPyBmdW5jdGlvbiAoaywgdikgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3tcXG5cXHQgICAgcmV0dXJuICgvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL3R5cGVvZiB2ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZFJlcGxhY2VtZW50IDogdlxcblxcdCAgICApO1xcblxcdCAgfSA6IF9vcHRpb25zJHN0cmluZ2lmeVJlcDtcXG5cXG5cXG5cXHQgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnID8gdmFsdWUgOiBKU09OLnN0cmluZ2lmeShjYW5vbmljYWxpemUodmFsdWUsIG51bGwsIG51bGwsIHN0cmluZ2lmeVJlcGxhY2VyKSwgc3RyaW5naWZ5UmVwbGFjZXIsICcgICcpO1xcblxcdH07XFxuXFx0anNvbkRpZmYuZXF1YWxzID0gZnVuY3Rpb24gKGxlZnQsIHJpZ2h0KSB7XFxuXFx0ICByZXR1cm4gKC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLy5wcm90b3R5cGUuZXF1YWxzLmNhbGwoanNvbkRpZmYsIGxlZnQucmVwbGFjZSgvLChbXFxcXHJcXFxcbl0pL2csICckMScpLCByaWdodC5yZXBsYWNlKC8sKFtcXFxcclxcXFxuXSkvZywgJyQxJykpXFxuXFx0ICApO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZkpzb24ob2xkT2JqLCBuZXdPYmosIG9wdGlvbnMpIHtcXG5cXHQgIHJldHVybiBqc29uRGlmZi5kaWZmKG9sZE9iaiwgbmV3T2JqLCBvcHRpb25zKTtcXG5cXHR9XFxuXFxuXFx0Ly8gVGhpcyBmdW5jdGlvbiBoYW5kbGVzIHRoZSBwcmVzZW5jZSBvZiBjaXJjdWxhciByZWZlcmVuY2VzIGJ5IGJhaWxpbmcgb3V0IHdoZW4gZW5jb3VudGVyaW5nIGFuXFxuXFx0Ly8gb2JqZWN0IHRoYXQgaXMgYWxyZWFkeSBvbiB0aGUgXFxcInN0YWNrXFxcIiBvZiBpdGVtcyBiZWluZyBwcm9jZXNzZWQuIEFjY2VwdHMgYW4gb3B0aW9uYWwgcmVwbGFjZXJcXG5cXHRmdW5jdGlvbiBjYW5vbmljYWxpemUob2JqLCBzdGFjaywgcmVwbGFjZW1lbnRTdGFjaywgcmVwbGFjZXIsIGtleSkge1xcblxcdCAgc3RhY2sgPSBzdGFjayB8fCBbXTtcXG5cXHQgIHJlcGxhY2VtZW50U3RhY2sgPSByZXBsYWNlbWVudFN0YWNrIHx8IFtdO1xcblxcblxcdCAgaWYgKHJlcGxhY2VyKSB7XFxuXFx0ICAgIG9iaiA9IHJlcGxhY2VyKGtleSwgb2JqKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBpID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHQgIGZvciAoaSA9IDA7IGkgPCBzdGFjay5sZW5ndGg7IGkgKz0gMSkge1xcblxcdCAgICBpZiAoc3RhY2tbaV0gPT09IG9iaikge1xcblxcdCAgICAgIHJldHVybiByZXBsYWNlbWVudFN0YWNrW2ldO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgY2Fub25pY2FsaXplZE9iaiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0ICBpZiAoJ1tvYmplY3QgQXJyYXldJyA9PT0gb2JqZWN0UHJvdG90eXBlVG9TdHJpbmcuY2FsbChvYmopKSB7XFxuXFx0ICAgIHN0YWNrLnB1c2gob2JqKTtcXG5cXHQgICAgY2Fub25pY2FsaXplZE9iaiA9IG5ldyBBcnJheShvYmoubGVuZ3RoKTtcXG5cXHQgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcblxcdCAgICBmb3IgKGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0ICAgICAgY2Fub25pY2FsaXplZE9ialtpXSA9IGNhbm9uaWNhbGl6ZShvYmpbaV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwga2V5KTtcXG5cXHQgICAgfVxcblxcdCAgICBzdGFjay5wb3AoKTtcXG5cXHQgICAgcmVwbGFjZW1lbnRTdGFjay5wb3AoKTtcXG5cXHQgICAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAob2JqICYmIG9iai50b0pTT04pIHtcXG5cXHQgICAgb2JqID0gb2JqLnRvSlNPTigpO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKHR5cGVvZiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29iaiA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2Yob2JqKSkgPT09ICdvYmplY3QnICYmIG9iaiAhPT0gbnVsbCkge1xcblxcdCAgICBzdGFjay5wdXNoKG9iaik7XFxuXFx0ICAgIGNhbm9uaWNhbGl6ZWRPYmogPSB7fTtcXG5cXHQgICAgcmVwbGFjZW1lbnRTdGFjay5wdXNoKGNhbm9uaWNhbGl6ZWRPYmopO1xcblxcdCAgICB2YXIgc29ydGVkS2V5cyA9IFtdLFxcblxcdCAgICAgICAgX2tleSA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFx0ICAgIGZvciAoX2tleSBpbiBvYmopIHtcXG5cXHQgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xcblxcdCAgICAgIGlmIChvYmouaGFzT3duUHJvcGVydHkoX2tleSkpIHtcXG5cXHQgICAgICAgIHNvcnRlZEtleXMucHVzaChfa2V5KTtcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgICAgc29ydGVkS2V5cy5zb3J0KCk7XFxuXFx0ICAgIGZvciAoaSA9IDA7IGkgPCBzb3J0ZWRLZXlzLmxlbmd0aDsgaSArPSAxKSB7XFxuXFx0ICAgICAgX2tleSA9IHNvcnRlZEtleXNbaV07XFxuXFx0ICAgICAgY2Fub25pY2FsaXplZE9ialtfa2V5XSA9IGNhbm9uaWNhbGl6ZShvYmpbX2tleV0sIHN0YWNrLCByZXBsYWNlbWVudFN0YWNrLCByZXBsYWNlciwgX2tleSk7XFxuXFx0ICAgIH1cXG5cXHQgICAgc3RhY2sucG9wKCk7XFxuXFx0ICAgIHJlcGxhY2VtZW50U3RhY2sucG9wKCk7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBjYW5vbmljYWxpemVkT2JqID0gb2JqO1xcblxcdCAgfVxcblxcdCAgcmV0dXJuIGNhbm9uaWNhbGl6ZWRPYmo7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDkgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuYXJyYXlEaWZmID0gdW5kZWZpbmVkO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovZGlmZkFycmF5cyA9IGRpZmZBcnJheXM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfYmFzZTIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9iYXNlKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi92YXIgYXJyYXlEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovYXJyYXlEaWZmID0gbmV3IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fYmFzZTJbJ2RlZmF1bHQnXSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLygpO1xcblxcdGFycmF5RGlmZi50b2tlbml6ZSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlLnNsaWNlKCk7XFxuXFx0fTtcXG5cXHRhcnJheURpZmYuam9pbiA9IGFycmF5RGlmZi5yZW1vdmVFbXB0eSA9IGZ1bmN0aW9uICh2YWx1ZSkge1xcblxcdCAgcmV0dXJuIHZhbHVlO1xcblxcdH07XFxuXFxuXFx0ZnVuY3Rpb24gZGlmZkFycmF5cyhvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spIHtcXG5cXHQgIHJldHVybiBhcnJheURpZmYuZGlmZihvbGRBcnIsIG5ld0FyciwgY2FsbGJhY2spO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMCAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoID0gYXBwbHlQYXRjaDtcXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9hcHBseVBhdGNoZXMgPSBhcHBseVBhdGNoZXM7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19kaXN0YW5jZUl0ZXJhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMikgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfZGlzdGFuY2VJdGVyYXRvcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9kaXN0YW5jZUl0ZXJhdG9yKTtcXG5cXG5cXHRmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikgeyByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDogeyAnZGVmYXVsdCc6IG9iaiB9OyB9XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9mdW5jdGlvbiBhcHBseVBhdGNoKHNvdXJjZSwgdW5pRGlmZikge1xcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL29wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IHt9O1xcblxcblxcdCAgaWYgKHR5cGVvZiB1bmlEaWZmID09PSAnc3RyaW5nJykge1xcblxcdCAgICB1bmlEaWZmID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLygwLCBfcGFyc2UucGFyc2VQYXRjaCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odW5pRGlmZik7XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoQXJyYXkuaXNBcnJheSh1bmlEaWZmKSkge1xcblxcdCAgICBpZiAodW5pRGlmZi5sZW5ndGggPiAxKSB7XFxuXFx0ICAgICAgdGhyb3cgbmV3IEVycm9yKCdhcHBseVBhdGNoIG9ubHkgd29ya3Mgd2l0aCBhIHNpbmdsZSBpbnB1dC4nKTtcXG5cXHQgICAgfVxcblxcblxcdCAgICB1bmlEaWZmID0gdW5pRGlmZlswXTtcXG5cXHQgIH1cXG5cXG5cXHQgIC8vIEFwcGx5IHRoZSBkaWZmIHRvIHRoZSBpbnB1dFxcblxcdCAgdmFyIGxpbmVzID0gc291cmNlLnNwbGl0KC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdLyksXFxuXFx0ICAgICAgZGVsaW1pdGVycyA9IHNvdXJjZS5tYXRjaCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS9nKSB8fCBbXSxcXG5cXHQgICAgICBodW5rcyA9IHVuaURpZmYuaHVua3MsXFxuXFx0ICAgICAgY29tcGFyZUxpbmUgPSBvcHRpb25zLmNvbXBhcmVMaW5lIHx8IGZ1bmN0aW9uIChsaW5lTnVtYmVyLCBsaW5lLCBvcGVyYXRpb24sIHBhdGNoQ29udGVudCkgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3tcXG5cXHQgICAgcmV0dXJuICgvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2xpbmUgPT09IHBhdGNoQ29udGVudFxcblxcdCAgICApO1xcblxcdCAgfSxcXG5cXHQgICAgICBlcnJvckNvdW50ID0gMCxcXG5cXHQgICAgICBmdXp6RmFjdG9yID0gb3B0aW9ucy5mdXp6RmFjdG9yIHx8IDAsXFxuXFx0ICAgICAgbWluTGluZSA9IDAsXFxuXFx0ICAgICAgb2Zmc2V0ID0gMCxcXG5cXHQgICAgICByZW1vdmVFT0ZOTCA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sXFxuXFx0ICAgICAgYWRkRU9GTkwgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdm9pZCAwIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdCAgLyoqXFxuXFx0ICAgKiBDaGVja3MgaWYgdGhlIGh1bmsgZXhhY3RseSBmaXRzIG9uIHRoZSBwcm92aWRlZCBsb2NhdGlvblxcblxcdCAgICovXFxuXFx0ICBmdW5jdGlvbiBodW5rRml0cyhodW5rLCB0b1Bvcykge1xcblxcdCAgICBmb3IgKHZhciBqID0gMDsgaiA8IGh1bmsubGluZXMubGVuZ3RoOyBqKyspIHtcXG5cXHQgICAgICB2YXIgbGluZSA9IGh1bmsubGluZXNbal0sXFxuXFx0ICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXFxuXFx0ICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmU7XFxuXFxuXFx0ICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJy0nKSB7XFxuXFx0ICAgICAgICAvLyBDb250ZXh0IHNhbml0eSBjaGVja1xcblxcdCAgICAgICAgaWYgKCFjb21wYXJlTGluZSh0b1BvcyArIDEsIGxpbmVzW3RvUG9zXSwgb3BlcmF0aW9uLCBjb250ZW50KSkge1xcblxcdCAgICAgICAgICBlcnJvckNvdW50Kys7XFxuXFxuXFx0ICAgICAgICAgIGlmIChlcnJvckNvdW50ID4gZnV6ekZhY3Rvcikge1xcblxcdCAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG5cXHQgICAgICAgICAgfVxcblxcdCAgICAgICAgfVxcblxcdCAgICAgICAgdG9Qb3MrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0dXJuIHRydWU7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBTZWFyY2ggYmVzdCBmaXQgb2Zmc2V0cyBmb3IgZWFjaCBodW5rIGJhc2VkIG9uIHRoZSBwcmV2aW91cyBvbmVzXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGh1bmtzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIHZhciBodW5rID0gaHVua3NbaV0sXFxuXFx0ICAgICAgICBtYXhMaW5lID0gbGluZXMubGVuZ3RoIC0gaHVuay5vbGRMaW5lcyxcXG5cXHQgICAgICAgIGxvY2FsT2Zmc2V0ID0gMCxcXG5cXHQgICAgICAgIHRvUG9zID0gb2Zmc2V0ICsgaHVuay5vbGRTdGFydCAtIDE7XFxuXFxuXFx0ICAgIHZhciBpdGVyYXRvciA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2Rpc3RhbmNlSXRlcmF0b3IyWydkZWZhdWx0J10pIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKHRvUG9zLCBtaW5MaW5lLCBtYXhMaW5lKTtcXG5cXG5cXHQgICAgZm9yICg7IGxvY2FsT2Zmc2V0ICE9PSB1bmRlZmluZWQ7IGxvY2FsT2Zmc2V0ID0gaXRlcmF0b3IoKSkge1xcblxcdCAgICAgIGlmIChodW5rRml0cyhodW5rLCB0b1BvcyArIGxvY2FsT2Zmc2V0KSkge1xcblxcdCAgICAgICAgaHVuay5vZmZzZXQgPSBvZmZzZXQgKz0gbG9jYWxPZmZzZXQ7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgaWYgKGxvY2FsT2Zmc2V0ID09PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgLy8gU2V0IGxvd2VyIHRleHQgbGltaXQgdG8gZW5kIG9mIHRoZSBjdXJyZW50IGh1bmssIHNvIG5leHQgb25lcyBkb24ndCB0cnlcXG5cXHQgICAgLy8gdG8gZml0IG92ZXIgYWxyZWFkeSBwYXRjaGVkIHRleHRcXG5cXHQgICAgbWluTGluZSA9IGh1bmsub2Zmc2V0ICsgaHVuay5vbGRTdGFydCArIGh1bmsub2xkTGluZXM7XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBBcHBseSBwYXRjaCBodW5rc1xcblxcdCAgdmFyIGRpZmZPZmZzZXQgPSAwO1xcblxcdCAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGh1bmtzLmxlbmd0aDsgX2krKykge1xcblxcdCAgICB2YXIgX2h1bmsgPSBodW5rc1tfaV0sXFxuXFx0ICAgICAgICBfdG9Qb3MgPSBfaHVuay5vbGRTdGFydCArIF9odW5rLm9mZnNldCArIGRpZmZPZmZzZXQgLSAxO1xcblxcdCAgICBkaWZmT2Zmc2V0ICs9IF9odW5rLm5ld0xpbmVzIC0gX2h1bmsub2xkTGluZXM7XFxuXFxuXFx0ICAgIGlmIChfdG9Qb3MgPCAwKSB7XFxuXFx0ICAgICAgLy8gQ3JlYXRpbmcgYSBuZXcgZmlsZVxcblxcdCAgICAgIF90b1BvcyA9IDA7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgZm9yICh2YXIgaiA9IDA7IGogPCBfaHVuay5saW5lcy5sZW5ndGg7IGorKykge1xcblxcdCAgICAgIHZhciBsaW5lID0gX2h1bmsubGluZXNbal0sXFxuXFx0ICAgICAgICAgIG9wZXJhdGlvbiA9IGxpbmUubGVuZ3RoID4gMCA/IGxpbmVbMF0gOiAnICcsXFxuXFx0ICAgICAgICAgIGNvbnRlbnQgPSBsaW5lLmxlbmd0aCA+IDAgPyBsaW5lLnN1YnN0cigxKSA6IGxpbmUsXFxuXFx0ICAgICAgICAgIGRlbGltaXRlciA9IF9odW5rLmxpbmVkZWxpbWl0ZXJzW2pdO1xcblxcblxcdCAgICAgIGlmIChvcGVyYXRpb24gPT09ICcgJykge1xcblxcdCAgICAgICAgX3RvUG9zKys7XFxuXFx0ICAgICAgfSBlbHNlIGlmIChvcGVyYXRpb24gPT09ICctJykge1xcblxcdCAgICAgICAgbGluZXMuc3BsaWNlKF90b1BvcywgMSk7XFxuXFx0ICAgICAgICBkZWxpbWl0ZXJzLnNwbGljZShfdG9Qb3MsIDEpO1xcblxcdCAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cXG5cXHQgICAgICB9IGVsc2UgaWYgKG9wZXJhdGlvbiA9PT0gJysnKSB7XFxuXFx0ICAgICAgICBsaW5lcy5zcGxpY2UoX3RvUG9zLCAwLCBjb250ZW50KTtcXG5cXHQgICAgICAgIGRlbGltaXRlcnMuc3BsaWNlKF90b1BvcywgMCwgZGVsaW1pdGVyKTtcXG5cXHQgICAgICAgIF90b1BvcysrO1xcblxcdCAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnXFxcXFxcXFwnKSB7XFxuXFx0ICAgICAgICB2YXIgcHJldmlvdXNPcGVyYXRpb24gPSBfaHVuay5saW5lc1tqIC0gMV0gPyBfaHVuay5saW5lc1tqIC0gMV1bMF0gOiBudWxsO1xcblxcdCAgICAgICAgaWYgKHByZXZpb3VzT3BlcmF0aW9uID09PSAnKycpIHtcXG5cXHQgICAgICAgICAgcmVtb3ZlRU9GTkwgPSB0cnVlO1xcblxcdCAgICAgICAgfSBlbHNlIGlmIChwcmV2aW91c09wZXJhdGlvbiA9PT0gJy0nKSB7XFxuXFx0ICAgICAgICAgIGFkZEVPRk5MID0gdHJ1ZTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIEhhbmRsZSBFT0ZOTCBpbnNlcnRpb24vcmVtb3ZhbFxcblxcdCAgaWYgKHJlbW92ZUVPRk5MKSB7XFxuXFx0ICAgIHdoaWxlICghbGluZXNbbGluZXMubGVuZ3RoIC0gMV0pIHtcXG5cXHQgICAgICBsaW5lcy5wb3AoKTtcXG5cXHQgICAgICBkZWxpbWl0ZXJzLnBvcCgpO1xcblxcdCAgICB9XFxuXFx0ICB9IGVsc2UgaWYgKGFkZEVPRk5MKSB7XFxuXFx0ICAgIGxpbmVzLnB1c2goJycpO1xcblxcdCAgICBkZWxpbWl0ZXJzLnB1c2goJ1xcXFxuJyk7XFxuXFx0ICB9XFxuXFx0ICBmb3IgKHZhciBfayA9IDA7IF9rIDwgbGluZXMubGVuZ3RoIC0gMTsgX2srKykge1xcblxcdCAgICBsaW5lc1tfa10gPSBsaW5lc1tfa10gKyBkZWxpbWl0ZXJzW19rXTtcXG5cXHQgIH1cXG5cXHQgIHJldHVybiBsaW5lcy5qb2luKCcnKTtcXG5cXHR9XFxuXFxuXFx0Ly8gV3JhcHBlciB0aGF0IHN1cHBvcnRzIG11bHRpcGxlIGZpbGUgcGF0Y2hlcyB2aWEgY2FsbGJhY2tzLlxcblxcdGZ1bmN0aW9uIGFwcGx5UGF0Y2hlcyh1bmlEaWZmLCBvcHRpb25zKSB7XFxuXFx0ICBpZiAodHlwZW9mIHVuaURpZmYgPT09ICdzdHJpbmcnKSB7XFxuXFx0ICAgIHVuaURpZmYgPSAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmlEaWZmKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHZhciBjdXJyZW50SW5kZXggPSAwO1xcblxcdCAgZnVuY3Rpb24gcHJvY2Vzc0luZGV4KCkge1xcblxcdCAgICB2YXIgaW5kZXggPSB1bmlEaWZmW2N1cnJlbnRJbmRleCsrXTtcXG5cXHQgICAgaWYgKCFpbmRleCkge1xcblxcdCAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKCk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgb3B0aW9ucy5sb2FkRmlsZShpbmRleCwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xcblxcdCAgICAgIGlmIChlcnIpIHtcXG5cXHQgICAgICAgIHJldHVybiBvcHRpb25zLmNvbXBsZXRlKGVycik7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIHZhciB1cGRhdGVkQ29udGVudCA9IGFwcGx5UGF0Y2goZGF0YSwgaW5kZXgsIG9wdGlvbnMpO1xcblxcdCAgICAgIG9wdGlvbnMucGF0Y2hlZChpbmRleCwgdXBkYXRlZENvbnRlbnQsIGZ1bmN0aW9uIChlcnIpIHtcXG5cXHQgICAgICAgIGlmIChlcnIpIHtcXG5cXHQgICAgICAgICAgcmV0dXJuIG9wdGlvbnMuY29tcGxldGUoZXJyKTtcXG5cXHQgICAgICAgIH1cXG5cXG5cXHQgICAgICAgIHByb2Nlc3NJbmRleCgpO1xcblxcdCAgICAgIH0pO1xcblxcdCAgICB9KTtcXG5cXHQgIH1cXG5cXHQgIHByb2Nlc3NJbmRleCgpO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxMSAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9wYXJzZVBhdGNoID0gcGFyc2VQYXRjaDtcXG5cXHRmdW5jdGlvbiBwYXJzZVBhdGNoKHVuaURpZmYpIHtcXG5cXHQgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9vcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcXG5cXG5cXHQgIHZhciBkaWZmc3RyID0gdW5pRGlmZi5zcGxpdCgvXFxcXHJcXFxcbnxbXFxcXG5cXFxcdlxcXFxmXFxcXHJcXFxceDg1XS8pLFxcblxcdCAgICAgIGRlbGltaXRlcnMgPSB1bmlEaWZmLm1hdGNoKC9cXFxcclxcXFxufFtcXFxcblxcXFx2XFxcXGZcXFxcclxcXFx4ODVdL2cpIHx8IFtdLFxcblxcdCAgICAgIGxpc3QgPSBbXSxcXG5cXHQgICAgICBpID0gMDtcXG5cXG5cXHQgIGZ1bmN0aW9uIHBhcnNlSW5kZXgoKSB7XFxuXFx0ICAgIHZhciBpbmRleCA9IHt9O1xcblxcdCAgICBsaXN0LnB1c2goaW5kZXgpO1xcblxcblxcdCAgICAvLyBQYXJzZSBkaWZmIG1ldGFkYXRhXFxuXFx0ICAgIHdoaWxlIChpIDwgZGlmZnN0ci5sZW5ndGgpIHtcXG5cXHQgICAgICB2YXIgbGluZSA9IGRpZmZzdHJbaV07XFxuXFxuXFx0ICAgICAgLy8gRmlsZSBoZWFkZXIgZm91bmQsIGVuZCBwYXJzaW5nIGRpZmYgbWV0YWRhdGFcXG5cXHQgICAgICBpZiAoL14oXFxcXC1cXFxcLVxcXFwtfFxcXFwrXFxcXCtcXFxcK3xAQClcXFxccy8udGVzdChsaW5lKSkge1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIC8vIERpZmYgaW5kZXhcXG5cXHQgICAgICB2YXIgaGVhZGVyID0gL14oPzpJbmRleDp8ZGlmZig/OiAtciBcXFxcdyspKylcXFxccysoLis/KVxcXFxzKiQvLmV4ZWMobGluZSk7XFxuXFx0ICAgICAgaWYgKGhlYWRlcikge1xcblxcdCAgICAgICAgaW5kZXguaW5kZXggPSBoZWFkZXJbMV07XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIGkrKztcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBQYXJzZSBmaWxlIGhlYWRlcnMgaWYgdGhleSBhcmUgZGVmaW5lZC4gVW5pZmllZCBkaWZmIHJlcXVpcmVzIHRoZW0sIGJ1dFxcblxcdCAgICAvLyB0aGVyZSdzIG5vIHRlY2huaWNhbCBpc3N1ZXMgdG8gaGF2ZSBhbiBpc29sYXRlZCBodW5rIHdpdGhvdXQgZmlsZSBoZWFkZXJcXG5cXHQgICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcXG5cXHQgICAgcGFyc2VGaWxlSGVhZGVyKGluZGV4KTtcXG5cXG5cXHQgICAgLy8gUGFyc2UgaHVua3NcXG5cXHQgICAgaW5kZXguaHVua3MgPSBbXTtcXG5cXG5cXHQgICAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcblxcdCAgICAgIHZhciBfbGluZSA9IGRpZmZzdHJbaV07XFxuXFxuXFx0ICAgICAgaWYgKC9eKEluZGV4OnxkaWZmfFxcXFwtXFxcXC1cXFxcLXxcXFxcK1xcXFwrXFxcXCspXFxcXHMvLnRlc3QoX2xpbmUpKSB7XFxuXFx0ICAgICAgICBicmVhaztcXG5cXHQgICAgICB9IGVsc2UgaWYgKC9eQEAvLnRlc3QoX2xpbmUpKSB7XFxuXFx0ICAgICAgICBpbmRleC5odW5rcy5wdXNoKHBhcnNlSHVuaygpKTtcXG5cXHQgICAgICB9IGVsc2UgaWYgKF9saW5lICYmIG9wdGlvbnMuc3RyaWN0KSB7XFxuXFx0ICAgICAgICAvLyBJZ25vcmUgdW5leHBlY3RlZCBjb250ZW50IHVubGVzcyBpbiBzdHJpY3QgbW9kZVxcblxcdCAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIGxpbmUgJyArIChpICsgMSkgKyAnICcgKyBKU09OLnN0cmluZ2lmeShfbGluZSkpO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICBpKys7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICAvLyBQYXJzZXMgdGhlIC0tLSBhbmQgKysrIGhlYWRlcnMsIGlmIG5vbmUgYXJlIGZvdW5kLCBubyBsaW5lc1xcblxcdCAgLy8gYXJlIGNvbnN1bWVkLlxcblxcdCAgZnVuY3Rpb24gcGFyc2VGaWxlSGVhZGVyKGluZGV4KSB7XFxuXFx0ICAgIHZhciBmaWxlSGVhZGVyID0gL14oLS0tfFxcXFwrXFxcXCtcXFxcKylcXFxccysoLiopJC8uZXhlYyhkaWZmc3RyW2ldKTtcXG5cXHQgICAgaWYgKGZpbGVIZWFkZXIpIHtcXG5cXHQgICAgICB2YXIga2V5UHJlZml4ID0gZmlsZUhlYWRlclsxXSA9PT0gJy0tLScgPyAnb2xkJyA6ICduZXcnO1xcblxcdCAgICAgIHZhciBkYXRhID0gZmlsZUhlYWRlclsyXS5zcGxpdCgnXFxcXHQnLCAyKTtcXG5cXHQgICAgICB2YXIgZmlsZU5hbWUgPSBkYXRhWzBdLnJlcGxhY2UoL1xcXFxcXFxcXFxcXFxcXFwvZywgJ1xcXFxcXFxcJyk7XFxuXFx0ICAgICAgaWYgKC9eXFxcIi4qXFxcIiQvLnRlc3QoZmlsZU5hbWUpKSB7XFxuXFx0ICAgICAgICBmaWxlTmFtZSA9IGZpbGVOYW1lLnN1YnN0cigxLCBmaWxlTmFtZS5sZW5ndGggLSAyKTtcXG5cXHQgICAgICB9XFxuXFx0ICAgICAgaW5kZXhba2V5UHJlZml4ICsgJ0ZpbGVOYW1lJ10gPSBmaWxlTmFtZTtcXG5cXHQgICAgICBpbmRleFtrZXlQcmVmaXggKyAnSGVhZGVyJ10gPSAoZGF0YVsxXSB8fCAnJykudHJpbSgpO1xcblxcblxcdCAgICAgIGkrKztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgLy8gUGFyc2VzIGEgaHVua1xcblxcdCAgLy8gVGhpcyBhc3N1bWVzIHRoYXQgd2UgYXJlIGF0IHRoZSBzdGFydCBvZiBhIGh1bmsuXFxuXFx0ICBmdW5jdGlvbiBwYXJzZUh1bmsoKSB7XFxuXFx0ICAgIHZhciBjaHVua0hlYWRlckluZGV4ID0gaSxcXG5cXHQgICAgICAgIGNodW5rSGVhZGVyTGluZSA9IGRpZmZzdHJbaSsrXSxcXG5cXHQgICAgICAgIGNodW5rSGVhZGVyID0gY2h1bmtIZWFkZXJMaW5lLnNwbGl0KC9AQCAtKFxcXFxkKykoPzosKFxcXFxkKykpPyBcXFxcKyhcXFxcZCspKD86LChcXFxcZCspKT8gQEAvKTtcXG5cXG5cXHQgICAgdmFyIGh1bmsgPSB7XFxuXFx0ICAgICAgb2xkU3RhcnQ6ICtjaHVua0hlYWRlclsxXSxcXG5cXHQgICAgICBvbGRMaW5lczogK2NodW5rSGVhZGVyWzJdIHx8IDEsXFxuXFx0ICAgICAgbmV3U3RhcnQ6ICtjaHVua0hlYWRlclszXSxcXG5cXHQgICAgICBuZXdMaW5lczogK2NodW5rSGVhZGVyWzRdIHx8IDEsXFxuXFx0ICAgICAgbGluZXM6IFtdLFxcblxcdCAgICAgIGxpbmVkZWxpbWl0ZXJzOiBbXVxcblxcdCAgICB9O1xcblxcblxcdCAgICB2YXIgYWRkQ291bnQgPSAwLFxcblxcdCAgICAgICAgcmVtb3ZlQ291bnQgPSAwO1xcblxcdCAgICBmb3IgKDsgaSA8IGRpZmZzdHIubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgICAvLyBMaW5lcyBzdGFydGluZyB3aXRoICctLS0nIGNvdWxkIGJlIG1pc3Rha2VuIGZvciB0aGUgXFxcInJlbW92ZSBsaW5lXFxcIiBvcGVyYXRpb25cXG5cXHQgICAgICAvLyBCdXQgdGhleSBjb3VsZCBiZSB0aGUgaGVhZGVyIGZvciB0aGUgbmV4dCBmaWxlLiBUaGVyZWZvcmUgcHJ1bmUgc3VjaCBjYXNlcyBvdXQuXFxuXFx0ICAgICAgaWYgKGRpZmZzdHJbaV0uaW5kZXhPZignLS0tICcpID09PSAwICYmIGkgKyAyIDwgZGlmZnN0ci5sZW5ndGggJiYgZGlmZnN0cltpICsgMV0uaW5kZXhPZignKysrICcpID09PSAwICYmIGRpZmZzdHJbaSArIDJdLmluZGV4T2YoJ0BAJykgPT09IDApIHtcXG5cXHQgICAgICAgIGJyZWFrO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICB2YXIgb3BlcmF0aW9uID0gZGlmZnN0cltpXS5sZW5ndGggPT0gMCAmJiBpICE9IGRpZmZzdHIubGVuZ3RoIC0gMSA/ICcgJyA6IGRpZmZzdHJbaV1bMF07XFxuXFxuXFx0ICAgICAgaWYgKG9wZXJhdGlvbiA9PT0gJysnIHx8IG9wZXJhdGlvbiA9PT0gJy0nIHx8IG9wZXJhdGlvbiA9PT0gJyAnIHx8IG9wZXJhdGlvbiA9PT0gJ1xcXFxcXFxcJykge1xcblxcdCAgICAgICAgaHVuay5saW5lcy5wdXNoKGRpZmZzdHJbaV0pO1xcblxcdCAgICAgICAgaHVuay5saW5lZGVsaW1pdGVycy5wdXNoKGRlbGltaXRlcnNbaV0gfHwgJ1xcXFxuJyk7XFxuXFxuXFx0ICAgICAgICBpZiAob3BlcmF0aW9uID09PSAnKycpIHtcXG5cXHQgICAgICAgICAgYWRkQ291bnQrKztcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnLScpIHtcXG5cXHQgICAgICAgICAgcmVtb3ZlQ291bnQrKztcXG5cXHQgICAgICAgIH0gZWxzZSBpZiAob3BlcmF0aW9uID09PSAnICcpIHtcXG5cXHQgICAgICAgICAgYWRkQ291bnQrKztcXG5cXHQgICAgICAgICAgcmVtb3ZlQ291bnQrKztcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9IGVsc2Uge1xcblxcdCAgICAgICAgYnJlYWs7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIEhhbmRsZSB0aGUgZW1wdHkgYmxvY2sgY291bnQgY2FzZVxcblxcdCAgICBpZiAoIWFkZENvdW50ICYmIGh1bmsubmV3TGluZXMgPT09IDEpIHtcXG5cXHQgICAgICBodW5rLm5ld0xpbmVzID0gMDtcXG5cXHQgICAgfVxcblxcdCAgICBpZiAoIXJlbW92ZUNvdW50ICYmIGh1bmsub2xkTGluZXMgPT09IDEpIHtcXG5cXHQgICAgICBodW5rLm9sZExpbmVzID0gMDtcXG5cXHQgICAgfVxcblxcblxcdCAgICAvLyBQZXJmb3JtIG9wdGlvbmFsIHNhbml0eSBjaGVja2luZ1xcblxcdCAgICBpZiAob3B0aW9ucy5zdHJpY3QpIHtcXG5cXHQgICAgICBpZiAoYWRkQ291bnQgIT09IGh1bmsubmV3TGluZXMpIHtcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignQWRkZWQgbGluZSBjb3VudCBkaWQgbm90IG1hdGNoIGZvciBodW5rIGF0IGxpbmUgJyArIChjaHVua0hlYWRlckluZGV4ICsgMSkpO1xcblxcdCAgICAgIH1cXG5cXHQgICAgICBpZiAocmVtb3ZlQ291bnQgIT09IGh1bmsub2xkTGluZXMpIHtcXG5cXHQgICAgICAgIHRocm93IG5ldyBFcnJvcignUmVtb3ZlZCBsaW5lIGNvdW50IGRpZCBub3QgbWF0Y2ggZm9yIGh1bmsgYXQgbGluZSAnICsgKGNodW5rSGVhZGVySW5kZXggKyAxKSk7XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIHJldHVybiBodW5rO1xcblxcdCAgfVxcblxcblxcdCAgd2hpbGUgKGkgPCBkaWZmc3RyLmxlbmd0aCkge1xcblxcdCAgICBwYXJzZUluZGV4KCk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gbGlzdDtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTIgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL1xcXCJ1c2Ugc3RyaWN0XFxcIjtcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcblxcdGV4cG9ydHNbXFxcImRlZmF1bHRcXFwiXSA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gKHN0YXJ0LCBtaW5MaW5lLCBtYXhMaW5lKSB7XFxuXFx0ICB2YXIgd2FudEZvcndhcmQgPSB0cnVlLFxcblxcdCAgICAgIGJhY2t3YXJkRXhoYXVzdGVkID0gZmFsc2UsXFxuXFx0ICAgICAgZm9yd2FyZEV4aGF1c3RlZCA9IGZhbHNlLFxcblxcdCAgICAgIGxvY2FsT2Zmc2V0ID0gMTtcXG5cXG5cXHQgIHJldHVybiBmdW5jdGlvbiBpdGVyYXRvcigpIHtcXG5cXHQgICAgaWYgKHdhbnRGb3J3YXJkICYmICFmb3J3YXJkRXhoYXVzdGVkKSB7XFxuXFx0ICAgICAgaWYgKGJhY2t3YXJkRXhoYXVzdGVkKSB7XFxuXFx0ICAgICAgICBsb2NhbE9mZnNldCsrO1xcblxcdCAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICB3YW50Rm9yd2FyZCA9IGZhbHNlO1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICAvLyBDaGVjayBpZiB0cnlpbmcgdG8gZml0IGJleW9uZCB0ZXh0IGxlbmd0aCwgYW5kIGlmIG5vdCwgY2hlY2sgaXQgZml0c1xcblxcdCAgICAgIC8vIGFmdGVyIG9mZnNldCBsb2NhdGlvbiAob3IgZGVzaXJlZCBsb2NhdGlvbiBvbiBmaXJzdCBpdGVyYXRpb24pXFxuXFx0ICAgICAgaWYgKHN0YXJ0ICsgbG9jYWxPZmZzZXQgPD0gbWF4TGluZSkge1xcblxcdCAgICAgICAgcmV0dXJuIGxvY2FsT2Zmc2V0O1xcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBmb3J3YXJkRXhoYXVzdGVkID0gdHJ1ZTtcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAoIWJhY2t3YXJkRXhoYXVzdGVkKSB7XFxuXFx0ICAgICAgaWYgKCFmb3J3YXJkRXhoYXVzdGVkKSB7XFxuXFx0ICAgICAgICB3YW50Rm9yd2FyZCA9IHRydWU7XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIC8vIENoZWNrIGlmIHRyeWluZyB0byBmaXQgYmVmb3JlIHRleHQgYmVnaW5uaW5nLCBhbmQgaWYgbm90LCBjaGVjayBpdCBmaXRzXFxuXFx0ICAgICAgLy8gYmVmb3JlIG9mZnNldCBsb2NhdGlvblxcblxcdCAgICAgIGlmIChtaW5MaW5lIDw9IHN0YXJ0IC0gbG9jYWxPZmZzZXQpIHtcXG5cXHQgICAgICAgIHJldHVybiAtbG9jYWxPZmZzZXQrKztcXG5cXHQgICAgICB9XFxuXFxuXFx0ICAgICAgYmFja3dhcmRFeGhhdXN0ZWQgPSB0cnVlO1xcblxcdCAgICAgIHJldHVybiBpdGVyYXRvcigpO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIC8vIFdlIHRyaWVkIHRvIGZpdCBodW5rIGJlZm9yZSB0ZXh0IGJlZ2lubmluZyBhbmQgYmV5b25kIHRleHQgbGVuZ3RoLCB0aGVuXFxuXFx0ICAgIC8vIGh1bmsgY2FuJ3QgZml0IG9uIHRoZSB0ZXh0LiBSZXR1cm4gdW5kZWZpbmVkXFxuXFx0ICB9O1xcblxcdH07XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTMgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY2FsY0xpbmVDb3VudCA9IGNhbGNMaW5lQ291bnQ7XFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2V4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbWVyZ2UgPSBtZXJnZTtcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jcmVhdGUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXG5cXHR2YXIgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19wYXJzZSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovO1xcblxcblxcdHZhciAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2FycmF5ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gY2FsY0xpbmVDb3VudChodW5rKSB7XFxuXFx0ICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9jYWxjT2xkTmV3TGluZUNvdW50ID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jYWxjT2xkTmV3TGluZUNvdW50KGh1bmsubGluZXMpLFxcblxcdCAgICAgIG9sZExpbmVzID0gX2NhbGNPbGROZXdMaW5lQ291bnQub2xkTGluZXMsXFxuXFx0ICAgICAgbmV3TGluZXMgPSBfY2FsY09sZE5ld0xpbmVDb3VudC5uZXdMaW5lcztcXG5cXG5cXHQgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkKSB7XFxuXFx0ICAgIGh1bmsub2xkTGluZXMgPSBvbGRMaW5lcztcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGRlbGV0ZSBodW5rLm9sZExpbmVzO1xcblxcdCAgfVxcblxcblxcdCAgaWYgKG5ld0xpbmVzICE9PSB1bmRlZmluZWQpIHtcXG5cXHQgICAgaHVuay5uZXdMaW5lcyA9IG5ld0xpbmVzO1xcblxcdCAgfSBlbHNlIHtcXG5cXHQgICAgZGVsZXRlIGh1bmsubmV3TGluZXM7XFxuXFx0ICB9XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG1lcmdlKG1pbmUsIHRoZWlycywgYmFzZSkge1xcblxcdCAgbWluZSA9IGxvYWRQYXRjaChtaW5lLCBiYXNlKTtcXG5cXHQgIHRoZWlycyA9IGxvYWRQYXRjaCh0aGVpcnMsIGJhc2UpO1xcblxcblxcdCAgdmFyIHJldCA9IHt9O1xcblxcblxcdCAgLy8gRm9yIGluZGV4IHdlIGp1c3QgbGV0IGl0IHBhc3MgdGhyb3VnaCBhcyBpdCBkb2Vzbid0IGhhdmUgYW55IG5lY2Vzc2FyeSBtZWFuaW5nLlxcblxcdCAgLy8gTGVhdmluZyBzYW5pdHkgY2hlY2tzIG9uIHRoaXMgdG8gdGhlIEFQSSBjb25zdW1lciB0aGF0IG1heSBrbm93IG1vcmUgYWJvdXQgdGhlXFxuXFx0ICAvLyBtZWFuaW5nIGluIHRoZWlyIG93biBjb250ZXh0LlxcblxcdCAgaWYgKG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4KSB7XFxuXFx0ICAgIHJldC5pbmRleCA9IG1pbmUuaW5kZXggfHwgdGhlaXJzLmluZGV4O1xcblxcdCAgfVxcblxcblxcdCAgaWYgKG1pbmUubmV3RmlsZU5hbWUgfHwgdGhlaXJzLm5ld0ZpbGVOYW1lKSB7XFxuXFx0ICAgIGlmICghZmlsZU5hbWVDaGFuZ2VkKG1pbmUpKSB7XFxuXFx0ICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiBvdXJzLCB1c2UgdGhlaXJzIChhbmQgb3VycyBpZiB0aGVpcnMgZG9lcyBub3QgZXhpc3QpXFxuXFx0ICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gdGhlaXJzLm9sZEZpbGVOYW1lIHx8IG1pbmUub2xkRmlsZU5hbWU7XFxuXFx0ICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gdGhlaXJzLm5ld0ZpbGVOYW1lIHx8IG1pbmUubmV3RmlsZU5hbWU7XFxuXFx0ICAgICAgcmV0Lm9sZEhlYWRlciA9IHRoZWlycy5vbGRIZWFkZXIgfHwgbWluZS5vbGRIZWFkZXI7XFxuXFx0ICAgICAgcmV0Lm5ld0hlYWRlciA9IHRoZWlycy5uZXdIZWFkZXIgfHwgbWluZS5uZXdIZWFkZXI7XFxuXFx0ICAgIH0gZWxzZSBpZiAoIWZpbGVOYW1lQ2hhbmdlZCh0aGVpcnMpKSB7XFxuXFx0ICAgICAgLy8gTm8gaGVhZGVyIG9yIG5vIGNoYW5nZSBpbiB0aGVpcnMsIHVzZSBvdXJzXFxuXFx0ICAgICAgcmV0Lm9sZEZpbGVOYW1lID0gbWluZS5vbGRGaWxlTmFtZTtcXG5cXHQgICAgICByZXQubmV3RmlsZU5hbWUgPSBtaW5lLm5ld0ZpbGVOYW1lO1xcblxcdCAgICAgIHJldC5vbGRIZWFkZXIgPSBtaW5lLm9sZEhlYWRlcjtcXG5cXHQgICAgICByZXQubmV3SGVhZGVyID0gbWluZS5uZXdIZWFkZXI7XFxuXFx0ICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgLy8gQm90aCBjaGFuZ2VkLi4uIGZpZ3VyZSBpdCBvdXRcXG5cXHQgICAgICByZXQub2xkRmlsZU5hbWUgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkRmlsZU5hbWUsIHRoZWlycy5vbGRGaWxlTmFtZSk7XFxuXFx0ICAgICAgcmV0Lm5ld0ZpbGVOYW1lID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0ZpbGVOYW1lLCB0aGVpcnMubmV3RmlsZU5hbWUpO1xcblxcdCAgICAgIHJldC5vbGRIZWFkZXIgPSBzZWxlY3RGaWVsZChyZXQsIG1pbmUub2xkSGVhZGVyLCB0aGVpcnMub2xkSGVhZGVyKTtcXG5cXHQgICAgICByZXQubmV3SGVhZGVyID0gc2VsZWN0RmllbGQocmV0LCBtaW5lLm5ld0hlYWRlciwgdGhlaXJzLm5ld0hlYWRlcik7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldC5odW5rcyA9IFtdO1xcblxcblxcdCAgdmFyIG1pbmVJbmRleCA9IDAsXFxuXFx0ICAgICAgdGhlaXJzSW5kZXggPSAwLFxcblxcdCAgICAgIG1pbmVPZmZzZXQgPSAwLFxcblxcdCAgICAgIHRoZWlyc09mZnNldCA9IDA7XFxuXFxuXFx0ICB3aGlsZSAobWluZUluZGV4IDwgbWluZS5odW5rcy5sZW5ndGggfHwgdGhlaXJzSW5kZXggPCB0aGVpcnMuaHVua3MubGVuZ3RoKSB7XFxuXFx0ICAgIHZhciBtaW5lQ3VycmVudCA9IG1pbmUuaHVua3NbbWluZUluZGV4XSB8fCB7IG9sZFN0YXJ0OiBJbmZpbml0eSB9LFxcblxcdCAgICAgICAgdGhlaXJzQ3VycmVudCA9IHRoZWlycy5odW5rc1t0aGVpcnNJbmRleF0gfHwgeyBvbGRTdGFydDogSW5maW5pdHkgfTtcXG5cXG5cXHQgICAgaWYgKGh1bmtCZWZvcmUobWluZUN1cnJlbnQsIHRoZWlyc0N1cnJlbnQpKSB7XFxuXFx0ICAgICAgLy8gVGhpcyBwYXRjaCBkb2VzIG5vdCBvdmVybGFwIHdpdGggYW55IG9mIHRoZSBvdGhlcnMsIHlheS5cXG5cXHQgICAgICByZXQuaHVua3MucHVzaChjbG9uZUh1bmsobWluZUN1cnJlbnQsIG1pbmVPZmZzZXQpKTtcXG5cXHQgICAgICBtaW5lSW5kZXgrKztcXG5cXHQgICAgICB0aGVpcnNPZmZzZXQgKz0gbWluZUN1cnJlbnQubmV3TGluZXMgLSBtaW5lQ3VycmVudC5vbGRMaW5lcztcXG5cXHQgICAgfSBlbHNlIGlmIChodW5rQmVmb3JlKHRoZWlyc0N1cnJlbnQsIG1pbmVDdXJyZW50KSkge1xcblxcdCAgICAgIC8vIFRoaXMgcGF0Y2ggZG9lcyBub3Qgb3ZlcmxhcCB3aXRoIGFueSBvZiB0aGUgb3RoZXJzLCB5YXkuXFxuXFx0ICAgICAgcmV0Lmh1bmtzLnB1c2goY2xvbmVIdW5rKHRoZWlyc0N1cnJlbnQsIHRoZWlyc09mZnNldCkpO1xcblxcdCAgICAgIHRoZWlyc0luZGV4Kys7XFxuXFx0ICAgICAgbWluZU9mZnNldCArPSB0aGVpcnNDdXJyZW50Lm5ld0xpbmVzIC0gdGhlaXJzQ3VycmVudC5vbGRMaW5lcztcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBPdmVybGFwLCBtZXJnZSBhcyBiZXN0IHdlIGNhblxcblxcdCAgICAgIHZhciBtZXJnZWRIdW5rID0ge1xcblxcdCAgICAgICAgb2xkU3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm9sZFN0YXJ0LCB0aGVpcnNDdXJyZW50Lm9sZFN0YXJ0KSxcXG5cXHQgICAgICAgIG9sZExpbmVzOiAwLFxcblxcdCAgICAgICAgbmV3U3RhcnQ6IE1hdGgubWluKG1pbmVDdXJyZW50Lm5ld1N0YXJ0ICsgbWluZU9mZnNldCwgdGhlaXJzQ3VycmVudC5vbGRTdGFydCArIHRoZWlyc09mZnNldCksXFxuXFx0ICAgICAgICBuZXdMaW5lczogMCxcXG5cXHQgICAgICAgIGxpbmVzOiBbXVxcblxcdCAgICAgIH07XFxuXFx0ICAgICAgbWVyZ2VMaW5lcyhtZXJnZWRIdW5rLCBtaW5lQ3VycmVudC5vbGRTdGFydCwgbWluZUN1cnJlbnQubGluZXMsIHRoZWlyc0N1cnJlbnQub2xkU3RhcnQsIHRoZWlyc0N1cnJlbnQubGluZXMpO1xcblxcdCAgICAgIHRoZWlyc0luZGV4Kys7XFxuXFx0ICAgICAgbWluZUluZGV4Kys7XFxuXFxuXFx0ICAgICAgcmV0Lmh1bmtzLnB1c2gobWVyZ2VkSHVuayk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiByZXQ7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGxvYWRQYXRjaChwYXJhbSwgYmFzZSkge1xcblxcdCAgaWYgKHR5cGVvZiBwYXJhbSA9PT0gJ3N0cmluZycpIHtcXG5cXHQgICAgaWYgKC9eQEAvbS50ZXN0KHBhcmFtKSB8fCAvXkluZGV4Oi9tLnRlc3QocGFyYW0pKSB7XFxuXFx0ICAgICAgcmV0dXJuICgvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9wYXJzZS5wYXJzZVBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhwYXJhbSlbMF1cXG5cXHQgICAgICApO1xcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmICghYmFzZSkge1xcblxcdCAgICAgIHRocm93IG5ldyBFcnJvcignTXVzdCBwcm92aWRlIGEgYmFzZSByZWZlcmVuY2Ugb3IgcGFzcyBpbiBhIHBhdGNoJyk7XFxuXFx0ICAgIH1cXG5cXHQgICAgcmV0dXJuICgvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9jcmVhdGUuc3RydWN0dXJlZFBhdGNoKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyh1bmRlZmluZWQsIHVuZGVmaW5lZCwgYmFzZSwgcGFyYW0pXFxuXFx0ICAgICk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcGFyYW07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGZpbGVOYW1lQ2hhbmdlZChwYXRjaCkge1xcblxcdCAgcmV0dXJuIHBhdGNoLm5ld0ZpbGVOYW1lICYmIHBhdGNoLm5ld0ZpbGVOYW1lICE9PSBwYXRjaC5vbGRGaWxlTmFtZTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gc2VsZWN0RmllbGQoaW5kZXgsIG1pbmUsIHRoZWlycykge1xcblxcdCAgaWYgKG1pbmUgPT09IHRoZWlycykge1xcblxcdCAgICByZXR1cm4gbWluZTtcXG5cXHQgIH0gZWxzZSB7XFxuXFx0ICAgIGluZGV4LmNvbmZsaWN0ID0gdHJ1ZTtcXG5cXHQgICAgcmV0dXJuIHsgbWluZTogbWluZSwgdGhlaXJzOiB0aGVpcnMgfTtcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gaHVua0JlZm9yZSh0ZXN0LCBjaGVjaykge1xcblxcdCAgcmV0dXJuIHRlc3Qub2xkU3RhcnQgPCBjaGVjay5vbGRTdGFydCAmJiB0ZXN0Lm9sZFN0YXJ0ICsgdGVzdC5vbGRMaW5lcyA8IGNoZWNrLm9sZFN0YXJ0O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjbG9uZUh1bmsoaHVuaywgb2Zmc2V0KSB7XFxuXFx0ICByZXR1cm4ge1xcblxcdCAgICBvbGRTdGFydDogaHVuay5vbGRTdGFydCwgb2xkTGluZXM6IGh1bmsub2xkTGluZXMsXFxuXFx0ICAgIG5ld1N0YXJ0OiBodW5rLm5ld1N0YXJ0ICsgb2Zmc2V0LCBuZXdMaW5lczogaHVuay5uZXdMaW5lcyxcXG5cXHQgICAgbGluZXM6IGh1bmsubGluZXNcXG5cXHQgIH07XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIG1lcmdlTGluZXMoaHVuaywgbWluZU9mZnNldCwgbWluZUxpbmVzLCB0aGVpck9mZnNldCwgdGhlaXJMaW5lcykge1xcblxcdCAgLy8gVGhpcyB3aWxsIGdlbmVyYWxseSByZXN1bHQgaW4gYSBjb25mbGljdGVkIGh1bmssIGJ1dCB0aGVyZSBhcmUgY2FzZXMgd2hlcmUgdGhlIGNvbnRleHRcXG5cXHQgIC8vIGlzIHRoZSBvbmx5IG92ZXJsYXAgd2hlcmUgd2UgY2FuIHN1Y2Nlc3NmdWxseSBtZXJnZSB0aGUgY29udGVudCBoZXJlLlxcblxcdCAgdmFyIG1pbmUgPSB7IG9mZnNldDogbWluZU9mZnNldCwgbGluZXM6IG1pbmVMaW5lcywgaW5kZXg6IDAgfSxcXG5cXHQgICAgICB0aGVpciA9IHsgb2Zmc2V0OiB0aGVpck9mZnNldCwgbGluZXM6IHRoZWlyTGluZXMsIGluZGV4OiAwIH07XFxuXFxuXFx0ICAvLyBIYW5kbGUgYW55IGxlYWRpbmcgY29udGVudFxcblxcdCAgaW5zZXJ0TGVhZGluZyhodW5rLCBtaW5lLCB0aGVpcik7XFxuXFx0ICBpbnNlcnRMZWFkaW5nKGh1bmssIHRoZWlyLCBtaW5lKTtcXG5cXG5cXHQgIC8vIE5vdyBpbiB0aGUgb3ZlcmxhcCBjb250ZW50LiBTY2FuIHRocm91Z2ggYW5kIHNlbGVjdCB0aGUgYmVzdCBjaGFuZ2VzIGZyb20gZWFjaC5cXG5cXHQgIHdoaWxlIChtaW5lLmluZGV4IDwgbWluZS5saW5lcy5sZW5ndGggJiYgdGhlaXIuaW5kZXggPCB0aGVpci5saW5lcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIG1pbmVDdXJyZW50ID0gbWluZS5saW5lc1ttaW5lLmluZGV4XSxcXG5cXHQgICAgICAgIHRoZWlyQ3VycmVudCA9IHRoZWlyLmxpbmVzW3RoZWlyLmluZGV4XTtcXG5cXG5cXHQgICAgaWYgKChtaW5lQ3VycmVudFswXSA9PT0gJy0nIHx8IG1pbmVDdXJyZW50WzBdID09PSAnKycpICYmICh0aGVpckN1cnJlbnRbMF0gPT09ICctJyB8fCB0aGVpckN1cnJlbnRbMF0gPT09ICcrJykpIHtcXG5cXHQgICAgICAvLyBCb3RoIG1vZGlmaWVkIC4uLlxcblxcdCAgICAgIG11dHVhbENoYW5nZShodW5rLCBtaW5lLCB0aGVpcik7XFxuXFx0ICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnRbMF0gPT09ICcrJyAmJiB0aGVpckN1cnJlbnRbMF0gPT09ICcgJykge1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXM7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gTWluZSBpbnNlcnRlZFxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXMgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbGxlY3RDaGFuZ2UobWluZSkpKTtcXG5cXHQgICAgfSBlbHNlIGlmICh0aGVpckN1cnJlbnRbMF0gPT09ICcrJyAmJiBtaW5lQ3VycmVudFswXSA9PT0gJyAnKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczI7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLy8gVGhlaXJzIGluc2VydGVkXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczIgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzMiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb2xsZWN0Q2hhbmdlKHRoZWlyKSkpO1xcblxcdCAgICB9IGVsc2UgaWYgKG1pbmVDdXJyZW50WzBdID09PSAnLScgJiYgdGhlaXJDdXJyZW50WzBdID09PSAnICcpIHtcXG5cXHQgICAgICAvLyBNaW5lIHJlbW92ZWQgb3IgZWRpdGVkXFxuXFx0ICAgICAgcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpcik7XFxuXFx0ICAgIH0gZWxzZSBpZiAodGhlaXJDdXJyZW50WzBdID09PSAnLScgJiYgbWluZUN1cnJlbnRbMF0gPT09ICcgJykge1xcblxcdCAgICAgIC8vIFRoZWlyIHJlbW92ZWQgb3IgZWRpdGVkXFxuXFx0ICAgICAgcmVtb3ZhbChodW5rLCB0aGVpciwgbWluZSwgdHJ1ZSk7XFxuXFx0ICAgIH0gZWxzZSBpZiAobWluZUN1cnJlbnQgPT09IHRoZWlyQ3VycmVudCkge1xcblxcdCAgICAgIC8vIENvbnRleHQgaWRlbnRpdHlcXG5cXHQgICAgICBodW5rLmxpbmVzLnB1c2gobWluZUN1cnJlbnQpO1xcblxcdCAgICAgIG1pbmUuaW5kZXgrKztcXG5cXHQgICAgICB0aGVpci5pbmRleCsrO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIC8vIENvbnRleHQgbWlzbWF0Y2hcXG5cXHQgICAgICBjb25mbGljdChodW5rLCBjb2xsZWN0Q2hhbmdlKG1pbmUpLCBjb2xsZWN0Q2hhbmdlKHRoZWlyKSk7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIC8vIE5vdyBwdXNoIGFueXRoaW5nIHRoYXQgbWF5IGJlIHJlbWFpbmluZ1xcblxcdCAgaW5zZXJ0VHJhaWxpbmcoaHVuaywgbWluZSk7XFxuXFx0ICBpbnNlcnRUcmFpbGluZyhodW5rLCB0aGVpcik7XFxuXFxuXFx0ICBjYWxjTGluZUNvdW50KGh1bmspO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBtdXR1YWxDaGFuZ2UoaHVuaywgbWluZSwgdGhlaXIpIHtcXG5cXHQgIHZhciBteUNoYW5nZXMgPSBjb2xsZWN0Q2hhbmdlKG1pbmUpLFxcblxcdCAgICAgIHRoZWlyQ2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UodGhlaXIpO1xcblxcblxcdCAgaWYgKGFsbFJlbW92ZXMobXlDaGFuZ2VzKSAmJiBhbGxSZW1vdmVzKHRoZWlyQ2hhbmdlcykpIHtcXG5cXHQgICAgLy8gU3BlY2lhbCBjYXNlIGZvciByZW1vdmUgY2hhbmdlcyB0aGF0IGFyZSBzdXBlcnNldHMgb2Ygb25lIGFub3RoZXJcXG5cXHQgICAgaWYgKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9hcnJheS5hcnJheVN0YXJ0c1dpdGgpIC8qaXN0YW5idWwgaWdub3JlIGVuZCovKG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKSAmJiBza2lwUmVtb3ZlU3VwZXJzZXQodGhlaXIsIG15Q2hhbmdlcywgbXlDaGFuZ2VzLmxlbmd0aCAtIHRoZWlyQ2hhbmdlcy5sZW5ndGgpKSB7XFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczM7XFxuXFxuXFx0ICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczMgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzMyAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9teUNoYW5nZXMpKTtcXG5cXHQgICAgICByZXR1cm47XFxuXFx0ICAgIH0gZWxzZSBpZiAoIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2FycmF5LmFycmF5U3RhcnRzV2l0aCkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8odGhlaXJDaGFuZ2VzLCBteUNoYW5nZXMpICYmIHNraXBSZW1vdmVTdXBlcnNldChtaW5lLCB0aGVpckNoYW5nZXMsIHRoZWlyQ2hhbmdlcy5sZW5ndGggLSBteUNoYW5nZXMubGVuZ3RoKSkge1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2h1bmskbGluZXM0O1xcblxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXM0ID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lczQgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovdGhlaXJDaGFuZ2VzKSk7XFxuXFx0ICAgICAgcmV0dXJuO1xcblxcdCAgICB9XFxuXFx0ICB9IGVsc2UgaWYgKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKDAsIF9hcnJheS5hcnJheUVxdWFsKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhteUNoYW5nZXMsIHRoZWlyQ2hhbmdlcykpIHtcXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfaHVuayRsaW5lczU7XFxuXFxuXFx0ICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2h1bmskbGluZXM1ID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9odW5rLmxpbmVzKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9faHVuayRsaW5lczUgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovbXlDaGFuZ2VzKSk7XFxuXFx0ICAgIHJldHVybjtcXG5cXHQgIH1cXG5cXG5cXHQgIGNvbmZsaWN0KGh1bmssIG15Q2hhbmdlcywgdGhlaXJDaGFuZ2VzKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gcmVtb3ZhbChodW5rLCBtaW5lLCB0aGVpciwgc3dhcCkge1xcblxcdCAgdmFyIG15Q2hhbmdlcyA9IGNvbGxlY3RDaGFuZ2UobWluZSksXFxuXFx0ICAgICAgdGhlaXJDaGFuZ2VzID0gY29sbGVjdENvbnRleHQodGhlaXIsIG15Q2hhbmdlcyk7XFxuXFx0ICBpZiAodGhlaXJDaGFuZ2VzLm1lcmdlZCkge1xcblxcdCAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9odW5rJGxpbmVzNjtcXG5cXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyhfaHVuayRsaW5lczYgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2h1bmsubGluZXMpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19odW5rJGxpbmVzNiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLywgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL190b0NvbnN1bWFibGVBcnJheSggLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi90aGVpckNoYW5nZXMubWVyZ2VkKSk7XFxuXFx0ICB9IGVsc2Uge1xcblxcdCAgICBjb25mbGljdChodW5rLCBzd2FwID8gdGhlaXJDaGFuZ2VzIDogbXlDaGFuZ2VzLCBzd2FwID8gbXlDaGFuZ2VzIDogdGhlaXJDaGFuZ2VzKTtcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY29uZmxpY3QoaHVuaywgbWluZSwgdGhlaXIpIHtcXG5cXHQgIGh1bmsuY29uZmxpY3QgPSB0cnVlO1xcblxcdCAgaHVuay5saW5lcy5wdXNoKHtcXG5cXHQgICAgY29uZmxpY3Q6IHRydWUsXFxuXFx0ICAgIG1pbmU6IG1pbmUsXFxuXFx0ICAgIHRoZWlyczogdGhlaXJcXG5cXHQgIH0pO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBpbnNlcnRMZWFkaW5nKGh1bmssIGluc2VydCwgdGhlaXIpIHtcXG5cXHQgIHdoaWxlIChpbnNlcnQub2Zmc2V0IDwgdGhlaXIub2Zmc2V0ICYmIGluc2VydC5pbmRleCA8IGluc2VydC5saW5lcy5sZW5ndGgpIHtcXG5cXHQgICAgdmFyIGxpbmUgPSBpbnNlcnQubGluZXNbaW5zZXJ0LmluZGV4KytdO1xcblxcdCAgICBodW5rLmxpbmVzLnB1c2gobGluZSk7XFxuXFx0ICAgIGluc2VydC5vZmZzZXQrKztcXG5cXHQgIH1cXG5cXHR9XFxuXFx0ZnVuY3Rpb24gaW5zZXJ0VHJhaWxpbmcoaHVuaywgaW5zZXJ0KSB7XFxuXFx0ICB3aGlsZSAoaW5zZXJ0LmluZGV4IDwgaW5zZXJ0LmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbGluZSA9IGluc2VydC5saW5lc1tpbnNlcnQuaW5kZXgrK107XFxuXFx0ICAgIGh1bmsubGluZXMucHVzaChsaW5lKTtcXG5cXHQgIH1cXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gY29sbGVjdENoYW5nZShzdGF0ZSkge1xcblxcdCAgdmFyIHJldCA9IFtdLFxcblxcdCAgICAgIG9wZXJhdGlvbiA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XVswXTtcXG5cXHQgIHdoaWxlIChzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgbGluZSA9IHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4XTtcXG5cXG5cXHQgICAgLy8gR3JvdXAgYWRkaXRpb25zIHRoYXQgYXJlIGltbWVkaWF0ZWx5IGFmdGVyIHN1YnRyYWN0aW9ucyBhbmQgdHJlYXQgdGhlbSBhcyBvbmUgXFxcImF0b21pY1xcXCIgbW9kaWZ5IGNoYW5nZS5cXG5cXHQgICAgaWYgKG9wZXJhdGlvbiA9PT0gJy0nICYmIGxpbmVbMF0gPT09ICcrJykge1xcblxcdCAgICAgIG9wZXJhdGlvbiA9ICcrJztcXG5cXHQgICAgfVxcblxcblxcdCAgICBpZiAob3BlcmF0aW9uID09PSBsaW5lWzBdKSB7XFxuXFx0ICAgICAgcmV0LnB1c2gobGluZSk7XFxuXFx0ICAgICAgc3RhdGUuaW5kZXgrKztcXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHJldDtcXG5cXHR9XFxuXFx0ZnVuY3Rpb24gY29sbGVjdENvbnRleHQoc3RhdGUsIG1hdGNoQ2hhbmdlcykge1xcblxcdCAgdmFyIGNoYW5nZXMgPSBbXSxcXG5cXHQgICAgICBtZXJnZWQgPSBbXSxcXG5cXHQgICAgICBtYXRjaEluZGV4ID0gMCxcXG5cXHQgICAgICBjb250ZXh0Q2hhbmdlcyA9IGZhbHNlLFxcblxcdCAgICAgIGNvbmZsaWN0ZWQgPSBmYWxzZTtcXG5cXHQgIHdoaWxlIChtYXRjaEluZGV4IDwgbWF0Y2hDaGFuZ2VzLmxlbmd0aCAmJiBzdGF0ZS5pbmRleCA8IHN0YXRlLmxpbmVzLmxlbmd0aCkge1xcblxcdCAgICB2YXIgY2hhbmdlID0gc3RhdGUubGluZXNbc3RhdGUuaW5kZXhdLFxcblxcdCAgICAgICAgbWF0Y2ggPSBtYXRjaENoYW5nZXNbbWF0Y2hJbmRleF07XFxuXFxuXFx0ICAgIC8vIE9uY2Ugd2UndmUgaGl0IG91ciBhZGQsIHRoZW4gd2UgYXJlIGRvbmVcXG5cXHQgICAgaWYgKG1hdGNoWzBdID09PSAnKycpIHtcXG5cXHQgICAgICBicmVhaztcXG5cXHQgICAgfVxcblxcblxcdCAgICBjb250ZXh0Q2hhbmdlcyA9IGNvbnRleHRDaGFuZ2VzIHx8IGNoYW5nZVswXSAhPT0gJyAnO1xcblxcblxcdCAgICBtZXJnZWQucHVzaChtYXRjaCk7XFxuXFx0ICAgIG1hdGNoSW5kZXgrKztcXG5cXG5cXHQgICAgLy8gQ29uc3VtZSBhbnkgYWRkaXRpb25zIGluIHRoZSBvdGhlciBibG9jayBhcyBhIGNvbmZsaWN0IHRvIGF0dGVtcHRcXG5cXHQgICAgLy8gdG8gcHVsbCBpbiB0aGUgcmVtYWluaW5nIGNvbnRleHQgYWZ0ZXIgdGhpc1xcblxcdCAgICBpZiAoY2hhbmdlWzBdID09PSAnKycpIHtcXG5cXHQgICAgICBjb25mbGljdGVkID0gdHJ1ZTtcXG5cXG5cXHQgICAgICB3aGlsZSAoY2hhbmdlWzBdID09PSAnKycpIHtcXG5cXHQgICAgICAgIGNoYW5nZXMucHVzaChjaGFuZ2UpO1xcblxcdCAgICAgICAgY2hhbmdlID0gc3RhdGUubGluZXNbKytzdGF0ZS5pbmRleF07XFxuXFx0ICAgICAgfVxcblxcdCAgICB9XFxuXFxuXFx0ICAgIGlmIChtYXRjaC5zdWJzdHIoMSkgPT09IGNoYW5nZS5zdWJzdHIoMSkpIHtcXG5cXHQgICAgICBjaGFuZ2VzLnB1c2goY2hhbmdlKTtcXG5cXHQgICAgICBzdGF0ZS5pbmRleCsrO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIGNvbmZsaWN0ZWQgPSB0cnVlO1xcblxcdCAgICB9XFxuXFx0ICB9XFxuXFxuXFx0ICBpZiAoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4XSB8fCAnJylbMF0gPT09ICcrJyAmJiBjb250ZXh0Q2hhbmdlcykge1xcblxcdCAgICBjb25mbGljdGVkID0gdHJ1ZTtcXG5cXHQgIH1cXG5cXG5cXHQgIGlmIChjb25mbGljdGVkKSB7XFxuXFx0ICAgIHJldHVybiBjaGFuZ2VzO1xcblxcdCAgfVxcblxcblxcdCAgd2hpbGUgKG1hdGNoSW5kZXggPCBtYXRjaENoYW5nZXMubGVuZ3RoKSB7XFxuXFx0ICAgIG1lcmdlZC5wdXNoKG1hdGNoQ2hhbmdlc1ttYXRjaEluZGV4KytdKTtcXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB7XFxuXFx0ICAgIG1lcmdlZDogbWVyZ2VkLFxcblxcdCAgICBjaGFuZ2VzOiBjaGFuZ2VzXFxuXFx0ICB9O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBhbGxSZW1vdmVzKGNoYW5nZXMpIHtcXG5cXHQgIHJldHVybiBjaGFuZ2VzLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY2hhbmdlKSB7XFxuXFx0ICAgIHJldHVybiBwcmV2ICYmIGNoYW5nZVswXSA9PT0gJy0nO1xcblxcdCAgfSwgdHJ1ZSk7XFxuXFx0fVxcblxcdGZ1bmN0aW9uIHNraXBSZW1vdmVTdXBlcnNldChzdGF0ZSwgcmVtb3ZlQ2hhbmdlcywgZGVsdGEpIHtcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgZGVsdGE7IGkrKykge1xcblxcdCAgICB2YXIgY2hhbmdlQ29udGVudCA9IHJlbW92ZUNoYW5nZXNbcmVtb3ZlQ2hhbmdlcy5sZW5ndGggLSBkZWx0YSArIGldLnN1YnN0cigxKTtcXG5cXHQgICAgaWYgKHN0YXRlLmxpbmVzW3N0YXRlLmluZGV4ICsgaV0gIT09ICcgJyArIGNoYW5nZUNvbnRlbnQpIHtcXG5cXHQgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHN0YXRlLmluZGV4ICs9IGRlbHRhO1xcblxcdCAgcmV0dXJuIHRydWU7XFxuXFx0fVxcblxcblxcdGZ1bmN0aW9uIGNhbGNPbGROZXdMaW5lQ291bnQobGluZXMpIHtcXG5cXHQgIHZhciBvbGRMaW5lcyA9IDA7XFxuXFx0ICB2YXIgbmV3TGluZXMgPSAwO1xcblxcblxcdCAgbGluZXMuZm9yRWFjaChmdW5jdGlvbiAobGluZSkge1xcblxcdCAgICBpZiAodHlwZW9mIGxpbmUgIT09ICdzdHJpbmcnKSB7XFxuXFx0ICAgICAgdmFyIG15Q291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUubWluZSk7XFxuXFx0ICAgICAgdmFyIHRoZWlyQ291bnQgPSBjYWxjT2xkTmV3TGluZUNvdW50KGxpbmUudGhlaXJzKTtcXG5cXG5cXHQgICAgICBpZiAob2xkTGluZXMgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgaWYgKG15Q291bnQub2xkTGluZXMgPT09IHRoZWlyQ291bnQub2xkTGluZXMpIHtcXG5cXHQgICAgICAgICAgb2xkTGluZXMgKz0gbXlDb3VudC5vbGRMaW5lcztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIG9sZExpbmVzID0gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXG5cXHQgICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCkge1xcblxcdCAgICAgICAgaWYgKG15Q291bnQubmV3TGluZXMgPT09IHRoZWlyQ291bnQubmV3TGluZXMpIHtcXG5cXHQgICAgICAgICAgbmV3TGluZXMgKz0gbXlDb3VudC5uZXdMaW5lcztcXG5cXHQgICAgICAgIH0gZWxzZSB7XFxuXFx0ICAgICAgICAgIG5ld0xpbmVzID0gdW5kZWZpbmVkO1xcblxcdCAgICAgICAgfVxcblxcdCAgICAgIH1cXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICBpZiAobmV3TGluZXMgIT09IHVuZGVmaW5lZCAmJiAobGluZVswXSA9PT0gJysnIHx8IGxpbmVbMF0gPT09ICcgJykpIHtcXG5cXHQgICAgICAgIG5ld0xpbmVzKys7XFxuXFx0ICAgICAgfVxcblxcdCAgICAgIGlmIChvbGRMaW5lcyAhPT0gdW5kZWZpbmVkICYmIChsaW5lWzBdID09PSAnLScgfHwgbGluZVswXSA9PT0gJyAnKSkge1xcblxcdCAgICAgICAgb2xkTGluZXMrKztcXG5cXHQgICAgICB9XFxuXFx0ICAgIH1cXG5cXHQgIH0pO1xcblxcblxcdCAgcmV0dXJuIHsgb2xkTGluZXM6IG9sZExpbmVzLCBuZXdMaW5lczogbmV3TGluZXMgfTtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSksXFxuLyogMTQgKi9cXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqLyd1c2Ugc3RyaWN0JztcXG5cXG5cXHRleHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlO1xcblxcdGV4cG9ydHMuIC8qaXN0YW5idWwgaWdub3JlIGVuZCovc3RydWN0dXJlZFBhdGNoID0gc3RydWN0dXJlZFBhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVR3b0ZpbGVzUGF0Y2ggPSBjcmVhdGVUd29GaWxlc1BhdGNoO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NyZWF0ZVBhdGNoID0gY3JlYXRlUGF0Y2g7XFxuXFxuXFx0dmFyIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fbGluZSA9IF9fd2VicGFja19yZXF1aXJlX18oNSkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi87XFxuXFxuXFx0Lyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2Z1bmN0aW9uIF90b0NvbnN1bWFibGVBcnJheShhcnIpIHsgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgeyBmb3IgKHZhciBpID0gMCwgYXJyMiA9IEFycmF5KGFyci5sZW5ndGgpOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7IGFycjJbaV0gPSBhcnJbaV07IH0gcmV0dXJuIGFycjI7IH0gZWxzZSB7IHJldHVybiBBcnJheS5mcm9tKGFycik7IH0gfVxcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIGVuZCovZnVuY3Rpb24gc3RydWN0dXJlZFBhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuXFx0ICBpZiAoIW9wdGlvbnMpIHtcXG5cXHQgICAgb3B0aW9ucyA9IHt9O1xcblxcdCAgfVxcblxcdCAgaWYgKHR5cGVvZiBvcHRpb25zLmNvbnRleHQgPT09ICd1bmRlZmluZWQnKSB7XFxuXFx0ICAgIG9wdGlvbnMuY29udGV4dCA9IDQ7XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgZGlmZiA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oMCwgX2xpbmUuZGlmZkxpbmVzKSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyhvbGRTdHIsIG5ld1N0ciwgb3B0aW9ucyk7XFxuXFx0ICBkaWZmLnB1c2goeyB2YWx1ZTogJycsIGxpbmVzOiBbXSB9KTsgLy8gQXBwZW5kIGFuIGVtcHR5IHZhbHVlIHRvIG1ha2UgY2xlYW51cCBlYXNpZXJcXG5cXG5cXHQgIGZ1bmN0aW9uIGNvbnRleHRMaW5lcyhsaW5lcykge1xcblxcdCAgICByZXR1cm4gbGluZXMubWFwKGZ1bmN0aW9uIChlbnRyeSkge1xcblxcdCAgICAgIHJldHVybiAnICcgKyBlbnRyeTtcXG5cXHQgICAgfSk7XFxuXFx0ICB9XFxuXFxuXFx0ICB2YXIgaHVua3MgPSBbXTtcXG5cXHQgIHZhciBvbGRSYW5nZVN0YXJ0ID0gMCxcXG5cXHQgICAgICBuZXdSYW5nZVN0YXJ0ID0gMCxcXG5cXHQgICAgICBjdXJSYW5nZSA9IFtdLFxcblxcdCAgICAgIG9sZExpbmUgPSAxLFxcblxcdCAgICAgIG5ld0xpbmUgPSAxO1xcblxcblxcdCAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfbG9vcCA9IGZ1bmN0aW9uIF9sb29wKCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2kpIHtcXG5cXHQgICAgdmFyIGN1cnJlbnQgPSBkaWZmW2ldLFxcblxcdCAgICAgICAgbGluZXMgPSBjdXJyZW50LmxpbmVzIHx8IGN1cnJlbnQudmFsdWUucmVwbGFjZSgvXFxcXG4kLywgJycpLnNwbGl0KCdcXFxcbicpO1xcblxcdCAgICBjdXJyZW50LmxpbmVzID0gbGluZXM7XFxuXFxuXFx0ICAgIGlmIChjdXJyZW50LmFkZGVkIHx8IGN1cnJlbnQucmVtb3ZlZCkge1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92YXIgX2N1clJhbmdlO1xcblxcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIElmIHdlIGhhdmUgcHJldmlvdXMgY29udGV4dCwgc3RhcnQgd2l0aCB0aGF0XFxuXFx0ICAgICAgaWYgKCFvbGRSYW5nZVN0YXJ0KSB7XFxuXFx0ICAgICAgICB2YXIgcHJldiA9IGRpZmZbaSAtIDFdO1xcblxcdCAgICAgICAgb2xkUmFuZ2VTdGFydCA9IG9sZExpbmU7XFxuXFx0ICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gbmV3TGluZTtcXG5cXG5cXHQgICAgICAgIGlmIChwcmV2KSB7XFxuXFx0ICAgICAgICAgIGN1clJhbmdlID0gb3B0aW9ucy5jb250ZXh0ID4gMCA/IGNvbnRleHRMaW5lcyhwcmV2LmxpbmVzLnNsaWNlKC1vcHRpb25zLmNvbnRleHQpKSA6IFtdO1xcblxcdCAgICAgICAgICBvbGRSYW5nZVN0YXJ0IC09IGN1clJhbmdlLmxlbmd0aDtcXG5cXHQgICAgICAgICAgbmV3UmFuZ2VTdGFydCAtPSBjdXJSYW5nZS5sZW5ndGg7XFxuXFx0ICAgICAgICB9XFxuXFx0ICAgICAgfVxcblxcblxcdCAgICAgIC8vIE91dHB1dCBvdXIgY2hhbmdlc1xcblxcdCAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlID0gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jdXJSYW5nZSkucHVzaC4gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL2FwcGx5IC8qaXN0YW5idWwgaWdub3JlIGVuZCovKCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX2N1clJhbmdlIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2xpbmVzLm1hcChmdW5jdGlvbiAoZW50cnkpIHtcXG5cXHQgICAgICAgIHJldHVybiAoY3VycmVudC5hZGRlZCA/ICcrJyA6ICctJykgKyBlbnRyeTtcXG5cXHQgICAgICB9KSkpO1xcblxcblxcdCAgICAgIC8vIFRyYWNrIHRoZSB1cGRhdGVkIGZpbGUgcG9zaXRpb25cXG5cXHQgICAgICBpZiAoY3VycmVudC5hZGRlZCkge1xcblxcdCAgICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgIG9sZExpbmUgKz0gbGluZXMubGVuZ3RoO1xcblxcdCAgICAgIH1cXG5cXHQgICAgfSBlbHNlIHtcXG5cXHQgICAgICAvLyBJZGVudGljYWwgY29udGV4dCBsaW5lcy4gVHJhY2sgbGluZSBjaGFuZ2VzXFxuXFx0ICAgICAgaWYgKG9sZFJhbmdlU3RhcnQpIHtcXG5cXHQgICAgICAgIC8vIENsb3NlIG91dCBhbnkgY2hhbmdlcyB0aGF0IGhhdmUgYmVlbiBvdXRwdXQgKG9yIGpvaW4gb3ZlcmxhcHBpbmcpXFxuXFx0ICAgICAgICBpZiAobGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCAqIDIgJiYgaSA8IGRpZmYubGVuZ3RoIC0gMikge1xcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovdmFyIF9jdXJSYW5nZTI7XFxuXFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIGVuZCovIC8vIE92ZXJsYXBwaW5nXFxuXFx0ICAgICAgICAgIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki8oX2N1clJhbmdlMiA9IC8qaXN0YW5idWwgaWdub3JlIGVuZCovY3VyUmFuZ2UpLnB1c2guIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9hcHBseSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyggLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19jdXJSYW5nZTIgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fdG9Db25zdW1hYmxlQXJyYXkoIC8qaXN0YW5idWwgaWdub3JlIGVuZCovY29udGV4dExpbmVzKGxpbmVzKSkpO1xcblxcdCAgICAgICAgfSBlbHNlIHtcXG5cXHQgICAgICAgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZhciBfY3VyUmFuZ2UzO1xcblxcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLyAvLyBlbmQgdGhlIHJhbmdlIGFuZCBvdXRwdXRcXG5cXHQgICAgICAgICAgdmFyIGNvbnRleHRTaXplID0gTWF0aC5taW4obGluZXMubGVuZ3RoLCBvcHRpb25zLmNvbnRleHQpO1xcblxcdCAgICAgICAgICAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovKF9jdXJSYW5nZTMgPSAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2N1clJhbmdlKS5wdXNoLiAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovYXBwbHkgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8oIC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9fY3VyUmFuZ2UzIC8qaXN0YW5idWwgaWdub3JlIGVuZCovLCAvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovX3RvQ29uc3VtYWJsZUFycmF5KCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2NvbnRleHRMaW5lcyhsaW5lcy5zbGljZSgwLCBjb250ZXh0U2l6ZSkpKSk7XFxuXFxuXFx0ICAgICAgICAgIHZhciBodW5rID0ge1xcblxcdCAgICAgICAgICAgIG9sZFN0YXJ0OiBvbGRSYW5nZVN0YXJ0LFxcblxcdCAgICAgICAgICAgIG9sZExpbmVzOiBvbGRMaW5lIC0gb2xkUmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxcblxcdCAgICAgICAgICAgIG5ld1N0YXJ0OiBuZXdSYW5nZVN0YXJ0LFxcblxcdCAgICAgICAgICAgIG5ld0xpbmVzOiBuZXdMaW5lIC0gbmV3UmFuZ2VTdGFydCArIGNvbnRleHRTaXplLFxcblxcdCAgICAgICAgICAgIGxpbmVzOiBjdXJSYW5nZVxcblxcdCAgICAgICAgICB9O1xcblxcdCAgICAgICAgICBpZiAoaSA+PSBkaWZmLmxlbmd0aCAtIDIgJiYgbGluZXMubGVuZ3RoIDw9IG9wdGlvbnMuY29udGV4dCkge1xcblxcdCAgICAgICAgICAgIC8vIEVPRiBpcyBpbnNpZGUgdGhpcyBodW5rXFxuXFx0ICAgICAgICAgICAgdmFyIG9sZEVPRk5ld2xpbmUgPSAvXFxcXG4kLy50ZXN0KG9sZFN0cik7XFxuXFx0ICAgICAgICAgICAgdmFyIG5ld0VPRk5ld2xpbmUgPSAvXFxcXG4kLy50ZXN0KG5ld1N0cik7XFxuXFx0ICAgICAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCA9PSAwICYmICFvbGRFT0ZOZXdsaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICAvLyBzcGVjaWFsIGNhc2U6IG9sZCBoYXMgbm8gZW9sIGFuZCBubyB0cmFpbGluZyBjb250ZXh0OyBuby1ubCBjYW4gZW5kIHVwIGJlZm9yZSBhZGRzXFxuXFx0ICAgICAgICAgICAgICBjdXJSYW5nZS5zcGxpY2UoaHVuay5vbGRMaW5lcywgMCwgJ1xcXFxcXFxcIE5vIG5ld2xpbmUgYXQgZW5kIG9mIGZpbGUnKTtcXG5cXHQgICAgICAgICAgICB9IGVsc2UgaWYgKCFvbGRFT0ZOZXdsaW5lIHx8ICFuZXdFT0ZOZXdsaW5lKSB7XFxuXFx0ICAgICAgICAgICAgICBjdXJSYW5nZS5wdXNoKCdcXFxcXFxcXCBObyBuZXdsaW5lIGF0IGVuZCBvZiBmaWxlJyk7XFxuXFx0ICAgICAgICAgICAgfVxcblxcdCAgICAgICAgICB9XFxuXFx0ICAgICAgICAgIGh1bmtzLnB1c2goaHVuayk7XFxuXFxuXFx0ICAgICAgICAgIG9sZFJhbmdlU3RhcnQgPSAwO1xcblxcdCAgICAgICAgICBuZXdSYW5nZVN0YXJ0ID0gMDtcXG5cXHQgICAgICAgICAgY3VyUmFuZ2UgPSBbXTtcXG5cXHQgICAgICAgIH1cXG5cXHQgICAgICB9XFxuXFx0ICAgICAgb2xkTGluZSArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgICAgbmV3TGluZSArPSBsaW5lcy5sZW5ndGg7XFxuXFx0ICAgIH1cXG5cXHQgIH07XFxuXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IGRpZmYubGVuZ3RoOyBpKyspIHtcXG5cXHQgICAgLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL19sb29wKCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2kpO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIHtcXG5cXHQgICAgb2xkRmlsZU5hbWU6IG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZTogbmV3RmlsZU5hbWUsXFxuXFx0ICAgIG9sZEhlYWRlcjogb2xkSGVhZGVyLCBuZXdIZWFkZXI6IG5ld0hlYWRlcixcXG5cXHQgICAgaHVua3M6IGh1bmtzXFxuXFx0ICB9O1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjcmVhdGVUd29GaWxlc1BhdGNoKG9sZEZpbGVOYW1lLCBuZXdGaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuXFx0ICB2YXIgZGlmZiA9IHN0cnVjdHVyZWRQYXRjaChvbGRGaWxlTmFtZSwgbmV3RmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XFxuXFxuXFx0ICB2YXIgcmV0ID0gW107XFxuXFx0ICBpZiAob2xkRmlsZU5hbWUgPT0gbmV3RmlsZU5hbWUpIHtcXG5cXHQgICAgcmV0LnB1c2goJ0luZGV4OiAnICsgb2xkRmlsZU5hbWUpO1xcblxcdCAgfVxcblxcdCAgcmV0LnB1c2goJz09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT09PT0nKTtcXG5cXHQgIHJldC5wdXNoKCctLS0gJyArIGRpZmYub2xkRmlsZU5hbWUgKyAodHlwZW9mIGRpZmYub2xkSGVhZGVyID09PSAndW5kZWZpbmVkJyA/ICcnIDogJ1xcXFx0JyArIGRpZmYub2xkSGVhZGVyKSk7XFxuXFx0ICByZXQucHVzaCgnKysrICcgKyBkaWZmLm5ld0ZpbGVOYW1lICsgKHR5cGVvZiBkaWZmLm5ld0hlYWRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnJyA6ICdcXFxcdCcgKyBkaWZmLm5ld0hlYWRlcikpO1xcblxcblxcdCAgZm9yICh2YXIgaSA9IDA7IGkgPCBkaWZmLmh1bmtzLmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIHZhciBodW5rID0gZGlmZi5odW5rc1tpXTtcXG5cXHQgICAgcmV0LnB1c2goJ0BAIC0nICsgaHVuay5vbGRTdGFydCArICcsJyArIGh1bmsub2xkTGluZXMgKyAnICsnICsgaHVuay5uZXdTdGFydCArICcsJyArIGh1bmsubmV3TGluZXMgKyAnIEBAJyk7XFxuXFx0ICAgIHJldC5wdXNoLmFwcGx5KHJldCwgaHVuay5saW5lcyk7XFxuXFx0ICB9XFxuXFxuXFx0ICByZXR1cm4gcmV0LmpvaW4oJ1xcXFxuJykgKyAnXFxcXG4nO1xcblxcdH1cXG5cXG5cXHRmdW5jdGlvbiBjcmVhdGVQYXRjaChmaWxlTmFtZSwgb2xkU3RyLCBuZXdTdHIsIG9sZEhlYWRlciwgbmV3SGVhZGVyLCBvcHRpb25zKSB7XFxuXFx0ICByZXR1cm4gY3JlYXRlVHdvRmlsZXNQYXRjaChmaWxlTmFtZSwgZmlsZU5hbWUsIG9sZFN0ciwgbmV3U3RyLCBvbGRIZWFkZXIsIG5ld0hlYWRlciwgb3B0aW9ucyk7XFxuXFx0fVxcblxcblxcblxcbi8qKiovIH0pLFxcbi8qIDE1ICovXFxuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xcblxcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9cXFwidXNlIHN0cmljdFxcXCI7XFxuXFxuXFx0ZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcXG5cXHRleHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FycmF5RXF1YWwgPSBhcnJheUVxdWFsO1xcblxcdC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki9leHBvcnRzLiAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqL2FycmF5U3RhcnRzV2l0aCA9IGFycmF5U3RhcnRzV2l0aDtcXG5cXHRmdW5jdGlvbiBhcnJheUVxdWFsKGEsIGIpIHtcXG5cXHQgIGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHtcXG5cXHQgICAgcmV0dXJuIGZhbHNlO1xcblxcdCAgfVxcblxcblxcdCAgcmV0dXJuIGFycmF5U3RhcnRzV2l0aChhLCBiKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gYXJyYXlTdGFydHNXaXRoKGFycmF5LCBzdGFydCkge1xcblxcdCAgaWYgKHN0YXJ0Lmxlbmd0aCA+IGFycmF5Lmxlbmd0aCkge1xcblxcdCAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICB9XFxuXFxuXFx0ICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXJ0Lmxlbmd0aDsgaSsrKSB7XFxuXFx0ICAgIGlmIChzdGFydFtpXSAhPT0gYXJyYXlbaV0pIHtcXG5cXHQgICAgICByZXR1cm4gZmFsc2U7XFxuXFx0ICAgIH1cXG5cXHQgIH1cXG5cXG5cXHQgIHJldHVybiB0cnVlO1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxNiAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovXFxcInVzZSBzdHJpY3RcXFwiO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvRE1QID0gY29udmVydENoYW5nZXNUb0RNUDtcXG5cXHQvLyBTZWU6IGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC9nb29nbGUtZGlmZi1tYXRjaC1wYXRjaC93aWtpL0FQSVxcblxcdGZ1bmN0aW9uIGNvbnZlcnRDaGFuZ2VzVG9ETVAoY2hhbmdlcykge1xcblxcdCAgdmFyIHJldCA9IFtdLFxcblxcdCAgICAgIGNoYW5nZSA9IC8qaXN0YW5idWwgaWdub3JlIHN0YXJ0Ki92b2lkIDAgLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi8sXFxuXFx0ICAgICAgb3BlcmF0aW9uID0gLyppc3RhbmJ1bCBpZ25vcmUgc3RhcnQqL3ZvaWQgMCAvKmlzdGFuYnVsIGlnbm9yZSBlbmQqLztcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICBjaGFuZ2UgPSBjaGFuZ2VzW2ldO1xcblxcdCAgICBpZiAoY2hhbmdlLmFkZGVkKSB7XFxuXFx0ICAgICAgb3BlcmF0aW9uID0gMTtcXG5cXHQgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcblxcdCAgICAgIG9wZXJhdGlvbiA9IC0xO1xcblxcdCAgICB9IGVsc2Uge1xcblxcdCAgICAgIG9wZXJhdGlvbiA9IDA7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0LnB1c2goW29wZXJhdGlvbiwgY2hhbmdlLnZhbHVlXSk7XFxuXFx0ICB9XFxuXFx0ICByZXR1cm4gcmV0O1xcblxcdH1cXG5cXG5cXG5cXG4vKioqLyB9KSxcXG4vKiAxNyAqL1xcbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMpIHtcXG5cXG5cXHQvKmlzdGFuYnVsIGlnbm9yZSBzdGFydCovJ3VzZSBzdHJpY3QnO1xcblxcblxcdGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XFxuXFx0ZXhwb3J0cy4gLyppc3RhbmJ1bCBpZ25vcmUgZW5kKi9jb252ZXJ0Q2hhbmdlc1RvWE1MID0gY29udmVydENoYW5nZXNUb1hNTDtcXG5cXHRmdW5jdGlvbiBjb252ZXJ0Q2hhbmdlc1RvWE1MKGNoYW5nZXMpIHtcXG5cXHQgIHZhciByZXQgPSBbXTtcXG5cXHQgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hhbmdlcy5sZW5ndGg7IGkrKykge1xcblxcdCAgICB2YXIgY2hhbmdlID0gY2hhbmdlc1tpXTtcXG5cXHQgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcblxcdCAgICAgIHJldC5wdXNoKCc8aW5zPicpO1xcblxcdCAgICB9IGVsc2UgaWYgKGNoYW5nZS5yZW1vdmVkKSB7XFxuXFx0ICAgICAgcmV0LnB1c2goJzxkZWw+Jyk7XFxuXFx0ICAgIH1cXG5cXG5cXHQgICAgcmV0LnB1c2goZXNjYXBlSFRNTChjaGFuZ2UudmFsdWUpKTtcXG5cXG5cXHQgICAgaWYgKGNoYW5nZS5hZGRlZCkge1xcblxcdCAgICAgIHJldC5wdXNoKCc8L2lucz4nKTtcXG5cXHQgICAgfSBlbHNlIGlmIChjaGFuZ2UucmVtb3ZlZCkge1xcblxcdCAgICAgIHJldC5wdXNoKCc8L2RlbD4nKTtcXG5cXHQgICAgfVxcblxcdCAgfVxcblxcdCAgcmV0dXJuIHJldC5qb2luKCcnKTtcXG5cXHR9XFxuXFxuXFx0ZnVuY3Rpb24gZXNjYXBlSFRNTChzKSB7XFxuXFx0ICB2YXIgbiA9IHM7XFxuXFx0ICBuID0gbi5yZXBsYWNlKC8mL2csICcmYW1wOycpO1xcblxcdCAgbiA9IG4ucmVwbGFjZSgvPC9nLCAnJmx0OycpO1xcblxcdCAgbiA9IG4ucmVwbGFjZSgvPi9nLCAnJmd0OycpO1xcblxcdCAgbiA9IG4ucmVwbGFjZSgvXFxcIi9nLCAnJnF1b3Q7Jyk7XFxuXFxuXFx0ICByZXR1cm4gbjtcXG5cXHR9XFxuXFxuXFxuXFxuLyoqKi8gfSlcXG4vKioqKioqLyBdKVxcbn0pO1xcbjtcXG59LHt9XSw0NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuJ3VzZSBzdHJpY3QnO1xcblxcbnZhciBtYXRjaE9wZXJhdG9yc1JlID0gL1t8XFxcXFxcXFx7fSgpW1xcXFxdXiQrKj8uXS9nO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHN0cikge1xcblxcdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJykge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGEgc3RyaW5nJyk7XFxuXFx0fVxcblxcblxcdHJldHVybiBzdHIucmVwbGFjZShtYXRjaE9wZXJhdG9yc1JlLCAnXFxcXFxcXFwkJicpO1xcbn07XFxuXFxufSx7fV0sNDc6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcXG4gIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cyB8fCB7fTtcXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XFxufVxcbm1vZHVsZS5leHBvcnRzID0gRXZlbnRFbWl0dGVyO1xcblxcbi8vIEJhY2t3YXJkcy1jb21wYXQgd2l0aCBub2RlIDAuMTAueFxcbkV2ZW50RW1pdHRlci5FdmVudEVtaXR0ZXIgPSBFdmVudEVtaXR0ZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5fZXZlbnRzID0gdW5kZWZpbmVkO1xcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuX21heExpc3RlbmVycyA9IHVuZGVmaW5lZDtcXG5cXG4vLyBCeSBkZWZhdWx0IEV2ZW50RW1pdHRlcnMgd2lsbCBwcmludCBhIHdhcm5pbmcgaWYgbW9yZSB0aGFuIDEwIGxpc3RlbmVycyBhcmVcXG4vLyBhZGRlZCB0byBpdC4gVGhpcyBpcyBhIHVzZWZ1bCBkZWZhdWx0IHdoaWNoIGhlbHBzIGZpbmRpbmcgbWVtb3J5IGxlYWtzLlxcbkV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XFxuXFxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXFxuLy8gdGhhdCB0byBiZSBpbmNyZWFzZWQuIFNldCB0byB6ZXJvIGZvciB1bmxpbWl0ZWQuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5zZXRNYXhMaXN0ZW5lcnMgPSBmdW5jdGlvbihuKSB7XFxuICBpZiAoIWlzTnVtYmVyKG4pIHx8IG4gPCAwIHx8IGlzTmFOKG4pKVxcbiAgICB0aHJvdyBUeXBlRXJyb3IoJ24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlcicpO1xcbiAgdGhpcy5fbWF4TGlzdGVuZXJzID0gbjtcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5lbWl0ID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIGVyLCBoYW5kbGVyLCBsZW4sIGFyZ3MsIGksIGxpc3RlbmVycztcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG5cXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cXG4gIGlmICh0eXBlID09PSAnZXJyb3InKSB7XFxuICAgIGlmICghdGhpcy5fZXZlbnRzLmVycm9yIHx8XFxuICAgICAgICAoaXNPYmplY3QodGhpcy5fZXZlbnRzLmVycm9yKSAmJiAhdGhpcy5fZXZlbnRzLmVycm9yLmxlbmd0aCkpIHtcXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcXG4gICAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xcbiAgICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcXG4gICAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuY2F1Z2h0LCB1bnNwZWNpZmllZCBcXFwiZXJyb3JcXFwiIGV2ZW50LiAoJyArIGVyICsgJyknKTtcXG4gICAgICAgIGVyci5jb250ZXh0ID0gZXI7XFxuICAgICAgICB0aHJvdyBlcnI7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBoYW5kbGVyID0gdGhpcy5fZXZlbnRzW3R5cGVdO1xcblxcbiAgaWYgKGlzVW5kZWZpbmVkKGhhbmRsZXIpKVxcbiAgICByZXR1cm4gZmFsc2U7XFxuXFxuICBpZiAoaXNGdW5jdGlvbihoYW5kbGVyKSkge1xcbiAgICBzd2l0Y2ggKGFyZ3VtZW50cy5sZW5ndGgpIHtcXG4gICAgICAvLyBmYXN0IGNhc2VzXFxuICAgICAgY2FzZSAxOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMpO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgY2FzZSAyOlxcbiAgICAgICAgaGFuZGxlci5jYWxsKHRoaXMsIGFyZ3VtZW50c1sxXSk7XFxuICAgICAgICBicmVhaztcXG4gICAgICBjYXNlIDM6XFxuICAgICAgICBoYW5kbGVyLmNhbGwodGhpcywgYXJndW1lbnRzWzFdLCBhcmd1bWVudHNbMl0pO1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgLy8gc2xvd2VyXFxuICAgICAgZGVmYXVsdDpcXG4gICAgICAgIGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xcbiAgICAgICAgaGFuZGxlci5hcHBseSh0aGlzLCBhcmdzKTtcXG4gICAgfVxcbiAgfSBlbHNlIGlmIChpc09iamVjdChoYW5kbGVyKSkge1xcbiAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG4gICAgbGlzdGVuZXJzID0gaGFuZGxlci5zbGljZSgpO1xcbiAgICBsZW4gPSBsaXN0ZW5lcnMubGVuZ3RoO1xcbiAgICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXFxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHRydWU7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBtO1xcblxcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzKVxcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG5cXG4gIC8vIFRvIGF2b2lkIHJlY3Vyc2lvbiBpbiB0aGUgY2FzZSB0aGF0IHR5cGUgPT09IFxcXCJuZXdMaXN0ZW5lclxcXCIhIEJlZm9yZVxcbiAgLy8gYWRkaW5nIGl0IHRvIHRoZSBsaXN0ZW5lcnMsIGZpcnN0IGVtaXQgXFxcIm5ld0xpc3RlbmVyXFxcIi5cXG4gIGlmICh0aGlzLl9ldmVudHMubmV3TGlzdGVuZXIpXFxuICAgIHRoaXMuZW1pdCgnbmV3TGlzdGVuZXInLCB0eXBlLFxcbiAgICAgICAgICAgICAgaXNGdW5jdGlvbihsaXN0ZW5lci5saXN0ZW5lcikgP1xcbiAgICAgICAgICAgICAgbGlzdGVuZXIubGlzdGVuZXIgOiBsaXN0ZW5lcik7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50c1t0eXBlXSlcXG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXFxuICAgIHRoaXMuX2V2ZW50c1t0eXBlXSA9IGxpc3RlbmVyO1xcbiAgZWxzZSBpZiAoaXNPYmplY3QodGhpcy5fZXZlbnRzW3R5cGVdKSlcXG4gICAgLy8gSWYgd2UndmUgYWxyZWFkeSBnb3QgYW4gYXJyYXksIGp1c3QgYXBwZW5kLlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XFxuICBlbHNlXFxuICAgIC8vIEFkZGluZyB0aGUgc2Vjb25kIGVsZW1lbnQsIG5lZWQgdG8gY2hhbmdlIHRvIGFycmF5LlxcbiAgICB0aGlzLl9ldmVudHNbdHlwZV0gPSBbdGhpcy5fZXZlbnRzW3R5cGVdLCBsaXN0ZW5lcl07XFxuXFxuICAvLyBDaGVjayBmb3IgbGlzdGVuZXIgbGVha1xcbiAgaWYgKGlzT2JqZWN0KHRoaXMuX2V2ZW50c1t0eXBlXSkgJiYgIXRoaXMuX2V2ZW50c1t0eXBlXS53YXJuZWQpIHtcXG4gICAgaWYgKCFpc1VuZGVmaW5lZCh0aGlzLl9tYXhMaXN0ZW5lcnMpKSB7XFxuICAgICAgbSA9IHRoaXMuX21heExpc3RlbmVycztcXG4gICAgfSBlbHNlIHtcXG4gICAgICBtID0gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XFxuICAgIH1cXG5cXG4gICAgaWYgKG0gJiYgbSA+IDAgJiYgdGhpcy5fZXZlbnRzW3R5cGVdLmxlbmd0aCA+IG0pIHtcXG4gICAgICB0aGlzLl9ldmVudHNbdHlwZV0ud2FybmVkID0gdHJ1ZTtcXG4gICAgICBjb25zb2xlLmVycm9yKCcobm9kZSkgd2FybmluZzogcG9zc2libGUgRXZlbnRFbWl0dGVyIG1lbW9yeSAnICtcXG4gICAgICAgICAgICAgICAgICAgICdsZWFrIGRldGVjdGVkLiAlZCBsaXN0ZW5lcnMgYWRkZWQuICcgK1xcbiAgICAgICAgICAgICAgICAgICAgJ1VzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvIGluY3JlYXNlIGxpbWl0LicsXFxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHNbdHlwZV0ubGVuZ3RoKTtcXG4gICAgICBpZiAodHlwZW9mIGNvbnNvbGUudHJhY2UgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIC8vIG5vdCBzdXBwb3J0ZWQgaW4gSUUgMTBcXG4gICAgICAgIGNvbnNvbGUudHJhY2UoKTtcXG4gICAgICB9XFxuICAgIH1cXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbiA9IEV2ZW50RW1pdHRlci5wcm90b3R5cGUuYWRkTGlzdGVuZXI7XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIGlmICghaXNGdW5jdGlvbihsaXN0ZW5lcikpXFxuICAgIHRocm93IFR5cGVFcnJvcignbGlzdGVuZXIgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XFxuXFxuICB2YXIgZmlyZWQgPSBmYWxzZTtcXG5cXG4gIGZ1bmN0aW9uIGcoKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgZyk7XFxuXFxuICAgIGlmICghZmlyZWQpIHtcXG4gICAgICBmaXJlZCA9IHRydWU7XFxuICAgICAgbGlzdGVuZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgZy5saXN0ZW5lciA9IGxpc3RlbmVyO1xcbiAgdGhpcy5vbih0eXBlLCBnKTtcXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gZW1pdHMgYSAncmVtb3ZlTGlzdGVuZXInIGV2ZW50IGlmZiB0aGUgbGlzdGVuZXIgd2FzIHJlbW92ZWRcXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnJlbW92ZUxpc3RlbmVyID0gZnVuY3Rpb24odHlwZSwgbGlzdGVuZXIpIHtcXG4gIHZhciBsaXN0LCBwb3NpdGlvbiwgbGVuZ3RoLCBpO1xcblxcbiAgaWYgKCFpc0Z1bmN0aW9uKGxpc3RlbmVyKSlcXG4gICAgdGhyb3cgVHlwZUVycm9yKCdsaXN0ZW5lciBtdXN0IGJlIGEgZnVuY3Rpb24nKTtcXG5cXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldHVybiB0aGlzO1xcblxcbiAgbGlzdCA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG4gIGxlbmd0aCA9IGxpc3QubGVuZ3RoO1xcbiAgcG9zaXRpb24gPSAtMTtcXG5cXG4gIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fFxcbiAgICAgIChpc0Z1bmN0aW9uKGxpc3QubGlzdGVuZXIpICYmIGxpc3QubGlzdGVuZXIgPT09IGxpc3RlbmVyKSkge1xcbiAgICBkZWxldGUgdGhpcy5fZXZlbnRzW3R5cGVdO1xcbiAgICBpZiAodGhpcy5fZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxcbiAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0ZW5lcik7XFxuXFxuICB9IGVsc2UgaWYgKGlzT2JqZWN0KGxpc3QpKSB7XFxuICAgIGZvciAoaSA9IGxlbmd0aDsgaS0tID4gMDspIHtcXG4gICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHxcXG4gICAgICAgICAgKGxpc3RbaV0ubGlzdGVuZXIgJiYgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpKSB7XFxuICAgICAgICBwb3NpdGlvbiA9IGk7XFxuICAgICAgICBicmVhaztcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHBvc2l0aW9uIDwgMClcXG4gICAgICByZXR1cm4gdGhpcztcXG5cXG4gICAgaWYgKGxpc3QubGVuZ3RoID09PSAxKSB7XFxuICAgICAgbGlzdC5sZW5ndGggPSAwO1xcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgbGlzdC5zcGxpY2UocG9zaXRpb24sIDEpO1xcbiAgICB9XFxuXFxuICAgIGlmICh0aGlzLl9ldmVudHMucmVtb3ZlTGlzdGVuZXIpXFxuICAgICAgdGhpcy5lbWl0KCdyZW1vdmVMaXN0ZW5lcicsIHR5cGUsIGxpc3RlbmVyKTtcXG4gIH1cXG5cXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBmdW5jdGlvbih0eXBlKSB7XFxuICB2YXIga2V5LCBsaXN0ZW5lcnM7XFxuXFxuICBpZiAoIXRoaXMuX2V2ZW50cylcXG4gICAgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBub3QgbGlzdGVuaW5nIGZvciByZW1vdmVMaXN0ZW5lciwgbm8gbmVlZCB0byBlbWl0XFxuICBpZiAoIXRoaXMuX2V2ZW50cy5yZW1vdmVMaXN0ZW5lcikge1xcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMClcXG4gICAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgZWxzZSBpZiAodGhpcy5fZXZlbnRzW3R5cGVdKVxcbiAgICAgIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gZW1pdCByZW1vdmVMaXN0ZW5lciBmb3IgYWxsIGxpc3RlbmVycyBvbiBhbGwgZXZlbnRzXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMCkge1xcbiAgICBmb3IgKGtleSBpbiB0aGlzLl9ldmVudHMpIHtcXG4gICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcXG4gICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xcbiAgICB9XFxuICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xcbiAgICB0aGlzLl9ldmVudHMgPSB7fTtcXG4gICAgcmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICBsaXN0ZW5lcnMgPSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICBpZiAoaXNGdW5jdGlvbihsaXN0ZW5lcnMpKSB7XFxuICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXJzKTtcXG4gIH0gZWxzZSBpZiAobGlzdGVuZXJzKSB7XFxuICAgIC8vIExJRk8gb3JkZXJcXG4gICAgd2hpbGUgKGxpc3RlbmVycy5sZW5ndGgpXFxuICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnNbbGlzdGVuZXJzLmxlbmd0aCAtIDFdKTtcXG4gIH1cXG4gIGRlbGV0ZSB0aGlzLl9ldmVudHNbdHlwZV07XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJzID0gZnVuY3Rpb24odHlwZSkge1xcbiAgdmFyIHJldDtcXG4gIGlmICghdGhpcy5fZXZlbnRzIHx8ICF0aGlzLl9ldmVudHNbdHlwZV0pXFxuICAgIHJldCA9IFtdO1xcbiAgZWxzZSBpZiAoaXNGdW5jdGlvbih0aGlzLl9ldmVudHNbdHlwZV0pKVxcbiAgICByZXQgPSBbdGhpcy5fZXZlbnRzW3R5cGVdXTtcXG4gIGVsc2VcXG4gICAgcmV0ID0gdGhpcy5fZXZlbnRzW3R5cGVdLnNsaWNlKCk7XFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lckNvdW50ID0gZnVuY3Rpb24odHlwZSkge1xcbiAgaWYgKHRoaXMuX2V2ZW50cykge1xcbiAgICB2YXIgZXZsaXN0ZW5lciA9IHRoaXMuX2V2ZW50c1t0eXBlXTtcXG5cXG4gICAgaWYgKGlzRnVuY3Rpb24oZXZsaXN0ZW5lcikpXFxuICAgICAgcmV0dXJuIDE7XFxuICAgIGVsc2UgaWYgKGV2bGlzdGVuZXIpXFxuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xcbiAgfVxcbiAgcmV0dXJuIDA7XFxufTtcXG5cXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcXG4gIHJldHVybiBlbWl0dGVyLmxpc3RlbmVyQ291bnQodHlwZSk7XFxufTtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5cXG5mdW5jdGlvbiBpc09iamVjdChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnb2JqZWN0JyAmJiBhcmcgIT09IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5cXG59LHt9XSw0ODpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChnbG9iYWwpe1xcbi8qISBodHRwczovL210aHMuYmUvaGUgdjEuMS4xIGJ5IEBtYXRoaWFzIHwgTUlUIGxpY2Vuc2UgKi9cXG47KGZ1bmN0aW9uKHJvb3QpIHtcXG5cXG5cXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZXMgYGV4cG9ydHNgLlxcblxcdHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XFxuXFxuXFx0Ly8gRGV0ZWN0IGZyZWUgdmFyaWFibGUgYG1vZHVsZWAuXFxuXFx0dmFyIGZyZWVNb2R1bGUgPSB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJlxcblxcdFxcdG1vZHVsZS5leHBvcnRzID09IGZyZWVFeHBvcnRzICYmIG1vZHVsZTtcXG5cXG5cXHQvLyBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCwgZnJvbSBOb2RlLmpzIG9yIEJyb3dzZXJpZmllZCBjb2RlLFxcblxcdC8vIGFuZCB1c2UgaXQgYXMgYHJvb3RgLlxcblxcdHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWw7XFxuXFx0aWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsIHx8IGZyZWVHbG9iYWwud2luZG93ID09PSBmcmVlR2xvYmFsKSB7XFxuXFx0XFx0cm9vdCA9IGZyZWVHbG9iYWw7XFxuXFx0fVxcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdC8vIEFsbCBhc3RyYWwgc3ltYm9scy5cXG5cXHR2YXIgcmVnZXhBc3RyYWxTeW1ib2xzID0gL1tcXFxcdUQ4MDAtXFxcXHVEQkZGXVtcXFxcdURDMDAtXFxcXHVERkZGXS9nO1xcblxcdC8vIEFsbCBBU0NJSSBzeW1ib2xzIChub3QganVzdCBwcmludGFibGUgQVNDSUkpIGV4Y2VwdCB0aG9zZSBsaXN0ZWQgaW4gdGhlXFxuXFx0Ly8gZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUuXFxuXFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjdGFibGUtY2hhcnJlZi1vdmVycmlkZXNcXG5cXHR2YXIgcmVnZXhBc2NpaVdoaXRlbGlzdCA9IC9bXFxcXHgwMS1cXFxceDdGXS9nO1xcblxcdC8vIEFsbCBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgQVNDSUkgbmV3bGluZXMsIHByaW50YWJsZSBBU0NJSSBzeW1ib2xzLCBvclxcblxcdC8vIGNvZGUgcG9pbnRzIGxpc3RlZCBpbiB0aGUgZmlyc3QgY29sdW1uIG9mIHRoZSBvdmVycmlkZXMgdGFibGUgb25cXG5cXHQvLyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9zeW50YXguaHRtbCN0YWJsZS1jaGFycmVmLW92ZXJyaWRlcy5cXG5cXHR2YXIgcmVnZXhCbXBXaGl0ZWxpc3QgPSAvW1xcXFx4MDEtXFxcXHRcXFxceDBCXFxcXGZcXFxceDBFLVxcXFx4MUZcXFxceDdGXFxcXHg4MVxcXFx4OERcXFxceDhGXFxcXHg5MFxcXFx4OURcXFxceEEwLVxcXFx1RkZGRl0vZztcXG5cXG5cXHR2YXIgcmVnZXhFbmNvZGVOb25Bc2NpaSA9IC88XFxcXHUyMEQyfD1cXFxcdTIwRTV8PlxcXFx1MjBEMnxcXFxcdTIwNUZcXFxcdTIwMEF8XFxcXHUyMTlEXFxcXHUwMzM4fFxcXFx1MjIwMlxcXFx1MDMzOHxcXFxcdTIyMjBcXFxcdTIwRDJ8XFxcXHUyMjI5XFxcXHVGRTAwfFxcXFx1MjIyQVxcXFx1RkUwMHxcXFxcdTIyM0NcXFxcdTIwRDJ8XFxcXHUyMjNEXFxcXHUwMzMxfFxcXFx1MjIzRVxcXFx1MDMzM3xcXFxcdTIyNDJcXFxcdTAzMzh8XFxcXHUyMjRCXFxcXHUwMzM4fFxcXFx1MjI0RFxcXFx1MjBEMnxcXFxcdTIyNEVcXFxcdTAzMzh8XFxcXHUyMjRGXFxcXHUwMzM4fFxcXFx1MjI1MFxcXFx1MDMzOHxcXFxcdTIyNjFcXFxcdTIwRTV8XFxcXHUyMjY0XFxcXHUyMEQyfFxcXFx1MjI2NVxcXFx1MjBEMnxcXFxcdTIyNjZcXFxcdTAzMzh8XFxcXHUyMjY3XFxcXHUwMzM4fFxcXFx1MjI2OFxcXFx1RkUwMHxcXFxcdTIyNjlcXFxcdUZFMDB8XFxcXHUyMjZBXFxcXHUwMzM4fFxcXFx1MjI2QVxcXFx1MjBEMnxcXFxcdTIyNkJcXFxcdTAzMzh8XFxcXHUyMjZCXFxcXHUyMEQyfFxcXFx1MjI3RlxcXFx1MDMzOHxcXFxcdTIyODJcXFxcdTIwRDJ8XFxcXHUyMjgzXFxcXHUyMEQyfFxcXFx1MjI4QVxcXFx1RkUwMHxcXFxcdTIyOEJcXFxcdUZFMDB8XFxcXHUyMjhGXFxcXHUwMzM4fFxcXFx1MjI5MFxcXFx1MDMzOHxcXFxcdTIyOTNcXFxcdUZFMDB8XFxcXHUyMjk0XFxcXHVGRTAwfFxcXFx1MjJCNFxcXFx1MjBEMnxcXFxcdTIyQjVcXFxcdTIwRDJ8XFxcXHUyMkQ4XFxcXHUwMzM4fFxcXFx1MjJEOVxcXFx1MDMzOHxcXFxcdTIyREFcXFxcdUZFMDB8XFxcXHUyMkRCXFxcXHVGRTAwfFxcXFx1MjJGNVxcXFx1MDMzOHxcXFxcdTIyRjlcXFxcdTAzMzh8XFxcXHUyOTMzXFxcXHUwMzM4fFxcXFx1MjlDRlxcXFx1MDMzOHxcXFxcdTI5RDBcXFxcdTAzMzh8XFxcXHUyQTZEXFxcXHUwMzM4fFxcXFx1MkE3MFxcXFx1MDMzOHxcXFxcdTJBN0RcXFxcdTAzMzh8XFxcXHUyQTdFXFxcXHUwMzM4fFxcXFx1MkFBMVxcXFx1MDMzOHxcXFxcdTJBQTJcXFxcdTAzMzh8XFxcXHUyQUFDXFxcXHVGRTAwfFxcXFx1MkFBRFxcXFx1RkUwMHxcXFxcdTJBQUZcXFxcdTAzMzh8XFxcXHUyQUIwXFxcXHUwMzM4fFxcXFx1MkFDNVxcXFx1MDMzOHxcXFxcdTJBQzZcXFxcdTAzMzh8XFxcXHUyQUNCXFxcXHVGRTAwfFxcXFx1MkFDQ1xcXFx1RkUwMHxcXFxcdTJBRkRcXFxcdTIwRTV8W1xcXFx4QTAtXFxcXHUwMTEzXFxcXHUwMTE2LVxcXFx1MDEyMlxcXFx1MDEyNC1cXFxcdTAxMkJcXFxcdTAxMkUtXFxcXHUwMTREXFxcXHUwMTUwLVxcXFx1MDE3RVxcXFx1MDE5MlxcXFx1MDFCNVxcXFx1MDFGNVxcXFx1MDIzN1xcXFx1MDJDNlxcXFx1MDJDN1xcXFx1MDJEOC1cXFxcdTAyRERcXFxcdTAzMTFcXFxcdTAzOTEtXFxcXHUwM0ExXFxcXHUwM0EzLVxcXFx1MDNBOVxcXFx1MDNCMS1cXFxcdTAzQzlcXFxcdTAzRDFcXFxcdTAzRDJcXFxcdTAzRDVcXFxcdTAzRDZcXFxcdTAzRENcXFxcdTAzRERcXFxcdTAzRjBcXFxcdTAzRjFcXFxcdTAzRjVcXFxcdTAzRjZcXFxcdTA0MDEtXFxcXHUwNDBDXFxcXHUwNDBFLVxcXFx1MDQ0RlxcXFx1MDQ1MS1cXFxcdTA0NUNcXFxcdTA0NUVcXFxcdTA0NUZcXFxcdTIwMDItXFxcXHUyMDA1XFxcXHUyMDA3LVxcXFx1MjAxMFxcXFx1MjAxMy1cXFxcdTIwMTZcXFxcdTIwMTgtXFxcXHUyMDFBXFxcXHUyMDFDLVxcXFx1MjAxRVxcXFx1MjAyMC1cXFxcdTIwMjJcXFxcdTIwMjVcXFxcdTIwMjZcXFxcdTIwMzAtXFxcXHUyMDM1XFxcXHUyMDM5XFxcXHUyMDNBXFxcXHUyMDNFXFxcXHUyMDQxXFxcXHUyMDQzXFxcXHUyMDQ0XFxcXHUyMDRGXFxcXHUyMDU3XFxcXHUyMDVGLVxcXFx1MjA2M1xcXFx1MjBBQ1xcXFx1MjBEQlxcXFx1MjBEQ1xcXFx1MjEwMlxcXFx1MjEwNVxcXFx1MjEwQS1cXFxcdTIxMTNcXFxcdTIxMTUtXFxcXHUyMTFFXFxcXHUyMTIyXFxcXHUyMTI0XFxcXHUyMTI3LVxcXFx1MjEyOVxcXFx1MjEyQ1xcXFx1MjEyRFxcXFx1MjEyRi1cXFxcdTIxMzFcXFxcdTIxMzMtXFxcXHUyMTM4XFxcXHUyMTQ1LVxcXFx1MjE0OFxcXFx1MjE1My1cXFxcdTIxNUVcXFxcdTIxOTAtXFxcXHUyMTlCXFxcXHUyMTlELVxcXFx1MjFBN1xcXFx1MjFBOS1cXFxcdTIxQUVcXFxcdTIxQjAtXFxcXHUyMUIzXFxcXHUyMUI1LVxcXFx1MjFCN1xcXFx1MjFCQS1cXFxcdTIxREJcXFxcdTIxRERcXFxcdTIxRTRcXFxcdTIxRTVcXFxcdTIxRjVcXFxcdTIxRkQtXFxcXHUyMjA1XFxcXHUyMjA3LVxcXFx1MjIwOVxcXFx1MjIwQlxcXFx1MjIwQ1xcXFx1MjIwRi1cXFxcdTIyMTRcXFxcdTIyMTYtXFxcXHUyMjE4XFxcXHUyMjFBXFxcXHUyMjFELVxcXFx1MjIzOFxcXFx1MjIzQS1cXFxcdTIyNTdcXFxcdTIyNTlcXFxcdTIyNUFcXFxcdTIyNUNcXFxcdTIyNUYtXFxcXHUyMjYyXFxcXHUyMjY0LVxcXFx1MjI4QlxcXFx1MjI4RC1cXFxcdTIyOUJcXFxcdTIyOUQtXFxcXHUyMkE1XFxcXHUyMkE3LVxcXFx1MjJCMFxcXFx1MjJCMi1cXFxcdTIyQkJcXFxcdTIyQkQtXFxcXHUyMkRCXFxcXHUyMkRFLVxcXFx1MjJFM1xcXFx1MjJFNi1cXFxcdTIyRjdcXFxcdTIyRjktXFxcXHUyMkZFXFxcXHUyMzA1XFxcXHUyMzA2XFxcXHUyMzA4LVxcXFx1MjMxMFxcXFx1MjMxMlxcXFx1MjMxM1xcXFx1MjMxNVxcXFx1MjMxNlxcXFx1MjMxQy1cXFxcdTIzMUZcXFxcdTIzMjJcXFxcdTIzMjNcXFxcdTIzMkRcXFxcdTIzMkVcXFxcdTIzMzZcXFxcdTIzM0RcXFxcdTIzM0ZcXFxcdTIzN0NcXFxcdTIzQjBcXFxcdTIzQjFcXFxcdTIzQjQtXFxcXHUyM0I2XFxcXHUyM0RDLVxcXFx1MjNERlxcXFx1MjNFMlxcXFx1MjNFN1xcXFx1MjQyM1xcXFx1MjRDOFxcXFx1MjUwMFxcXFx1MjUwMlxcXFx1MjUwQ1xcXFx1MjUxMFxcXFx1MjUxNFxcXFx1MjUxOFxcXFx1MjUxQ1xcXFx1MjUyNFxcXFx1MjUyQ1xcXFx1MjUzNFxcXFx1MjUzQ1xcXFx1MjU1MC1cXFxcdTI1NkNcXFxcdTI1ODBcXFxcdTI1ODRcXFxcdTI1ODhcXFxcdTI1OTEtXFxcXHUyNTkzXFxcXHUyNUExXFxcXHUyNUFBXFxcXHUyNUFCXFxcXHUyNUFEXFxcXHUyNUFFXFxcXHUyNUIxXFxcXHUyNUIzLVxcXFx1MjVCNVxcXFx1MjVCOFxcXFx1MjVCOVxcXFx1MjVCRC1cXFxcdTI1QkZcXFxcdTI1QzJcXFxcdTI1QzNcXFxcdTI1Q0FcXFxcdTI1Q0JcXFxcdTI1RUNcXFxcdTI1RUZcXFxcdTI1RjgtXFxcXHUyNUZDXFxcXHUyNjA1XFxcXHUyNjA2XFxcXHUyNjBFXFxcXHUyNjQwXFxcXHUyNjQyXFxcXHUyNjYwXFxcXHUyNjYzXFxcXHUyNjY1XFxcXHUyNjY2XFxcXHUyNjZBXFxcXHUyNjZELVxcXFx1MjY2RlxcXFx1MjcxM1xcXFx1MjcxN1xcXFx1MjcyMFxcXFx1MjczNlxcXFx1Mjc1OFxcXFx1Mjc3MlxcXFx1Mjc3M1xcXFx1MjdDOFxcXFx1MjdDOVxcXFx1MjdFNi1cXFxcdTI3RURcXFxcdTI3RjUtXFxcXHUyN0ZBXFxcXHUyN0ZDXFxcXHUyN0ZGXFxcXHUyOTAyLVxcXFx1MjkwNVxcXFx1MjkwQy1cXFxcdTI5MTNcXFxcdTI5MTZcXFxcdTI5MTktXFxcXHUyOTIwXFxcXHUyOTIzLVxcXFx1MjkyQVxcXFx1MjkzM1xcXFx1MjkzNS1cXFxcdTI5MzlcXFxcdTI5M0NcXFxcdTI5M0RcXFxcdTI5NDVcXFxcdTI5NDgtXFxcXHUyOTRCXFxcXHUyOTRFLVxcXFx1Mjk3NlxcXFx1Mjk3OFxcXFx1Mjk3OVxcXFx1Mjk3Qi1cXFxcdTI5N0ZcXFxcdTI5ODVcXFxcdTI5ODZcXFxcdTI5OEItXFxcXHUyOTk2XFxcXHUyOTlBXFxcXHUyOTlDXFxcXHUyOTlEXFxcXHUyOUE0LVxcXFx1MjlCN1xcXFx1MjlCOVxcXFx1MjlCQlxcXFx1MjlCQ1xcXFx1MjlCRS1cXFxcdTI5QzVcXFxcdTI5QzlcXFxcdTI5Q0QtXFxcXHUyOUQwXFxcXHUyOURDLVxcXFx1MjlERVxcXFx1MjlFMy1cXFxcdTI5RTVcXFxcdTI5RUJcXFxcdTI5RjRcXFxcdTI5RjZcXFxcdTJBMDAtXFxcXHUyQTAyXFxcXHUyQTA0XFxcXHUyQTA2XFxcXHUyQTBDXFxcXHUyQTBEXFxcXHUyQTEwLVxcXFx1MkExN1xcXFx1MkEyMi1cXFxcdTJBMjdcXFxcdTJBMjlcXFxcdTJBMkFcXFxcdTJBMkQtXFxcXHUyQTMxXFxcXHUyQTMzLVxcXFx1MkEzQ1xcXFx1MkEzRlxcXFx1MkE0MFxcXFx1MkE0Mi1cXFxcdTJBNERcXFxcdTJBNTBcXFxcdTJBNTMtXFxcXHUyQTU4XFxcXHUyQTVBLVxcXFx1MkE1RFxcXFx1MkE1RlxcXFx1MkE2NlxcXFx1MkE2QVxcXFx1MkE2RC1cXFxcdTJBNzVcXFxcdTJBNzctXFxcXHUyQTlBXFxcXHUyQTlELVxcXFx1MkFBMlxcXFx1MkFBNC1cXFxcdTJBQjBcXFxcdTJBQjMtXFxcXHUyQUM4XFxcXHUyQUNCXFxcXHUyQUNDXFxcXHUyQUNGLVxcXFx1MkFEQlxcXFx1MkFFNFxcXFx1MkFFNi1cXFxcdTJBRTlcXFxcdTJBRUItXFxcXHUyQUYzXFxcXHUyQUZEXFxcXHVGQjAwLVxcXFx1RkIwNF18XFxcXHVEODM1W1xcXFx1REM5Q1xcXFx1REM5RVxcXFx1REM5RlxcXFx1RENBMlxcXFx1RENBNVxcXFx1RENBNlxcXFx1RENBOS1cXFxcdURDQUNcXFxcdURDQUUtXFxcXHVEQ0I5XFxcXHVEQ0JCXFxcXHVEQ0JELVxcXFx1RENDM1xcXFx1RENDNS1cXFxcdURDQ0ZcXFxcdUREMDRcXFxcdUREMDVcXFxcdUREMDctXFxcXHVERDBBXFxcXHVERDBELVxcXFx1REQxNFxcXFx1REQxNi1cXFxcdUREMUNcXFxcdUREMUUtXFxcXHVERDM5XFxcXHVERDNCLVxcXFx1REQzRVxcXFx1REQ0MC1cXFxcdURENDRcXFxcdURENDZcXFxcdURENEEtXFxcXHVERDUwXFxcXHVERDUyLVxcXFx1REQ2Ql0vZztcXG5cXHR2YXIgZW5jb2RlTWFwID0geydcXFxceEFEJzonc2h5JywnXFxcXHUyMDBDJzonenduaicsJ1xcXFx1MjAwRCc6J3p3aicsJ1xcXFx1MjAwRSc6J2xybScsJ1xcXFx1MjA2Myc6J2ljJywnXFxcXHUyMDYyJzonaXQnLCdcXFxcdTIwNjEnOidhZicsJ1xcXFx1MjAwRic6J3JsbScsJ1xcXFx1MjAwQic6J1plcm9XaWR0aFNwYWNlJywnXFxcXHUyMDYwJzonTm9CcmVhaycsJ1xcXFx1MDMxMSc6J0Rvd25CcmV2ZScsJ1xcXFx1MjBEQic6J3Rkb3QnLCdcXFxcdTIwREMnOidEb3REb3QnLCdcXFxcdCc6J1RhYicsJ1xcXFxuJzonTmV3TGluZScsJ1xcXFx1MjAwOCc6J3B1bmNzcCcsJ1xcXFx1MjA1Ric6J01lZGl1bVNwYWNlJywnXFxcXHUyMDA5JzondGhpbnNwJywnXFxcXHUyMDBBJzonaGFpcnNwJywnXFxcXHUyMDA0JzonZW1zcDEzJywnXFxcXHUyMDAyJzonZW5zcCcsJ1xcXFx1MjAwNSc6J2Vtc3AxNCcsJ1xcXFx1MjAwMyc6J2Vtc3AnLCdcXFxcdTIwMDcnOidudW1zcCcsJ1xcXFx4QTAnOiduYnNwJywnXFxcXHUyMDVGXFxcXHUyMDBBJzonVGhpY2tTcGFjZScsJ1xcXFx1MjAzRSc6J29saW5lJywnXyc6J2xvd2JhcicsJ1xcXFx1MjAxMCc6J2Rhc2gnLCdcXFxcdTIwMTMnOiduZGFzaCcsJ1xcXFx1MjAxNCc6J21kYXNoJywnXFxcXHUyMDE1JzonaG9yYmFyJywnLCc6J2NvbW1hJywnOyc6J3NlbWknLCdcXFxcdTIwNEYnOidic2VtaScsJzonOidjb2xvbicsJ1xcXFx1MkE3NCc6J0NvbG9uZScsJyEnOidleGNsJywnXFxcXHhBMSc6J2lleGNsJywnPyc6J3F1ZXN0JywnXFxcXHhCRic6J2lxdWVzdCcsJy4nOidwZXJpb2QnLCdcXFxcdTIwMjUnOidubGRyJywnXFxcXHUyMDI2JzonbWxkcicsJ1xcXFx4QjcnOidtaWRkb3QnLCdcXFxcJyc6J2Fwb3MnLCdcXFxcdTIwMTgnOidsc3F1bycsJ1xcXFx1MjAxOSc6J3JzcXVvJywnXFxcXHUyMDFBJzonc2JxdW8nLCdcXFxcdTIwMzknOidsc2FxdW8nLCdcXFxcdTIwM0EnOidyc2FxdW8nLCdcXFwiJzoncXVvdCcsJ1xcXFx1MjAxQyc6J2xkcXVvJywnXFxcXHUyMDFEJzoncmRxdW8nLCdcXFxcdTIwMUUnOidiZHF1bycsJ1xcXFx4QUInOidsYXF1bycsJ1xcXFx4QkInOidyYXF1bycsJygnOidscGFyJywnKSc6J3JwYXInLCdbJzonbHNxYicsJ10nOidyc3FiJywneyc6J2xjdWInLCd9JzoncmN1YicsJ1xcXFx1MjMwOCc6J2xjZWlsJywnXFxcXHUyMzA5JzoncmNlaWwnLCdcXFxcdTIzMEEnOidsZmxvb3InLCdcXFxcdTIzMEInOidyZmxvb3InLCdcXFxcdTI5ODUnOidsb3BhcicsJ1xcXFx1Mjk4Nic6J3JvcGFyJywnXFxcXHUyOThCJzonbGJya2UnLCdcXFxcdTI5OEMnOidyYnJrZScsJ1xcXFx1Mjk4RCc6J2xicmtzbHUnLCdcXFxcdTI5OEUnOidyYnJrc2xkJywnXFxcXHUyOThGJzonbGJya3NsZCcsJ1xcXFx1Mjk5MCc6J3JicmtzbHUnLCdcXFxcdTI5OTEnOidsYW5nZCcsJ1xcXFx1Mjk5Mic6J3JhbmdkJywnXFxcXHUyOTkzJzonbHBhcmx0JywnXFxcXHUyOTk0JzoncnBhcmd0JywnXFxcXHUyOTk1JzonZ3RsUGFyJywnXFxcXHUyOTk2JzonbHRyUGFyJywnXFxcXHUyN0U2JzonbG9icmsnLCdcXFxcdTI3RTcnOidyb2JyaycsJ1xcXFx1MjdFOCc6J2xhbmcnLCdcXFxcdTI3RTknOidyYW5nJywnXFxcXHUyN0VBJzonTGFuZycsJ1xcXFx1MjdFQic6J1JhbmcnLCdcXFxcdTI3RUMnOidsb2FuZycsJ1xcXFx1MjdFRCc6J3JvYW5nJywnXFxcXHUyNzcyJzonbGJicmsnLCdcXFxcdTI3NzMnOidyYmJyaycsJ1xcXFx1MjAxNic6J1ZlcnQnLCdcXFxceEE3Jzonc2VjdCcsJ1xcXFx4QjYnOidwYXJhJywnQCc6J2NvbW1hdCcsJyonOidhc3QnLCcvJzonc29sJywndW5kZWZpbmVkJzpudWxsLCcmJzonYW1wJywnIyc6J251bScsJyUnOidwZXJjbnQnLCdcXFxcdTIwMzAnOidwZXJtaWwnLCdcXFxcdTIwMzEnOidwZXJ0ZW5rJywnXFxcXHUyMDIwJzonZGFnZ2VyJywnXFxcXHUyMDIxJzonRGFnZ2VyJywnXFxcXHUyMDIyJzonYnVsbCcsJ1xcXFx1MjA0Myc6J2h5YnVsbCcsJ1xcXFx1MjAzMic6J3ByaW1lJywnXFxcXHUyMDMzJzonUHJpbWUnLCdcXFxcdTIwMzQnOid0cHJpbWUnLCdcXFxcdTIwNTcnOidxcHJpbWUnLCdcXFxcdTIwMzUnOidicHJpbWUnLCdcXFxcdTIwNDEnOidjYXJldCcsJ2AnOidncmF2ZScsJ1xcXFx4QjQnOidhY3V0ZScsJ1xcXFx1MDJEQyc6J3RpbGRlJywnXic6J0hhdCcsJ1xcXFx4QUYnOidtYWNyJywnXFxcXHUwMkQ4JzonYnJldmUnLCdcXFxcdTAyRDknOidkb3QnLCdcXFxceEE4JzonZGllJywnXFxcXHUwMkRBJzoncmluZycsJ1xcXFx1MDJERCc6J2RibGFjJywnXFxcXHhCOCc6J2NlZGlsJywnXFxcXHUwMkRCJzonb2dvbicsJ1xcXFx1MDJDNic6J2NpcmMnLCdcXFxcdTAyQzcnOidjYXJvbicsJ1xcXFx4QjAnOidkZWcnLCdcXFxceEE5JzonY29weScsJ1xcXFx4QUUnOidyZWcnLCdcXFxcdTIxMTcnOidjb3B5c3InLCdcXFxcdTIxMTgnOid3cCcsJ1xcXFx1MjExRSc6J3J4JywnXFxcXHUyMTI3JzonbWhvJywnXFxcXHUyMTI5JzonaWlvdGEnLCdcXFxcdTIxOTAnOidsYXJyJywnXFxcXHUyMTlBJzonbmxhcnInLCdcXFxcdTIxOTInOidyYXJyJywnXFxcXHUyMTlCJzonbnJhcnInLCdcXFxcdTIxOTEnOid1YXJyJywnXFxcXHUyMTkzJzonZGFycicsJ1xcXFx1MjE5NCc6J2hhcnInLCdcXFxcdTIxQUUnOiduaGFycicsJ1xcXFx1MjE5NSc6J3ZhcnInLCdcXFxcdTIxOTYnOidud2FycicsJ1xcXFx1MjE5Nyc6J25lYXJyJywnXFxcXHUyMTk4Jzonc2VhcnInLCdcXFxcdTIxOTknOidzd2FycicsJ1xcXFx1MjE5RCc6J3JhcnJ3JywnXFxcXHUyMTlEXFxcXHUwMzM4JzonbnJhcnJ3JywnXFxcXHUyMTlFJzonTGFycicsJ1xcXFx1MjE5Ric6J1VhcnInLCdcXFxcdTIxQTAnOidSYXJyJywnXFxcXHUyMUExJzonRGFycicsJ1xcXFx1MjFBMic6J2xhcnJ0bCcsJ1xcXFx1MjFBMyc6J3JhcnJ0bCcsJ1xcXFx1MjFBNCc6J21hcHN0b2xlZnQnLCdcXFxcdTIxQTUnOidtYXBzdG91cCcsJ1xcXFx1MjFBNic6J21hcCcsJ1xcXFx1MjFBNyc6J21hcHN0b2Rvd24nLCdcXFxcdTIxQTknOidsYXJyaGsnLCdcXFxcdTIxQUEnOidyYXJyaGsnLCdcXFxcdTIxQUInOidsYXJybHAnLCdcXFxcdTIxQUMnOidyYXJybHAnLCdcXFxcdTIxQUQnOidoYXJydycsJ1xcXFx1MjFCMCc6J2xzaCcsJ1xcXFx1MjFCMSc6J3JzaCcsJ1xcXFx1MjFCMic6J2xkc2gnLCdcXFxcdTIxQjMnOidyZHNoJywnXFxcXHUyMUI1JzonY3JhcnInLCdcXFxcdTIxQjYnOidjdWxhcnInLCdcXFxcdTIxQjcnOidjdXJhcnInLCdcXFxcdTIxQkEnOidvbGFycicsJ1xcXFx1MjFCQic6J29yYXJyJywnXFxcXHUyMUJDJzonbGhhcnUnLCdcXFxcdTIxQkQnOidsaGFyZCcsJ1xcXFx1MjFCRSc6J3VoYXJyJywnXFxcXHUyMUJGJzondWhhcmwnLCdcXFxcdTIxQzAnOidyaGFydScsJ1xcXFx1MjFDMSc6J3JoYXJkJywnXFxcXHUyMUMyJzonZGhhcnInLCdcXFxcdTIxQzMnOidkaGFybCcsJ1xcXFx1MjFDNCc6J3JsYXJyJywnXFxcXHUyMUM1JzondWRhcnInLCdcXFxcdTIxQzYnOidscmFycicsJ1xcXFx1MjFDNyc6J2xsYXJyJywnXFxcXHUyMUM4JzondXVhcnInLCdcXFxcdTIxQzknOidycmFycicsJ1xcXFx1MjFDQSc6J2RkYXJyJywnXFxcXHUyMUNCJzonbHJoYXInLCdcXFxcdTIxQ0MnOidybGhhcicsJ1xcXFx1MjFEMCc6J2xBcnInLCdcXFxcdTIxQ0QnOidubEFycicsJ1xcXFx1MjFEMSc6J3VBcnInLCdcXFxcdTIxRDInOidyQXJyJywnXFxcXHUyMUNGJzonbnJBcnInLCdcXFxcdTIxRDMnOidkQXJyJywnXFxcXHUyMUQ0JzonaWZmJywnXFxcXHUyMUNFJzonbmhBcnInLCdcXFxcdTIxRDUnOid2QXJyJywnXFxcXHUyMUQ2JzonbndBcnInLCdcXFxcdTIxRDcnOiduZUFycicsJ1xcXFx1MjFEOCc6J3NlQXJyJywnXFxcXHUyMUQ5Jzonc3dBcnInLCdcXFxcdTIxREEnOidsQWFycicsJ1xcXFx1MjFEQic6J3JBYXJyJywnXFxcXHUyMUREJzonemlncmFycicsJ1xcXFx1MjFFNCc6J2xhcnJiJywnXFxcXHUyMUU1JzoncmFycmInLCdcXFxcdTIxRjUnOidkdWFycicsJ1xcXFx1MjFGRCc6J2xvYXJyJywnXFxcXHUyMUZFJzoncm9hcnInLCdcXFxcdTIxRkYnOidob2FycicsJ1xcXFx1MjIwMCc6J2ZvcmFsbCcsJ1xcXFx1MjIwMSc6J2NvbXAnLCdcXFxcdTIyMDInOidwYXJ0JywnXFxcXHUyMjAyXFxcXHUwMzM4JzonbnBhcnQnLCdcXFxcdTIyMDMnOidleGlzdCcsJ1xcXFx1MjIwNCc6J25leGlzdCcsJ1xcXFx1MjIwNSc6J2VtcHR5JywnXFxcXHUyMjA3JzonRGVsJywnXFxcXHUyMjA4JzonaW4nLCdcXFxcdTIyMDknOidub3RpbicsJ1xcXFx1MjIwQic6J25pJywnXFxcXHUyMjBDJzonbm90bmknLCdcXFxcdTAzRjYnOidiZXBzaScsJ1xcXFx1MjIwRic6J3Byb2QnLCdcXFxcdTIyMTAnOidjb3Byb2QnLCdcXFxcdTIyMTEnOidzdW0nLCcrJzoncGx1cycsJ1xcXFx4QjEnOidwbScsJ1xcXFx4RjcnOidkaXYnLCdcXFxceEQ3JzondGltZXMnLCc8JzonbHQnLCdcXFxcdTIyNkUnOidubHQnLCc8XFxcXHUyMEQyJzonbnZsdCcsJz0nOidlcXVhbHMnLCdcXFxcdTIyNjAnOiduZScsJz1cXFxcdTIwRTUnOidibmUnLCdcXFxcdTJBNzUnOidFcXVhbCcsJz4nOidndCcsJ1xcXFx1MjI2Ric6J25ndCcsJz5cXFxcdTIwRDInOidudmd0JywnXFxcXHhBQyc6J25vdCcsJ3wnOid2ZXJ0JywnXFxcXHhBNic6J2JydmJhcicsJ1xcXFx1MjIxMic6J21pbnVzJywnXFxcXHUyMjEzJzonbXAnLCdcXFxcdTIyMTQnOidwbHVzZG8nLCdcXFxcdTIwNDQnOidmcmFzbCcsJ1xcXFx1MjIxNic6J3NldG1uJywnXFxcXHUyMjE3JzonbG93YXN0JywnXFxcXHUyMjE4JzonY29tcGZuJywnXFxcXHUyMjFBJzonU3FydCcsJ1xcXFx1MjIxRCc6J3Byb3AnLCdcXFxcdTIyMUUnOidpbmZpbicsJ1xcXFx1MjIxRic6J2FuZ3J0JywnXFxcXHUyMjIwJzonYW5nJywnXFxcXHUyMjIwXFxcXHUyMEQyJzonbmFuZycsJ1xcXFx1MjIyMSc6J2FuZ21zZCcsJ1xcXFx1MjIyMic6J2FuZ3NwaCcsJ1xcXFx1MjIyMyc6J21pZCcsJ1xcXFx1MjIyNCc6J25taWQnLCdcXFxcdTIyMjUnOidwYXInLCdcXFxcdTIyMjYnOiducGFyJywnXFxcXHUyMjI3JzonYW5kJywnXFxcXHUyMjI4Jzonb3InLCdcXFxcdTIyMjknOidjYXAnLCdcXFxcdTIyMjlcXFxcdUZFMDAnOidjYXBzJywnXFxcXHUyMjJBJzonY3VwJywnXFxcXHUyMjJBXFxcXHVGRTAwJzonY3VwcycsJ1xcXFx1MjIyQic6J2ludCcsJ1xcXFx1MjIyQyc6J0ludCcsJ1xcXFx1MjIyRCc6J3RpbnQnLCdcXFxcdTJBMEMnOidxaW50JywnXFxcXHUyMjJFJzonb2ludCcsJ1xcXFx1MjIyRic6J0NvbmludCcsJ1xcXFx1MjIzMCc6J0Njb25pbnQnLCdcXFxcdTIyMzEnOidjd2ludCcsJ1xcXFx1MjIzMic6J2N3Y29uaW50JywnXFxcXHUyMjMzJzonYXdjb25pbnQnLCdcXFxcdTIyMzQnOid0aGVyZTQnLCdcXFxcdTIyMzUnOidiZWNhdXMnLCdcXFxcdTIyMzYnOidyYXRpbycsJ1xcXFx1MjIzNyc6J0NvbG9uJywnXFxcXHUyMjM4JzonbWludXNkJywnXFxcXHUyMjNBJzonbUREb3QnLCdcXFxcdTIyM0InOidob210aHQnLCdcXFxcdTIyM0MnOidzaW0nLCdcXFxcdTIyNDEnOiduc2ltJywnXFxcXHUyMjNDXFxcXHUyMEQyJzonbnZzaW0nLCdcXFxcdTIyM0QnOidic2ltJywnXFxcXHUyMjNEXFxcXHUwMzMxJzoncmFjZScsJ1xcXFx1MjIzRSc6J2FjJywnXFxcXHUyMjNFXFxcXHUwMzMzJzonYWNFJywnXFxcXHUyMjNGJzonYWNkJywnXFxcXHUyMjQwJzond3InLCdcXFxcdTIyNDInOidlc2ltJywnXFxcXHUyMjQyXFxcXHUwMzM4JzonbmVzaW0nLCdcXFxcdTIyNDMnOidzaW1lJywnXFxcXHUyMjQ0JzonbnNpbWUnLCdcXFxcdTIyNDUnOidjb25nJywnXFxcXHUyMjQ3JzonbmNvbmcnLCdcXFxcdTIyNDYnOidzaW1uZScsJ1xcXFx1MjI0OCc6J2FwJywnXFxcXHUyMjQ5JzonbmFwJywnXFxcXHUyMjRBJzonYXBlJywnXFxcXHUyMjRCJzonYXBpZCcsJ1xcXFx1MjI0QlxcXFx1MDMzOCc6J25hcGlkJywnXFxcXHUyMjRDJzonYmNvbmcnLCdcXFxcdTIyNEQnOidDdXBDYXAnLCdcXFxcdTIyNkQnOidOb3RDdXBDYXAnLCdcXFxcdTIyNERcXFxcdTIwRDInOidudmFwJywnXFxcXHUyMjRFJzonYnVtcCcsJ1xcXFx1MjI0RVxcXFx1MDMzOCc6J25idW1wJywnXFxcXHUyMjRGJzonYnVtcGUnLCdcXFxcdTIyNEZcXFxcdTAzMzgnOiduYnVtcGUnLCdcXFxcdTIyNTAnOidkb3RlcScsJ1xcXFx1MjI1MFxcXFx1MDMzOCc6J25lZG90JywnXFxcXHUyMjUxJzonZURvdCcsJ1xcXFx1MjI1Mic6J2VmRG90JywnXFxcXHUyMjUzJzonZXJEb3QnLCdcXFxcdTIyNTQnOidjb2xvbmUnLCdcXFxcdTIyNTUnOidlY29sb24nLCdcXFxcdTIyNTYnOidlY2lyJywnXFxcXHUyMjU3JzonY2lyZScsJ1xcXFx1MjI1OSc6J3dlZGdlcScsJ1xcXFx1MjI1QSc6J3ZlZWVxJywnXFxcXHUyMjVDJzondHJpZScsJ1xcXFx1MjI1Ric6J2VxdWVzdCcsJ1xcXFx1MjI2MSc6J2VxdWl2JywnXFxcXHUyMjYyJzonbmVxdWl2JywnXFxcXHUyMjYxXFxcXHUyMEU1JzonYm5lcXVpdicsJ1xcXFx1MjI2NCc6J2xlJywnXFxcXHUyMjcwJzonbmxlJywnXFxcXHUyMjY0XFxcXHUyMEQyJzonbnZsZScsJ1xcXFx1MjI2NSc6J2dlJywnXFxcXHUyMjcxJzonbmdlJywnXFxcXHUyMjY1XFxcXHUyMEQyJzonbnZnZScsJ1xcXFx1MjI2Nic6J2xFJywnXFxcXHUyMjY2XFxcXHUwMzM4JzonbmxFJywnXFxcXHUyMjY3JzonZ0UnLCdcXFxcdTIyNjdcXFxcdTAzMzgnOiduZ0UnLCdcXFxcdTIyNjhcXFxcdUZFMDAnOidsdm5FJywnXFxcXHUyMjY4JzonbG5FJywnXFxcXHUyMjY5JzonZ25FJywnXFxcXHUyMjY5XFxcXHVGRTAwJzonZ3ZuRScsJ1xcXFx1MjI2QSc6J2xsJywnXFxcXHUyMjZBXFxcXHUwMzM4Jzonbkx0dicsJ1xcXFx1MjI2QVxcXFx1MjBEMic6J25MdCcsJ1xcXFx1MjI2Qic6J2dnJywnXFxcXHUyMjZCXFxcXHUwMzM4Jzonbkd0dicsJ1xcXFx1MjI2QlxcXFx1MjBEMic6J25HdCcsJ1xcXFx1MjI2Qyc6J3R3aXh0JywnXFxcXHUyMjcyJzonbHNpbScsJ1xcXFx1MjI3NCc6J25sc2ltJywnXFxcXHUyMjczJzonZ3NpbScsJ1xcXFx1MjI3NSc6J25nc2ltJywnXFxcXHUyMjc2JzonbGcnLCdcXFxcdTIyNzgnOidudGxnJywnXFxcXHUyMjc3JzonZ2wnLCdcXFxcdTIyNzknOidudGdsJywnXFxcXHUyMjdBJzoncHInLCdcXFxcdTIyODAnOiducHInLCdcXFxcdTIyN0InOidzYycsJ1xcXFx1MjI4MSc6J25zYycsJ1xcXFx1MjI3Qyc6J3ByY3VlJywnXFxcXHUyMkUwJzonbnByY3VlJywnXFxcXHUyMjdEJzonc2NjdWUnLCdcXFxcdTIyRTEnOiduc2NjdWUnLCdcXFxcdTIyN0UnOidwcnNpbScsJ1xcXFx1MjI3Ric6J3Njc2ltJywnXFxcXHUyMjdGXFxcXHUwMzM4JzonTm90U3VjY2VlZHNUaWxkZScsJ1xcXFx1MjI4Mic6J3N1YicsJ1xcXFx1MjI4NCc6J25zdWInLCdcXFxcdTIyODJcXFxcdTIwRDInOid2bnN1YicsJ1xcXFx1MjI4Myc6J3N1cCcsJ1xcXFx1MjI4NSc6J25zdXAnLCdcXFxcdTIyODNcXFxcdTIwRDInOid2bnN1cCcsJ1xcXFx1MjI4Nic6J3N1YmUnLCdcXFxcdTIyODgnOiduc3ViZScsJ1xcXFx1MjI4Nyc6J3N1cGUnLCdcXFxcdTIyODknOiduc3VwZScsJ1xcXFx1MjI4QVxcXFx1RkUwMCc6J3ZzdWJuZScsJ1xcXFx1MjI4QSc6J3N1Ym5lJywnXFxcXHUyMjhCXFxcXHVGRTAwJzondnN1cG5lJywnXFxcXHUyMjhCJzonc3VwbmUnLCdcXFxcdTIyOEQnOidjdXBkb3QnLCdcXFxcdTIyOEUnOid1cGx1cycsJ1xcXFx1MjI4Ric6J3Nxc3ViJywnXFxcXHUyMjhGXFxcXHUwMzM4JzonTm90U3F1YXJlU3Vic2V0JywnXFxcXHUyMjkwJzonc3FzdXAnLCdcXFxcdTIyOTBcXFxcdTAzMzgnOidOb3RTcXVhcmVTdXBlcnNldCcsJ1xcXFx1MjI5MSc6J3Nxc3ViZScsJ1xcXFx1MjJFMic6J25zcXN1YmUnLCdcXFxcdTIyOTInOidzcXN1cGUnLCdcXFxcdTIyRTMnOiduc3FzdXBlJywnXFxcXHUyMjkzJzonc3FjYXAnLCdcXFxcdTIyOTNcXFxcdUZFMDAnOidzcWNhcHMnLCdcXFxcdTIyOTQnOidzcWN1cCcsJ1xcXFx1MjI5NFxcXFx1RkUwMCc6J3NxY3VwcycsJ1xcXFx1MjI5NSc6J29wbHVzJywnXFxcXHUyMjk2Jzonb21pbnVzJywnXFxcXHUyMjk3Jzonb3RpbWVzJywnXFxcXHUyMjk4Jzonb3NvbCcsJ1xcXFx1MjI5OSc6J29kb3QnLCdcXFxcdTIyOUEnOidvY2lyJywnXFxcXHUyMjlCJzonb2FzdCcsJ1xcXFx1MjI5RCc6J29kYXNoJywnXFxcXHUyMjlFJzoncGx1c2InLCdcXFxcdTIyOUYnOidtaW51c2InLCdcXFxcdTIyQTAnOid0aW1lc2InLCdcXFxcdTIyQTEnOidzZG90YicsJ1xcXFx1MjJBMic6J3ZkYXNoJywnXFxcXHUyMkFDJzonbnZkYXNoJywnXFxcXHUyMkEzJzonZGFzaHYnLCdcXFxcdTIyQTQnOid0b3AnLCdcXFxcdTIyQTUnOidib3QnLCdcXFxcdTIyQTcnOidtb2RlbHMnLCdcXFxcdTIyQTgnOid2RGFzaCcsJ1xcXFx1MjJBRCc6J252RGFzaCcsJ1xcXFx1MjJBOSc6J1ZkYXNoJywnXFxcXHUyMkFFJzonblZkYXNoJywnXFxcXHUyMkFBJzonVnZkYXNoJywnXFxcXHUyMkFCJzonVkRhc2gnLCdcXFxcdTIyQUYnOiduVkRhc2gnLCdcXFxcdTIyQjAnOidwcnVyZWwnLCdcXFxcdTIyQjInOid2bHRyaScsJ1xcXFx1MjJFQSc6J25sdHJpJywnXFxcXHUyMkIzJzondnJ0cmknLCdcXFxcdTIyRUInOiducnRyaScsJ1xcXFx1MjJCNCc6J2x0cmllJywnXFxcXHUyMkVDJzonbmx0cmllJywnXFxcXHUyMkI0XFxcXHUyMEQyJzonbnZsdHJpZScsJ1xcXFx1MjJCNSc6J3J0cmllJywnXFxcXHUyMkVEJzonbnJ0cmllJywnXFxcXHUyMkI1XFxcXHUyMEQyJzonbnZydHJpZScsJ1xcXFx1MjJCNic6J29yaWdvZicsJ1xcXFx1MjJCNyc6J2ltb2YnLCdcXFxcdTIyQjgnOidtdW1hcCcsJ1xcXFx1MjJCOSc6J2hlcmNvbicsJ1xcXFx1MjJCQSc6J2ludGNhbCcsJ1xcXFx1MjJCQic6J3ZlZWJhcicsJ1xcXFx1MjJCRCc6J2JhcnZlZScsJ1xcXFx1MjJCRSc6J2FuZ3J0dmInLCdcXFxcdTIyQkYnOidscnRyaScsJ1xcXFx1MjJDMCc6J1dlZGdlJywnXFxcXHUyMkMxJzonVmVlJywnXFxcXHUyMkMyJzoneGNhcCcsJ1xcXFx1MjJDMyc6J3hjdXAnLCdcXFxcdTIyQzQnOidkaWFtJywnXFxcXHUyMkM1Jzonc2RvdCcsJ1xcXFx1MjJDNic6J1N0YXInLCdcXFxcdTIyQzcnOidkaXZvbngnLCdcXFxcdTIyQzgnOidib3d0aWUnLCdcXFxcdTIyQzknOidsdGltZXMnLCdcXFxcdTIyQ0EnOidydGltZXMnLCdcXFxcdTIyQ0InOidsdGhyZWUnLCdcXFxcdTIyQ0MnOidydGhyZWUnLCdcXFxcdTIyQ0QnOidic2ltZScsJ1xcXFx1MjJDRSc6J2N1dmVlJywnXFxcXHUyMkNGJzonY3V3ZWQnLCdcXFxcdTIyRDAnOidTdWInLCdcXFxcdTIyRDEnOidTdXAnLCdcXFxcdTIyRDInOidDYXAnLCdcXFxcdTIyRDMnOidDdXAnLCdcXFxcdTIyRDQnOidmb3JrJywnXFxcXHUyMkQ1JzonZXBhcicsJ1xcXFx1MjJENic6J2x0ZG90JywnXFxcXHUyMkQ3JzonZ3Rkb3QnLCdcXFxcdTIyRDgnOidMbCcsJ1xcXFx1MjJEOFxcXFx1MDMzOCc6J25MbCcsJ1xcXFx1MjJEOSc6J0dnJywnXFxcXHUyMkQ5XFxcXHUwMzM4JzonbkdnJywnXFxcXHUyMkRBXFxcXHVGRTAwJzonbGVzZycsJ1xcXFx1MjJEQSc6J2xlZycsJ1xcXFx1MjJEQic6J2dlbCcsJ1xcXFx1MjJEQlxcXFx1RkUwMCc6J2dlc2wnLCdcXFxcdTIyREUnOidjdWVwcicsJ1xcXFx1MjJERic6J2N1ZXNjJywnXFxcXHUyMkU2JzonbG5zaW0nLCdcXFxcdTIyRTcnOidnbnNpbScsJ1xcXFx1MjJFOCc6J3BybnNpbScsJ1xcXFx1MjJFOSc6J3NjbnNpbScsJ1xcXFx1MjJFRSc6J3ZlbGxpcCcsJ1xcXFx1MjJFRic6J2N0ZG90JywnXFxcXHUyMkYwJzondXRkb3QnLCdcXFxcdTIyRjEnOidkdGRvdCcsJ1xcXFx1MjJGMic6J2Rpc2luJywnXFxcXHUyMkYzJzonaXNpbnN2JywnXFxcXHUyMkY0JzonaXNpbnMnLCdcXFxcdTIyRjUnOidpc2luZG90JywnXFxcXHUyMkY1XFxcXHUwMzM4Jzonbm90aW5kb3QnLCdcXFxcdTIyRjYnOidub3RpbnZjJywnXFxcXHUyMkY3Jzonbm90aW52YicsJ1xcXFx1MjJGOSc6J2lzaW5FJywnXFxcXHUyMkY5XFxcXHUwMzM4Jzonbm90aW5FJywnXFxcXHUyMkZBJzonbmlzZCcsJ1xcXFx1MjJGQic6J3huaXMnLCdcXFxcdTIyRkMnOiduaXMnLCdcXFxcdTIyRkQnOidub3RuaXZjJywnXFxcXHUyMkZFJzonbm90bml2YicsJ1xcXFx1MjMwNSc6J2JhcndlZCcsJ1xcXFx1MjMwNic6J0JhcndlZCcsJ1xcXFx1MjMwQyc6J2RyY3JvcCcsJ1xcXFx1MjMwRCc6J2RsY3JvcCcsJ1xcXFx1MjMwRSc6J3VyY3JvcCcsJ1xcXFx1MjMwRic6J3VsY3JvcCcsJ1xcXFx1MjMxMCc6J2Jub3QnLCdcXFxcdTIzMTInOidwcm9mbGluZScsJ1xcXFx1MjMxMyc6J3Byb2ZzdXJmJywnXFxcXHUyMzE1JzondGVscmVjJywnXFxcXHUyMzE2JzondGFyZ2V0JywnXFxcXHUyMzFDJzondWxjb3JuJywnXFxcXHUyMzFEJzondXJjb3JuJywnXFxcXHUyMzFFJzonZGxjb3JuJywnXFxcXHUyMzFGJzonZHJjb3JuJywnXFxcXHUyMzIyJzonZnJvd24nLCdcXFxcdTIzMjMnOidzbWlsZScsJ1xcXFx1MjMyRCc6J2N5bGN0eScsJ1xcXFx1MjMyRSc6J3Byb2ZhbGFyJywnXFxcXHUyMzM2JzondG9wYm90JywnXFxcXHUyMzNEJzonb3ZiYXInLCdcXFxcdTIzM0YnOidzb2xiYXInLCdcXFxcdTIzN0MnOidhbmd6YXJyJywnXFxcXHUyM0IwJzonbG1vdXN0JywnXFxcXHUyM0IxJzoncm1vdXN0JywnXFxcXHUyM0I0JzondGJyaycsJ1xcXFx1MjNCNSc6J2JicmsnLCdcXFxcdTIzQjYnOidiYnJrdGJyaycsJ1xcXFx1MjNEQyc6J092ZXJQYXJlbnRoZXNpcycsJ1xcXFx1MjNERCc6J1VuZGVyUGFyZW50aGVzaXMnLCdcXFxcdTIzREUnOidPdmVyQnJhY2UnLCdcXFxcdTIzREYnOidVbmRlckJyYWNlJywnXFxcXHUyM0UyJzondHJwZXppdW0nLCdcXFxcdTIzRTcnOidlbGludGVycycsJ1xcXFx1MjQyMyc6J2JsYW5rJywnXFxcXHUyNTAwJzonYm94aCcsJ1xcXFx1MjUwMic6J2JveHYnLCdcXFxcdTI1MEMnOidib3hkcicsJ1xcXFx1MjUxMCc6J2JveGRsJywnXFxcXHUyNTE0JzonYm94dXInLCdcXFxcdTI1MTgnOidib3h1bCcsJ1xcXFx1MjUxQyc6J2JveHZyJywnXFxcXHUyNTI0JzonYm94dmwnLCdcXFxcdTI1MkMnOidib3hoZCcsJ1xcXFx1MjUzNCc6J2JveGh1JywnXFxcXHUyNTNDJzonYm94dmgnLCdcXFxcdTI1NTAnOidib3hIJywnXFxcXHUyNTUxJzonYm94VicsJ1xcXFx1MjU1Mic6J2JveGRSJywnXFxcXHUyNTUzJzonYm94RHInLCdcXFxcdTI1NTQnOidib3hEUicsJ1xcXFx1MjU1NSc6J2JveGRMJywnXFxcXHUyNTU2JzonYm94RGwnLCdcXFxcdTI1NTcnOidib3hETCcsJ1xcXFx1MjU1OCc6J2JveHVSJywnXFxcXHUyNTU5JzonYm94VXInLCdcXFxcdTI1NUEnOidib3hVUicsJ1xcXFx1MjU1Qic6J2JveHVMJywnXFxcXHUyNTVDJzonYm94VWwnLCdcXFxcdTI1NUQnOidib3hVTCcsJ1xcXFx1MjU1RSc6J2JveHZSJywnXFxcXHUyNTVGJzonYm94VnInLCdcXFxcdTI1NjAnOidib3hWUicsJ1xcXFx1MjU2MSc6J2JveHZMJywnXFxcXHUyNTYyJzonYm94VmwnLCdcXFxcdTI1NjMnOidib3hWTCcsJ1xcXFx1MjU2NCc6J2JveEhkJywnXFxcXHUyNTY1JzonYm94aEQnLCdcXFxcdTI1NjYnOidib3hIRCcsJ1xcXFx1MjU2Nyc6J2JveEh1JywnXFxcXHUyNTY4JzonYm94aFUnLCdcXFxcdTI1NjknOidib3hIVScsJ1xcXFx1MjU2QSc6J2JveHZIJywnXFxcXHUyNTZCJzonYm94VmgnLCdcXFxcdTI1NkMnOidib3hWSCcsJ1xcXFx1MjU4MCc6J3VoYmxrJywnXFxcXHUyNTg0JzonbGhibGsnLCdcXFxcdTI1ODgnOidibG9jaycsJ1xcXFx1MjU5MSc6J2JsazE0JywnXFxcXHUyNTkyJzonYmxrMTInLCdcXFxcdTI1OTMnOidibGszNCcsJ1xcXFx1MjVBMSc6J3NxdScsJ1xcXFx1MjVBQSc6J3NxdWYnLCdcXFxcdTI1QUInOidFbXB0eVZlcnlTbWFsbFNxdWFyZScsJ1xcXFx1MjVBRCc6J3JlY3QnLCdcXFxcdTI1QUUnOidtYXJrZXInLCdcXFxcdTI1QjEnOidmbHRucycsJ1xcXFx1MjVCMyc6J3h1dHJpJywnXFxcXHUyNUI0JzondXRyaWYnLCdcXFxcdTI1QjUnOid1dHJpJywnXFxcXHUyNUI4JzoncnRyaWYnLCdcXFxcdTI1QjknOidydHJpJywnXFxcXHUyNUJEJzoneGR0cmknLCdcXFxcdTI1QkUnOidkdHJpZicsJ1xcXFx1MjVCRic6J2R0cmknLCdcXFxcdTI1QzInOidsdHJpZicsJ1xcXFx1MjVDMyc6J2x0cmknLCdcXFxcdTI1Q0EnOidsb3onLCdcXFxcdTI1Q0InOidjaXInLCdcXFxcdTI1RUMnOid0cmlkb3QnLCdcXFxcdTI1RUYnOid4Y2lyYycsJ1xcXFx1MjVGOCc6J3VsdHJpJywnXFxcXHUyNUY5JzondXJ0cmknLCdcXFxcdTI1RkEnOidsbHRyaScsJ1xcXFx1MjVGQic6J0VtcHR5U21hbGxTcXVhcmUnLCdcXFxcdTI1RkMnOidGaWxsZWRTbWFsbFNxdWFyZScsJ1xcXFx1MjYwNSc6J3N0YXJmJywnXFxcXHUyNjA2Jzonc3RhcicsJ1xcXFx1MjYwRSc6J3Bob25lJywnXFxcXHUyNjQwJzonZmVtYWxlJywnXFxcXHUyNjQyJzonbWFsZScsJ1xcXFx1MjY2MCc6J3NwYWRlcycsJ1xcXFx1MjY2Myc6J2NsdWJzJywnXFxcXHUyNjY1JzonaGVhcnRzJywnXFxcXHUyNjY2JzonZGlhbXMnLCdcXFxcdTI2NkEnOidzdW5nJywnXFxcXHUyNzEzJzonY2hlY2snLCdcXFxcdTI3MTcnOidjcm9zcycsJ1xcXFx1MjcyMCc6J21hbHQnLCdcXFxcdTI3MzYnOidzZXh0JywnXFxcXHUyNzU4JzonVmVydGljYWxTZXBhcmF0b3InLCdcXFxcdTI3QzgnOidic29saHN1YicsJ1xcXFx1MjdDOSc6J3N1cGhzb2wnLCdcXFxcdTI3RjUnOid4bGFycicsJ1xcXFx1MjdGNic6J3hyYXJyJywnXFxcXHUyN0Y3JzoneGhhcnInLCdcXFxcdTI3RjgnOid4bEFycicsJ1xcXFx1MjdGOSc6J3hyQXJyJywnXFxcXHUyN0ZBJzoneGhBcnInLCdcXFxcdTI3RkMnOid4bWFwJywnXFxcXHUyN0ZGJzonZHppZ3JhcnInLCdcXFxcdTI5MDInOidudmxBcnInLCdcXFxcdTI5MDMnOidudnJBcnInLCdcXFxcdTI5MDQnOidudkhhcnInLCdcXFxcdTI5MDUnOidNYXAnLCdcXFxcdTI5MEMnOidsYmFycicsJ1xcXFx1MjkwRCc6J3JiYXJyJywnXFxcXHUyOTBFJzonbEJhcnInLCdcXFxcdTI5MEYnOidyQmFycicsJ1xcXFx1MjkxMCc6J1JCYXJyJywnXFxcXHUyOTExJzonRERvdHJhaGQnLCdcXFxcdTI5MTInOidVcEFycm93QmFyJywnXFxcXHUyOTEzJzonRG93bkFycm93QmFyJywnXFxcXHUyOTE2JzonUmFycnRsJywnXFxcXHUyOTE5JzonbGF0YWlsJywnXFxcXHUyOTFBJzoncmF0YWlsJywnXFxcXHUyOTFCJzonbEF0YWlsJywnXFxcXHUyOTFDJzonckF0YWlsJywnXFxcXHUyOTFEJzonbGFycmZzJywnXFxcXHUyOTFFJzoncmFycmZzJywnXFxcXHUyOTFGJzonbGFycmJmcycsJ1xcXFx1MjkyMCc6J3JhcnJiZnMnLCdcXFxcdTI5MjMnOidud2FyaGsnLCdcXFxcdTI5MjQnOiduZWFyaGsnLCdcXFxcdTI5MjUnOidzZWFyaGsnLCdcXFxcdTI5MjYnOidzd2FyaGsnLCdcXFxcdTI5MjcnOidud25lYXInLCdcXFxcdTI5MjgnOid0b2VhJywnXFxcXHUyOTI5JzondG9zYScsJ1xcXFx1MjkyQSc6J3N3bndhcicsJ1xcXFx1MjkzMyc6J3JhcnJjJywnXFxcXHUyOTMzXFxcXHUwMzM4JzonbnJhcnJjJywnXFxcXHUyOTM1JzonY3VkYXJycicsJ1xcXFx1MjkzNic6J2xkY2EnLCdcXFxcdTI5MzcnOidyZGNhJywnXFxcXHUyOTM4JzonY3VkYXJybCcsJ1xcXFx1MjkzOSc6J2xhcnJwbCcsJ1xcXFx1MjkzQyc6J2N1cmFycm0nLCdcXFxcdTI5M0QnOidjdWxhcnJwJywnXFxcXHUyOTQ1JzoncmFycnBsJywnXFxcXHUyOTQ4JzonaGFycmNpcicsJ1xcXFx1Mjk0OSc6J1VhcnJvY2lyJywnXFxcXHUyOTRBJzonbHVyZHNoYXInLCdcXFxcdTI5NEInOidsZHJ1c2hhcicsJ1xcXFx1Mjk0RSc6J0xlZnRSaWdodFZlY3RvcicsJ1xcXFx1Mjk0Ric6J1JpZ2h0VXBEb3duVmVjdG9yJywnXFxcXHUyOTUwJzonRG93bkxlZnRSaWdodFZlY3RvcicsJ1xcXFx1Mjk1MSc6J0xlZnRVcERvd25WZWN0b3InLCdcXFxcdTI5NTInOidMZWZ0VmVjdG9yQmFyJywnXFxcXHUyOTUzJzonUmlnaHRWZWN0b3JCYXInLCdcXFxcdTI5NTQnOidSaWdodFVwVmVjdG9yQmFyJywnXFxcXHUyOTU1JzonUmlnaHREb3duVmVjdG9yQmFyJywnXFxcXHUyOTU2JzonRG93bkxlZnRWZWN0b3JCYXInLCdcXFxcdTI5NTcnOidEb3duUmlnaHRWZWN0b3JCYXInLCdcXFxcdTI5NTgnOidMZWZ0VXBWZWN0b3JCYXInLCdcXFxcdTI5NTknOidMZWZ0RG93blZlY3RvckJhcicsJ1xcXFx1Mjk1QSc6J0xlZnRUZWVWZWN0b3InLCdcXFxcdTI5NUInOidSaWdodFRlZVZlY3RvcicsJ1xcXFx1Mjk1Qyc6J1JpZ2h0VXBUZWVWZWN0b3InLCdcXFxcdTI5NUQnOidSaWdodERvd25UZWVWZWN0b3InLCdcXFxcdTI5NUUnOidEb3duTGVmdFRlZVZlY3RvcicsJ1xcXFx1Mjk1Ric6J0Rvd25SaWdodFRlZVZlY3RvcicsJ1xcXFx1Mjk2MCc6J0xlZnRVcFRlZVZlY3RvcicsJ1xcXFx1Mjk2MSc6J0xlZnREb3duVGVlVmVjdG9yJywnXFxcXHUyOTYyJzonbEhhcicsJ1xcXFx1Mjk2Myc6J3VIYXInLCdcXFxcdTI5NjQnOidySGFyJywnXFxcXHUyOTY1JzonZEhhcicsJ1xcXFx1Mjk2Nic6J2x1cnVoYXInLCdcXFxcdTI5NjcnOidsZHJkaGFyJywnXFxcXHUyOTY4JzoncnVsdWhhcicsJ1xcXFx1Mjk2OSc6J3JkbGRoYXInLCdcXFxcdTI5NkEnOidsaGFydWwnLCdcXFxcdTI5NkInOidsbGhhcmQnLCdcXFxcdTI5NkMnOidyaGFydWwnLCdcXFxcdTI5NkQnOidscmhhcmQnLCdcXFxcdTI5NkUnOid1ZGhhcicsJ1xcXFx1Mjk2Ric6J2R1aGFyJywnXFxcXHUyOTcwJzonUm91bmRJbXBsaWVzJywnXFxcXHUyOTcxJzonZXJhcnInLCdcXFxcdTI5NzInOidzaW1yYXJyJywnXFxcXHUyOTczJzonbGFycnNpbScsJ1xcXFx1Mjk3NCc6J3JhcnJzaW0nLCdcXFxcdTI5NzUnOidyYXJyYXAnLCdcXFxcdTI5NzYnOidsdGxhcnInLCdcXFxcdTI5NzgnOidndHJhcnInLCdcXFxcdTI5NzknOidzdWJyYXJyJywnXFxcXHUyOTdCJzonc3VwbGFycicsJ1xcXFx1Mjk3Qyc6J2xmaXNodCcsJ1xcXFx1Mjk3RCc6J3JmaXNodCcsJ1xcXFx1Mjk3RSc6J3VmaXNodCcsJ1xcXFx1Mjk3Ric6J2RmaXNodCcsJ1xcXFx1Mjk5QSc6J3Z6aWd6YWcnLCdcXFxcdTI5OUMnOid2YW5ncnQnLCdcXFxcdTI5OUQnOidhbmdydHZiZCcsJ1xcXFx1MjlBNCc6J2FuZ2UnLCdcXFxcdTI5QTUnOidyYW5nZScsJ1xcXFx1MjlBNic6J2R3YW5nbGUnLCdcXFxcdTI5QTcnOid1d2FuZ2xlJywnXFxcXHUyOUE4JzonYW5nbXNkYWEnLCdcXFxcdTI5QTknOidhbmdtc2RhYicsJ1xcXFx1MjlBQSc6J2FuZ21zZGFjJywnXFxcXHUyOUFCJzonYW5nbXNkYWQnLCdcXFxcdTI5QUMnOidhbmdtc2RhZScsJ1xcXFx1MjlBRCc6J2FuZ21zZGFmJywnXFxcXHUyOUFFJzonYW5nbXNkYWcnLCdcXFxcdTI5QUYnOidhbmdtc2RhaCcsJ1xcXFx1MjlCMCc6J2JlbXB0eXYnLCdcXFxcdTI5QjEnOidkZW1wdHl2JywnXFxcXHUyOUIyJzonY2VtcHR5dicsJ1xcXFx1MjlCMyc6J3JhZW1wdHl2JywnXFxcXHUyOUI0JzonbGFlbXB0eXYnLCdcXFxcdTI5QjUnOidvaGJhcicsJ1xcXFx1MjlCNic6J29taWQnLCdcXFxcdTI5QjcnOidvcGFyJywnXFxcXHUyOUI5Jzonb3BlcnAnLCdcXFxcdTI5QkInOidvbGNyb3NzJywnXFxcXHUyOUJDJzonb2Rzb2xkJywnXFxcXHUyOUJFJzonb2xjaXInLCdcXFxcdTI5QkYnOidvZmNpcicsJ1xcXFx1MjlDMCc6J29sdCcsJ1xcXFx1MjlDMSc6J29ndCcsJ1xcXFx1MjlDMic6J2NpcnNjaXInLCdcXFxcdTI5QzMnOidjaXJFJywnXFxcXHUyOUM0Jzonc29sYicsJ1xcXFx1MjlDNSc6J2Jzb2xiJywnXFxcXHUyOUM5JzonYm94Ym94JywnXFxcXHUyOUNEJzondHJpc2InLCdcXFxcdTI5Q0UnOidydHJpbHRyaScsJ1xcXFx1MjlDRic6J0xlZnRUcmlhbmdsZUJhcicsJ1xcXFx1MjlDRlxcXFx1MDMzOCc6J05vdExlZnRUcmlhbmdsZUJhcicsJ1xcXFx1MjlEMCc6J1JpZ2h0VHJpYW5nbGVCYXInLCdcXFxcdTI5RDBcXFxcdTAzMzgnOidOb3RSaWdodFRyaWFuZ2xlQmFyJywnXFxcXHUyOURDJzonaWluZmluJywnXFxcXHUyOUREJzonaW5maW50aWUnLCdcXFxcdTI5REUnOidudmluZmluJywnXFxcXHUyOUUzJzonZXBhcnNsJywnXFxcXHUyOUU0Jzonc21lcGFyc2wnLCdcXFxcdTI5RTUnOidlcXZwYXJzbCcsJ1xcXFx1MjlFQic6J2xvemYnLCdcXFxcdTI5RjQnOidSdWxlRGVsYXllZCcsJ1xcXFx1MjlGNic6J2Rzb2wnLCdcXFxcdTJBMDAnOid4b2RvdCcsJ1xcXFx1MkEwMSc6J3hvcGx1cycsJ1xcXFx1MkEwMic6J3hvdGltZScsJ1xcXFx1MkEwNCc6J3h1cGx1cycsJ1xcXFx1MkEwNic6J3hzcWN1cCcsJ1xcXFx1MkEwRCc6J2ZwYXJ0aW50JywnXFxcXHUyQTEwJzonY2lyZm5pbnQnLCdcXFxcdTJBMTEnOidhd2ludCcsJ1xcXFx1MkExMic6J3JwcG9saW50JywnXFxcXHUyQTEzJzonc2Nwb2xpbnQnLCdcXFxcdTJBMTQnOiducG9saW50JywnXFxcXHUyQTE1JzoncG9pbnRpbnQnLCdcXFxcdTJBMTYnOidxdWF0aW50JywnXFxcXHUyQTE3JzonaW50bGFyaGsnLCdcXFxcdTJBMjInOidwbHVzY2lyJywnXFxcXHUyQTIzJzoncGx1c2FjaXInLCdcXFxcdTJBMjQnOidzaW1wbHVzJywnXFxcXHUyQTI1JzoncGx1c2R1JywnXFxcXHUyQTI2JzoncGx1c3NpbScsJ1xcXFx1MkEyNyc6J3BsdXN0d28nLCdcXFxcdTJBMjknOidtY29tbWEnLCdcXFxcdTJBMkEnOidtaW51c2R1JywnXFxcXHUyQTJEJzonbG9wbHVzJywnXFxcXHUyQTJFJzoncm9wbHVzJywnXFxcXHUyQTJGJzonQ3Jvc3MnLCdcXFxcdTJBMzAnOid0aW1lc2QnLCdcXFxcdTJBMzEnOid0aW1lc2JhcicsJ1xcXFx1MkEzMyc6J3NtYXNocCcsJ1xcXFx1MkEzNCc6J2xvdGltZXMnLCdcXFxcdTJBMzUnOidyb3RpbWVzJywnXFxcXHUyQTM2Jzonb3RpbWVzYXMnLCdcXFxcdTJBMzcnOidPdGltZXMnLCdcXFxcdTJBMzgnOidvZGl2JywnXFxcXHUyQTM5JzondHJpcGx1cycsJ1xcXFx1MkEzQSc6J3RyaW1pbnVzJywnXFxcXHUyQTNCJzondHJpdGltZScsJ1xcXFx1MkEzQyc6J2lwcm9kJywnXFxcXHUyQTNGJzonYW1hbGcnLCdcXFxcdTJBNDAnOidjYXBkb3QnLCdcXFxcdTJBNDInOiduY3VwJywnXFxcXHUyQTQzJzonbmNhcCcsJ1xcXFx1MkE0NCc6J2NhcGFuZCcsJ1xcXFx1MkE0NSc6J2N1cG9yJywnXFxcXHUyQTQ2JzonY3VwY2FwJywnXFxcXHUyQTQ3JzonY2FwY3VwJywnXFxcXHUyQTQ4JzonY3VwYnJjYXAnLCdcXFxcdTJBNDknOidjYXBicmN1cCcsJ1xcXFx1MkE0QSc6J2N1cGN1cCcsJ1xcXFx1MkE0Qic6J2NhcGNhcCcsJ1xcXFx1MkE0Qyc6J2NjdXBzJywnXFxcXHUyQTREJzonY2NhcHMnLCdcXFxcdTJBNTAnOidjY3Vwc3NtJywnXFxcXHUyQTUzJzonQW5kJywnXFxcXHUyQTU0JzonT3InLCdcXFxcdTJBNTUnOidhbmRhbmQnLCdcXFxcdTJBNTYnOidvcm9yJywnXFxcXHUyQTU3Jzonb3JzbG9wZScsJ1xcXFx1MkE1OCc6J2FuZHNsb3BlJywnXFxcXHUyQTVBJzonYW5kdicsJ1xcXFx1MkE1Qic6J29ydicsJ1xcXFx1MkE1Qyc6J2FuZGQnLCdcXFxcdTJBNUQnOidvcmQnLCdcXFxcdTJBNUYnOid3ZWRiYXInLCdcXFxcdTJBNjYnOidzZG90ZScsJ1xcXFx1MkE2QSc6J3NpbWRvdCcsJ1xcXFx1MkE2RCc6J2Nvbmdkb3QnLCdcXFxcdTJBNkRcXFxcdTAzMzgnOiduY29uZ2RvdCcsJ1xcXFx1MkE2RSc6J2Vhc3RlcicsJ1xcXFx1MkE2Ric6J2FwYWNpcicsJ1xcXFx1MkE3MCc6J2FwRScsJ1xcXFx1MkE3MFxcXFx1MDMzOCc6J25hcEUnLCdcXFxcdTJBNzEnOidlcGx1cycsJ1xcXFx1MkE3Mic6J3BsdXNlJywnXFxcXHUyQTczJzonRXNpbScsJ1xcXFx1MkE3Nyc6J2VERG90JywnXFxcXHUyQTc4JzonZXF1aXZERCcsJ1xcXFx1MkE3OSc6J2x0Y2lyJywnXFxcXHUyQTdBJzonZ3RjaXInLCdcXFxcdTJBN0InOidsdHF1ZXN0JywnXFxcXHUyQTdDJzonZ3RxdWVzdCcsJ1xcXFx1MkE3RCc6J2xlcycsJ1xcXFx1MkE3RFxcXFx1MDMzOCc6J25sZXMnLCdcXFxcdTJBN0UnOidnZXMnLCdcXFxcdTJBN0VcXFxcdTAzMzgnOiduZ2VzJywnXFxcXHUyQTdGJzonbGVzZG90JywnXFxcXHUyQTgwJzonZ2VzZG90JywnXFxcXHUyQTgxJzonbGVzZG90bycsJ1xcXFx1MkE4Mic6J2dlc2RvdG8nLCdcXFxcdTJBODMnOidsZXNkb3RvcicsJ1xcXFx1MkE4NCc6J2dlc2RvdG9sJywnXFxcXHUyQTg1JzonbGFwJywnXFxcXHUyQTg2JzonZ2FwJywnXFxcXHUyQTg3JzonbG5lJywnXFxcXHUyQTg4JzonZ25lJywnXFxcXHUyQTg5JzonbG5hcCcsJ1xcXFx1MkE4QSc6J2duYXAnLCdcXFxcdTJBOEInOidsRWcnLCdcXFxcdTJBOEMnOidnRWwnLCdcXFxcdTJBOEQnOidsc2ltZScsJ1xcXFx1MkE4RSc6J2dzaW1lJywnXFxcXHUyQThGJzonbHNpbWcnLCdcXFxcdTJBOTAnOidnc2ltbCcsJ1xcXFx1MkE5MSc6J2xnRScsJ1xcXFx1MkE5Mic6J2dsRScsJ1xcXFx1MkE5Myc6J2xlc2dlcycsJ1xcXFx1MkE5NCc6J2dlc2xlcycsJ1xcXFx1MkE5NSc6J2VscycsJ1xcXFx1MkE5Nic6J2VncycsJ1xcXFx1MkE5Nyc6J2Vsc2RvdCcsJ1xcXFx1MkE5OCc6J2Vnc2RvdCcsJ1xcXFx1MkE5OSc6J2VsJywnXFxcXHUyQTlBJzonZWcnLCdcXFxcdTJBOUQnOidzaW1sJywnXFxcXHUyQTlFJzonc2ltZycsJ1xcXFx1MkE5Ric6J3NpbWxFJywnXFxcXHUyQUEwJzonc2ltZ0UnLCdcXFxcdTJBQTEnOidMZXNzTGVzcycsJ1xcXFx1MkFBMVxcXFx1MDMzOCc6J05vdE5lc3RlZExlc3NMZXNzJywnXFxcXHUyQUEyJzonR3JlYXRlckdyZWF0ZXInLCdcXFxcdTJBQTJcXFxcdTAzMzgnOidOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcicsJ1xcXFx1MkFBNCc6J2dsaicsJ1xcXFx1MkFBNSc6J2dsYScsJ1xcXFx1MkFBNic6J2x0Y2MnLCdcXFxcdTJBQTcnOidndGNjJywnXFxcXHUyQUE4JzonbGVzY2MnLCdcXFxcdTJBQTknOidnZXNjYycsJ1xcXFx1MkFBQSc6J3NtdCcsJ1xcXFx1MkFBQic6J2xhdCcsJ1xcXFx1MkFBQyc6J3NtdGUnLCdcXFxcdTJBQUNcXFxcdUZFMDAnOidzbXRlcycsJ1xcXFx1MkFBRCc6J2xhdGUnLCdcXFxcdTJBQURcXFxcdUZFMDAnOidsYXRlcycsJ1xcXFx1MkFBRSc6J2J1bXBFJywnXFxcXHUyQUFGJzoncHJlJywnXFxcXHUyQUFGXFxcXHUwMzM4JzonbnByZScsJ1xcXFx1MkFCMCc6J3NjZScsJ1xcXFx1MkFCMFxcXFx1MDMzOCc6J25zY2UnLCdcXFxcdTJBQjMnOidwckUnLCdcXFxcdTJBQjQnOidzY0UnLCdcXFxcdTJBQjUnOidwcm5FJywnXFxcXHUyQUI2Jzonc2NuRScsJ1xcXFx1MkFCNyc6J3ByYXAnLCdcXFxcdTJBQjgnOidzY2FwJywnXFxcXHUyQUI5JzoncHJuYXAnLCdcXFxcdTJBQkEnOidzY25hcCcsJ1xcXFx1MkFCQic6J1ByJywnXFxcXHUyQUJDJzonU2MnLCdcXFxcdTJBQkQnOidzdWJkb3QnLCdcXFxcdTJBQkUnOidzdXBkb3QnLCdcXFxcdTJBQkYnOidzdWJwbHVzJywnXFxcXHUyQUMwJzonc3VwcGx1cycsJ1xcXFx1MkFDMSc6J3N1Ym11bHQnLCdcXFxcdTJBQzInOidzdXBtdWx0JywnXFxcXHUyQUMzJzonc3ViZWRvdCcsJ1xcXFx1MkFDNCc6J3N1cGVkb3QnLCdcXFxcdTJBQzUnOidzdWJFJywnXFxcXHUyQUM1XFxcXHUwMzM4JzonbnN1YkUnLCdcXFxcdTJBQzYnOidzdXBFJywnXFxcXHUyQUM2XFxcXHUwMzM4JzonbnN1cEUnLCdcXFxcdTJBQzcnOidzdWJzaW0nLCdcXFxcdTJBQzgnOidzdXBzaW0nLCdcXFxcdTJBQ0JcXFxcdUZFMDAnOid2c3VibkUnLCdcXFxcdTJBQ0InOidzdWJuRScsJ1xcXFx1MkFDQ1xcXFx1RkUwMCc6J3ZzdXBuRScsJ1xcXFx1MkFDQyc6J3N1cG5FJywnXFxcXHUyQUNGJzonY3N1YicsJ1xcXFx1MkFEMCc6J2NzdXAnLCdcXFxcdTJBRDEnOidjc3ViZScsJ1xcXFx1MkFEMic6J2NzdXBlJywnXFxcXHUyQUQzJzonc3Vic3VwJywnXFxcXHUyQUQ0Jzonc3Vwc3ViJywnXFxcXHUyQUQ1Jzonc3Vic3ViJywnXFxcXHUyQUQ2Jzonc3Vwc3VwJywnXFxcXHUyQUQ3Jzonc3VwaHN1YicsJ1xcXFx1MkFEOCc6J3N1cGRzdWInLCdcXFxcdTJBRDknOidmb3JrdicsJ1xcXFx1MkFEQSc6J3RvcGZvcmsnLCdcXFxcdTJBREInOidtbGNwJywnXFxcXHUyQUU0JzonRGFzaHYnLCdcXFxcdTJBRTYnOidWZGFzaGwnLCdcXFxcdTJBRTcnOidCYXJ2JywnXFxcXHUyQUU4JzondkJhcicsJ1xcXFx1MkFFOSc6J3ZCYXJ2JywnXFxcXHUyQUVCJzonVmJhcicsJ1xcXFx1MkFFQyc6J05vdCcsJ1xcXFx1MkFFRCc6J2JOb3QnLCdcXFxcdTJBRUUnOidybm1pZCcsJ1xcXFx1MkFFRic6J2Npcm1pZCcsJ1xcXFx1MkFGMCc6J21pZGNpcicsJ1xcXFx1MkFGMSc6J3RvcGNpcicsJ1xcXFx1MkFGMic6J25ocGFyJywnXFxcXHUyQUYzJzoncGFyc2ltJywnXFxcXHUyQUZEJzoncGFyc2wnLCdcXFxcdTJBRkRcXFxcdTIwRTUnOiducGFyc2wnLCdcXFxcdTI2NkQnOidmbGF0JywnXFxcXHUyNjZFJzonbmF0dXInLCdcXFxcdTI2NkYnOidzaGFycCcsJ1xcXFx4QTQnOidjdXJyZW4nLCdcXFxceEEyJzonY2VudCcsJyQnOidkb2xsYXInLCdcXFxceEEzJzoncG91bmQnLCdcXFxceEE1JzoneWVuJywnXFxcXHUyMEFDJzonZXVybycsJ1xcXFx4QjknOidzdXAxJywnXFxcXHhCRCc6J2hhbGYnLCdcXFxcdTIxNTMnOidmcmFjMTMnLCdcXFxceEJDJzonZnJhYzE0JywnXFxcXHUyMTU1JzonZnJhYzE1JywnXFxcXHUyMTU5JzonZnJhYzE2JywnXFxcXHUyMTVCJzonZnJhYzE4JywnXFxcXHhCMic6J3N1cDInLCdcXFxcdTIxNTQnOidmcmFjMjMnLCdcXFxcdTIxNTYnOidmcmFjMjUnLCdcXFxceEIzJzonc3VwMycsJ1xcXFx4QkUnOidmcmFjMzQnLCdcXFxcdTIxNTcnOidmcmFjMzUnLCdcXFxcdTIxNUMnOidmcmFjMzgnLCdcXFxcdTIxNTgnOidmcmFjNDUnLCdcXFxcdTIxNUEnOidmcmFjNTYnLCdcXFxcdTIxNUQnOidmcmFjNTgnLCdcXFxcdTIxNUUnOidmcmFjNzgnLCdcXFxcdUQ4MzVcXFxcdURDQjYnOidhc2NyJywnXFxcXHVEODM1XFxcXHVERDUyJzonYW9wZicsJ1xcXFx1RDgzNVxcXFx1REQxRSc6J2FmcicsJ1xcXFx1RDgzNVxcXFx1REQzOCc6J0FvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMDQnOidBZnInLCdcXFxcdUQ4MzVcXFxcdURDOUMnOidBc2NyJywnXFxcXHhBQSc6J29yZGYnLCdcXFxceEUxJzonYWFjdXRlJywnXFxcXHhDMSc6J0FhY3V0ZScsJ1xcXFx4RTAnOidhZ3JhdmUnLCdcXFxceEMwJzonQWdyYXZlJywnXFxcXHUwMTAzJzonYWJyZXZlJywnXFxcXHUwMTAyJzonQWJyZXZlJywnXFxcXHhFMic6J2FjaXJjJywnXFxcXHhDMic6J0FjaXJjJywnXFxcXHhFNSc6J2FyaW5nJywnXFxcXHhDNSc6J2FuZ3N0JywnXFxcXHhFNCc6J2F1bWwnLCdcXFxceEM0JzonQXVtbCcsJ1xcXFx4RTMnOidhdGlsZGUnLCdcXFxceEMzJzonQXRpbGRlJywnXFxcXHUwMTA1JzonYW9nb24nLCdcXFxcdTAxMDQnOidBb2dvbicsJ1xcXFx1MDEwMSc6J2FtYWNyJywnXFxcXHUwMTAwJzonQW1hY3InLCdcXFxceEU2JzonYWVsaWcnLCdcXFxceEM2JzonQUVsaWcnLCdcXFxcdUQ4MzVcXFxcdURDQjcnOidic2NyJywnXFxcXHVEODM1XFxcXHVERDUzJzonYm9wZicsJ1xcXFx1RDgzNVxcXFx1REQxRic6J2JmcicsJ1xcXFx1RDgzNVxcXFx1REQzOSc6J0JvcGYnLCdcXFxcdTIxMkMnOidCc2NyJywnXFxcXHVEODM1XFxcXHVERDA1JzonQmZyJywnXFxcXHVEODM1XFxcXHVERDIwJzonY2ZyJywnXFxcXHVEODM1XFxcXHVEQ0I4JzonY3NjcicsJ1xcXFx1RDgzNVxcXFx1REQ1NCc6J2NvcGYnLCdcXFxcdTIxMkQnOidDZnInLCdcXFxcdUQ4MzVcXFxcdURDOUUnOidDc2NyJywnXFxcXHUyMTAyJzonQ29wZicsJ1xcXFx1MDEwNyc6J2NhY3V0ZScsJ1xcXFx1MDEwNic6J0NhY3V0ZScsJ1xcXFx1MDEwOSc6J2NjaXJjJywnXFxcXHUwMTA4JzonQ2NpcmMnLCdcXFxcdTAxMEQnOidjY2Fyb24nLCdcXFxcdTAxMEMnOidDY2Fyb24nLCdcXFxcdTAxMEInOidjZG90JywnXFxcXHUwMTBBJzonQ2RvdCcsJ1xcXFx4RTcnOidjY2VkaWwnLCdcXFxceEM3JzonQ2NlZGlsJywnXFxcXHUyMTA1JzonaW5jYXJlJywnXFxcXHVEODM1XFxcXHVERDIxJzonZGZyJywnXFxcXHUyMTQ2JzonZGQnLCdcXFxcdUQ4MzVcXFxcdURENTUnOidkb3BmJywnXFxcXHVEODM1XFxcXHVEQ0I5JzonZHNjcicsJ1xcXFx1RDgzNVxcXFx1REM5Ric6J0RzY3InLCdcXFxcdUQ4MzVcXFxcdUREMDcnOidEZnInLCdcXFxcdTIxNDUnOidERCcsJ1xcXFx1RDgzNVxcXFx1REQzQic6J0RvcGYnLCdcXFxcdTAxMEYnOidkY2Fyb24nLCdcXFxcdTAxMEUnOidEY2Fyb24nLCdcXFxcdTAxMTEnOidkc3Ryb2snLCdcXFxcdTAxMTAnOidEc3Ryb2snLCdcXFxceEYwJzonZXRoJywnXFxcXHhEMCc6J0VUSCcsJ1xcXFx1MjE0Nyc6J2VlJywnXFxcXHUyMTJGJzonZXNjcicsJ1xcXFx1RDgzNVxcXFx1REQyMic6J2VmcicsJ1xcXFx1RDgzNVxcXFx1REQ1Nic6J2VvcGYnLCdcXFxcdTIxMzAnOidFc2NyJywnXFxcXHVEODM1XFxcXHVERDA4JzonRWZyJywnXFxcXHVEODM1XFxcXHVERDNDJzonRW9wZicsJ1xcXFx4RTknOidlYWN1dGUnLCdcXFxceEM5JzonRWFjdXRlJywnXFxcXHhFOCc6J2VncmF2ZScsJ1xcXFx4QzgnOidFZ3JhdmUnLCdcXFxceEVBJzonZWNpcmMnLCdcXFxceENBJzonRWNpcmMnLCdcXFxcdTAxMUInOidlY2Fyb24nLCdcXFxcdTAxMUEnOidFY2Fyb24nLCdcXFxceEVCJzonZXVtbCcsJ1xcXFx4Q0InOidFdW1sJywnXFxcXHUwMTE3JzonZWRvdCcsJ1xcXFx1MDExNic6J0Vkb3QnLCdcXFxcdTAxMTknOidlb2dvbicsJ1xcXFx1MDExOCc6J0VvZ29uJywnXFxcXHUwMTEzJzonZW1hY3InLCdcXFxcdTAxMTInOidFbWFjcicsJ1xcXFx1RDgzNVxcXFx1REQyMyc6J2ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ1Nyc6J2ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQkInOidmc2NyJywnXFxcXHVEODM1XFxcXHVERDA5JzonRmZyJywnXFxcXHVEODM1XFxcXHVERDNEJzonRm9wZicsJ1xcXFx1MjEzMSc6J0ZzY3InLCdcXFxcdUZCMDAnOidmZmxpZycsJ1xcXFx1RkIwMyc6J2ZmaWxpZycsJ1xcXFx1RkIwNCc6J2ZmbGxpZycsJ1xcXFx1RkIwMSc6J2ZpbGlnJywnZmonOidmamxpZycsJ1xcXFx1RkIwMic6J2ZsbGlnJywnXFxcXHUwMTkyJzonZm5vZicsJ1xcXFx1MjEwQSc6J2dzY3InLCdcXFxcdUQ4MzVcXFxcdURENTgnOidnb3BmJywnXFxcXHVEODM1XFxcXHVERDI0JzonZ2ZyJywnXFxcXHVEODM1XFxcXHVEQ0EyJzonR3NjcicsJ1xcXFx1RDgzNVxcXFx1REQzRSc6J0dvcGYnLCdcXFxcdUQ4MzVcXFxcdUREMEEnOidHZnInLCdcXFxcdTAxRjUnOidnYWN1dGUnLCdcXFxcdTAxMUYnOidnYnJldmUnLCdcXFxcdTAxMUUnOidHYnJldmUnLCdcXFxcdTAxMUQnOidnY2lyYycsJ1xcXFx1MDExQyc6J0djaXJjJywnXFxcXHUwMTIxJzonZ2RvdCcsJ1xcXFx1MDEyMCc6J0dkb3QnLCdcXFxcdTAxMjInOidHY2VkaWwnLCdcXFxcdUQ4MzVcXFxcdUREMjUnOidoZnInLCdcXFxcdTIxMEUnOidwbGFuY2toJywnXFxcXHVEODM1XFxcXHVEQ0JEJzonaHNjcicsJ1xcXFx1RDgzNVxcXFx1REQ1OSc6J2hvcGYnLCdcXFxcdTIxMEInOidIc2NyJywnXFxcXHUyMTBDJzonSGZyJywnXFxcXHUyMTBEJzonSG9wZicsJ1xcXFx1MDEyNSc6J2hjaXJjJywnXFxcXHUwMTI0JzonSGNpcmMnLCdcXFxcdTIxMEYnOidoYmFyJywnXFxcXHUwMTI3JzonaHN0cm9rJywnXFxcXHUwMTI2JzonSHN0cm9rJywnXFxcXHVEODM1XFxcXHVERDVBJzonaW9wZicsJ1xcXFx1RDgzNVxcXFx1REQyNic6J2lmcicsJ1xcXFx1RDgzNVxcXFx1RENCRSc6J2lzY3InLCdcXFxcdTIxNDgnOidpaScsJ1xcXFx1RDgzNVxcXFx1REQ0MCc6J0lvcGYnLCdcXFxcdTIxMTAnOidJc2NyJywnXFxcXHUyMTExJzonSW0nLCdcXFxceEVEJzonaWFjdXRlJywnXFxcXHhDRCc6J0lhY3V0ZScsJ1xcXFx4RUMnOidpZ3JhdmUnLCdcXFxceENDJzonSWdyYXZlJywnXFxcXHhFRSc6J2ljaXJjJywnXFxcXHhDRSc6J0ljaXJjJywnXFxcXHhFRic6J2l1bWwnLCdcXFxceENGJzonSXVtbCcsJ1xcXFx1MDEyOSc6J2l0aWxkZScsJ1xcXFx1MDEyOCc6J0l0aWxkZScsJ1xcXFx1MDEzMCc6J0lkb3QnLCdcXFxcdTAxMkYnOidpb2dvbicsJ1xcXFx1MDEyRSc6J0lvZ29uJywnXFxcXHUwMTJCJzonaW1hY3InLCdcXFxcdTAxMkEnOidJbWFjcicsJ1xcXFx1MDEzMyc6J2lqbGlnJywnXFxcXHUwMTMyJzonSUpsaWcnLCdcXFxcdTAxMzEnOidpbWF0aCcsJ1xcXFx1RDgzNVxcXFx1RENCRic6J2pzY3InLCdcXFxcdUQ4MzVcXFxcdURENUInOidqb3BmJywnXFxcXHVEODM1XFxcXHVERDI3JzonamZyJywnXFxcXHVEODM1XFxcXHVEQ0E1JzonSnNjcicsJ1xcXFx1RDgzNVxcXFx1REQwRCc6J0pmcicsJ1xcXFx1RDgzNVxcXFx1REQ0MSc6J0pvcGYnLCdcXFxcdTAxMzUnOidqY2lyYycsJ1xcXFx1MDEzNCc6J0pjaXJjJywnXFxcXHUwMjM3Jzonam1hdGgnLCdcXFxcdUQ4MzVcXFxcdURENUMnOidrb3BmJywnXFxcXHVEODM1XFxcXHVEQ0MwJzona3NjcicsJ1xcXFx1RDgzNVxcXFx1REQyOCc6J2tmcicsJ1xcXFx1RDgzNVxcXFx1RENBNic6J0tzY3InLCdcXFxcdUQ4MzVcXFxcdURENDInOidLb3BmJywnXFxcXHVEODM1XFxcXHVERDBFJzonS2ZyJywnXFxcXHUwMTM3Jzona2NlZGlsJywnXFxcXHUwMTM2JzonS2NlZGlsJywnXFxcXHVEODM1XFxcXHVERDI5JzonbGZyJywnXFxcXHVEODM1XFxcXHVEQ0MxJzonbHNjcicsJ1xcXFx1MjExMyc6J2VsbCcsJ1xcXFx1RDgzNVxcXFx1REQ1RCc6J2xvcGYnLCdcXFxcdTIxMTInOidMc2NyJywnXFxcXHVEODM1XFxcXHVERDBGJzonTGZyJywnXFxcXHVEODM1XFxcXHVERDQzJzonTG9wZicsJ1xcXFx1MDEzQSc6J2xhY3V0ZScsJ1xcXFx1MDEzOSc6J0xhY3V0ZScsJ1xcXFx1MDEzRSc6J2xjYXJvbicsJ1xcXFx1MDEzRCc6J0xjYXJvbicsJ1xcXFx1MDEzQyc6J2xjZWRpbCcsJ1xcXFx1MDEzQic6J0xjZWRpbCcsJ1xcXFx1MDE0Mic6J2xzdHJvaycsJ1xcXFx1MDE0MSc6J0xzdHJvaycsJ1xcXFx1MDE0MCc6J2xtaWRvdCcsJ1xcXFx1MDEzRic6J0xtaWRvdCcsJ1xcXFx1RDgzNVxcXFx1REQyQSc6J21mcicsJ1xcXFx1RDgzNVxcXFx1REQ1RSc6J21vcGYnLCdcXFxcdUQ4MzVcXFxcdURDQzInOidtc2NyJywnXFxcXHVEODM1XFxcXHVERDEwJzonTWZyJywnXFxcXHVEODM1XFxcXHVERDQ0JzonTW9wZicsJ1xcXFx1MjEzMyc6J01zY3InLCdcXFxcdUQ4MzVcXFxcdUREMkInOiduZnInLCdcXFxcdUQ4MzVcXFxcdURENUYnOidub3BmJywnXFxcXHVEODM1XFxcXHVEQ0MzJzonbnNjcicsJ1xcXFx1MjExNSc6J05vcGYnLCdcXFxcdUQ4MzVcXFxcdURDQTknOidOc2NyJywnXFxcXHVEODM1XFxcXHVERDExJzonTmZyJywnXFxcXHUwMTQ0JzonbmFjdXRlJywnXFxcXHUwMTQzJzonTmFjdXRlJywnXFxcXHUwMTQ4JzonbmNhcm9uJywnXFxcXHUwMTQ3JzonTmNhcm9uJywnXFxcXHhGMSc6J250aWxkZScsJ1xcXFx4RDEnOidOdGlsZGUnLCdcXFxcdTAxNDYnOiduY2VkaWwnLCdcXFxcdTAxNDUnOidOY2VkaWwnLCdcXFxcdTIxMTYnOidudW1lcm8nLCdcXFxcdTAxNEInOidlbmcnLCdcXFxcdTAxNEEnOidFTkcnLCdcXFxcdUQ4MzVcXFxcdURENjAnOidvb3BmJywnXFxcXHVEODM1XFxcXHVERDJDJzonb2ZyJywnXFxcXHUyMTM0Jzonb3NjcicsJ1xcXFx1RDgzNVxcXFx1RENBQSc6J09zY3InLCdcXFxcdUQ4MzVcXFxcdUREMTInOidPZnInLCdcXFxcdUQ4MzVcXFxcdURENDYnOidPb3BmJywnXFxcXHhCQSc6J29yZG0nLCdcXFxceEYzJzonb2FjdXRlJywnXFxcXHhEMyc6J09hY3V0ZScsJ1xcXFx4RjInOidvZ3JhdmUnLCdcXFxceEQyJzonT2dyYXZlJywnXFxcXHhGNCc6J29jaXJjJywnXFxcXHhENCc6J09jaXJjJywnXFxcXHhGNic6J291bWwnLCdcXFxceEQ2JzonT3VtbCcsJ1xcXFx1MDE1MSc6J29kYmxhYycsJ1xcXFx1MDE1MCc6J09kYmxhYycsJ1xcXFx4RjUnOidvdGlsZGUnLCdcXFxceEQ1JzonT3RpbGRlJywnXFxcXHhGOCc6J29zbGFzaCcsJ1xcXFx4RDgnOidPc2xhc2gnLCdcXFxcdTAxNEQnOidvbWFjcicsJ1xcXFx1MDE0Qyc6J09tYWNyJywnXFxcXHUwMTUzJzonb2VsaWcnLCdcXFxcdTAxNTInOidPRWxpZycsJ1xcXFx1RDgzNVxcXFx1REQyRCc6J3BmcicsJ1xcXFx1RDgzNVxcXFx1RENDNSc6J3BzY3InLCdcXFxcdUQ4MzVcXFxcdURENjEnOidwb3BmJywnXFxcXHUyMTE5JzonUG9wZicsJ1xcXFx1RDgzNVxcXFx1REQxMyc6J1BmcicsJ1xcXFx1RDgzNVxcXFx1RENBQic6J1BzY3InLCdcXFxcdUQ4MzVcXFxcdURENjInOidxb3BmJywnXFxcXHVEODM1XFxcXHVERDJFJzoncWZyJywnXFxcXHVEODM1XFxcXHVEQ0M2JzoncXNjcicsJ1xcXFx1RDgzNVxcXFx1RENBQyc6J1FzY3InLCdcXFxcdUQ4MzVcXFxcdUREMTQnOidRZnInLCdcXFxcdTIxMUEnOidRb3BmJywnXFxcXHUwMTM4Jzona2dyZWVuJywnXFxcXHVEODM1XFxcXHVERDJGJzoncmZyJywnXFxcXHVEODM1XFxcXHVERDYzJzoncm9wZicsJ1xcXFx1RDgzNVxcXFx1RENDNyc6J3JzY3InLCdcXFxcdTIxMUInOidSc2NyJywnXFxcXHUyMTFDJzonUmUnLCdcXFxcdTIxMUQnOidSb3BmJywnXFxcXHUwMTU1JzoncmFjdXRlJywnXFxcXHUwMTU0JzonUmFjdXRlJywnXFxcXHUwMTU5JzoncmNhcm9uJywnXFxcXHUwMTU4JzonUmNhcm9uJywnXFxcXHUwMTU3JzoncmNlZGlsJywnXFxcXHUwMTU2JzonUmNlZGlsJywnXFxcXHVEODM1XFxcXHVERDY0Jzonc29wZicsJ1xcXFx1RDgzNVxcXFx1RENDOCc6J3NzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzAnOidzZnInLCdcXFxcdUQ4MzVcXFxcdURENEEnOidTb3BmJywnXFxcXHVEODM1XFxcXHVERDE2JzonU2ZyJywnXFxcXHVEODM1XFxcXHVEQ0FFJzonU3NjcicsJ1xcXFx1MjRDOCc6J29TJywnXFxcXHUwMTVCJzonc2FjdXRlJywnXFxcXHUwMTVBJzonU2FjdXRlJywnXFxcXHUwMTVEJzonc2NpcmMnLCdcXFxcdTAxNUMnOidTY2lyYycsJ1xcXFx1MDE2MSc6J3NjYXJvbicsJ1xcXFx1MDE2MCc6J1NjYXJvbicsJ1xcXFx1MDE1Ric6J3NjZWRpbCcsJ1xcXFx1MDE1RSc6J1NjZWRpbCcsJ1xcXFx4REYnOidzemxpZycsJ1xcXFx1RDgzNVxcXFx1REQzMSc6J3RmcicsJ1xcXFx1RDgzNVxcXFx1RENDOSc6J3RzY3InLCdcXFxcdUQ4MzVcXFxcdURENjUnOid0b3BmJywnXFxcXHVEODM1XFxcXHVEQ0FGJzonVHNjcicsJ1xcXFx1RDgzNVxcXFx1REQxNyc6J1RmcicsJ1xcXFx1RDgzNVxcXFx1REQ0Qic6J1RvcGYnLCdcXFxcdTAxNjUnOid0Y2Fyb24nLCdcXFxcdTAxNjQnOidUY2Fyb24nLCdcXFxcdTAxNjMnOid0Y2VkaWwnLCdcXFxcdTAxNjInOidUY2VkaWwnLCdcXFxcdTIxMjInOid0cmFkZScsJ1xcXFx1MDE2Nyc6J3RzdHJvaycsJ1xcXFx1MDE2Nic6J1RzdHJvaycsJ1xcXFx1RDgzNVxcXFx1RENDQSc6J3VzY3InLCdcXFxcdUQ4MzVcXFxcdURENjYnOid1b3BmJywnXFxcXHVEODM1XFxcXHVERDMyJzondWZyJywnXFxcXHVEODM1XFxcXHVERDRDJzonVW9wZicsJ1xcXFx1RDgzNVxcXFx1REQxOCc6J1VmcicsJ1xcXFx1RDgzNVxcXFx1RENCMCc6J1VzY3InLCdcXFxceEZBJzondWFjdXRlJywnXFxcXHhEQSc6J1VhY3V0ZScsJ1xcXFx4RjknOid1Z3JhdmUnLCdcXFxceEQ5JzonVWdyYXZlJywnXFxcXHUwMTZEJzondWJyZXZlJywnXFxcXHUwMTZDJzonVWJyZXZlJywnXFxcXHhGQic6J3VjaXJjJywnXFxcXHhEQic6J1VjaXJjJywnXFxcXHUwMTZGJzondXJpbmcnLCdcXFxcdTAxNkUnOidVcmluZycsJ1xcXFx4RkMnOid1dW1sJywnXFxcXHhEQyc6J1V1bWwnLCdcXFxcdTAxNzEnOid1ZGJsYWMnLCdcXFxcdTAxNzAnOidVZGJsYWMnLCdcXFxcdTAxNjknOid1dGlsZGUnLCdcXFxcdTAxNjgnOidVdGlsZGUnLCdcXFxcdTAxNzMnOid1b2dvbicsJ1xcXFx1MDE3Mic6J1VvZ29uJywnXFxcXHUwMTZCJzondW1hY3InLCdcXFxcdTAxNkEnOidVbWFjcicsJ1xcXFx1RDgzNVxcXFx1REQzMyc6J3ZmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Nyc6J3ZvcGYnLCdcXFxcdUQ4MzVcXFxcdURDQ0InOid2c2NyJywnXFxcXHVEODM1XFxcXHVERDE5JzonVmZyJywnXFxcXHVEODM1XFxcXHVERDREJzonVm9wZicsJ1xcXFx1RDgzNVxcXFx1RENCMSc6J1ZzY3InLCdcXFxcdUQ4MzVcXFxcdURENjgnOid3b3BmJywnXFxcXHVEODM1XFxcXHVEQ0NDJzond3NjcicsJ1xcXFx1RDgzNVxcXFx1REQzNCc6J3dmcicsJ1xcXFx1RDgzNVxcXFx1RENCMic6J1dzY3InLCdcXFxcdUQ4MzVcXFxcdURENEUnOidXb3BmJywnXFxcXHVEODM1XFxcXHVERDFBJzonV2ZyJywnXFxcXHUwMTc1Jzond2NpcmMnLCdcXFxcdTAxNzQnOidXY2lyYycsJ1xcXFx1RDgzNVxcXFx1REQzNSc6J3hmcicsJ1xcXFx1RDgzNVxcXFx1RENDRCc6J3hzY3InLCdcXFxcdUQ4MzVcXFxcdURENjknOid4b3BmJywnXFxcXHVEODM1XFxcXHVERDRGJzonWG9wZicsJ1xcXFx1RDgzNVxcXFx1REQxQic6J1hmcicsJ1xcXFx1RDgzNVxcXFx1RENCMyc6J1hzY3InLCdcXFxcdUQ4MzVcXFxcdUREMzYnOid5ZnInLCdcXFxcdUQ4MzVcXFxcdURDQ0UnOid5c2NyJywnXFxcXHVEODM1XFxcXHVERDZBJzoneW9wZicsJ1xcXFx1RDgzNVxcXFx1RENCNCc6J1lzY3InLCdcXFxcdUQ4MzVcXFxcdUREMUMnOidZZnInLCdcXFxcdUQ4MzVcXFxcdURENTAnOidZb3BmJywnXFxcXHhGRCc6J3lhY3V0ZScsJ1xcXFx4REQnOidZYWN1dGUnLCdcXFxcdTAxNzcnOid5Y2lyYycsJ1xcXFx1MDE3Nic6J1ljaXJjJywnXFxcXHhGRic6J3l1bWwnLCdcXFxcdTAxNzgnOidZdW1sJywnXFxcXHVEODM1XFxcXHVEQ0NGJzonenNjcicsJ1xcXFx1RDgzNVxcXFx1REQzNyc6J3pmcicsJ1xcXFx1RDgzNVxcXFx1REQ2Qic6J3pvcGYnLCdcXFxcdTIxMjgnOidaZnInLCdcXFxcdTIxMjQnOidab3BmJywnXFxcXHVEODM1XFxcXHVEQ0I1JzonWnNjcicsJ1xcXFx1MDE3QSc6J3phY3V0ZScsJ1xcXFx1MDE3OSc6J1phY3V0ZScsJ1xcXFx1MDE3RSc6J3pjYXJvbicsJ1xcXFx1MDE3RCc6J1pjYXJvbicsJ1xcXFx1MDE3Qyc6J3pkb3QnLCdcXFxcdTAxN0InOidaZG90JywnXFxcXHUwMUI1JzonaW1wZWQnLCdcXFxceEZFJzondGhvcm4nLCdcXFxceERFJzonVEhPUk4nLCdcXFxcdTAxNDknOiduYXBvcycsJ1xcXFx1MDNCMSc6J2FscGhhJywnXFxcXHUwMzkxJzonQWxwaGEnLCdcXFxcdTAzQjInOidiZXRhJywnXFxcXHUwMzkyJzonQmV0YScsJ1xcXFx1MDNCMyc6J2dhbW1hJywnXFxcXHUwMzkzJzonR2FtbWEnLCdcXFxcdTAzQjQnOidkZWx0YScsJ1xcXFx1MDM5NCc6J0RlbHRhJywnXFxcXHUwM0I1JzonZXBzaScsJ1xcXFx1MDNGNSc6J2Vwc2l2JywnXFxcXHUwMzk1JzonRXBzaWxvbicsJ1xcXFx1MDNERCc6J2dhbW1hZCcsJ1xcXFx1MDNEQyc6J0dhbW1hZCcsJ1xcXFx1MDNCNic6J3pldGEnLCdcXFxcdTAzOTYnOidaZXRhJywnXFxcXHUwM0I3JzonZXRhJywnXFxcXHUwMzk3JzonRXRhJywnXFxcXHUwM0I4JzondGhldGEnLCdcXFxcdTAzRDEnOid0aGV0YXYnLCdcXFxcdTAzOTgnOidUaGV0YScsJ1xcXFx1MDNCOSc6J2lvdGEnLCdcXFxcdTAzOTknOidJb3RhJywnXFxcXHUwM0JBJzona2FwcGEnLCdcXFxcdTAzRjAnOidrYXBwYXYnLCdcXFxcdTAzOUEnOidLYXBwYScsJ1xcXFx1MDNCQic6J2xhbWJkYScsJ1xcXFx1MDM5Qic6J0xhbWJkYScsJ1xcXFx1MDNCQyc6J211JywnXFxcXHhCNSc6J21pY3JvJywnXFxcXHUwMzlDJzonTXUnLCdcXFxcdTAzQkQnOidudScsJ1xcXFx1MDM5RCc6J051JywnXFxcXHUwM0JFJzoneGknLCdcXFxcdTAzOUUnOidYaScsJ1xcXFx1MDNCRic6J29taWNyb24nLCdcXFxcdTAzOUYnOidPbWljcm9uJywnXFxcXHUwM0MwJzoncGknLCdcXFxcdTAzRDYnOidwaXYnLCdcXFxcdTAzQTAnOidQaScsJ1xcXFx1MDNDMSc6J3JobycsJ1xcXFx1MDNGMSc6J3Job3YnLCdcXFxcdTAzQTEnOidSaG8nLCdcXFxcdTAzQzMnOidzaWdtYScsJ1xcXFx1MDNBMyc6J1NpZ21hJywnXFxcXHUwM0MyJzonc2lnbWFmJywnXFxcXHUwM0M0JzondGF1JywnXFxcXHUwM0E0JzonVGF1JywnXFxcXHUwM0M1JzondXBzaScsJ1xcXFx1MDNBNSc6J1Vwc2lsb24nLCdcXFxcdTAzRDInOidVcHNpJywnXFxcXHUwM0M2JzoncGhpJywnXFxcXHUwM0Q1JzoncGhpdicsJ1xcXFx1MDNBNic6J1BoaScsJ1xcXFx1MDNDNyc6J2NoaScsJ1xcXFx1MDNBNyc6J0NoaScsJ1xcXFx1MDNDOCc6J3BzaScsJ1xcXFx1MDNBOCc6J1BzaScsJ1xcXFx1MDNDOSc6J29tZWdhJywnXFxcXHUwM0E5Jzonb2htJywnXFxcXHUwNDMwJzonYWN5JywnXFxcXHUwNDEwJzonQWN5JywnXFxcXHUwNDMxJzonYmN5JywnXFxcXHUwNDExJzonQmN5JywnXFxcXHUwNDMyJzondmN5JywnXFxcXHUwNDEyJzonVmN5JywnXFxcXHUwNDMzJzonZ2N5JywnXFxcXHUwNDEzJzonR2N5JywnXFxcXHUwNDUzJzonZ2pjeScsJ1xcXFx1MDQwMyc6J0dKY3knLCdcXFxcdTA0MzQnOidkY3knLCdcXFxcdTA0MTQnOidEY3knLCdcXFxcdTA0NTInOidkamN5JywnXFxcXHUwNDAyJzonREpjeScsJ1xcXFx1MDQzNSc6J2llY3knLCdcXFxcdTA0MTUnOidJRWN5JywnXFxcXHUwNDUxJzonaW9jeScsJ1xcXFx1MDQwMSc6J0lPY3knLCdcXFxcdTA0NTQnOidqdWtjeScsJ1xcXFx1MDQwNCc6J0p1a2N5JywnXFxcXHUwNDM2JzonemhjeScsJ1xcXFx1MDQxNic6J1pIY3knLCdcXFxcdTA0MzcnOid6Y3knLCdcXFxcdTA0MTcnOidaY3knLCdcXFxcdTA0NTUnOidkc2N5JywnXFxcXHUwNDA1JzonRFNjeScsJ1xcXFx1MDQzOCc6J2ljeScsJ1xcXFx1MDQxOCc6J0ljeScsJ1xcXFx1MDQ1Nic6J2l1a2N5JywnXFxcXHUwNDA2JzonSXVrY3knLCdcXFxcdTA0NTcnOid5aWN5JywnXFxcXHUwNDA3JzonWUljeScsJ1xcXFx1MDQzOSc6J2pjeScsJ1xcXFx1MDQxOSc6J0pjeScsJ1xcXFx1MDQ1OCc6J2pzZXJjeScsJ1xcXFx1MDQwOCc6J0pzZXJjeScsJ1xcXFx1MDQzQSc6J2tjeScsJ1xcXFx1MDQxQSc6J0tjeScsJ1xcXFx1MDQ1Qyc6J2tqY3knLCdcXFxcdTA0MEMnOidLSmN5JywnXFxcXHUwNDNCJzonbGN5JywnXFxcXHUwNDFCJzonTGN5JywnXFxcXHUwNDU5JzonbGpjeScsJ1xcXFx1MDQwOSc6J0xKY3knLCdcXFxcdTA0M0MnOidtY3knLCdcXFxcdTA0MUMnOidNY3knLCdcXFxcdTA0M0QnOiduY3knLCdcXFxcdTA0MUQnOidOY3knLCdcXFxcdTA0NUEnOiduamN5JywnXFxcXHUwNDBBJzonTkpjeScsJ1xcXFx1MDQzRSc6J29jeScsJ1xcXFx1MDQxRSc6J09jeScsJ1xcXFx1MDQzRic6J3BjeScsJ1xcXFx1MDQxRic6J1BjeScsJ1xcXFx1MDQ0MCc6J3JjeScsJ1xcXFx1MDQyMCc6J1JjeScsJ1xcXFx1MDQ0MSc6J3NjeScsJ1xcXFx1MDQyMSc6J1NjeScsJ1xcXFx1MDQ0Mic6J3RjeScsJ1xcXFx1MDQyMic6J1RjeScsJ1xcXFx1MDQ1Qic6J3RzaGN5JywnXFxcXHUwNDBCJzonVFNIY3knLCdcXFxcdTA0NDMnOid1Y3knLCdcXFxcdTA0MjMnOidVY3knLCdcXFxcdTA0NUUnOid1YnJjeScsJ1xcXFx1MDQwRSc6J1VicmN5JywnXFxcXHUwNDQ0JzonZmN5JywnXFxcXHUwNDI0JzonRmN5JywnXFxcXHUwNDQ1Jzona2hjeScsJ1xcXFx1MDQyNSc6J0tIY3knLCdcXFxcdTA0NDYnOid0c2N5JywnXFxcXHUwNDI2JzonVFNjeScsJ1xcXFx1MDQ0Nyc6J2NoY3knLCdcXFxcdTA0MjcnOidDSGN5JywnXFxcXHUwNDVGJzonZHpjeScsJ1xcXFx1MDQwRic6J0RaY3knLCdcXFxcdTA0NDgnOidzaGN5JywnXFxcXHUwNDI4JzonU0hjeScsJ1xcXFx1MDQ0OSc6J3NoY2hjeScsJ1xcXFx1MDQyOSc6J1NIQ0hjeScsJ1xcXFx1MDQ0QSc6J2hhcmRjeScsJ1xcXFx1MDQyQSc6J0hBUkRjeScsJ1xcXFx1MDQ0Qic6J3ljeScsJ1xcXFx1MDQyQic6J1ljeScsJ1xcXFx1MDQ0Qyc6J3NvZnRjeScsJ1xcXFx1MDQyQyc6J1NPRlRjeScsJ1xcXFx1MDQ0RCc6J2VjeScsJ1xcXFx1MDQyRCc6J0VjeScsJ1xcXFx1MDQ0RSc6J3l1Y3knLCdcXFxcdTA0MkUnOidZVWN5JywnXFxcXHUwNDRGJzoneWFjeScsJ1xcXFx1MDQyRic6J1lBY3knLCdcXFxcdTIxMzUnOidhbGVwaCcsJ1xcXFx1MjEzNic6J2JldGgnLCdcXFxcdTIxMzcnOidnaW1lbCcsJ1xcXFx1MjEzOCc6J2RhbGV0aCd9O1xcblxcblxcdHZhciByZWdleEVzY2FwZSA9IC9bXFxcIiYnPD5gXS9nO1xcblxcdHZhciBlc2NhcGVNYXAgPSB7XFxuXFx0XFx0J1xcXCInOiAnJnF1b3Q7JyxcXG5cXHRcXHQnJic6ICcmYW1wOycsXFxuXFx0XFx0J1xcXFwnJzogJyYjeDI3OycsXFxuXFx0XFx0JzwnOiAnJmx0OycsXFxuXFx0XFx0Ly8gU2VlIGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kczogaW4gSFRNTCwgdGhlXFxuXFx0XFx0Ly8gZm9sbG93aW5nIGlzIG5vdCBzdHJpY3RseSBuZWNlc3NhcnkgdW5sZXNzIGl04oCZcyBwYXJ0IG9mIGEgdGFnIG9yIGFuXFxuXFx0XFx0Ly8gdW5xdW90ZWQgYXR0cmlidXRlIHZhbHVlLiBXZeKAmXJlIG9ubHkgZXNjYXBpbmcgaXQgdG8gc3VwcG9ydCB0aG9zZVxcblxcdFxcdC8vIHNpdHVhdGlvbnMsIGFuZCBmb3IgWE1MIHN1cHBvcnQuXFxuXFx0XFx0Jz4nOiAnJmd0OycsXFxuXFx0XFx0Ly8gSW4gSW50ZXJuZXQgRXhwbG9yZXIg4omkIDgsIHRoZSBiYWNrdGljayBjaGFyYWN0ZXIgY2FuIGJlIHVzZWRcXG5cXHRcXHQvLyB0byBicmVhayBvdXQgb2YgKHVuKXF1b3RlZCBhdHRyaWJ1dGUgdmFsdWVzIG9yIEhUTUwgY29tbWVudHMuXFxuXFx0XFx0Ly8gU2VlIGh0dHA6Ly9odG1sNXNlYy5vcmcvIzEwMiwgaHR0cDovL2h0bWw1c2VjLm9yZy8jMTA4LCBhbmRcXG5cXHRcXHQvLyBodHRwOi8vaHRtbDVzZWMub3JnLyMxMzMuXFxuXFx0XFx0J2AnOiAnJiN4NjA7J1xcblxcdH07XFxuXFxuXFx0dmFyIHJlZ2V4SW52YWxpZEVudGl0eSA9IC8mIyg/Olt4WF1bXmEtZkEtRjAtOV18W14wLTl4WF0pLztcXG5cXHR2YXIgcmVnZXhJbnZhbGlkUmF3Q29kZVBvaW50ID0gL1tcXFxcMC1cXFxceDA4XFxcXHgwQlxcXFx4MEUtXFxcXHgxRlxcXFx4N0YtXFxcXHg5RlxcXFx1RkREMC1cXFxcdUZERUZcXFxcdUZGRkVcXFxcdUZGRkZdfFtcXFxcdUQ4M0ZcXFxcdUQ4N0ZcXFxcdUQ4QkZcXFxcdUQ4RkZcXFxcdUQ5M0ZcXFxcdUQ5N0ZcXFxcdUQ5QkZcXFxcdUQ5RkZcXFxcdURBM0ZcXFxcdURBN0ZcXFxcdURBQkZcXFxcdURBRkZcXFxcdURCM0ZcXFxcdURCN0ZcXFxcdURCQkZcXFxcdURCRkZdW1xcXFx1REZGRVxcXFx1REZGRl18W1xcXFx1RDgwMC1cXFxcdURCRkZdKD8hW1xcXFx1REMwMC1cXFxcdURGRkZdKXwoPzpbXlxcXFx1RDgwMC1cXFxcdURCRkZdfF4pW1xcXFx1REMwMC1cXFxcdURGRkZdLztcXG5cXHR2YXIgcmVnZXhEZWNvZGUgPSAvJiMoWzAtOV0rKSg7Pyl8JiNbeFhdKFthLWZBLUYwLTldKykoOz8pfCYoWzAtOWEtekEtWl0rKTt8JihBYWN1dGV8QWdyYXZlfEF0aWxkZXxDY2VkaWx8RWFjdXRlfEVncmF2ZXxJYWN1dGV8SWdyYXZlfE50aWxkZXxPYWN1dGV8T2dyYXZlfE9zbGFzaHxPdGlsZGV8VWFjdXRlfFVncmF2ZXxZYWN1dGV8YWFjdXRlfGFncmF2ZXxhdGlsZGV8YnJ2YmFyfGNjZWRpbHxjdXJyZW58ZGl2aWRlfGVhY3V0ZXxlZ3JhdmV8ZnJhYzEyfGZyYWMxNHxmcmFjMzR8aWFjdXRlfGlncmF2ZXxpcXVlc3R8bWlkZG90fG50aWxkZXxvYWN1dGV8b2dyYXZlfG9zbGFzaHxvdGlsZGV8cGx1c21ufHVhY3V0ZXx1Z3JhdmV8eWFjdXRlfEFFbGlnfEFjaXJjfEFyaW5nfEVjaXJjfEljaXJjfE9jaXJjfFRIT1JOfFVjaXJjfGFjaXJjfGFjdXRlfGFlbGlnfGFyaW5nfGNlZGlsfGVjaXJjfGljaXJjfGlleGNsfGxhcXVvfG1pY3JvfG9jaXJjfHBvdW5kfHJhcXVvfHN6bGlnfHRob3JufHRpbWVzfHVjaXJjfEF1bWx8Q09QWXxFdW1sfEl1bWx8T3VtbHxRVU9UfFV1bWx8YXVtbHxjZW50fGNvcHl8ZXVtbHxpdW1sfG1hY3J8bmJzcHxvcmRmfG9yZG18b3VtbHxwYXJhfHF1b3R8c2VjdHxzdXAxfHN1cDJ8c3VwM3x1dW1sfHl1bWx8QU1QfEVUSHxSRUd8YW1wfGRlZ3xldGh8bm90fHJlZ3xzaHl8dW1sfHllbnxHVHxMVHxndHxsdCkoWz1hLXpBLVowLTldKT8vZztcXG5cXHR2YXIgZGVjb2RlTWFwID0geydhYWN1dGUnOidcXFxceEUxJywnQWFjdXRlJzonXFxcXHhDMScsJ2FicmV2ZSc6J1xcXFx1MDEwMycsJ0FicmV2ZSc6J1xcXFx1MDEwMicsJ2FjJzonXFxcXHUyMjNFJywnYWNkJzonXFxcXHUyMjNGJywnYWNFJzonXFxcXHUyMjNFXFxcXHUwMzMzJywnYWNpcmMnOidcXFxceEUyJywnQWNpcmMnOidcXFxceEMyJywnYWN1dGUnOidcXFxceEI0JywnYWN5JzonXFxcXHUwNDMwJywnQWN5JzonXFxcXHUwNDEwJywnYWVsaWcnOidcXFxceEU2JywnQUVsaWcnOidcXFxceEM2JywnYWYnOidcXFxcdTIwNjEnLCdhZnInOidcXFxcdUQ4MzVcXFxcdUREMUUnLCdBZnInOidcXFxcdUQ4MzVcXFxcdUREMDQnLCdhZ3JhdmUnOidcXFxceEUwJywnQWdyYXZlJzonXFxcXHhDMCcsJ2FsZWZzeW0nOidcXFxcdTIxMzUnLCdhbGVwaCc6J1xcXFx1MjEzNScsJ2FscGhhJzonXFxcXHUwM0IxJywnQWxwaGEnOidcXFxcdTAzOTEnLCdhbWFjcic6J1xcXFx1MDEwMScsJ0FtYWNyJzonXFxcXHUwMTAwJywnYW1hbGcnOidcXFxcdTJBM0YnLCdhbXAnOicmJywnQU1QJzonJicsJ2FuZCc6J1xcXFx1MjIyNycsJ0FuZCc6J1xcXFx1MkE1MycsJ2FuZGFuZCc6J1xcXFx1MkE1NScsJ2FuZGQnOidcXFxcdTJBNUMnLCdhbmRzbG9wZSc6J1xcXFx1MkE1OCcsJ2FuZHYnOidcXFxcdTJBNUEnLCdhbmcnOidcXFxcdTIyMjAnLCdhbmdlJzonXFxcXHUyOUE0JywnYW5nbGUnOidcXFxcdTIyMjAnLCdhbmdtc2QnOidcXFxcdTIyMjEnLCdhbmdtc2RhYSc6J1xcXFx1MjlBOCcsJ2FuZ21zZGFiJzonXFxcXHUyOUE5JywnYW5nbXNkYWMnOidcXFxcdTI5QUEnLCdhbmdtc2RhZCc6J1xcXFx1MjlBQicsJ2FuZ21zZGFlJzonXFxcXHUyOUFDJywnYW5nbXNkYWYnOidcXFxcdTI5QUQnLCdhbmdtc2RhZyc6J1xcXFx1MjlBRScsJ2FuZ21zZGFoJzonXFxcXHUyOUFGJywnYW5ncnQnOidcXFxcdTIyMUYnLCdhbmdydHZiJzonXFxcXHUyMkJFJywnYW5ncnR2YmQnOidcXFxcdTI5OUQnLCdhbmdzcGgnOidcXFxcdTIyMjInLCdhbmdzdCc6J1xcXFx4QzUnLCdhbmd6YXJyJzonXFxcXHUyMzdDJywnYW9nb24nOidcXFxcdTAxMDUnLCdBb2dvbic6J1xcXFx1MDEwNCcsJ2FvcGYnOidcXFxcdUQ4MzVcXFxcdURENTInLCdBb3BmJzonXFxcXHVEODM1XFxcXHVERDM4JywnYXAnOidcXFxcdTIyNDgnLCdhcGFjaXInOidcXFxcdTJBNkYnLCdhcGUnOidcXFxcdTIyNEEnLCdhcEUnOidcXFxcdTJBNzAnLCdhcGlkJzonXFxcXHUyMjRCJywnYXBvcyc6J1xcXFwnJywnQXBwbHlGdW5jdGlvbic6J1xcXFx1MjA2MScsJ2FwcHJveCc6J1xcXFx1MjI0OCcsJ2FwcHJveGVxJzonXFxcXHUyMjRBJywnYXJpbmcnOidcXFxceEU1JywnQXJpbmcnOidcXFxceEM1JywnYXNjcic6J1xcXFx1RDgzNVxcXFx1RENCNicsJ0FzY3InOidcXFxcdUQ4MzVcXFxcdURDOUMnLCdBc3NpZ24nOidcXFxcdTIyNTQnLCdhc3QnOicqJywnYXN5bXAnOidcXFxcdTIyNDgnLCdhc3ltcGVxJzonXFxcXHUyMjREJywnYXRpbGRlJzonXFxcXHhFMycsJ0F0aWxkZSc6J1xcXFx4QzMnLCdhdW1sJzonXFxcXHhFNCcsJ0F1bWwnOidcXFxceEM0JywnYXdjb25pbnQnOidcXFxcdTIyMzMnLCdhd2ludCc6J1xcXFx1MkExMScsJ2JhY2tjb25nJzonXFxcXHUyMjRDJywnYmFja2Vwc2lsb24nOidcXFxcdTAzRjYnLCdiYWNrcHJpbWUnOidcXFxcdTIwMzUnLCdiYWNrc2ltJzonXFxcXHUyMjNEJywnYmFja3NpbWVxJzonXFxcXHUyMkNEJywnQmFja3NsYXNoJzonXFxcXHUyMjE2JywnQmFydic6J1xcXFx1MkFFNycsJ2JhcnZlZSc6J1xcXFx1MjJCRCcsJ2JhcndlZCc6J1xcXFx1MjMwNScsJ0JhcndlZCc6J1xcXFx1MjMwNicsJ2JhcndlZGdlJzonXFxcXHUyMzA1JywnYmJyayc6J1xcXFx1MjNCNScsJ2Jicmt0YnJrJzonXFxcXHUyM0I2JywnYmNvbmcnOidcXFxcdTIyNEMnLCdiY3knOidcXFxcdTA0MzEnLCdCY3knOidcXFxcdTA0MTEnLCdiZHF1byc6J1xcXFx1MjAxRScsJ2JlY2F1cyc6J1xcXFx1MjIzNScsJ2JlY2F1c2UnOidcXFxcdTIyMzUnLCdCZWNhdXNlJzonXFxcXHUyMjM1JywnYmVtcHR5dic6J1xcXFx1MjlCMCcsJ2JlcHNpJzonXFxcXHUwM0Y2JywnYmVybm91JzonXFxcXHUyMTJDJywnQmVybm91bGxpcyc6J1xcXFx1MjEyQycsJ2JldGEnOidcXFxcdTAzQjInLCdCZXRhJzonXFxcXHUwMzkyJywnYmV0aCc6J1xcXFx1MjEzNicsJ2JldHdlZW4nOidcXFxcdTIyNkMnLCdiZnInOidcXFxcdUQ4MzVcXFxcdUREMUYnLCdCZnInOidcXFxcdUQ4MzVcXFxcdUREMDUnLCdiaWdjYXAnOidcXFxcdTIyQzInLCdiaWdjaXJjJzonXFxcXHUyNUVGJywnYmlnY3VwJzonXFxcXHUyMkMzJywnYmlnb2RvdCc6J1xcXFx1MkEwMCcsJ2JpZ29wbHVzJzonXFxcXHUyQTAxJywnYmlnb3RpbWVzJzonXFxcXHUyQTAyJywnYmlnc3FjdXAnOidcXFxcdTJBMDYnLCdiaWdzdGFyJzonXFxcXHUyNjA1JywnYmlndHJpYW5nbGVkb3duJzonXFxcXHUyNUJEJywnYmlndHJpYW5nbGV1cCc6J1xcXFx1MjVCMycsJ2JpZ3VwbHVzJzonXFxcXHUyQTA0JywnYmlndmVlJzonXFxcXHUyMkMxJywnYmlnd2VkZ2UnOidcXFxcdTIyQzAnLCdia2Fyb3cnOidcXFxcdTI5MEQnLCdibGFja2xvemVuZ2UnOidcXFxcdTI5RUInLCdibGFja3NxdWFyZSc6J1xcXFx1MjVBQScsJ2JsYWNrdHJpYW5nbGUnOidcXFxcdTI1QjQnLCdibGFja3RyaWFuZ2xlZG93bic6J1xcXFx1MjVCRScsJ2JsYWNrdHJpYW5nbGVsZWZ0JzonXFxcXHUyNUMyJywnYmxhY2t0cmlhbmdsZXJpZ2h0JzonXFxcXHUyNUI4JywnYmxhbmsnOidcXFxcdTI0MjMnLCdibGsxMic6J1xcXFx1MjU5MicsJ2JsazE0JzonXFxcXHUyNTkxJywnYmxrMzQnOidcXFxcdTI1OTMnLCdibG9jayc6J1xcXFx1MjU4OCcsJ2JuZSc6Jz1cXFxcdTIwRTUnLCdibmVxdWl2JzonXFxcXHUyMjYxXFxcXHUyMEU1JywnYm5vdCc6J1xcXFx1MjMxMCcsJ2JOb3QnOidcXFxcdTJBRUQnLCdib3BmJzonXFxcXHVEODM1XFxcXHVERDUzJywnQm9wZic6J1xcXFx1RDgzNVxcXFx1REQzOScsJ2JvdCc6J1xcXFx1MjJBNScsJ2JvdHRvbSc6J1xcXFx1MjJBNScsJ2Jvd3RpZSc6J1xcXFx1MjJDOCcsJ2JveGJveCc6J1xcXFx1MjlDOScsJ2JveGRsJzonXFxcXHUyNTEwJywnYm94ZEwnOidcXFxcdTI1NTUnLCdib3hEbCc6J1xcXFx1MjU1NicsJ2JveERMJzonXFxcXHUyNTU3JywnYm94ZHInOidcXFxcdTI1MEMnLCdib3hkUic6J1xcXFx1MjU1MicsJ2JveERyJzonXFxcXHUyNTUzJywnYm94RFInOidcXFxcdTI1NTQnLCdib3hoJzonXFxcXHUyNTAwJywnYm94SCc6J1xcXFx1MjU1MCcsJ2JveGhkJzonXFxcXHUyNTJDJywnYm94aEQnOidcXFxcdTI1NjUnLCdib3hIZCc6J1xcXFx1MjU2NCcsJ2JveEhEJzonXFxcXHUyNTY2JywnYm94aHUnOidcXFxcdTI1MzQnLCdib3hoVSc6J1xcXFx1MjU2OCcsJ2JveEh1JzonXFxcXHUyNTY3JywnYm94SFUnOidcXFxcdTI1NjknLCdib3htaW51cyc6J1xcXFx1MjI5RicsJ2JveHBsdXMnOidcXFxcdTIyOUUnLCdib3h0aW1lcyc6J1xcXFx1MjJBMCcsJ2JveHVsJzonXFxcXHUyNTE4JywnYm94dUwnOidcXFxcdTI1NUInLCdib3hVbCc6J1xcXFx1MjU1QycsJ2JveFVMJzonXFxcXHUyNTVEJywnYm94dXInOidcXFxcdTI1MTQnLCdib3h1Uic6J1xcXFx1MjU1OCcsJ2JveFVyJzonXFxcXHUyNTU5JywnYm94VVInOidcXFxcdTI1NUEnLCdib3h2JzonXFxcXHUyNTAyJywnYm94Vic6J1xcXFx1MjU1MScsJ2JveHZoJzonXFxcXHUyNTNDJywnYm94dkgnOidcXFxcdTI1NkEnLCdib3hWaCc6J1xcXFx1MjU2QicsJ2JveFZIJzonXFxcXHUyNTZDJywnYm94dmwnOidcXFxcdTI1MjQnLCdib3h2TCc6J1xcXFx1MjU2MScsJ2JveFZsJzonXFxcXHUyNTYyJywnYm94VkwnOidcXFxcdTI1NjMnLCdib3h2cic6J1xcXFx1MjUxQycsJ2JveHZSJzonXFxcXHUyNTVFJywnYm94VnInOidcXFxcdTI1NUYnLCdib3hWUic6J1xcXFx1MjU2MCcsJ2JwcmltZSc6J1xcXFx1MjAzNScsJ2JyZXZlJzonXFxcXHUwMkQ4JywnQnJldmUnOidcXFxcdTAyRDgnLCdicnZiYXInOidcXFxceEE2JywnYnNjcic6J1xcXFx1RDgzNVxcXFx1RENCNycsJ0JzY3InOidcXFxcdTIxMkMnLCdic2VtaSc6J1xcXFx1MjA0RicsJ2JzaW0nOidcXFxcdTIyM0QnLCdic2ltZSc6J1xcXFx1MjJDRCcsJ2Jzb2wnOidcXFxcXFxcXCcsJ2Jzb2xiJzonXFxcXHUyOUM1JywnYnNvbGhzdWInOidcXFxcdTI3QzgnLCdidWxsJzonXFxcXHUyMDIyJywnYnVsbGV0JzonXFxcXHUyMDIyJywnYnVtcCc6J1xcXFx1MjI0RScsJ2J1bXBlJzonXFxcXHUyMjRGJywnYnVtcEUnOidcXFxcdTJBQUUnLCdidW1wZXEnOidcXFxcdTIyNEYnLCdCdW1wZXEnOidcXFxcdTIyNEUnLCdjYWN1dGUnOidcXFxcdTAxMDcnLCdDYWN1dGUnOidcXFxcdTAxMDYnLCdjYXAnOidcXFxcdTIyMjknLCdDYXAnOidcXFxcdTIyRDInLCdjYXBhbmQnOidcXFxcdTJBNDQnLCdjYXBicmN1cCc6J1xcXFx1MkE0OScsJ2NhcGNhcCc6J1xcXFx1MkE0QicsJ2NhcGN1cCc6J1xcXFx1MkE0NycsJ2NhcGRvdCc6J1xcXFx1MkE0MCcsJ0NhcGl0YWxEaWZmZXJlbnRpYWxEJzonXFxcXHUyMTQ1JywnY2Fwcyc6J1xcXFx1MjIyOVxcXFx1RkUwMCcsJ2NhcmV0JzonXFxcXHUyMDQxJywnY2Fyb24nOidcXFxcdTAyQzcnLCdDYXlsZXlzJzonXFxcXHUyMTJEJywnY2NhcHMnOidcXFxcdTJBNEQnLCdjY2Fyb24nOidcXFxcdTAxMEQnLCdDY2Fyb24nOidcXFxcdTAxMEMnLCdjY2VkaWwnOidcXFxceEU3JywnQ2NlZGlsJzonXFxcXHhDNycsJ2NjaXJjJzonXFxcXHUwMTA5JywnQ2NpcmMnOidcXFxcdTAxMDgnLCdDY29uaW50JzonXFxcXHUyMjMwJywnY2N1cHMnOidcXFxcdTJBNEMnLCdjY3Vwc3NtJzonXFxcXHUyQTUwJywnY2RvdCc6J1xcXFx1MDEwQicsJ0Nkb3QnOidcXFxcdTAxMEEnLCdjZWRpbCc6J1xcXFx4QjgnLCdDZWRpbGxhJzonXFxcXHhCOCcsJ2NlbXB0eXYnOidcXFxcdTI5QjInLCdjZW50JzonXFxcXHhBMicsJ2NlbnRlcmRvdCc6J1xcXFx4QjcnLCdDZW50ZXJEb3QnOidcXFxceEI3JywnY2ZyJzonXFxcXHVEODM1XFxcXHVERDIwJywnQ2ZyJzonXFxcXHUyMTJEJywnY2hjeSc6J1xcXFx1MDQ0NycsJ0NIY3knOidcXFxcdTA0MjcnLCdjaGVjayc6J1xcXFx1MjcxMycsJ2NoZWNrbWFyayc6J1xcXFx1MjcxMycsJ2NoaSc6J1xcXFx1MDNDNycsJ0NoaSc6J1xcXFx1MDNBNycsJ2Npcic6J1xcXFx1MjVDQicsJ2NpcmMnOidcXFxcdTAyQzYnLCdjaXJjZXEnOidcXFxcdTIyNTcnLCdjaXJjbGVhcnJvd2xlZnQnOidcXFxcdTIxQkEnLCdjaXJjbGVhcnJvd3JpZ2h0JzonXFxcXHUyMUJCJywnY2lyY2xlZGFzdCc6J1xcXFx1MjI5QicsJ2NpcmNsZWRjaXJjJzonXFxcXHUyMjlBJywnY2lyY2xlZGRhc2gnOidcXFxcdTIyOUQnLCdDaXJjbGVEb3QnOidcXFxcdTIyOTknLCdjaXJjbGVkUic6J1xcXFx4QUUnLCdjaXJjbGVkUyc6J1xcXFx1MjRDOCcsJ0NpcmNsZU1pbnVzJzonXFxcXHUyMjk2JywnQ2lyY2xlUGx1cyc6J1xcXFx1MjI5NScsJ0NpcmNsZVRpbWVzJzonXFxcXHUyMjk3JywnY2lyZSc6J1xcXFx1MjI1NycsJ2NpckUnOidcXFxcdTI5QzMnLCdjaXJmbmludCc6J1xcXFx1MkExMCcsJ2Npcm1pZCc6J1xcXFx1MkFFRicsJ2NpcnNjaXInOidcXFxcdTI5QzInLCdDbG9ja3dpc2VDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMzInLCdDbG9zZUN1cmx5RG91YmxlUXVvdGUnOidcXFxcdTIwMUQnLCdDbG9zZUN1cmx5UXVvdGUnOidcXFxcdTIwMTknLCdjbHVicyc6J1xcXFx1MjY2MycsJ2NsdWJzdWl0JzonXFxcXHUyNjYzJywnY29sb24nOic6JywnQ29sb24nOidcXFxcdTIyMzcnLCdjb2xvbmUnOidcXFxcdTIyNTQnLCdDb2xvbmUnOidcXFxcdTJBNzQnLCdjb2xvbmVxJzonXFxcXHUyMjU0JywnY29tbWEnOicsJywnY29tbWF0JzonQCcsJ2NvbXAnOidcXFxcdTIyMDEnLCdjb21wZm4nOidcXFxcdTIyMTgnLCdjb21wbGVtZW50JzonXFxcXHUyMjAxJywnY29tcGxleGVzJzonXFxcXHUyMTAyJywnY29uZyc6J1xcXFx1MjI0NScsJ2Nvbmdkb3QnOidcXFxcdTJBNkQnLCdDb25ncnVlbnQnOidcXFxcdTIyNjEnLCdjb25pbnQnOidcXFxcdTIyMkUnLCdDb25pbnQnOidcXFxcdTIyMkYnLCdDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMkUnLCdjb3BmJzonXFxcXHVEODM1XFxcXHVERDU0JywnQ29wZic6J1xcXFx1MjEwMicsJ2NvcHJvZCc6J1xcXFx1MjIxMCcsJ0NvcHJvZHVjdCc6J1xcXFx1MjIxMCcsJ2NvcHknOidcXFxceEE5JywnQ09QWSc6J1xcXFx4QTknLCdjb3B5c3InOidcXFxcdTIxMTcnLCdDb3VudGVyQ2xvY2t3aXNlQ29udG91ckludGVncmFsJzonXFxcXHUyMjMzJywnY3JhcnInOidcXFxcdTIxQjUnLCdjcm9zcyc6J1xcXFx1MjcxNycsJ0Nyb3NzJzonXFxcXHUyQTJGJywnY3Njcic6J1xcXFx1RDgzNVxcXFx1RENCOCcsJ0NzY3InOidcXFxcdUQ4MzVcXFxcdURDOUUnLCdjc3ViJzonXFxcXHUyQUNGJywnY3N1YmUnOidcXFxcdTJBRDEnLCdjc3VwJzonXFxcXHUyQUQwJywnY3N1cGUnOidcXFxcdTJBRDInLCdjdGRvdCc6J1xcXFx1MjJFRicsJ2N1ZGFycmwnOidcXFxcdTI5MzgnLCdjdWRhcnJyJzonXFxcXHUyOTM1JywnY3VlcHInOidcXFxcdTIyREUnLCdjdWVzYyc6J1xcXFx1MjJERicsJ2N1bGFycic6J1xcXFx1MjFCNicsJ2N1bGFycnAnOidcXFxcdTI5M0QnLCdjdXAnOidcXFxcdTIyMkEnLCdDdXAnOidcXFxcdTIyRDMnLCdjdXBicmNhcCc6J1xcXFx1MkE0OCcsJ2N1cGNhcCc6J1xcXFx1MkE0NicsJ0N1cENhcCc6J1xcXFx1MjI0RCcsJ2N1cGN1cCc6J1xcXFx1MkE0QScsJ2N1cGRvdCc6J1xcXFx1MjI4RCcsJ2N1cG9yJzonXFxcXHUyQTQ1JywnY3Vwcyc6J1xcXFx1MjIyQVxcXFx1RkUwMCcsJ2N1cmFycic6J1xcXFx1MjFCNycsJ2N1cmFycm0nOidcXFxcdTI5M0MnLCdjdXJseWVxcHJlYyc6J1xcXFx1MjJERScsJ2N1cmx5ZXFzdWNjJzonXFxcXHUyMkRGJywnY3VybHl2ZWUnOidcXFxcdTIyQ0UnLCdjdXJseXdlZGdlJzonXFxcXHUyMkNGJywnY3VycmVuJzonXFxcXHhBNCcsJ2N1cnZlYXJyb3dsZWZ0JzonXFxcXHUyMUI2JywnY3VydmVhcnJvd3JpZ2h0JzonXFxcXHUyMUI3JywnY3V2ZWUnOidcXFxcdTIyQ0UnLCdjdXdlZCc6J1xcXFx1MjJDRicsJ2N3Y29uaW50JzonXFxcXHUyMjMyJywnY3dpbnQnOidcXFxcdTIyMzEnLCdjeWxjdHknOidcXFxcdTIzMkQnLCdkYWdnZXInOidcXFxcdTIwMjAnLCdEYWdnZXInOidcXFxcdTIwMjEnLCdkYWxldGgnOidcXFxcdTIxMzgnLCdkYXJyJzonXFxcXHUyMTkzJywnZEFycic6J1xcXFx1MjFEMycsJ0RhcnInOidcXFxcdTIxQTEnLCdkYXNoJzonXFxcXHUyMDEwJywnZGFzaHYnOidcXFxcdTIyQTMnLCdEYXNodic6J1xcXFx1MkFFNCcsJ2Ria2Fyb3cnOidcXFxcdTI5MEYnLCdkYmxhYyc6J1xcXFx1MDJERCcsJ2RjYXJvbic6J1xcXFx1MDEwRicsJ0RjYXJvbic6J1xcXFx1MDEwRScsJ2RjeSc6J1xcXFx1MDQzNCcsJ0RjeSc6J1xcXFx1MDQxNCcsJ2RkJzonXFxcXHUyMTQ2JywnREQnOidcXFxcdTIxNDUnLCdkZGFnZ2VyJzonXFxcXHUyMDIxJywnZGRhcnInOidcXFxcdTIxQ0EnLCdERG90cmFoZCc6J1xcXFx1MjkxMScsJ2Rkb3RzZXEnOidcXFxcdTJBNzcnLCdkZWcnOidcXFxceEIwJywnRGVsJzonXFxcXHUyMjA3JywnZGVsdGEnOidcXFxcdTAzQjQnLCdEZWx0YSc6J1xcXFx1MDM5NCcsJ2RlbXB0eXYnOidcXFxcdTI5QjEnLCdkZmlzaHQnOidcXFxcdTI5N0YnLCdkZnInOidcXFxcdUQ4MzVcXFxcdUREMjEnLCdEZnInOidcXFxcdUQ4MzVcXFxcdUREMDcnLCdkSGFyJzonXFxcXHUyOTY1JywnZGhhcmwnOidcXFxcdTIxQzMnLCdkaGFycic6J1xcXFx1MjFDMicsJ0RpYWNyaXRpY2FsQWN1dGUnOidcXFxceEI0JywnRGlhY3JpdGljYWxEb3QnOidcXFxcdTAyRDknLCdEaWFjcml0aWNhbERvdWJsZUFjdXRlJzonXFxcXHUwMkREJywnRGlhY3JpdGljYWxHcmF2ZSc6J2AnLCdEaWFjcml0aWNhbFRpbGRlJzonXFxcXHUwMkRDJywnZGlhbSc6J1xcXFx1MjJDNCcsJ2RpYW1vbmQnOidcXFxcdTIyQzQnLCdEaWFtb25kJzonXFxcXHUyMkM0JywnZGlhbW9uZHN1aXQnOidcXFxcdTI2NjYnLCdkaWFtcyc6J1xcXFx1MjY2NicsJ2RpZSc6J1xcXFx4QTgnLCdEaWZmZXJlbnRpYWxEJzonXFxcXHUyMTQ2JywnZGlnYW1tYSc6J1xcXFx1MDNERCcsJ2Rpc2luJzonXFxcXHUyMkYyJywnZGl2JzonXFxcXHhGNycsJ2RpdmlkZSc6J1xcXFx4RjcnLCdkaXZpZGVvbnRpbWVzJzonXFxcXHUyMkM3JywnZGl2b254JzonXFxcXHUyMkM3JywnZGpjeSc6J1xcXFx1MDQ1MicsJ0RKY3knOidcXFxcdTA0MDInLCdkbGNvcm4nOidcXFxcdTIzMUUnLCdkbGNyb3AnOidcXFxcdTIzMEQnLCdkb2xsYXInOickJywnZG9wZic6J1xcXFx1RDgzNVxcXFx1REQ1NScsJ0RvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0InLCdkb3QnOidcXFxcdTAyRDknLCdEb3QnOidcXFxceEE4JywnRG90RG90JzonXFxcXHUyMERDJywnZG90ZXEnOidcXFxcdTIyNTAnLCdkb3RlcWRvdCc6J1xcXFx1MjI1MScsJ0RvdEVxdWFsJzonXFxcXHUyMjUwJywnZG90bWludXMnOidcXFxcdTIyMzgnLCdkb3RwbHVzJzonXFxcXHUyMjE0JywnZG90c3F1YXJlJzonXFxcXHUyMkExJywnZG91YmxlYmFyd2VkZ2UnOidcXFxcdTIzMDYnLCdEb3VibGVDb250b3VySW50ZWdyYWwnOidcXFxcdTIyMkYnLCdEb3VibGVEb3QnOidcXFxceEE4JywnRG91YmxlRG93bkFycm93JzonXFxcXHUyMUQzJywnRG91YmxlTGVmdEFycm93JzonXFxcXHUyMUQwJywnRG91YmxlTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTIxRDQnLCdEb3VibGVMZWZ0VGVlJzonXFxcXHUyQUU0JywnRG91YmxlTG9uZ0xlZnRBcnJvdyc6J1xcXFx1MjdGOCcsJ0RvdWJsZUxvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjdGQScsJ0RvdWJsZUxvbmdSaWdodEFycm93JzonXFxcXHUyN0Y5JywnRG91YmxlUmlnaHRBcnJvdyc6J1xcXFx1MjFEMicsJ0RvdWJsZVJpZ2h0VGVlJzonXFxcXHUyMkE4JywnRG91YmxlVXBBcnJvdyc6J1xcXFx1MjFEMScsJ0RvdWJsZVVwRG93bkFycm93JzonXFxcXHUyMUQ1JywnRG91YmxlVmVydGljYWxCYXInOidcXFxcdTIyMjUnLCdkb3duYXJyb3cnOidcXFxcdTIxOTMnLCdEb3duYXJyb3cnOidcXFxcdTIxRDMnLCdEb3duQXJyb3cnOidcXFxcdTIxOTMnLCdEb3duQXJyb3dCYXInOidcXFxcdTI5MTMnLCdEb3duQXJyb3dVcEFycm93JzonXFxcXHUyMUY1JywnRG93bkJyZXZlJzonXFxcXHUwMzExJywnZG93bmRvd25hcnJvd3MnOidcXFxcdTIxQ0EnLCdkb3duaGFycG9vbmxlZnQnOidcXFxcdTIxQzMnLCdkb3duaGFycG9vbnJpZ2h0JzonXFxcXHUyMUMyJywnRG93bkxlZnRSaWdodFZlY3Rvcic6J1xcXFx1Mjk1MCcsJ0Rvd25MZWZ0VGVlVmVjdG9yJzonXFxcXHUyOTVFJywnRG93bkxlZnRWZWN0b3InOidcXFxcdTIxQkQnLCdEb3duTGVmdFZlY3RvckJhcic6J1xcXFx1Mjk1NicsJ0Rvd25SaWdodFRlZVZlY3Rvcic6J1xcXFx1Mjk1RicsJ0Rvd25SaWdodFZlY3Rvcic6J1xcXFx1MjFDMScsJ0Rvd25SaWdodFZlY3RvckJhcic6J1xcXFx1Mjk1NycsJ0Rvd25UZWUnOidcXFxcdTIyQTQnLCdEb3duVGVlQXJyb3cnOidcXFxcdTIxQTcnLCdkcmJrYXJvdyc6J1xcXFx1MjkxMCcsJ2RyY29ybic6J1xcXFx1MjMxRicsJ2RyY3JvcCc6J1xcXFx1MjMwQycsJ2RzY3InOidcXFxcdUQ4MzVcXFxcdURDQjknLCdEc2NyJzonXFxcXHVEODM1XFxcXHVEQzlGJywnZHNjeSc6J1xcXFx1MDQ1NScsJ0RTY3knOidcXFxcdTA0MDUnLCdkc29sJzonXFxcXHUyOUY2JywnZHN0cm9rJzonXFxcXHUwMTExJywnRHN0cm9rJzonXFxcXHUwMTEwJywnZHRkb3QnOidcXFxcdTIyRjEnLCdkdHJpJzonXFxcXHUyNUJGJywnZHRyaWYnOidcXFxcdTI1QkUnLCdkdWFycic6J1xcXFx1MjFGNScsJ2R1aGFyJzonXFxcXHUyOTZGJywnZHdhbmdsZSc6J1xcXFx1MjlBNicsJ2R6Y3knOidcXFxcdTA0NUYnLCdEWmN5JzonXFxcXHUwNDBGJywnZHppZ3JhcnInOidcXFxcdTI3RkYnLCdlYWN1dGUnOidcXFxceEU5JywnRWFjdXRlJzonXFxcXHhDOScsJ2Vhc3Rlcic6J1xcXFx1MkE2RScsJ2VjYXJvbic6J1xcXFx1MDExQicsJ0VjYXJvbic6J1xcXFx1MDExQScsJ2VjaXInOidcXFxcdTIyNTYnLCdlY2lyYyc6J1xcXFx4RUEnLCdFY2lyYyc6J1xcXFx4Q0EnLCdlY29sb24nOidcXFxcdTIyNTUnLCdlY3knOidcXFxcdTA0NEQnLCdFY3knOidcXFxcdTA0MkQnLCdlRERvdCc6J1xcXFx1MkE3NycsJ2Vkb3QnOidcXFxcdTAxMTcnLCdlRG90JzonXFxcXHUyMjUxJywnRWRvdCc6J1xcXFx1MDExNicsJ2VlJzonXFxcXHUyMTQ3JywnZWZEb3QnOidcXFxcdTIyNTInLCdlZnInOidcXFxcdUQ4MzVcXFxcdUREMjInLCdFZnInOidcXFxcdUQ4MzVcXFxcdUREMDgnLCdlZyc6J1xcXFx1MkE5QScsJ2VncmF2ZSc6J1xcXFx4RTgnLCdFZ3JhdmUnOidcXFxceEM4JywnZWdzJzonXFxcXHUyQTk2JywnZWdzZG90JzonXFxcXHUyQTk4JywnZWwnOidcXFxcdTJBOTknLCdFbGVtZW50JzonXFxcXHUyMjA4JywnZWxpbnRlcnMnOidcXFxcdTIzRTcnLCdlbGwnOidcXFxcdTIxMTMnLCdlbHMnOidcXFxcdTJBOTUnLCdlbHNkb3QnOidcXFxcdTJBOTcnLCdlbWFjcic6J1xcXFx1MDExMycsJ0VtYWNyJzonXFxcXHUwMTEyJywnZW1wdHknOidcXFxcdTIyMDUnLCdlbXB0eXNldCc6J1xcXFx1MjIwNScsJ0VtcHR5U21hbGxTcXVhcmUnOidcXFxcdTI1RkInLCdlbXB0eXYnOidcXFxcdTIyMDUnLCdFbXB0eVZlcnlTbWFsbFNxdWFyZSc6J1xcXFx1MjVBQicsJ2Vtc3AnOidcXFxcdTIwMDMnLCdlbXNwMTMnOidcXFxcdTIwMDQnLCdlbXNwMTQnOidcXFxcdTIwMDUnLCdlbmcnOidcXFxcdTAxNEInLCdFTkcnOidcXFxcdTAxNEEnLCdlbnNwJzonXFxcXHUyMDAyJywnZW9nb24nOidcXFxcdTAxMTknLCdFb2dvbic6J1xcXFx1MDExOCcsJ2VvcGYnOidcXFxcdUQ4MzVcXFxcdURENTYnLCdFb3BmJzonXFxcXHVEODM1XFxcXHVERDNDJywnZXBhcic6J1xcXFx1MjJENScsJ2VwYXJzbCc6J1xcXFx1MjlFMycsJ2VwbHVzJzonXFxcXHUyQTcxJywnZXBzaSc6J1xcXFx1MDNCNScsJ2Vwc2lsb24nOidcXFxcdTAzQjUnLCdFcHNpbG9uJzonXFxcXHUwMzk1JywnZXBzaXYnOidcXFxcdTAzRjUnLCdlcWNpcmMnOidcXFxcdTIyNTYnLCdlcWNvbG9uJzonXFxcXHUyMjU1JywnZXFzaW0nOidcXFxcdTIyNDInLCdlcXNsYW50Z3RyJzonXFxcXHUyQTk2JywnZXFzbGFudGxlc3MnOidcXFxcdTJBOTUnLCdFcXVhbCc6J1xcXFx1MkE3NScsJ2VxdWFscyc6Jz0nLCdFcXVhbFRpbGRlJzonXFxcXHUyMjQyJywnZXF1ZXN0JzonXFxcXHUyMjVGJywnRXF1aWxpYnJpdW0nOidcXFxcdTIxQ0MnLCdlcXVpdic6J1xcXFx1MjI2MScsJ2VxdWl2REQnOidcXFxcdTJBNzgnLCdlcXZwYXJzbCc6J1xcXFx1MjlFNScsJ2VyYXJyJzonXFxcXHUyOTcxJywnZXJEb3QnOidcXFxcdTIyNTMnLCdlc2NyJzonXFxcXHUyMTJGJywnRXNjcic6J1xcXFx1MjEzMCcsJ2VzZG90JzonXFxcXHUyMjUwJywnZXNpbSc6J1xcXFx1MjI0MicsJ0VzaW0nOidcXFxcdTJBNzMnLCdldGEnOidcXFxcdTAzQjcnLCdFdGEnOidcXFxcdTAzOTcnLCdldGgnOidcXFxceEYwJywnRVRIJzonXFxcXHhEMCcsJ2V1bWwnOidcXFxceEVCJywnRXVtbCc6J1xcXFx4Q0InLCdldXJvJzonXFxcXHUyMEFDJywnZXhjbCc6JyEnLCdleGlzdCc6J1xcXFx1MjIwMycsJ0V4aXN0cyc6J1xcXFx1MjIwMycsJ2V4cGVjdGF0aW9uJzonXFxcXHUyMTMwJywnZXhwb25lbnRpYWxlJzonXFxcXHUyMTQ3JywnRXhwb25lbnRpYWxFJzonXFxcXHUyMTQ3JywnZmFsbGluZ2RvdHNlcSc6J1xcXFx1MjI1MicsJ2ZjeSc6J1xcXFx1MDQ0NCcsJ0ZjeSc6J1xcXFx1MDQyNCcsJ2ZlbWFsZSc6J1xcXFx1MjY0MCcsJ2ZmaWxpZyc6J1xcXFx1RkIwMycsJ2ZmbGlnJzonXFxcXHVGQjAwJywnZmZsbGlnJzonXFxcXHVGQjA0JywnZmZyJzonXFxcXHVEODM1XFxcXHVERDIzJywnRmZyJzonXFxcXHVEODM1XFxcXHVERDA5JywnZmlsaWcnOidcXFxcdUZCMDEnLCdGaWxsZWRTbWFsbFNxdWFyZSc6J1xcXFx1MjVGQycsJ0ZpbGxlZFZlcnlTbWFsbFNxdWFyZSc6J1xcXFx1MjVBQScsJ2ZqbGlnJzonZmonLCdmbGF0JzonXFxcXHUyNjZEJywnZmxsaWcnOidcXFxcdUZCMDInLCdmbHRucyc6J1xcXFx1MjVCMScsJ2Zub2YnOidcXFxcdTAxOTInLCdmb3BmJzonXFxcXHVEODM1XFxcXHVERDU3JywnRm9wZic6J1xcXFx1RDgzNVxcXFx1REQzRCcsJ2ZvcmFsbCc6J1xcXFx1MjIwMCcsJ0ZvckFsbCc6J1xcXFx1MjIwMCcsJ2ZvcmsnOidcXFxcdTIyRDQnLCdmb3Jrdic6J1xcXFx1MkFEOScsJ0ZvdXJpZXJ0cmYnOidcXFxcdTIxMzEnLCdmcGFydGludCc6J1xcXFx1MkEwRCcsJ2ZyYWMxMic6J1xcXFx4QkQnLCdmcmFjMTMnOidcXFxcdTIxNTMnLCdmcmFjMTQnOidcXFxceEJDJywnZnJhYzE1JzonXFxcXHUyMTU1JywnZnJhYzE2JzonXFxcXHUyMTU5JywnZnJhYzE4JzonXFxcXHUyMTVCJywnZnJhYzIzJzonXFxcXHUyMTU0JywnZnJhYzI1JzonXFxcXHUyMTU2JywnZnJhYzM0JzonXFxcXHhCRScsJ2ZyYWMzNSc6J1xcXFx1MjE1NycsJ2ZyYWMzOCc6J1xcXFx1MjE1QycsJ2ZyYWM0NSc6J1xcXFx1MjE1OCcsJ2ZyYWM1Nic6J1xcXFx1MjE1QScsJ2ZyYWM1OCc6J1xcXFx1MjE1RCcsJ2ZyYWM3OCc6J1xcXFx1MjE1RScsJ2ZyYXNsJzonXFxcXHUyMDQ0JywnZnJvd24nOidcXFxcdTIzMjInLCdmc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JCJywnRnNjcic6J1xcXFx1MjEzMScsJ2dhY3V0ZSc6J1xcXFx1MDFGNScsJ2dhbW1hJzonXFxcXHUwM0IzJywnR2FtbWEnOidcXFxcdTAzOTMnLCdnYW1tYWQnOidcXFxcdTAzREQnLCdHYW1tYWQnOidcXFxcdTAzREMnLCdnYXAnOidcXFxcdTJBODYnLCdnYnJldmUnOidcXFxcdTAxMUYnLCdHYnJldmUnOidcXFxcdTAxMUUnLCdHY2VkaWwnOidcXFxcdTAxMjInLCdnY2lyYyc6J1xcXFx1MDExRCcsJ0djaXJjJzonXFxcXHUwMTFDJywnZ2N5JzonXFxcXHUwNDMzJywnR2N5JzonXFxcXHUwNDEzJywnZ2RvdCc6J1xcXFx1MDEyMScsJ0dkb3QnOidcXFxcdTAxMjAnLCdnZSc6J1xcXFx1MjI2NScsJ2dFJzonXFxcXHUyMjY3JywnZ2VsJzonXFxcXHUyMkRCJywnZ0VsJzonXFxcXHUyQThDJywnZ2VxJzonXFxcXHUyMjY1JywnZ2VxcSc6J1xcXFx1MjI2NycsJ2dlcXNsYW50JzonXFxcXHUyQTdFJywnZ2VzJzonXFxcXHUyQTdFJywnZ2VzY2MnOidcXFxcdTJBQTknLCdnZXNkb3QnOidcXFxcdTJBODAnLCdnZXNkb3RvJzonXFxcXHUyQTgyJywnZ2VzZG90b2wnOidcXFxcdTJBODQnLCdnZXNsJzonXFxcXHUyMkRCXFxcXHVGRTAwJywnZ2VzbGVzJzonXFxcXHUyQTk0JywnZ2ZyJzonXFxcXHVEODM1XFxcXHVERDI0JywnR2ZyJzonXFxcXHVEODM1XFxcXHVERDBBJywnZ2cnOidcXFxcdTIyNkInLCdHZyc6J1xcXFx1MjJEOScsJ2dnZyc6J1xcXFx1MjJEOScsJ2dpbWVsJzonXFxcXHUyMTM3JywnZ2pjeSc6J1xcXFx1MDQ1MycsJ0dKY3knOidcXFxcdTA0MDMnLCdnbCc6J1xcXFx1MjI3NycsJ2dsYSc6J1xcXFx1MkFBNScsJ2dsRSc6J1xcXFx1MkE5MicsJ2dsaic6J1xcXFx1MkFBNCcsJ2duYXAnOidcXFxcdTJBOEEnLCdnbmFwcHJveCc6J1xcXFx1MkE4QScsJ2duZSc6J1xcXFx1MkE4OCcsJ2duRSc6J1xcXFx1MjI2OScsJ2duZXEnOidcXFxcdTJBODgnLCdnbmVxcSc6J1xcXFx1MjI2OScsJ2duc2ltJzonXFxcXHUyMkU3JywnZ29wZic6J1xcXFx1RDgzNVxcXFx1REQ1OCcsJ0dvcGYnOidcXFxcdUQ4MzVcXFxcdUREM0UnLCdncmF2ZSc6J2AnLCdHcmVhdGVyRXF1YWwnOidcXFxcdTIyNjUnLCdHcmVhdGVyRXF1YWxMZXNzJzonXFxcXHUyMkRCJywnR3JlYXRlckZ1bGxFcXVhbCc6J1xcXFx1MjI2NycsJ0dyZWF0ZXJHcmVhdGVyJzonXFxcXHUyQUEyJywnR3JlYXRlckxlc3MnOidcXFxcdTIyNzcnLCdHcmVhdGVyU2xhbnRFcXVhbCc6J1xcXFx1MkE3RScsJ0dyZWF0ZXJUaWxkZSc6J1xcXFx1MjI3MycsJ2dzY3InOidcXFxcdTIxMEEnLCdHc2NyJzonXFxcXHVEODM1XFxcXHVEQ0EyJywnZ3NpbSc6J1xcXFx1MjI3MycsJ2dzaW1lJzonXFxcXHUyQThFJywnZ3NpbWwnOidcXFxcdTJBOTAnLCdndCc6Jz4nLCdHdCc6J1xcXFx1MjI2QicsJ0dUJzonPicsJ2d0Y2MnOidcXFxcdTJBQTcnLCdndGNpcic6J1xcXFx1MkE3QScsJ2d0ZG90JzonXFxcXHUyMkQ3JywnZ3RsUGFyJzonXFxcXHUyOTk1JywnZ3RxdWVzdCc6J1xcXFx1MkE3QycsJ2d0cmFwcHJveCc6J1xcXFx1MkE4NicsJ2d0cmFycic6J1xcXFx1Mjk3OCcsJ2d0cmRvdCc6J1xcXFx1MjJENycsJ2d0cmVxbGVzcyc6J1xcXFx1MjJEQicsJ2d0cmVxcWxlc3MnOidcXFxcdTJBOEMnLCdndHJsZXNzJzonXFxcXHUyMjc3JywnZ3Ryc2ltJzonXFxcXHUyMjczJywnZ3ZlcnRuZXFxJzonXFxcXHUyMjY5XFxcXHVGRTAwJywnZ3ZuRSc6J1xcXFx1MjI2OVxcXFx1RkUwMCcsJ0hhY2VrJzonXFxcXHUwMkM3JywnaGFpcnNwJzonXFxcXHUyMDBBJywnaGFsZic6J1xcXFx4QkQnLCdoYW1pbHQnOidcXFxcdTIxMEInLCdoYXJkY3knOidcXFxcdTA0NEEnLCdIQVJEY3knOidcXFxcdTA0MkEnLCdoYXJyJzonXFxcXHUyMTk0JywnaEFycic6J1xcXFx1MjFENCcsJ2hhcnJjaXInOidcXFxcdTI5NDgnLCdoYXJydyc6J1xcXFx1MjFBRCcsJ0hhdCc6J14nLCdoYmFyJzonXFxcXHUyMTBGJywnaGNpcmMnOidcXFxcdTAxMjUnLCdIY2lyYyc6J1xcXFx1MDEyNCcsJ2hlYXJ0cyc6J1xcXFx1MjY2NScsJ2hlYXJ0c3VpdCc6J1xcXFx1MjY2NScsJ2hlbGxpcCc6J1xcXFx1MjAyNicsJ2hlcmNvbic6J1xcXFx1MjJCOScsJ2hmcic6J1xcXFx1RDgzNVxcXFx1REQyNScsJ0hmcic6J1xcXFx1MjEwQycsJ0hpbGJlcnRTcGFjZSc6J1xcXFx1MjEwQicsJ2hrc2Vhcm93JzonXFxcXHUyOTI1JywnaGtzd2Fyb3cnOidcXFxcdTI5MjYnLCdob2Fycic6J1xcXFx1MjFGRicsJ2hvbXRodCc6J1xcXFx1MjIzQicsJ2hvb2tsZWZ0YXJyb3cnOidcXFxcdTIxQTknLCdob29rcmlnaHRhcnJvdyc6J1xcXFx1MjFBQScsJ2hvcGYnOidcXFxcdUQ4MzVcXFxcdURENTknLCdIb3BmJzonXFxcXHUyMTBEJywnaG9yYmFyJzonXFxcXHUyMDE1JywnSG9yaXpvbnRhbExpbmUnOidcXFxcdTI1MDAnLCdoc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JEJywnSHNjcic6J1xcXFx1MjEwQicsJ2hzbGFzaCc6J1xcXFx1MjEwRicsJ2hzdHJvayc6J1xcXFx1MDEyNycsJ0hzdHJvayc6J1xcXFx1MDEyNicsJ0h1bXBEb3duSHVtcCc6J1xcXFx1MjI0RScsJ0h1bXBFcXVhbCc6J1xcXFx1MjI0RicsJ2h5YnVsbCc6J1xcXFx1MjA0MycsJ2h5cGhlbic6J1xcXFx1MjAxMCcsJ2lhY3V0ZSc6J1xcXFx4RUQnLCdJYWN1dGUnOidcXFxceENEJywnaWMnOidcXFxcdTIwNjMnLCdpY2lyYyc6J1xcXFx4RUUnLCdJY2lyYyc6J1xcXFx4Q0UnLCdpY3knOidcXFxcdTA0MzgnLCdJY3knOidcXFxcdTA0MTgnLCdJZG90JzonXFxcXHUwMTMwJywnaWVjeSc6J1xcXFx1MDQzNScsJ0lFY3knOidcXFxcdTA0MTUnLCdpZXhjbCc6J1xcXFx4QTEnLCdpZmYnOidcXFxcdTIxRDQnLCdpZnInOidcXFxcdUQ4MzVcXFxcdUREMjYnLCdJZnInOidcXFxcdTIxMTEnLCdpZ3JhdmUnOidcXFxceEVDJywnSWdyYXZlJzonXFxcXHhDQycsJ2lpJzonXFxcXHUyMTQ4JywnaWlpaW50JzonXFxcXHUyQTBDJywnaWlpbnQnOidcXFxcdTIyMkQnLCdpaW5maW4nOidcXFxcdTI5REMnLCdpaW90YSc6J1xcXFx1MjEyOScsJ2lqbGlnJzonXFxcXHUwMTMzJywnSUpsaWcnOidcXFxcdTAxMzInLCdJbSc6J1xcXFx1MjExMScsJ2ltYWNyJzonXFxcXHUwMTJCJywnSW1hY3InOidcXFxcdTAxMkEnLCdpbWFnZSc6J1xcXFx1MjExMScsJ0ltYWdpbmFyeUknOidcXFxcdTIxNDgnLCdpbWFnbGluZSc6J1xcXFx1MjExMCcsJ2ltYWdwYXJ0JzonXFxcXHUyMTExJywnaW1hdGgnOidcXFxcdTAxMzEnLCdpbW9mJzonXFxcXHUyMkI3JywnaW1wZWQnOidcXFxcdTAxQjUnLCdJbXBsaWVzJzonXFxcXHUyMUQyJywnaW4nOidcXFxcdTIyMDgnLCdpbmNhcmUnOidcXFxcdTIxMDUnLCdpbmZpbic6J1xcXFx1MjIxRScsJ2luZmludGllJzonXFxcXHUyOUREJywnaW5vZG90JzonXFxcXHUwMTMxJywnaW50JzonXFxcXHUyMjJCJywnSW50JzonXFxcXHUyMjJDJywnaW50Y2FsJzonXFxcXHUyMkJBJywnaW50ZWdlcnMnOidcXFxcdTIxMjQnLCdJbnRlZ3JhbCc6J1xcXFx1MjIyQicsJ2ludGVyY2FsJzonXFxcXHUyMkJBJywnSW50ZXJzZWN0aW9uJzonXFxcXHUyMkMyJywnaW50bGFyaGsnOidcXFxcdTJBMTcnLCdpbnRwcm9kJzonXFxcXHUyQTNDJywnSW52aXNpYmxlQ29tbWEnOidcXFxcdTIwNjMnLCdJbnZpc2libGVUaW1lcyc6J1xcXFx1MjA2MicsJ2lvY3knOidcXFxcdTA0NTEnLCdJT2N5JzonXFxcXHUwNDAxJywnaW9nb24nOidcXFxcdTAxMkYnLCdJb2dvbic6J1xcXFx1MDEyRScsJ2lvcGYnOidcXFxcdUQ4MzVcXFxcdURENUEnLCdJb3BmJzonXFxcXHVEODM1XFxcXHVERDQwJywnaW90YSc6J1xcXFx1MDNCOScsJ0lvdGEnOidcXFxcdTAzOTknLCdpcHJvZCc6J1xcXFx1MkEzQycsJ2lxdWVzdCc6J1xcXFx4QkYnLCdpc2NyJzonXFxcXHVEODM1XFxcXHVEQ0JFJywnSXNjcic6J1xcXFx1MjExMCcsJ2lzaW4nOidcXFxcdTIyMDgnLCdpc2luZG90JzonXFxcXHUyMkY1JywnaXNpbkUnOidcXFxcdTIyRjknLCdpc2lucyc6J1xcXFx1MjJGNCcsJ2lzaW5zdic6J1xcXFx1MjJGMycsJ2lzaW52JzonXFxcXHUyMjA4JywnaXQnOidcXFxcdTIwNjInLCdpdGlsZGUnOidcXFxcdTAxMjknLCdJdGlsZGUnOidcXFxcdTAxMjgnLCdpdWtjeSc6J1xcXFx1MDQ1NicsJ0l1a2N5JzonXFxcXHUwNDA2JywnaXVtbCc6J1xcXFx4RUYnLCdJdW1sJzonXFxcXHhDRicsJ2pjaXJjJzonXFxcXHUwMTM1JywnSmNpcmMnOidcXFxcdTAxMzQnLCdqY3knOidcXFxcdTA0MzknLCdKY3knOidcXFxcdTA0MTknLCdqZnInOidcXFxcdUQ4MzVcXFxcdUREMjcnLCdKZnInOidcXFxcdUQ4MzVcXFxcdUREMEQnLCdqbWF0aCc6J1xcXFx1MDIzNycsJ2pvcGYnOidcXFxcdUQ4MzVcXFxcdURENUInLCdKb3BmJzonXFxcXHVEODM1XFxcXHVERDQxJywnanNjcic6J1xcXFx1RDgzNVxcXFx1RENCRicsJ0pzY3InOidcXFxcdUQ4MzVcXFxcdURDQTUnLCdqc2VyY3knOidcXFxcdTA0NTgnLCdKc2VyY3knOidcXFxcdTA0MDgnLCdqdWtjeSc6J1xcXFx1MDQ1NCcsJ0p1a2N5JzonXFxcXHUwNDA0Jywna2FwcGEnOidcXFxcdTAzQkEnLCdLYXBwYSc6J1xcXFx1MDM5QScsJ2thcHBhdic6J1xcXFx1MDNGMCcsJ2tjZWRpbCc6J1xcXFx1MDEzNycsJ0tjZWRpbCc6J1xcXFx1MDEzNicsJ2tjeSc6J1xcXFx1MDQzQScsJ0tjeSc6J1xcXFx1MDQxQScsJ2tmcic6J1xcXFx1RDgzNVxcXFx1REQyOCcsJ0tmcic6J1xcXFx1RDgzNVxcXFx1REQwRScsJ2tncmVlbic6J1xcXFx1MDEzOCcsJ2toY3knOidcXFxcdTA0NDUnLCdLSGN5JzonXFxcXHUwNDI1Jywna2pjeSc6J1xcXFx1MDQ1QycsJ0tKY3knOidcXFxcdTA0MEMnLCdrb3BmJzonXFxcXHVEODM1XFxcXHVERDVDJywnS29wZic6J1xcXFx1RDgzNVxcXFx1REQ0MicsJ2tzY3InOidcXFxcdUQ4MzVcXFxcdURDQzAnLCdLc2NyJzonXFxcXHVEODM1XFxcXHVEQ0E2JywnbEFhcnInOidcXFxcdTIxREEnLCdsYWN1dGUnOidcXFxcdTAxM0EnLCdMYWN1dGUnOidcXFxcdTAxMzknLCdsYWVtcHR5dic6J1xcXFx1MjlCNCcsJ2xhZ3Jhbic6J1xcXFx1MjExMicsJ2xhbWJkYSc6J1xcXFx1MDNCQicsJ0xhbWJkYSc6J1xcXFx1MDM5QicsJ2xhbmcnOidcXFxcdTI3RTgnLCdMYW5nJzonXFxcXHUyN0VBJywnbGFuZ2QnOidcXFxcdTI5OTEnLCdsYW5nbGUnOidcXFxcdTI3RTgnLCdsYXAnOidcXFxcdTJBODUnLCdMYXBsYWNldHJmJzonXFxcXHUyMTEyJywnbGFxdW8nOidcXFxceEFCJywnbGFycic6J1xcXFx1MjE5MCcsJ2xBcnInOidcXFxcdTIxRDAnLCdMYXJyJzonXFxcXHUyMTlFJywnbGFycmInOidcXFxcdTIxRTQnLCdsYXJyYmZzJzonXFxcXHUyOTFGJywnbGFycmZzJzonXFxcXHUyOTFEJywnbGFycmhrJzonXFxcXHUyMUE5JywnbGFycmxwJzonXFxcXHUyMUFCJywnbGFycnBsJzonXFxcXHUyOTM5JywnbGFycnNpbSc6J1xcXFx1Mjk3MycsJ2xhcnJ0bCc6J1xcXFx1MjFBMicsJ2xhdCc6J1xcXFx1MkFBQicsJ2xhdGFpbCc6J1xcXFx1MjkxOScsJ2xBdGFpbCc6J1xcXFx1MjkxQicsJ2xhdGUnOidcXFxcdTJBQUQnLCdsYXRlcyc6J1xcXFx1MkFBRFxcXFx1RkUwMCcsJ2xiYXJyJzonXFxcXHUyOTBDJywnbEJhcnInOidcXFxcdTI5MEUnLCdsYmJyayc6J1xcXFx1Mjc3MicsJ2xicmFjZSc6J3snLCdsYnJhY2snOidbJywnbGJya2UnOidcXFxcdTI5OEInLCdsYnJrc2xkJzonXFxcXHUyOThGJywnbGJya3NsdSc6J1xcXFx1Mjk4RCcsJ2xjYXJvbic6J1xcXFx1MDEzRScsJ0xjYXJvbic6J1xcXFx1MDEzRCcsJ2xjZWRpbCc6J1xcXFx1MDEzQycsJ0xjZWRpbCc6J1xcXFx1MDEzQicsJ2xjZWlsJzonXFxcXHUyMzA4JywnbGN1Yic6J3snLCdsY3knOidcXFxcdTA0M0InLCdMY3knOidcXFxcdTA0MUInLCdsZGNhJzonXFxcXHUyOTM2JywnbGRxdW8nOidcXFxcdTIwMUMnLCdsZHF1b3InOidcXFxcdTIwMUUnLCdsZHJkaGFyJzonXFxcXHUyOTY3JywnbGRydXNoYXInOidcXFxcdTI5NEInLCdsZHNoJzonXFxcXHUyMUIyJywnbGUnOidcXFxcdTIyNjQnLCdsRSc6J1xcXFx1MjI2NicsJ0xlZnRBbmdsZUJyYWNrZXQnOidcXFxcdTI3RTgnLCdsZWZ0YXJyb3cnOidcXFxcdTIxOTAnLCdMZWZ0YXJyb3cnOidcXFxcdTIxRDAnLCdMZWZ0QXJyb3cnOidcXFxcdTIxOTAnLCdMZWZ0QXJyb3dCYXInOidcXFxcdTIxRTQnLCdMZWZ0QXJyb3dSaWdodEFycm93JzonXFxcXHUyMUM2JywnbGVmdGFycm93dGFpbCc6J1xcXFx1MjFBMicsJ0xlZnRDZWlsaW5nJzonXFxcXHUyMzA4JywnTGVmdERvdWJsZUJyYWNrZXQnOidcXFxcdTI3RTYnLCdMZWZ0RG93blRlZVZlY3Rvcic6J1xcXFx1Mjk2MScsJ0xlZnREb3duVmVjdG9yJzonXFxcXHUyMUMzJywnTGVmdERvd25WZWN0b3JCYXInOidcXFxcdTI5NTknLCdMZWZ0Rmxvb3InOidcXFxcdTIzMEEnLCdsZWZ0aGFycG9vbmRvd24nOidcXFxcdTIxQkQnLCdsZWZ0aGFycG9vbnVwJzonXFxcXHUyMUJDJywnbGVmdGxlZnRhcnJvd3MnOidcXFxcdTIxQzcnLCdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjE5NCcsJ0xlZnRyaWdodGFycm93JzonXFxcXHUyMUQ0JywnTGVmdFJpZ2h0QXJyb3cnOidcXFxcdTIxOTQnLCdsZWZ0cmlnaHRhcnJvd3MnOidcXFxcdTIxQzYnLCdsZWZ0cmlnaHRoYXJwb29ucyc6J1xcXFx1MjFDQicsJ2xlZnRyaWdodHNxdWlnYXJyb3cnOidcXFxcdTIxQUQnLCdMZWZ0UmlnaHRWZWN0b3InOidcXFxcdTI5NEUnLCdMZWZ0VGVlJzonXFxcXHUyMkEzJywnTGVmdFRlZUFycm93JzonXFxcXHUyMUE0JywnTGVmdFRlZVZlY3Rvcic6J1xcXFx1Mjk1QScsJ2xlZnR0aHJlZXRpbWVzJzonXFxcXHUyMkNCJywnTGVmdFRyaWFuZ2xlJzonXFxcXHUyMkIyJywnTGVmdFRyaWFuZ2xlQmFyJzonXFxcXHUyOUNGJywnTGVmdFRyaWFuZ2xlRXF1YWwnOidcXFxcdTIyQjQnLCdMZWZ0VXBEb3duVmVjdG9yJzonXFxcXHUyOTUxJywnTGVmdFVwVGVlVmVjdG9yJzonXFxcXHUyOTYwJywnTGVmdFVwVmVjdG9yJzonXFxcXHUyMUJGJywnTGVmdFVwVmVjdG9yQmFyJzonXFxcXHUyOTU4JywnTGVmdFZlY3Rvcic6J1xcXFx1MjFCQycsJ0xlZnRWZWN0b3JCYXInOidcXFxcdTI5NTInLCdsZWcnOidcXFxcdTIyREEnLCdsRWcnOidcXFxcdTJBOEInLCdsZXEnOidcXFxcdTIyNjQnLCdsZXFxJzonXFxcXHUyMjY2JywnbGVxc2xhbnQnOidcXFxcdTJBN0QnLCdsZXMnOidcXFxcdTJBN0QnLCdsZXNjYyc6J1xcXFx1MkFBOCcsJ2xlc2RvdCc6J1xcXFx1MkE3RicsJ2xlc2RvdG8nOidcXFxcdTJBODEnLCdsZXNkb3Rvcic6J1xcXFx1MkE4MycsJ2xlc2cnOidcXFxcdTIyREFcXFxcdUZFMDAnLCdsZXNnZXMnOidcXFxcdTJBOTMnLCdsZXNzYXBwcm94JzonXFxcXHUyQTg1JywnbGVzc2RvdCc6J1xcXFx1MjJENicsJ2xlc3NlcWd0cic6J1xcXFx1MjJEQScsJ2xlc3NlcXFndHInOidcXFxcdTJBOEInLCdMZXNzRXF1YWxHcmVhdGVyJzonXFxcXHUyMkRBJywnTGVzc0Z1bGxFcXVhbCc6J1xcXFx1MjI2NicsJ0xlc3NHcmVhdGVyJzonXFxcXHUyMjc2JywnbGVzc2d0cic6J1xcXFx1MjI3NicsJ0xlc3NMZXNzJzonXFxcXHUyQUExJywnbGVzc3NpbSc6J1xcXFx1MjI3MicsJ0xlc3NTbGFudEVxdWFsJzonXFxcXHUyQTdEJywnTGVzc1RpbGRlJzonXFxcXHUyMjcyJywnbGZpc2h0JzonXFxcXHUyOTdDJywnbGZsb29yJzonXFxcXHUyMzBBJywnbGZyJzonXFxcXHVEODM1XFxcXHVERDI5JywnTGZyJzonXFxcXHVEODM1XFxcXHVERDBGJywnbGcnOidcXFxcdTIyNzYnLCdsZ0UnOidcXFxcdTJBOTEnLCdsSGFyJzonXFxcXHUyOTYyJywnbGhhcmQnOidcXFxcdTIxQkQnLCdsaGFydSc6J1xcXFx1MjFCQycsJ2xoYXJ1bCc6J1xcXFx1Mjk2QScsJ2xoYmxrJzonXFxcXHUyNTg0JywnbGpjeSc6J1xcXFx1MDQ1OScsJ0xKY3knOidcXFxcdTA0MDknLCdsbCc6J1xcXFx1MjI2QScsJ0xsJzonXFxcXHUyMkQ4JywnbGxhcnInOidcXFxcdTIxQzcnLCdsbGNvcm5lcic6J1xcXFx1MjMxRScsJ0xsZWZ0YXJyb3cnOidcXFxcdTIxREEnLCdsbGhhcmQnOidcXFxcdTI5NkInLCdsbHRyaSc6J1xcXFx1MjVGQScsJ2xtaWRvdCc6J1xcXFx1MDE0MCcsJ0xtaWRvdCc6J1xcXFx1MDEzRicsJ2xtb3VzdCc6J1xcXFx1MjNCMCcsJ2xtb3VzdGFjaGUnOidcXFxcdTIzQjAnLCdsbmFwJzonXFxcXHUyQTg5JywnbG5hcHByb3gnOidcXFxcdTJBODknLCdsbmUnOidcXFxcdTJBODcnLCdsbkUnOidcXFxcdTIyNjgnLCdsbmVxJzonXFxcXHUyQTg3JywnbG5lcXEnOidcXFxcdTIyNjgnLCdsbnNpbSc6J1xcXFx1MjJFNicsJ2xvYW5nJzonXFxcXHUyN0VDJywnbG9hcnInOidcXFxcdTIxRkQnLCdsb2Jyayc6J1xcXFx1MjdFNicsJ2xvbmdsZWZ0YXJyb3cnOidcXFxcdTI3RjUnLCdMb25nbGVmdGFycm93JzonXFxcXHUyN0Y4JywnTG9uZ0xlZnRBcnJvdyc6J1xcXFx1MjdGNScsJ2xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjdGNycsJ0xvbmdsZWZ0cmlnaHRhcnJvdyc6J1xcXFx1MjdGQScsJ0xvbmdMZWZ0UmlnaHRBcnJvdyc6J1xcXFx1MjdGNycsJ2xvbmdtYXBzdG8nOidcXFxcdTI3RkMnLCdsb25ncmlnaHRhcnJvdyc6J1xcXFx1MjdGNicsJ0xvbmdyaWdodGFycm93JzonXFxcXHUyN0Y5JywnTG9uZ1JpZ2h0QXJyb3cnOidcXFxcdTI3RjYnLCdsb29wYXJyb3dsZWZ0JzonXFxcXHUyMUFCJywnbG9vcGFycm93cmlnaHQnOidcXFxcdTIxQUMnLCdsb3Bhcic6J1xcXFx1Mjk4NScsJ2xvcGYnOidcXFxcdUQ4MzVcXFxcdURENUQnLCdMb3BmJzonXFxcXHVEODM1XFxcXHVERDQzJywnbG9wbHVzJzonXFxcXHUyQTJEJywnbG90aW1lcyc6J1xcXFx1MkEzNCcsJ2xvd2FzdCc6J1xcXFx1MjIxNycsJ2xvd2Jhcic6J18nLCdMb3dlckxlZnRBcnJvdyc6J1xcXFx1MjE5OScsJ0xvd2VyUmlnaHRBcnJvdyc6J1xcXFx1MjE5OCcsJ2xveic6J1xcXFx1MjVDQScsJ2xvemVuZ2UnOidcXFxcdTI1Q0EnLCdsb3pmJzonXFxcXHUyOUVCJywnbHBhcic6JygnLCdscGFybHQnOidcXFxcdTI5OTMnLCdscmFycic6J1xcXFx1MjFDNicsJ2xyY29ybmVyJzonXFxcXHUyMzFGJywnbHJoYXInOidcXFxcdTIxQ0InLCdscmhhcmQnOidcXFxcdTI5NkQnLCdscm0nOidcXFxcdTIwMEUnLCdscnRyaSc6J1xcXFx1MjJCRicsJ2xzYXF1byc6J1xcXFx1MjAzOScsJ2xzY3InOidcXFxcdUQ4MzVcXFxcdURDQzEnLCdMc2NyJzonXFxcXHUyMTEyJywnbHNoJzonXFxcXHUyMUIwJywnTHNoJzonXFxcXHUyMUIwJywnbHNpbSc6J1xcXFx1MjI3MicsJ2xzaW1lJzonXFxcXHUyQThEJywnbHNpbWcnOidcXFxcdTJBOEYnLCdsc3FiJzonWycsJ2xzcXVvJzonXFxcXHUyMDE4JywnbHNxdW9yJzonXFxcXHUyMDFBJywnbHN0cm9rJzonXFxcXHUwMTQyJywnTHN0cm9rJzonXFxcXHUwMTQxJywnbHQnOic8JywnTHQnOidcXFxcdTIyNkEnLCdMVCc6JzwnLCdsdGNjJzonXFxcXHUyQUE2JywnbHRjaXInOidcXFxcdTJBNzknLCdsdGRvdCc6J1xcXFx1MjJENicsJ2x0aHJlZSc6J1xcXFx1MjJDQicsJ2x0aW1lcyc6J1xcXFx1MjJDOScsJ2x0bGFycic6J1xcXFx1Mjk3NicsJ2x0cXVlc3QnOidcXFxcdTJBN0InLCdsdHJpJzonXFxcXHUyNUMzJywnbHRyaWUnOidcXFxcdTIyQjQnLCdsdHJpZic6J1xcXFx1MjVDMicsJ2x0clBhcic6J1xcXFx1Mjk5NicsJ2x1cmRzaGFyJzonXFxcXHUyOTRBJywnbHVydWhhcic6J1xcXFx1Mjk2NicsJ2x2ZXJ0bmVxcSc6J1xcXFx1MjI2OFxcXFx1RkUwMCcsJ2x2bkUnOidcXFxcdTIyNjhcXFxcdUZFMDAnLCdtYWNyJzonXFxcXHhBRicsJ21hbGUnOidcXFxcdTI2NDInLCdtYWx0JzonXFxcXHUyNzIwJywnbWFsdGVzZSc6J1xcXFx1MjcyMCcsJ21hcCc6J1xcXFx1MjFBNicsJ01hcCc6J1xcXFx1MjkwNScsJ21hcHN0byc6J1xcXFx1MjFBNicsJ21hcHN0b2Rvd24nOidcXFxcdTIxQTcnLCdtYXBzdG9sZWZ0JzonXFxcXHUyMUE0JywnbWFwc3RvdXAnOidcXFxcdTIxQTUnLCdtYXJrZXInOidcXFxcdTI1QUUnLCdtY29tbWEnOidcXFxcdTJBMjknLCdtY3knOidcXFxcdTA0M0MnLCdNY3knOidcXFxcdTA0MUMnLCdtZGFzaCc6J1xcXFx1MjAxNCcsJ21ERG90JzonXFxcXHUyMjNBJywnbWVhc3VyZWRhbmdsZSc6J1xcXFx1MjIyMScsJ01lZGl1bVNwYWNlJzonXFxcXHUyMDVGJywnTWVsbGludHJmJzonXFxcXHUyMTMzJywnbWZyJzonXFxcXHVEODM1XFxcXHVERDJBJywnTWZyJzonXFxcXHVEODM1XFxcXHVERDEwJywnbWhvJzonXFxcXHUyMTI3JywnbWljcm8nOidcXFxceEI1JywnbWlkJzonXFxcXHUyMjIzJywnbWlkYXN0JzonKicsJ21pZGNpcic6J1xcXFx1MkFGMCcsJ21pZGRvdCc6J1xcXFx4QjcnLCdtaW51cyc6J1xcXFx1MjIxMicsJ21pbnVzYic6J1xcXFx1MjI5RicsJ21pbnVzZCc6J1xcXFx1MjIzOCcsJ21pbnVzZHUnOidcXFxcdTJBMkEnLCdNaW51c1BsdXMnOidcXFxcdTIyMTMnLCdtbGNwJzonXFxcXHUyQURCJywnbWxkcic6J1xcXFx1MjAyNicsJ21ucGx1cyc6J1xcXFx1MjIxMycsJ21vZGVscyc6J1xcXFx1MjJBNycsJ21vcGYnOidcXFxcdUQ4MzVcXFxcdURENUUnLCdNb3BmJzonXFxcXHVEODM1XFxcXHVERDQ0JywnbXAnOidcXFxcdTIyMTMnLCdtc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MyJywnTXNjcic6J1xcXFx1MjEzMycsJ21zdHBvcyc6J1xcXFx1MjIzRScsJ211JzonXFxcXHUwM0JDJywnTXUnOidcXFxcdTAzOUMnLCdtdWx0aW1hcCc6J1xcXFx1MjJCOCcsJ211bWFwJzonXFxcXHUyMkI4JywnbmFibGEnOidcXFxcdTIyMDcnLCduYWN1dGUnOidcXFxcdTAxNDQnLCdOYWN1dGUnOidcXFxcdTAxNDMnLCduYW5nJzonXFxcXHUyMjIwXFxcXHUyMEQyJywnbmFwJzonXFxcXHUyMjQ5JywnbmFwRSc6J1xcXFx1MkE3MFxcXFx1MDMzOCcsJ25hcGlkJzonXFxcXHUyMjRCXFxcXHUwMzM4JywnbmFwb3MnOidcXFxcdTAxNDknLCduYXBwcm94JzonXFxcXHUyMjQ5JywnbmF0dXInOidcXFxcdTI2NkUnLCduYXR1cmFsJzonXFxcXHUyNjZFJywnbmF0dXJhbHMnOidcXFxcdTIxMTUnLCduYnNwJzonXFxcXHhBMCcsJ25idW1wJzonXFxcXHUyMjRFXFxcXHUwMzM4JywnbmJ1bXBlJzonXFxcXHUyMjRGXFxcXHUwMzM4JywnbmNhcCc6J1xcXFx1MkE0MycsJ25jYXJvbic6J1xcXFx1MDE0OCcsJ05jYXJvbic6J1xcXFx1MDE0NycsJ25jZWRpbCc6J1xcXFx1MDE0NicsJ05jZWRpbCc6J1xcXFx1MDE0NScsJ25jb25nJzonXFxcXHUyMjQ3JywnbmNvbmdkb3QnOidcXFxcdTJBNkRcXFxcdTAzMzgnLCduY3VwJzonXFxcXHUyQTQyJywnbmN5JzonXFxcXHUwNDNEJywnTmN5JzonXFxcXHUwNDFEJywnbmRhc2gnOidcXFxcdTIwMTMnLCduZSc6J1xcXFx1MjI2MCcsJ25lYXJoayc6J1xcXFx1MjkyNCcsJ25lYXJyJzonXFxcXHUyMTk3JywnbmVBcnInOidcXFxcdTIxRDcnLCduZWFycm93JzonXFxcXHUyMTk3JywnbmVkb3QnOidcXFxcdTIyNTBcXFxcdTAzMzgnLCdOZWdhdGl2ZU1lZGl1bVNwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVUaGlja1NwYWNlJzonXFxcXHUyMDBCJywnTmVnYXRpdmVUaGluU3BhY2UnOidcXFxcdTIwMEInLCdOZWdhdGl2ZVZlcnlUaGluU3BhY2UnOidcXFxcdTIwMEInLCduZXF1aXYnOidcXFxcdTIyNjInLCduZXNlYXInOidcXFxcdTI5MjgnLCduZXNpbSc6J1xcXFx1MjI0MlxcXFx1MDMzOCcsJ05lc3RlZEdyZWF0ZXJHcmVhdGVyJzonXFxcXHUyMjZCJywnTmVzdGVkTGVzc0xlc3MnOidcXFxcdTIyNkEnLCdOZXdMaW5lJzonXFxcXG4nLCduZXhpc3QnOidcXFxcdTIyMDQnLCduZXhpc3RzJzonXFxcXHUyMjA0JywnbmZyJzonXFxcXHVEODM1XFxcXHVERDJCJywnTmZyJzonXFxcXHVEODM1XFxcXHVERDExJywnbmdlJzonXFxcXHUyMjcxJywnbmdFJzonXFxcXHUyMjY3XFxcXHUwMzM4JywnbmdlcSc6J1xcXFx1MjI3MScsJ25nZXFxJzonXFxcXHUyMjY3XFxcXHUwMzM4JywnbmdlcXNsYW50JzonXFxcXHUyQTdFXFxcXHUwMzM4Jywnbmdlcyc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ25HZyc6J1xcXFx1MjJEOVxcXFx1MDMzOCcsJ25nc2ltJzonXFxcXHUyMjc1Jywnbmd0JzonXFxcXHUyMjZGJywnbkd0JzonXFxcXHUyMjZCXFxcXHUyMEQyJywnbmd0cic6J1xcXFx1MjI2RicsJ25HdHYnOidcXFxcdTIyNkJcXFxcdTAzMzgnLCduaGFycic6J1xcXFx1MjFBRScsJ25oQXJyJzonXFxcXHUyMUNFJywnbmhwYXInOidcXFxcdTJBRjInLCduaSc6J1xcXFx1MjIwQicsJ25pcyc6J1xcXFx1MjJGQycsJ25pc2QnOidcXFxcdTIyRkEnLCduaXYnOidcXFxcdTIyMEInLCduamN5JzonXFxcXHUwNDVBJywnTkpjeSc6J1xcXFx1MDQwQScsJ25sYXJyJzonXFxcXHUyMTlBJywnbmxBcnInOidcXFxcdTIxQ0QnLCdubGRyJzonXFxcXHUyMDI1JywnbmxlJzonXFxcXHUyMjcwJywnbmxFJzonXFxcXHUyMjY2XFxcXHUwMzM4JywnbmxlZnRhcnJvdyc6J1xcXFx1MjE5QScsJ25MZWZ0YXJyb3cnOidcXFxcdTIxQ0QnLCdubGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxQUUnLCduTGVmdHJpZ2h0YXJyb3cnOidcXFxcdTIxQ0UnLCdubGVxJzonXFxcXHUyMjcwJywnbmxlcXEnOidcXFxcdTIyNjZcXFxcdTAzMzgnLCdubGVxc2xhbnQnOidcXFxcdTJBN0RcXFxcdTAzMzgnLCdubGVzJzonXFxcXHUyQTdEXFxcXHUwMzM4Jywnbmxlc3MnOidcXFxcdTIyNkUnLCduTGwnOidcXFxcdTIyRDhcXFxcdTAzMzgnLCdubHNpbSc6J1xcXFx1MjI3NCcsJ25sdCc6J1xcXFx1MjI2RScsJ25MdCc6J1xcXFx1MjI2QVxcXFx1MjBEMicsJ25sdHJpJzonXFxcXHUyMkVBJywnbmx0cmllJzonXFxcXHUyMkVDJywnbkx0dic6J1xcXFx1MjI2QVxcXFx1MDMzOCcsJ25taWQnOidcXFxcdTIyMjQnLCdOb0JyZWFrJzonXFxcXHUyMDYwJywnTm9uQnJlYWtpbmdTcGFjZSc6J1xcXFx4QTAnLCdub3BmJzonXFxcXHVEODM1XFxcXHVERDVGJywnTm9wZic6J1xcXFx1MjExNScsJ25vdCc6J1xcXFx4QUMnLCdOb3QnOidcXFxcdTJBRUMnLCdOb3RDb25ncnVlbnQnOidcXFxcdTIyNjInLCdOb3RDdXBDYXAnOidcXFxcdTIyNkQnLCdOb3REb3VibGVWZXJ0aWNhbEJhcic6J1xcXFx1MjIyNicsJ05vdEVsZW1lbnQnOidcXFxcdTIyMDknLCdOb3RFcXVhbCc6J1xcXFx1MjI2MCcsJ05vdEVxdWFsVGlsZGUnOidcXFxcdTIyNDJcXFxcdTAzMzgnLCdOb3RFeGlzdHMnOidcXFxcdTIyMDQnLCdOb3RHcmVhdGVyJzonXFxcXHUyMjZGJywnTm90R3JlYXRlckVxdWFsJzonXFxcXHUyMjcxJywnTm90R3JlYXRlckZ1bGxFcXVhbCc6J1xcXFx1MjI2N1xcXFx1MDMzOCcsJ05vdEdyZWF0ZXJHcmVhdGVyJzonXFxcXHUyMjZCXFxcXHUwMzM4JywnTm90R3JlYXRlckxlc3MnOidcXFxcdTIyNzknLCdOb3RHcmVhdGVyU2xhbnRFcXVhbCc6J1xcXFx1MkE3RVxcXFx1MDMzOCcsJ05vdEdyZWF0ZXJUaWxkZSc6J1xcXFx1MjI3NScsJ05vdEh1bXBEb3duSHVtcCc6J1xcXFx1MjI0RVxcXFx1MDMzOCcsJ05vdEh1bXBFcXVhbCc6J1xcXFx1MjI0RlxcXFx1MDMzOCcsJ25vdGluJzonXFxcXHUyMjA5Jywnbm90aW5kb3QnOidcXFxcdTIyRjVcXFxcdTAzMzgnLCdub3RpbkUnOidcXFxcdTIyRjlcXFxcdTAzMzgnLCdub3RpbnZhJzonXFxcXHUyMjA5Jywnbm90aW52Yic6J1xcXFx1MjJGNycsJ25vdGludmMnOidcXFxcdTIyRjYnLCdOb3RMZWZ0VHJpYW5nbGUnOidcXFxcdTIyRUEnLCdOb3RMZWZ0VHJpYW5nbGVCYXInOidcXFxcdTI5Q0ZcXFxcdTAzMzgnLCdOb3RMZWZ0VHJpYW5nbGVFcXVhbCc6J1xcXFx1MjJFQycsJ05vdExlc3MnOidcXFxcdTIyNkUnLCdOb3RMZXNzRXF1YWwnOidcXFxcdTIyNzAnLCdOb3RMZXNzR3JlYXRlcic6J1xcXFx1MjI3OCcsJ05vdExlc3NMZXNzJzonXFxcXHUyMjZBXFxcXHUwMzM4JywnTm90TGVzc1NsYW50RXF1YWwnOidcXFxcdTJBN0RcXFxcdTAzMzgnLCdOb3RMZXNzVGlsZGUnOidcXFxcdTIyNzQnLCdOb3ROZXN0ZWRHcmVhdGVyR3JlYXRlcic6J1xcXFx1MkFBMlxcXFx1MDMzOCcsJ05vdE5lc3RlZExlc3NMZXNzJzonXFxcXHUyQUExXFxcXHUwMzM4Jywnbm90bmknOidcXFxcdTIyMEMnLCdub3RuaXZhJzonXFxcXHUyMjBDJywnbm90bml2Yic6J1xcXFx1MjJGRScsJ25vdG5pdmMnOidcXFxcdTIyRkQnLCdOb3RQcmVjZWRlcyc6J1xcXFx1MjI4MCcsJ05vdFByZWNlZGVzRXF1YWwnOidcXFxcdTJBQUZcXFxcdTAzMzgnLCdOb3RQcmVjZWRlc1NsYW50RXF1YWwnOidcXFxcdTIyRTAnLCdOb3RSZXZlcnNlRWxlbWVudCc6J1xcXFx1MjIwQycsJ05vdFJpZ2h0VHJpYW5nbGUnOidcXFxcdTIyRUInLCdOb3RSaWdodFRyaWFuZ2xlQmFyJzonXFxcXHUyOUQwXFxcXHUwMzM4JywnTm90UmlnaHRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkVEJywnTm90U3F1YXJlU3Vic2V0JzonXFxcXHUyMjhGXFxcXHUwMzM4JywnTm90U3F1YXJlU3Vic2V0RXF1YWwnOidcXFxcdTIyRTInLCdOb3RTcXVhcmVTdXBlcnNldCc6J1xcXFx1MjI5MFxcXFx1MDMzOCcsJ05vdFNxdWFyZVN1cGVyc2V0RXF1YWwnOidcXFxcdTIyRTMnLCdOb3RTdWJzZXQnOidcXFxcdTIyODJcXFxcdTIwRDInLCdOb3RTdWJzZXRFcXVhbCc6J1xcXFx1MjI4OCcsJ05vdFN1Y2NlZWRzJzonXFxcXHUyMjgxJywnTm90U3VjY2VlZHNFcXVhbCc6J1xcXFx1MkFCMFxcXFx1MDMzOCcsJ05vdFN1Y2NlZWRzU2xhbnRFcXVhbCc6J1xcXFx1MjJFMScsJ05vdFN1Y2NlZWRzVGlsZGUnOidcXFxcdTIyN0ZcXFxcdTAzMzgnLCdOb3RTdXBlcnNldCc6J1xcXFx1MjI4M1xcXFx1MjBEMicsJ05vdFN1cGVyc2V0RXF1YWwnOidcXFxcdTIyODknLCdOb3RUaWxkZSc6J1xcXFx1MjI0MScsJ05vdFRpbGRlRXF1YWwnOidcXFxcdTIyNDQnLCdOb3RUaWxkZUZ1bGxFcXVhbCc6J1xcXFx1MjI0NycsJ05vdFRpbGRlVGlsZGUnOidcXFxcdTIyNDknLCdOb3RWZXJ0aWNhbEJhcic6J1xcXFx1MjIyNCcsJ25wYXInOidcXFxcdTIyMjYnLCducGFyYWxsZWwnOidcXFxcdTIyMjYnLCducGFyc2wnOidcXFxcdTJBRkRcXFxcdTIwRTUnLCducGFydCc6J1xcXFx1MjIwMlxcXFx1MDMzOCcsJ25wb2xpbnQnOidcXFxcdTJBMTQnLCducHInOidcXFxcdTIyODAnLCducHJjdWUnOidcXFxcdTIyRTAnLCducHJlJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnbnByZWMnOidcXFxcdTIyODAnLCducHJlY2VxJzonXFxcXHUyQUFGXFxcXHUwMzM4JywnbnJhcnInOidcXFxcdTIxOUInLCduckFycic6J1xcXFx1MjFDRicsJ25yYXJyYyc6J1xcXFx1MjkzM1xcXFx1MDMzOCcsJ25yYXJydyc6J1xcXFx1MjE5RFxcXFx1MDMzOCcsJ25yaWdodGFycm93JzonXFxcXHUyMTlCJywnblJpZ2h0YXJyb3cnOidcXFxcdTIxQ0YnLCducnRyaSc6J1xcXFx1MjJFQicsJ25ydHJpZSc6J1xcXFx1MjJFRCcsJ25zYyc6J1xcXFx1MjI4MScsJ25zY2N1ZSc6J1xcXFx1MjJFMScsJ25zY2UnOidcXFxcdTJBQjBcXFxcdTAzMzgnLCduc2NyJzonXFxcXHVEODM1XFxcXHVEQ0MzJywnTnNjcic6J1xcXFx1RDgzNVxcXFx1RENBOScsJ25zaG9ydG1pZCc6J1xcXFx1MjIyNCcsJ25zaG9ydHBhcmFsbGVsJzonXFxcXHUyMjI2JywnbnNpbSc6J1xcXFx1MjI0MScsJ25zaW1lJzonXFxcXHUyMjQ0JywnbnNpbWVxJzonXFxcXHUyMjQ0JywnbnNtaWQnOidcXFxcdTIyMjQnLCduc3Bhcic6J1xcXFx1MjIyNicsJ25zcXN1YmUnOidcXFxcdTIyRTInLCduc3FzdXBlJzonXFxcXHUyMkUzJywnbnN1Yic6J1xcXFx1MjI4NCcsJ25zdWJlJzonXFxcXHUyMjg4JywnbnN1YkUnOidcXFxcdTJBQzVcXFxcdTAzMzgnLCduc3Vic2V0JzonXFxcXHUyMjgyXFxcXHUyMEQyJywnbnN1YnNldGVxJzonXFxcXHUyMjg4JywnbnN1YnNldGVxcSc6J1xcXFx1MkFDNVxcXFx1MDMzOCcsJ25zdWNjJzonXFxcXHUyMjgxJywnbnN1Y2NlcSc6J1xcXFx1MkFCMFxcXFx1MDMzOCcsJ25zdXAnOidcXFxcdTIyODUnLCduc3VwZSc6J1xcXFx1MjI4OScsJ25zdXBFJzonXFxcXHUyQUM2XFxcXHUwMzM4JywnbnN1cHNldCc6J1xcXFx1MjI4M1xcXFx1MjBEMicsJ25zdXBzZXRlcSc6J1xcXFx1MjI4OScsJ25zdXBzZXRlcXEnOidcXFxcdTJBQzZcXFxcdTAzMzgnLCdudGdsJzonXFxcXHUyMjc5JywnbnRpbGRlJzonXFxcXHhGMScsJ050aWxkZSc6J1xcXFx4RDEnLCdudGxnJzonXFxcXHUyMjc4JywnbnRyaWFuZ2xlbGVmdCc6J1xcXFx1MjJFQScsJ250cmlhbmdsZWxlZnRlcSc6J1xcXFx1MjJFQycsJ250cmlhbmdsZXJpZ2h0JzonXFxcXHUyMkVCJywnbnRyaWFuZ2xlcmlnaHRlcSc6J1xcXFx1MjJFRCcsJ251JzonXFxcXHUwM0JEJywnTnUnOidcXFxcdTAzOUQnLCdudW0nOicjJywnbnVtZXJvJzonXFxcXHUyMTE2JywnbnVtc3AnOidcXFxcdTIwMDcnLCdudmFwJzonXFxcXHUyMjREXFxcXHUyMEQyJywnbnZkYXNoJzonXFxcXHUyMkFDJywnbnZEYXNoJzonXFxcXHUyMkFEJywnblZkYXNoJzonXFxcXHUyMkFFJywnblZEYXNoJzonXFxcXHUyMkFGJywnbnZnZSc6J1xcXFx1MjI2NVxcXFx1MjBEMicsJ252Z3QnOic+XFxcXHUyMEQyJywnbnZIYXJyJzonXFxcXHUyOTA0JywnbnZpbmZpbic6J1xcXFx1MjlERScsJ252bEFycic6J1xcXFx1MjkwMicsJ252bGUnOidcXFxcdTIyNjRcXFxcdTIwRDInLCdudmx0JzonPFxcXFx1MjBEMicsJ252bHRyaWUnOidcXFxcdTIyQjRcXFxcdTIwRDInLCdudnJBcnInOidcXFxcdTI5MDMnLCdudnJ0cmllJzonXFxcXHUyMkI1XFxcXHUyMEQyJywnbnZzaW0nOidcXFxcdTIyM0NcXFxcdTIwRDInLCdud2FyaGsnOidcXFxcdTI5MjMnLCdud2Fycic6J1xcXFx1MjE5NicsJ253QXJyJzonXFxcXHUyMUQ2JywnbndhcnJvdyc6J1xcXFx1MjE5NicsJ253bmVhcic6J1xcXFx1MjkyNycsJ29hY3V0ZSc6J1xcXFx4RjMnLCdPYWN1dGUnOidcXFxceEQzJywnb2FzdCc6J1xcXFx1MjI5QicsJ29jaXInOidcXFxcdTIyOUEnLCdvY2lyYyc6J1xcXFx4RjQnLCdPY2lyYyc6J1xcXFx4RDQnLCdvY3knOidcXFxcdTA0M0UnLCdPY3knOidcXFxcdTA0MUUnLCdvZGFzaCc6J1xcXFx1MjI5RCcsJ29kYmxhYyc6J1xcXFx1MDE1MScsJ09kYmxhYyc6J1xcXFx1MDE1MCcsJ29kaXYnOidcXFxcdTJBMzgnLCdvZG90JzonXFxcXHUyMjk5Jywnb2Rzb2xkJzonXFxcXHUyOUJDJywnb2VsaWcnOidcXFxcdTAxNTMnLCdPRWxpZyc6J1xcXFx1MDE1MicsJ29mY2lyJzonXFxcXHUyOUJGJywnb2ZyJzonXFxcXHVEODM1XFxcXHVERDJDJywnT2ZyJzonXFxcXHVEODM1XFxcXHVERDEyJywnb2dvbic6J1xcXFx1MDJEQicsJ29ncmF2ZSc6J1xcXFx4RjInLCdPZ3JhdmUnOidcXFxceEQyJywnb2d0JzonXFxcXHUyOUMxJywnb2hiYXInOidcXFxcdTI5QjUnLCdvaG0nOidcXFxcdTAzQTknLCdvaW50JzonXFxcXHUyMjJFJywnb2xhcnInOidcXFxcdTIxQkEnLCdvbGNpcic6J1xcXFx1MjlCRScsJ29sY3Jvc3MnOidcXFxcdTI5QkInLCdvbGluZSc6J1xcXFx1MjAzRScsJ29sdCc6J1xcXFx1MjlDMCcsJ29tYWNyJzonXFxcXHUwMTREJywnT21hY3InOidcXFxcdTAxNEMnLCdvbWVnYSc6J1xcXFx1MDNDOScsJ09tZWdhJzonXFxcXHUwM0E5Jywnb21pY3Jvbic6J1xcXFx1MDNCRicsJ09taWNyb24nOidcXFxcdTAzOUYnLCdvbWlkJzonXFxcXHUyOUI2Jywnb21pbnVzJzonXFxcXHUyMjk2Jywnb29wZic6J1xcXFx1RDgzNVxcXFx1REQ2MCcsJ09vcGYnOidcXFxcdUQ4MzVcXFxcdURENDYnLCdvcGFyJzonXFxcXHUyOUI3JywnT3BlbkN1cmx5RG91YmxlUXVvdGUnOidcXFxcdTIwMUMnLCdPcGVuQ3VybHlRdW90ZSc6J1xcXFx1MjAxOCcsJ29wZXJwJzonXFxcXHUyOUI5Jywnb3BsdXMnOidcXFxcdTIyOTUnLCdvcic6J1xcXFx1MjIyOCcsJ09yJzonXFxcXHUyQTU0Jywnb3JhcnInOidcXFxcdTIxQkInLCdvcmQnOidcXFxcdTJBNUQnLCdvcmRlcic6J1xcXFx1MjEzNCcsJ29yZGVyb2YnOidcXFxcdTIxMzQnLCdvcmRmJzonXFxcXHhBQScsJ29yZG0nOidcXFxceEJBJywnb3JpZ29mJzonXFxcXHUyMkI2Jywnb3Jvcic6J1xcXFx1MkE1NicsJ29yc2xvcGUnOidcXFxcdTJBNTcnLCdvcnYnOidcXFxcdTJBNUInLCdvUyc6J1xcXFx1MjRDOCcsJ29zY3InOidcXFxcdTIxMzQnLCdPc2NyJzonXFxcXHVEODM1XFxcXHVEQ0FBJywnb3NsYXNoJzonXFxcXHhGOCcsJ09zbGFzaCc6J1xcXFx4RDgnLCdvc29sJzonXFxcXHUyMjk4Jywnb3RpbGRlJzonXFxcXHhGNScsJ090aWxkZSc6J1xcXFx4RDUnLCdvdGltZXMnOidcXFxcdTIyOTcnLCdPdGltZXMnOidcXFxcdTJBMzcnLCdvdGltZXNhcyc6J1xcXFx1MkEzNicsJ291bWwnOidcXFxceEY2JywnT3VtbCc6J1xcXFx4RDYnLCdvdmJhcic6J1xcXFx1MjMzRCcsJ092ZXJCYXInOidcXFxcdTIwM0UnLCdPdmVyQnJhY2UnOidcXFxcdTIzREUnLCdPdmVyQnJhY2tldCc6J1xcXFx1MjNCNCcsJ092ZXJQYXJlbnRoZXNpcyc6J1xcXFx1MjNEQycsJ3Bhcic6J1xcXFx1MjIyNScsJ3BhcmEnOidcXFxceEI2JywncGFyYWxsZWwnOidcXFxcdTIyMjUnLCdwYXJzaW0nOidcXFxcdTJBRjMnLCdwYXJzbCc6J1xcXFx1MkFGRCcsJ3BhcnQnOidcXFxcdTIyMDInLCdQYXJ0aWFsRCc6J1xcXFx1MjIwMicsJ3BjeSc6J1xcXFx1MDQzRicsJ1BjeSc6J1xcXFx1MDQxRicsJ3BlcmNudCc6JyUnLCdwZXJpb2QnOicuJywncGVybWlsJzonXFxcXHUyMDMwJywncGVycCc6J1xcXFx1MjJBNScsJ3BlcnRlbmsnOidcXFxcdTIwMzEnLCdwZnInOidcXFxcdUQ4MzVcXFxcdUREMkQnLCdQZnInOidcXFxcdUQ4MzVcXFxcdUREMTMnLCdwaGknOidcXFxcdTAzQzYnLCdQaGknOidcXFxcdTAzQTYnLCdwaGl2JzonXFxcXHUwM0Q1JywncGhtbWF0JzonXFxcXHUyMTMzJywncGhvbmUnOidcXFxcdTI2MEUnLCdwaSc6J1xcXFx1MDNDMCcsJ1BpJzonXFxcXHUwM0EwJywncGl0Y2hmb3JrJzonXFxcXHUyMkQ0JywncGl2JzonXFxcXHUwM0Q2JywncGxhbmNrJzonXFxcXHUyMTBGJywncGxhbmNraCc6J1xcXFx1MjEwRScsJ3BsYW5rdic6J1xcXFx1MjEwRicsJ3BsdXMnOicrJywncGx1c2FjaXInOidcXFxcdTJBMjMnLCdwbHVzYic6J1xcXFx1MjI5RScsJ3BsdXNjaXInOidcXFxcdTJBMjInLCdwbHVzZG8nOidcXFxcdTIyMTQnLCdwbHVzZHUnOidcXFxcdTJBMjUnLCdwbHVzZSc6J1xcXFx1MkE3MicsJ1BsdXNNaW51cyc6J1xcXFx4QjEnLCdwbHVzbW4nOidcXFxceEIxJywncGx1c3NpbSc6J1xcXFx1MkEyNicsJ3BsdXN0d28nOidcXFxcdTJBMjcnLCdwbSc6J1xcXFx4QjEnLCdQb2luY2FyZXBsYW5lJzonXFxcXHUyMTBDJywncG9pbnRpbnQnOidcXFxcdTJBMTUnLCdwb3BmJzonXFxcXHVEODM1XFxcXHVERDYxJywnUG9wZic6J1xcXFx1MjExOScsJ3BvdW5kJzonXFxcXHhBMycsJ3ByJzonXFxcXHUyMjdBJywnUHInOidcXFxcdTJBQkInLCdwcmFwJzonXFxcXHUyQUI3JywncHJjdWUnOidcXFxcdTIyN0MnLCdwcmUnOidcXFxcdTJBQUYnLCdwckUnOidcXFxcdTJBQjMnLCdwcmVjJzonXFxcXHUyMjdBJywncHJlY2FwcHJveCc6J1xcXFx1MkFCNycsJ3ByZWNjdXJseWVxJzonXFxcXHUyMjdDJywnUHJlY2VkZXMnOidcXFxcdTIyN0EnLCdQcmVjZWRlc0VxdWFsJzonXFxcXHUyQUFGJywnUHJlY2VkZXNTbGFudEVxdWFsJzonXFxcXHUyMjdDJywnUHJlY2VkZXNUaWxkZSc6J1xcXFx1MjI3RScsJ3ByZWNlcSc6J1xcXFx1MkFBRicsJ3ByZWNuYXBwcm94JzonXFxcXHUyQUI5JywncHJlY25lcXEnOidcXFxcdTJBQjUnLCdwcmVjbnNpbSc6J1xcXFx1MjJFOCcsJ3ByZWNzaW0nOidcXFxcdTIyN0UnLCdwcmltZSc6J1xcXFx1MjAzMicsJ1ByaW1lJzonXFxcXHUyMDMzJywncHJpbWVzJzonXFxcXHUyMTE5JywncHJuYXAnOidcXFxcdTJBQjknLCdwcm5FJzonXFxcXHUyQUI1JywncHJuc2ltJzonXFxcXHUyMkU4JywncHJvZCc6J1xcXFx1MjIwRicsJ1Byb2R1Y3QnOidcXFxcdTIyMEYnLCdwcm9mYWxhcic6J1xcXFx1MjMyRScsJ3Byb2ZsaW5lJzonXFxcXHUyMzEyJywncHJvZnN1cmYnOidcXFxcdTIzMTMnLCdwcm9wJzonXFxcXHUyMjFEJywnUHJvcG9ydGlvbic6J1xcXFx1MjIzNycsJ1Byb3BvcnRpb25hbCc6J1xcXFx1MjIxRCcsJ3Byb3B0byc6J1xcXFx1MjIxRCcsJ3Byc2ltJzonXFxcXHUyMjdFJywncHJ1cmVsJzonXFxcXHUyMkIwJywncHNjcic6J1xcXFx1RDgzNVxcXFx1RENDNScsJ1BzY3InOidcXFxcdUQ4MzVcXFxcdURDQUInLCdwc2knOidcXFxcdTAzQzgnLCdQc2knOidcXFxcdTAzQTgnLCdwdW5jc3AnOidcXFxcdTIwMDgnLCdxZnInOidcXFxcdUQ4MzVcXFxcdUREMkUnLCdRZnInOidcXFxcdUQ4MzVcXFxcdUREMTQnLCdxaW50JzonXFxcXHUyQTBDJywncW9wZic6J1xcXFx1RDgzNVxcXFx1REQ2MicsJ1FvcGYnOidcXFxcdTIxMUEnLCdxcHJpbWUnOidcXFxcdTIwNTcnLCdxc2NyJzonXFxcXHVEODM1XFxcXHVEQ0M2JywnUXNjcic6J1xcXFx1RDgzNVxcXFx1RENBQycsJ3F1YXRlcm5pb25zJzonXFxcXHUyMTBEJywncXVhdGludCc6J1xcXFx1MkExNicsJ3F1ZXN0JzonPycsJ3F1ZXN0ZXEnOidcXFxcdTIyNUYnLCdxdW90JzonXFxcIicsJ1FVT1QnOidcXFwiJywnckFhcnInOidcXFxcdTIxREInLCdyYWNlJzonXFxcXHUyMjNEXFxcXHUwMzMxJywncmFjdXRlJzonXFxcXHUwMTU1JywnUmFjdXRlJzonXFxcXHUwMTU0JywncmFkaWMnOidcXFxcdTIyMUEnLCdyYWVtcHR5dic6J1xcXFx1MjlCMycsJ3JhbmcnOidcXFxcdTI3RTknLCdSYW5nJzonXFxcXHUyN0VCJywncmFuZ2QnOidcXFxcdTI5OTInLCdyYW5nZSc6J1xcXFx1MjlBNScsJ3JhbmdsZSc6J1xcXFx1MjdFOScsJ3JhcXVvJzonXFxcXHhCQicsJ3JhcnInOidcXFxcdTIxOTInLCdyQXJyJzonXFxcXHUyMUQyJywnUmFycic6J1xcXFx1MjFBMCcsJ3JhcnJhcCc6J1xcXFx1Mjk3NScsJ3JhcnJiJzonXFxcXHUyMUU1JywncmFycmJmcyc6J1xcXFx1MjkyMCcsJ3JhcnJjJzonXFxcXHUyOTMzJywncmFycmZzJzonXFxcXHUyOTFFJywncmFycmhrJzonXFxcXHUyMUFBJywncmFycmxwJzonXFxcXHUyMUFDJywncmFycnBsJzonXFxcXHUyOTQ1JywncmFycnNpbSc6J1xcXFx1Mjk3NCcsJ3JhcnJ0bCc6J1xcXFx1MjFBMycsJ1JhcnJ0bCc6J1xcXFx1MjkxNicsJ3JhcnJ3JzonXFxcXHUyMTlEJywncmF0YWlsJzonXFxcXHUyOTFBJywnckF0YWlsJzonXFxcXHUyOTFDJywncmF0aW8nOidcXFxcdTIyMzYnLCdyYXRpb25hbHMnOidcXFxcdTIxMUEnLCdyYmFycic6J1xcXFx1MjkwRCcsJ3JCYXJyJzonXFxcXHUyOTBGJywnUkJhcnInOidcXFxcdTI5MTAnLCdyYmJyayc6J1xcXFx1Mjc3MycsJ3JicmFjZSc6J30nLCdyYnJhY2snOiddJywncmJya2UnOidcXFxcdTI5OEMnLCdyYnJrc2xkJzonXFxcXHUyOThFJywncmJya3NsdSc6J1xcXFx1Mjk5MCcsJ3JjYXJvbic6J1xcXFx1MDE1OScsJ1JjYXJvbic6J1xcXFx1MDE1OCcsJ3JjZWRpbCc6J1xcXFx1MDE1NycsJ1JjZWRpbCc6J1xcXFx1MDE1NicsJ3JjZWlsJzonXFxcXHUyMzA5JywncmN1Yic6J30nLCdyY3knOidcXFxcdTA0NDAnLCdSY3knOidcXFxcdTA0MjAnLCdyZGNhJzonXFxcXHUyOTM3JywncmRsZGhhcic6J1xcXFx1Mjk2OScsJ3JkcXVvJzonXFxcXHUyMDFEJywncmRxdW9yJzonXFxcXHUyMDFEJywncmRzaCc6J1xcXFx1MjFCMycsJ1JlJzonXFxcXHUyMTFDJywncmVhbCc6J1xcXFx1MjExQycsJ3JlYWxpbmUnOidcXFxcdTIxMUInLCdyZWFscGFydCc6J1xcXFx1MjExQycsJ3JlYWxzJzonXFxcXHUyMTFEJywncmVjdCc6J1xcXFx1MjVBRCcsJ3JlZyc6J1xcXFx4QUUnLCdSRUcnOidcXFxceEFFJywnUmV2ZXJzZUVsZW1lbnQnOidcXFxcdTIyMEInLCdSZXZlcnNlRXF1aWxpYnJpdW0nOidcXFxcdTIxQ0InLCdSZXZlcnNlVXBFcXVpbGlicml1bSc6J1xcXFx1Mjk2RicsJ3JmaXNodCc6J1xcXFx1Mjk3RCcsJ3JmbG9vcic6J1xcXFx1MjMwQicsJ3Jmcic6J1xcXFx1RDgzNVxcXFx1REQyRicsJ1Jmcic6J1xcXFx1MjExQycsJ3JIYXInOidcXFxcdTI5NjQnLCdyaGFyZCc6J1xcXFx1MjFDMScsJ3JoYXJ1JzonXFxcXHUyMUMwJywncmhhcnVsJzonXFxcXHUyOTZDJywncmhvJzonXFxcXHUwM0MxJywnUmhvJzonXFxcXHUwM0ExJywncmhvdic6J1xcXFx1MDNGMScsJ1JpZ2h0QW5nbGVCcmFja2V0JzonXFxcXHUyN0U5JywncmlnaHRhcnJvdyc6J1xcXFx1MjE5MicsJ1JpZ2h0YXJyb3cnOidcXFxcdTIxRDInLCdSaWdodEFycm93JzonXFxcXHUyMTkyJywnUmlnaHRBcnJvd0Jhcic6J1xcXFx1MjFFNScsJ1JpZ2h0QXJyb3dMZWZ0QXJyb3cnOidcXFxcdTIxQzQnLCdyaWdodGFycm93dGFpbCc6J1xcXFx1MjFBMycsJ1JpZ2h0Q2VpbGluZyc6J1xcXFx1MjMwOScsJ1JpZ2h0RG91YmxlQnJhY2tldCc6J1xcXFx1MjdFNycsJ1JpZ2h0RG93blRlZVZlY3Rvcic6J1xcXFx1Mjk1RCcsJ1JpZ2h0RG93blZlY3Rvcic6J1xcXFx1MjFDMicsJ1JpZ2h0RG93blZlY3RvckJhcic6J1xcXFx1Mjk1NScsJ1JpZ2h0Rmxvb3InOidcXFxcdTIzMEInLCdyaWdodGhhcnBvb25kb3duJzonXFxcXHUyMUMxJywncmlnaHRoYXJwb29udXAnOidcXFxcdTIxQzAnLCdyaWdodGxlZnRhcnJvd3MnOidcXFxcdTIxQzQnLCdyaWdodGxlZnRoYXJwb29ucyc6J1xcXFx1MjFDQycsJ3JpZ2h0cmlnaHRhcnJvd3MnOidcXFxcdTIxQzknLCdyaWdodHNxdWlnYXJyb3cnOidcXFxcdTIxOUQnLCdSaWdodFRlZSc6J1xcXFx1MjJBMicsJ1JpZ2h0VGVlQXJyb3cnOidcXFxcdTIxQTYnLCdSaWdodFRlZVZlY3Rvcic6J1xcXFx1Mjk1QicsJ3JpZ2h0dGhyZWV0aW1lcyc6J1xcXFx1MjJDQycsJ1JpZ2h0VHJpYW5nbGUnOidcXFxcdTIyQjMnLCdSaWdodFRyaWFuZ2xlQmFyJzonXFxcXHUyOUQwJywnUmlnaHRUcmlhbmdsZUVxdWFsJzonXFxcXHUyMkI1JywnUmlnaHRVcERvd25WZWN0b3InOidcXFxcdTI5NEYnLCdSaWdodFVwVGVlVmVjdG9yJzonXFxcXHUyOTVDJywnUmlnaHRVcFZlY3Rvcic6J1xcXFx1MjFCRScsJ1JpZ2h0VXBWZWN0b3JCYXInOidcXFxcdTI5NTQnLCdSaWdodFZlY3Rvcic6J1xcXFx1MjFDMCcsJ1JpZ2h0VmVjdG9yQmFyJzonXFxcXHUyOTUzJywncmluZyc6J1xcXFx1MDJEQScsJ3Jpc2luZ2RvdHNlcSc6J1xcXFx1MjI1MycsJ3JsYXJyJzonXFxcXHUyMUM0JywncmxoYXInOidcXFxcdTIxQ0MnLCdybG0nOidcXFxcdTIwMEYnLCdybW91c3QnOidcXFxcdTIzQjEnLCdybW91c3RhY2hlJzonXFxcXHUyM0IxJywncm5taWQnOidcXFxcdTJBRUUnLCdyb2FuZyc6J1xcXFx1MjdFRCcsJ3JvYXJyJzonXFxcXHUyMUZFJywncm9icmsnOidcXFxcdTI3RTcnLCdyb3Bhcic6J1xcXFx1Mjk4NicsJ3JvcGYnOidcXFxcdUQ4MzVcXFxcdURENjMnLCdSb3BmJzonXFxcXHUyMTFEJywncm9wbHVzJzonXFxcXHUyQTJFJywncm90aW1lcyc6J1xcXFx1MkEzNScsJ1JvdW5kSW1wbGllcyc6J1xcXFx1Mjk3MCcsJ3JwYXInOicpJywncnBhcmd0JzonXFxcXHUyOTk0JywncnBwb2xpbnQnOidcXFxcdTJBMTInLCdycmFycic6J1xcXFx1MjFDOScsJ1JyaWdodGFycm93JzonXFxcXHUyMURCJywncnNhcXVvJzonXFxcXHUyMDNBJywncnNjcic6J1xcXFx1RDgzNVxcXFx1RENDNycsJ1JzY3InOidcXFxcdTIxMUInLCdyc2gnOidcXFxcdTIxQjEnLCdSc2gnOidcXFxcdTIxQjEnLCdyc3FiJzonXScsJ3JzcXVvJzonXFxcXHUyMDE5JywncnNxdW9yJzonXFxcXHUyMDE5JywncnRocmVlJzonXFxcXHUyMkNDJywncnRpbWVzJzonXFxcXHUyMkNBJywncnRyaSc6J1xcXFx1MjVCOScsJ3J0cmllJzonXFxcXHUyMkI1JywncnRyaWYnOidcXFxcdTI1QjgnLCdydHJpbHRyaSc6J1xcXFx1MjlDRScsJ1J1bGVEZWxheWVkJzonXFxcXHUyOUY0JywncnVsdWhhcic6J1xcXFx1Mjk2OCcsJ3J4JzonXFxcXHUyMTFFJywnc2FjdXRlJzonXFxcXHUwMTVCJywnU2FjdXRlJzonXFxcXHUwMTVBJywnc2JxdW8nOidcXFxcdTIwMUEnLCdzYyc6J1xcXFx1MjI3QicsJ1NjJzonXFxcXHUyQUJDJywnc2NhcCc6J1xcXFx1MkFCOCcsJ3NjYXJvbic6J1xcXFx1MDE2MScsJ1NjYXJvbic6J1xcXFx1MDE2MCcsJ3NjY3VlJzonXFxcXHUyMjdEJywnc2NlJzonXFxcXHUyQUIwJywnc2NFJzonXFxcXHUyQUI0Jywnc2NlZGlsJzonXFxcXHUwMTVGJywnU2NlZGlsJzonXFxcXHUwMTVFJywnc2NpcmMnOidcXFxcdTAxNUQnLCdTY2lyYyc6J1xcXFx1MDE1QycsJ3NjbmFwJzonXFxcXHUyQUJBJywnc2NuRSc6J1xcXFx1MkFCNicsJ3NjbnNpbSc6J1xcXFx1MjJFOScsJ3NjcG9saW50JzonXFxcXHUyQTEzJywnc2NzaW0nOidcXFxcdTIyN0YnLCdzY3knOidcXFxcdTA0NDEnLCdTY3knOidcXFxcdTA0MjEnLCdzZG90JzonXFxcXHUyMkM1Jywnc2RvdGInOidcXFxcdTIyQTEnLCdzZG90ZSc6J1xcXFx1MkE2NicsJ3NlYXJoayc6J1xcXFx1MjkyNScsJ3NlYXJyJzonXFxcXHUyMTk4Jywnc2VBcnInOidcXFxcdTIxRDgnLCdzZWFycm93JzonXFxcXHUyMTk4Jywnc2VjdCc6J1xcXFx4QTcnLCdzZW1pJzonOycsJ3Nlc3dhcic6J1xcXFx1MjkyOScsJ3NldG1pbnVzJzonXFxcXHUyMjE2Jywnc2V0bW4nOidcXFxcdTIyMTYnLCdzZXh0JzonXFxcXHUyNzM2Jywnc2ZyJzonXFxcXHVEODM1XFxcXHVERDMwJywnU2ZyJzonXFxcXHVEODM1XFxcXHVERDE2Jywnc2Zyb3duJzonXFxcXHUyMzIyJywnc2hhcnAnOidcXFxcdTI2NkYnLCdzaGNoY3knOidcXFxcdTA0NDknLCdTSENIY3knOidcXFxcdTA0MjknLCdzaGN5JzonXFxcXHUwNDQ4JywnU0hjeSc6J1xcXFx1MDQyOCcsJ1Nob3J0RG93bkFycm93JzonXFxcXHUyMTkzJywnU2hvcnRMZWZ0QXJyb3cnOidcXFxcdTIxOTAnLCdzaG9ydG1pZCc6J1xcXFx1MjIyMycsJ3Nob3J0cGFyYWxsZWwnOidcXFxcdTIyMjUnLCdTaG9ydFJpZ2h0QXJyb3cnOidcXFxcdTIxOTInLCdTaG9ydFVwQXJyb3cnOidcXFxcdTIxOTEnLCdzaHknOidcXFxceEFEJywnc2lnbWEnOidcXFxcdTAzQzMnLCdTaWdtYSc6J1xcXFx1MDNBMycsJ3NpZ21hZic6J1xcXFx1MDNDMicsJ3NpZ21hdic6J1xcXFx1MDNDMicsJ3NpbSc6J1xcXFx1MjIzQycsJ3NpbWRvdCc6J1xcXFx1MkE2QScsJ3NpbWUnOidcXFxcdTIyNDMnLCdzaW1lcSc6J1xcXFx1MjI0MycsJ3NpbWcnOidcXFxcdTJBOUUnLCdzaW1nRSc6J1xcXFx1MkFBMCcsJ3NpbWwnOidcXFxcdTJBOUQnLCdzaW1sRSc6J1xcXFx1MkE5RicsJ3NpbW5lJzonXFxcXHUyMjQ2Jywnc2ltcGx1cyc6J1xcXFx1MkEyNCcsJ3NpbXJhcnInOidcXFxcdTI5NzInLCdzbGFycic6J1xcXFx1MjE5MCcsJ1NtYWxsQ2lyY2xlJzonXFxcXHUyMjE4Jywnc21hbGxzZXRtaW51cyc6J1xcXFx1MjIxNicsJ3NtYXNocCc6J1xcXFx1MkEzMycsJ3NtZXBhcnNsJzonXFxcXHUyOUU0Jywnc21pZCc6J1xcXFx1MjIyMycsJ3NtaWxlJzonXFxcXHUyMzIzJywnc210JzonXFxcXHUyQUFBJywnc210ZSc6J1xcXFx1MkFBQycsJ3NtdGVzJzonXFxcXHUyQUFDXFxcXHVGRTAwJywnc29mdGN5JzonXFxcXHUwNDRDJywnU09GVGN5JzonXFxcXHUwNDJDJywnc29sJzonLycsJ3NvbGInOidcXFxcdTI5QzQnLCdzb2xiYXInOidcXFxcdTIzM0YnLCdzb3BmJzonXFxcXHVEODM1XFxcXHVERDY0JywnU29wZic6J1xcXFx1RDgzNVxcXFx1REQ0QScsJ3NwYWRlcyc6J1xcXFx1MjY2MCcsJ3NwYWRlc3VpdCc6J1xcXFx1MjY2MCcsJ3NwYXInOidcXFxcdTIyMjUnLCdzcWNhcCc6J1xcXFx1MjI5MycsJ3NxY2Fwcyc6J1xcXFx1MjI5M1xcXFx1RkUwMCcsJ3NxY3VwJzonXFxcXHUyMjk0Jywnc3FjdXBzJzonXFxcXHUyMjk0XFxcXHVGRTAwJywnU3FydCc6J1xcXFx1MjIxQScsJ3Nxc3ViJzonXFxcXHUyMjhGJywnc3FzdWJlJzonXFxcXHUyMjkxJywnc3FzdWJzZXQnOidcXFxcdTIyOEYnLCdzcXN1YnNldGVxJzonXFxcXHUyMjkxJywnc3FzdXAnOidcXFxcdTIyOTAnLCdzcXN1cGUnOidcXFxcdTIyOTInLCdzcXN1cHNldCc6J1xcXFx1MjI5MCcsJ3Nxc3Vwc2V0ZXEnOidcXFxcdTIyOTInLCdzcXUnOidcXFxcdTI1QTEnLCdzcXVhcmUnOidcXFxcdTI1QTEnLCdTcXVhcmUnOidcXFxcdTI1QTEnLCdTcXVhcmVJbnRlcnNlY3Rpb24nOidcXFxcdTIyOTMnLCdTcXVhcmVTdWJzZXQnOidcXFxcdTIyOEYnLCdTcXVhcmVTdWJzZXRFcXVhbCc6J1xcXFx1MjI5MScsJ1NxdWFyZVN1cGVyc2V0JzonXFxcXHUyMjkwJywnU3F1YXJlU3VwZXJzZXRFcXVhbCc6J1xcXFx1MjI5MicsJ1NxdWFyZVVuaW9uJzonXFxcXHUyMjk0Jywnc3F1YXJmJzonXFxcXHUyNUFBJywnc3F1Zic6J1xcXFx1MjVBQScsJ3NyYXJyJzonXFxcXHUyMTkyJywnc3Njcic6J1xcXFx1RDgzNVxcXFx1RENDOCcsJ1NzY3InOidcXFxcdUQ4MzVcXFxcdURDQUUnLCdzc2V0bW4nOidcXFxcdTIyMTYnLCdzc21pbGUnOidcXFxcdTIzMjMnLCdzc3RhcmYnOidcXFxcdTIyQzYnLCdzdGFyJzonXFxcXHUyNjA2JywnU3Rhcic6J1xcXFx1MjJDNicsJ3N0YXJmJzonXFxcXHUyNjA1Jywnc3RyYWlnaHRlcHNpbG9uJzonXFxcXHUwM0Y1Jywnc3RyYWlnaHRwaGknOidcXFxcdTAzRDUnLCdzdHJucyc6J1xcXFx4QUYnLCdzdWInOidcXFxcdTIyODInLCdTdWInOidcXFxcdTIyRDAnLCdzdWJkb3QnOidcXFxcdTJBQkQnLCdzdWJlJzonXFxcXHUyMjg2Jywnc3ViRSc6J1xcXFx1MkFDNScsJ3N1YmVkb3QnOidcXFxcdTJBQzMnLCdzdWJtdWx0JzonXFxcXHUyQUMxJywnc3VibmUnOidcXFxcdTIyOEEnLCdzdWJuRSc6J1xcXFx1MkFDQicsJ3N1YnBsdXMnOidcXFxcdTJBQkYnLCdzdWJyYXJyJzonXFxcXHUyOTc5Jywnc3Vic2V0JzonXFxcXHUyMjgyJywnU3Vic2V0JzonXFxcXHUyMkQwJywnc3Vic2V0ZXEnOidcXFxcdTIyODYnLCdzdWJzZXRlcXEnOidcXFxcdTJBQzUnLCdTdWJzZXRFcXVhbCc6J1xcXFx1MjI4NicsJ3N1YnNldG5lcSc6J1xcXFx1MjI4QScsJ3N1YnNldG5lcXEnOidcXFxcdTJBQ0InLCdzdWJzaW0nOidcXFxcdTJBQzcnLCdzdWJzdWInOidcXFxcdTJBRDUnLCdzdWJzdXAnOidcXFxcdTJBRDMnLCdzdWNjJzonXFxcXHUyMjdCJywnc3VjY2FwcHJveCc6J1xcXFx1MkFCOCcsJ3N1Y2NjdXJseWVxJzonXFxcXHUyMjdEJywnU3VjY2VlZHMnOidcXFxcdTIyN0InLCdTdWNjZWVkc0VxdWFsJzonXFxcXHUyQUIwJywnU3VjY2VlZHNTbGFudEVxdWFsJzonXFxcXHUyMjdEJywnU3VjY2VlZHNUaWxkZSc6J1xcXFx1MjI3RicsJ3N1Y2NlcSc6J1xcXFx1MkFCMCcsJ3N1Y2NuYXBwcm94JzonXFxcXHUyQUJBJywnc3VjY25lcXEnOidcXFxcdTJBQjYnLCdzdWNjbnNpbSc6J1xcXFx1MjJFOScsJ3N1Y2NzaW0nOidcXFxcdTIyN0YnLCdTdWNoVGhhdCc6J1xcXFx1MjIwQicsJ3N1bSc6J1xcXFx1MjIxMScsJ1N1bSc6J1xcXFx1MjIxMScsJ3N1bmcnOidcXFxcdTI2NkEnLCdzdXAnOidcXFxcdTIyODMnLCdTdXAnOidcXFxcdTIyRDEnLCdzdXAxJzonXFxcXHhCOScsJ3N1cDInOidcXFxceEIyJywnc3VwMyc6J1xcXFx4QjMnLCdzdXBkb3QnOidcXFxcdTJBQkUnLCdzdXBkc3ViJzonXFxcXHUyQUQ4Jywnc3VwZSc6J1xcXFx1MjI4NycsJ3N1cEUnOidcXFxcdTJBQzYnLCdzdXBlZG90JzonXFxcXHUyQUM0JywnU3VwZXJzZXQnOidcXFxcdTIyODMnLCdTdXBlcnNldEVxdWFsJzonXFxcXHUyMjg3Jywnc3VwaHNvbCc6J1xcXFx1MjdDOScsJ3N1cGhzdWInOidcXFxcdTJBRDcnLCdzdXBsYXJyJzonXFxcXHUyOTdCJywnc3VwbXVsdCc6J1xcXFx1MkFDMicsJ3N1cG5lJzonXFxcXHUyMjhCJywnc3VwbkUnOidcXFxcdTJBQ0MnLCdzdXBwbHVzJzonXFxcXHUyQUMwJywnc3Vwc2V0JzonXFxcXHUyMjgzJywnU3Vwc2V0JzonXFxcXHUyMkQxJywnc3Vwc2V0ZXEnOidcXFxcdTIyODcnLCdzdXBzZXRlcXEnOidcXFxcdTJBQzYnLCdzdXBzZXRuZXEnOidcXFxcdTIyOEInLCdzdXBzZXRuZXFxJzonXFxcXHUyQUNDJywnc3Vwc2ltJzonXFxcXHUyQUM4Jywnc3Vwc3ViJzonXFxcXHUyQUQ0Jywnc3Vwc3VwJzonXFxcXHUyQUQ2Jywnc3dhcmhrJzonXFxcXHUyOTI2Jywnc3dhcnInOidcXFxcdTIxOTknLCdzd0Fycic6J1xcXFx1MjFEOScsJ3N3YXJyb3cnOidcXFxcdTIxOTknLCdzd253YXInOidcXFxcdTI5MkEnLCdzemxpZyc6J1xcXFx4REYnLCdUYWInOidcXFxcdCcsJ3RhcmdldCc6J1xcXFx1MjMxNicsJ3RhdSc6J1xcXFx1MDNDNCcsJ1RhdSc6J1xcXFx1MDNBNCcsJ3RicmsnOidcXFxcdTIzQjQnLCd0Y2Fyb24nOidcXFxcdTAxNjUnLCdUY2Fyb24nOidcXFxcdTAxNjQnLCd0Y2VkaWwnOidcXFxcdTAxNjMnLCdUY2VkaWwnOidcXFxcdTAxNjInLCd0Y3knOidcXFxcdTA0NDInLCdUY3knOidcXFxcdTA0MjInLCd0ZG90JzonXFxcXHUyMERCJywndGVscmVjJzonXFxcXHUyMzE1JywndGZyJzonXFxcXHVEODM1XFxcXHVERDMxJywnVGZyJzonXFxcXHVEODM1XFxcXHVERDE3JywndGhlcmU0JzonXFxcXHUyMjM0JywndGhlcmVmb3JlJzonXFxcXHUyMjM0JywnVGhlcmVmb3JlJzonXFxcXHUyMjM0JywndGhldGEnOidcXFxcdTAzQjgnLCdUaGV0YSc6J1xcXFx1MDM5OCcsJ3RoZXRhc3ltJzonXFxcXHUwM0QxJywndGhldGF2JzonXFxcXHUwM0QxJywndGhpY2thcHByb3gnOidcXFxcdTIyNDgnLCd0aGlja3NpbSc6J1xcXFx1MjIzQycsJ1RoaWNrU3BhY2UnOidcXFxcdTIwNUZcXFxcdTIwMEEnLCd0aGluc3AnOidcXFxcdTIwMDknLCdUaGluU3BhY2UnOidcXFxcdTIwMDknLCd0aGthcCc6J1xcXFx1MjI0OCcsJ3Roa3NpbSc6J1xcXFx1MjIzQycsJ3Rob3JuJzonXFxcXHhGRScsJ1RIT1JOJzonXFxcXHhERScsJ3RpbGRlJzonXFxcXHUwMkRDJywnVGlsZGUnOidcXFxcdTIyM0MnLCdUaWxkZUVxdWFsJzonXFxcXHUyMjQzJywnVGlsZGVGdWxsRXF1YWwnOidcXFxcdTIyNDUnLCdUaWxkZVRpbGRlJzonXFxcXHUyMjQ4JywndGltZXMnOidcXFxceEQ3JywndGltZXNiJzonXFxcXHUyMkEwJywndGltZXNiYXInOidcXFxcdTJBMzEnLCd0aW1lc2QnOidcXFxcdTJBMzAnLCd0aW50JzonXFxcXHUyMjJEJywndG9lYSc6J1xcXFx1MjkyOCcsJ3RvcCc6J1xcXFx1MjJBNCcsJ3RvcGJvdCc6J1xcXFx1MjMzNicsJ3RvcGNpcic6J1xcXFx1MkFGMScsJ3RvcGYnOidcXFxcdUQ4MzVcXFxcdURENjUnLCdUb3BmJzonXFxcXHVEODM1XFxcXHVERDRCJywndG9wZm9yayc6J1xcXFx1MkFEQScsJ3Rvc2EnOidcXFxcdTI5MjknLCd0cHJpbWUnOidcXFxcdTIwMzQnLCd0cmFkZSc6J1xcXFx1MjEyMicsJ1RSQURFJzonXFxcXHUyMTIyJywndHJpYW5nbGUnOidcXFxcdTI1QjUnLCd0cmlhbmdsZWRvd24nOidcXFxcdTI1QkYnLCd0cmlhbmdsZWxlZnQnOidcXFxcdTI1QzMnLCd0cmlhbmdsZWxlZnRlcSc6J1xcXFx1MjJCNCcsJ3RyaWFuZ2xlcSc6J1xcXFx1MjI1QycsJ3RyaWFuZ2xlcmlnaHQnOidcXFxcdTI1QjknLCd0cmlhbmdsZXJpZ2h0ZXEnOidcXFxcdTIyQjUnLCd0cmlkb3QnOidcXFxcdTI1RUMnLCd0cmllJzonXFxcXHUyMjVDJywndHJpbWludXMnOidcXFxcdTJBM0EnLCdUcmlwbGVEb3QnOidcXFxcdTIwREInLCd0cmlwbHVzJzonXFxcXHUyQTM5JywndHJpc2InOidcXFxcdTI5Q0QnLCd0cml0aW1lJzonXFxcXHUyQTNCJywndHJwZXppdW0nOidcXFxcdTIzRTInLCd0c2NyJzonXFxcXHVEODM1XFxcXHVEQ0M5JywnVHNjcic6J1xcXFx1RDgzNVxcXFx1RENBRicsJ3RzY3knOidcXFxcdTA0NDYnLCdUU2N5JzonXFxcXHUwNDI2JywndHNoY3knOidcXFxcdTA0NUInLCdUU0hjeSc6J1xcXFx1MDQwQicsJ3RzdHJvayc6J1xcXFx1MDE2NycsJ1RzdHJvayc6J1xcXFx1MDE2NicsJ3R3aXh0JzonXFxcXHUyMjZDJywndHdvaGVhZGxlZnRhcnJvdyc6J1xcXFx1MjE5RScsJ3R3b2hlYWRyaWdodGFycm93JzonXFxcXHUyMUEwJywndWFjdXRlJzonXFxcXHhGQScsJ1VhY3V0ZSc6J1xcXFx4REEnLCd1YXJyJzonXFxcXHUyMTkxJywndUFycic6J1xcXFx1MjFEMScsJ1VhcnInOidcXFxcdTIxOUYnLCdVYXJyb2Npcic6J1xcXFx1Mjk0OScsJ3VicmN5JzonXFxcXHUwNDVFJywnVWJyY3knOidcXFxcdTA0MEUnLCd1YnJldmUnOidcXFxcdTAxNkQnLCdVYnJldmUnOidcXFxcdTAxNkMnLCd1Y2lyYyc6J1xcXFx4RkInLCdVY2lyYyc6J1xcXFx4REInLCd1Y3knOidcXFxcdTA0NDMnLCdVY3knOidcXFxcdTA0MjMnLCd1ZGFycic6J1xcXFx1MjFDNScsJ3VkYmxhYyc6J1xcXFx1MDE3MScsJ1VkYmxhYyc6J1xcXFx1MDE3MCcsJ3VkaGFyJzonXFxcXHUyOTZFJywndWZpc2h0JzonXFxcXHUyOTdFJywndWZyJzonXFxcXHVEODM1XFxcXHVERDMyJywnVWZyJzonXFxcXHVEODM1XFxcXHVERDE4JywndWdyYXZlJzonXFxcXHhGOScsJ1VncmF2ZSc6J1xcXFx4RDknLCd1SGFyJzonXFxcXHUyOTYzJywndWhhcmwnOidcXFxcdTIxQkYnLCd1aGFycic6J1xcXFx1MjFCRScsJ3VoYmxrJzonXFxcXHUyNTgwJywndWxjb3JuJzonXFxcXHUyMzFDJywndWxjb3JuZXInOidcXFxcdTIzMUMnLCd1bGNyb3AnOidcXFxcdTIzMEYnLCd1bHRyaSc6J1xcXFx1MjVGOCcsJ3VtYWNyJzonXFxcXHUwMTZCJywnVW1hY3InOidcXFxcdTAxNkEnLCd1bWwnOidcXFxceEE4JywnVW5kZXJCYXInOidfJywnVW5kZXJCcmFjZSc6J1xcXFx1MjNERicsJ1VuZGVyQnJhY2tldCc6J1xcXFx1MjNCNScsJ1VuZGVyUGFyZW50aGVzaXMnOidcXFxcdTIzREQnLCdVbmlvbic6J1xcXFx1MjJDMycsJ1VuaW9uUGx1cyc6J1xcXFx1MjI4RScsJ3VvZ29uJzonXFxcXHUwMTczJywnVW9nb24nOidcXFxcdTAxNzInLCd1b3BmJzonXFxcXHVEODM1XFxcXHVERDY2JywnVW9wZic6J1xcXFx1RDgzNVxcXFx1REQ0QycsJ3VwYXJyb3cnOidcXFxcdTIxOTEnLCdVcGFycm93JzonXFxcXHUyMUQxJywnVXBBcnJvdyc6J1xcXFx1MjE5MScsJ1VwQXJyb3dCYXInOidcXFxcdTI5MTInLCdVcEFycm93RG93bkFycm93JzonXFxcXHUyMUM1JywndXBkb3duYXJyb3cnOidcXFxcdTIxOTUnLCdVcGRvd25hcnJvdyc6J1xcXFx1MjFENScsJ1VwRG93bkFycm93JzonXFxcXHUyMTk1JywnVXBFcXVpbGlicml1bSc6J1xcXFx1Mjk2RScsJ3VwaGFycG9vbmxlZnQnOidcXFxcdTIxQkYnLCd1cGhhcnBvb25yaWdodCc6J1xcXFx1MjFCRScsJ3VwbHVzJzonXFxcXHUyMjhFJywnVXBwZXJMZWZ0QXJyb3cnOidcXFxcdTIxOTYnLCdVcHBlclJpZ2h0QXJyb3cnOidcXFxcdTIxOTcnLCd1cHNpJzonXFxcXHUwM0M1JywnVXBzaSc6J1xcXFx1MDNEMicsJ3Vwc2loJzonXFxcXHUwM0QyJywndXBzaWxvbic6J1xcXFx1MDNDNScsJ1Vwc2lsb24nOidcXFxcdTAzQTUnLCdVcFRlZSc6J1xcXFx1MjJBNScsJ1VwVGVlQXJyb3cnOidcXFxcdTIxQTUnLCd1cHVwYXJyb3dzJzonXFxcXHUyMUM4JywndXJjb3JuJzonXFxcXHUyMzFEJywndXJjb3JuZXInOidcXFxcdTIzMUQnLCd1cmNyb3AnOidcXFxcdTIzMEUnLCd1cmluZyc6J1xcXFx1MDE2RicsJ1VyaW5nJzonXFxcXHUwMTZFJywndXJ0cmknOidcXFxcdTI1RjknLCd1c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NBJywnVXNjcic6J1xcXFx1RDgzNVxcXFx1RENCMCcsJ3V0ZG90JzonXFxcXHUyMkYwJywndXRpbGRlJzonXFxcXHUwMTY5JywnVXRpbGRlJzonXFxcXHUwMTY4JywndXRyaSc6J1xcXFx1MjVCNScsJ3V0cmlmJzonXFxcXHUyNUI0JywndXVhcnInOidcXFxcdTIxQzgnLCd1dW1sJzonXFxcXHhGQycsJ1V1bWwnOidcXFxceERDJywndXdhbmdsZSc6J1xcXFx1MjlBNycsJ3ZhbmdydCc6J1xcXFx1Mjk5QycsJ3ZhcmVwc2lsb24nOidcXFxcdTAzRjUnLCd2YXJrYXBwYSc6J1xcXFx1MDNGMCcsJ3Zhcm5vdGhpbmcnOidcXFxcdTIyMDUnLCd2YXJwaGknOidcXFxcdTAzRDUnLCd2YXJwaSc6J1xcXFx1MDNENicsJ3ZhcnByb3B0byc6J1xcXFx1MjIxRCcsJ3ZhcnInOidcXFxcdTIxOTUnLCd2QXJyJzonXFxcXHUyMUQ1JywndmFycmhvJzonXFxcXHUwM0YxJywndmFyc2lnbWEnOidcXFxcdTAzQzInLCd2YXJzdWJzZXRuZXEnOidcXFxcdTIyOEFcXFxcdUZFMDAnLCd2YXJzdWJzZXRuZXFxJzonXFxcXHUyQUNCXFxcXHVGRTAwJywndmFyc3Vwc2V0bmVxJzonXFxcXHUyMjhCXFxcXHVGRTAwJywndmFyc3Vwc2V0bmVxcSc6J1xcXFx1MkFDQ1xcXFx1RkUwMCcsJ3ZhcnRoZXRhJzonXFxcXHUwM0QxJywndmFydHJpYW5nbGVsZWZ0JzonXFxcXHUyMkIyJywndmFydHJpYW5nbGVyaWdodCc6J1xcXFx1MjJCMycsJ3ZCYXInOidcXFxcdTJBRTgnLCdWYmFyJzonXFxcXHUyQUVCJywndkJhcnYnOidcXFxcdTJBRTknLCd2Y3knOidcXFxcdTA0MzInLCdWY3knOidcXFxcdTA0MTInLCd2ZGFzaCc6J1xcXFx1MjJBMicsJ3ZEYXNoJzonXFxcXHUyMkE4JywnVmRhc2gnOidcXFxcdTIyQTknLCdWRGFzaCc6J1xcXFx1MjJBQicsJ1ZkYXNobCc6J1xcXFx1MkFFNicsJ3ZlZSc6J1xcXFx1MjIyOCcsJ1ZlZSc6J1xcXFx1MjJDMScsJ3ZlZWJhcic6J1xcXFx1MjJCQicsJ3ZlZWVxJzonXFxcXHUyMjVBJywndmVsbGlwJzonXFxcXHUyMkVFJywndmVyYmFyJzonfCcsJ1ZlcmJhcic6J1xcXFx1MjAxNicsJ3ZlcnQnOid8JywnVmVydCc6J1xcXFx1MjAxNicsJ1ZlcnRpY2FsQmFyJzonXFxcXHUyMjIzJywnVmVydGljYWxMaW5lJzonfCcsJ1ZlcnRpY2FsU2VwYXJhdG9yJzonXFxcXHUyNzU4JywnVmVydGljYWxUaWxkZSc6J1xcXFx1MjI0MCcsJ1ZlcnlUaGluU3BhY2UnOidcXFxcdTIwMEEnLCd2ZnInOidcXFxcdUQ4MzVcXFxcdUREMzMnLCdWZnInOidcXFxcdUQ4MzVcXFxcdUREMTknLCd2bHRyaSc6J1xcXFx1MjJCMicsJ3Zuc3ViJzonXFxcXHUyMjgyXFxcXHUyMEQyJywndm5zdXAnOidcXFxcdTIyODNcXFxcdTIwRDInLCd2b3BmJzonXFxcXHVEODM1XFxcXHVERDY3JywnVm9wZic6J1xcXFx1RDgzNVxcXFx1REQ0RCcsJ3Zwcm9wJzonXFxcXHUyMjFEJywndnJ0cmknOidcXFxcdTIyQjMnLCd2c2NyJzonXFxcXHVEODM1XFxcXHVEQ0NCJywnVnNjcic6J1xcXFx1RDgzNVxcXFx1RENCMScsJ3ZzdWJuZSc6J1xcXFx1MjI4QVxcXFx1RkUwMCcsJ3ZzdWJuRSc6J1xcXFx1MkFDQlxcXFx1RkUwMCcsJ3ZzdXBuZSc6J1xcXFx1MjI4QlxcXFx1RkUwMCcsJ3ZzdXBuRSc6J1xcXFx1MkFDQ1xcXFx1RkUwMCcsJ1Z2ZGFzaCc6J1xcXFx1MjJBQScsJ3Z6aWd6YWcnOidcXFxcdTI5OUEnLCd3Y2lyYyc6J1xcXFx1MDE3NScsJ1djaXJjJzonXFxcXHUwMTc0Jywnd2VkYmFyJzonXFxcXHUyQTVGJywnd2VkZ2UnOidcXFxcdTIyMjcnLCdXZWRnZSc6J1xcXFx1MjJDMCcsJ3dlZGdlcSc6J1xcXFx1MjI1OScsJ3dlaWVycCc6J1xcXFx1MjExOCcsJ3dmcic6J1xcXFx1RDgzNVxcXFx1REQzNCcsJ1dmcic6J1xcXFx1RDgzNVxcXFx1REQxQScsJ3dvcGYnOidcXFxcdUQ4MzVcXFxcdURENjgnLCdXb3BmJzonXFxcXHVEODM1XFxcXHVERDRFJywnd3AnOidcXFxcdTIxMTgnLCd3cic6J1xcXFx1MjI0MCcsJ3dyZWF0aCc6J1xcXFx1MjI0MCcsJ3dzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0MnLCdXc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IyJywneGNhcCc6J1xcXFx1MjJDMicsJ3hjaXJjJzonXFxcXHUyNUVGJywneGN1cCc6J1xcXFx1MjJDMycsJ3hkdHJpJzonXFxcXHUyNUJEJywneGZyJzonXFxcXHVEODM1XFxcXHVERDM1JywnWGZyJzonXFxcXHVEODM1XFxcXHVERDFCJywneGhhcnInOidcXFxcdTI3RjcnLCd4aEFycic6J1xcXFx1MjdGQScsJ3hpJzonXFxcXHUwM0JFJywnWGknOidcXFxcdTAzOUUnLCd4bGFycic6J1xcXFx1MjdGNScsJ3hsQXJyJzonXFxcXHUyN0Y4JywneG1hcCc6J1xcXFx1MjdGQycsJ3huaXMnOidcXFxcdTIyRkInLCd4b2RvdCc6J1xcXFx1MkEwMCcsJ3hvcGYnOidcXFxcdUQ4MzVcXFxcdURENjknLCdYb3BmJzonXFxcXHVEODM1XFxcXHVERDRGJywneG9wbHVzJzonXFxcXHUyQTAxJywneG90aW1lJzonXFxcXHUyQTAyJywneHJhcnInOidcXFxcdTI3RjYnLCd4ckFycic6J1xcXFx1MjdGOScsJ3hzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0QnLCdYc2NyJzonXFxcXHVEODM1XFxcXHVEQ0IzJywneHNxY3VwJzonXFxcXHUyQTA2JywneHVwbHVzJzonXFxcXHUyQTA0JywneHV0cmknOidcXFxcdTI1QjMnLCd4dmVlJzonXFxcXHUyMkMxJywneHdlZGdlJzonXFxcXHUyMkMwJywneWFjdXRlJzonXFxcXHhGRCcsJ1lhY3V0ZSc6J1xcXFx4REQnLCd5YWN5JzonXFxcXHUwNDRGJywnWUFjeSc6J1xcXFx1MDQyRicsJ3ljaXJjJzonXFxcXHUwMTc3JywnWWNpcmMnOidcXFxcdTAxNzYnLCd5Y3knOidcXFxcdTA0NEInLCdZY3knOidcXFxcdTA0MkInLCd5ZW4nOidcXFxceEE1JywneWZyJzonXFxcXHVEODM1XFxcXHVERDM2JywnWWZyJzonXFxcXHVEODM1XFxcXHVERDFDJywneWljeSc6J1xcXFx1MDQ1NycsJ1lJY3knOidcXFxcdTA0MDcnLCd5b3BmJzonXFxcXHVEODM1XFxcXHVERDZBJywnWW9wZic6J1xcXFx1RDgzNVxcXFx1REQ1MCcsJ3lzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0UnLCdZc2NyJzonXFxcXHVEODM1XFxcXHVEQ0I0JywneXVjeSc6J1xcXFx1MDQ0RScsJ1lVY3knOidcXFxcdTA0MkUnLCd5dW1sJzonXFxcXHhGRicsJ1l1bWwnOidcXFxcdTAxNzgnLCd6YWN1dGUnOidcXFxcdTAxN0EnLCdaYWN1dGUnOidcXFxcdTAxNzknLCd6Y2Fyb24nOidcXFxcdTAxN0UnLCdaY2Fyb24nOidcXFxcdTAxN0QnLCd6Y3knOidcXFxcdTA0MzcnLCdaY3knOidcXFxcdTA0MTcnLCd6ZG90JzonXFxcXHUwMTdDJywnWmRvdCc6J1xcXFx1MDE3QicsJ3plZXRyZic6J1xcXFx1MjEyOCcsJ1plcm9XaWR0aFNwYWNlJzonXFxcXHUyMDBCJywnemV0YSc6J1xcXFx1MDNCNicsJ1pldGEnOidcXFxcdTAzOTYnLCd6ZnInOidcXFxcdUQ4MzVcXFxcdUREMzcnLCdaZnInOidcXFxcdTIxMjgnLCd6aGN5JzonXFxcXHUwNDM2JywnWkhjeSc6J1xcXFx1MDQxNicsJ3ppZ3JhcnInOidcXFxcdTIxREQnLCd6b3BmJzonXFxcXHVEODM1XFxcXHVERDZCJywnWm9wZic6J1xcXFx1MjEyNCcsJ3pzY3InOidcXFxcdUQ4MzVcXFxcdURDQ0YnLCdac2NyJzonXFxcXHVEODM1XFxcXHVEQ0I1JywnendqJzonXFxcXHUyMDBEJywnenduaic6J1xcXFx1MjAwQyd9O1xcblxcdHZhciBkZWNvZGVNYXBMZWdhY3kgPSB7J2FhY3V0ZSc6J1xcXFx4RTEnLCdBYWN1dGUnOidcXFxceEMxJywnYWNpcmMnOidcXFxceEUyJywnQWNpcmMnOidcXFxceEMyJywnYWN1dGUnOidcXFxceEI0JywnYWVsaWcnOidcXFxceEU2JywnQUVsaWcnOidcXFxceEM2JywnYWdyYXZlJzonXFxcXHhFMCcsJ0FncmF2ZSc6J1xcXFx4QzAnLCdhbXAnOicmJywnQU1QJzonJicsJ2FyaW5nJzonXFxcXHhFNScsJ0FyaW5nJzonXFxcXHhDNScsJ2F0aWxkZSc6J1xcXFx4RTMnLCdBdGlsZGUnOidcXFxceEMzJywnYXVtbCc6J1xcXFx4RTQnLCdBdW1sJzonXFxcXHhDNCcsJ2JydmJhcic6J1xcXFx4QTYnLCdjY2VkaWwnOidcXFxceEU3JywnQ2NlZGlsJzonXFxcXHhDNycsJ2NlZGlsJzonXFxcXHhCOCcsJ2NlbnQnOidcXFxceEEyJywnY29weSc6J1xcXFx4QTknLCdDT1BZJzonXFxcXHhBOScsJ2N1cnJlbic6J1xcXFx4QTQnLCdkZWcnOidcXFxceEIwJywnZGl2aWRlJzonXFxcXHhGNycsJ2VhY3V0ZSc6J1xcXFx4RTknLCdFYWN1dGUnOidcXFxceEM5JywnZWNpcmMnOidcXFxceEVBJywnRWNpcmMnOidcXFxceENBJywnZWdyYXZlJzonXFxcXHhFOCcsJ0VncmF2ZSc6J1xcXFx4QzgnLCdldGgnOidcXFxceEYwJywnRVRIJzonXFxcXHhEMCcsJ2V1bWwnOidcXFxceEVCJywnRXVtbCc6J1xcXFx4Q0InLCdmcmFjMTInOidcXFxceEJEJywnZnJhYzE0JzonXFxcXHhCQycsJ2ZyYWMzNCc6J1xcXFx4QkUnLCdndCc6Jz4nLCdHVCc6Jz4nLCdpYWN1dGUnOidcXFxceEVEJywnSWFjdXRlJzonXFxcXHhDRCcsJ2ljaXJjJzonXFxcXHhFRScsJ0ljaXJjJzonXFxcXHhDRScsJ2lleGNsJzonXFxcXHhBMScsJ2lncmF2ZSc6J1xcXFx4RUMnLCdJZ3JhdmUnOidcXFxceENDJywnaXF1ZXN0JzonXFxcXHhCRicsJ2l1bWwnOidcXFxceEVGJywnSXVtbCc6J1xcXFx4Q0YnLCdsYXF1byc6J1xcXFx4QUInLCdsdCc6JzwnLCdMVCc6JzwnLCdtYWNyJzonXFxcXHhBRicsJ21pY3JvJzonXFxcXHhCNScsJ21pZGRvdCc6J1xcXFx4QjcnLCduYnNwJzonXFxcXHhBMCcsJ25vdCc6J1xcXFx4QUMnLCdudGlsZGUnOidcXFxceEYxJywnTnRpbGRlJzonXFxcXHhEMScsJ29hY3V0ZSc6J1xcXFx4RjMnLCdPYWN1dGUnOidcXFxceEQzJywnb2NpcmMnOidcXFxceEY0JywnT2NpcmMnOidcXFxceEQ0Jywnb2dyYXZlJzonXFxcXHhGMicsJ09ncmF2ZSc6J1xcXFx4RDInLCdvcmRmJzonXFxcXHhBQScsJ29yZG0nOidcXFxceEJBJywnb3NsYXNoJzonXFxcXHhGOCcsJ09zbGFzaCc6J1xcXFx4RDgnLCdvdGlsZGUnOidcXFxceEY1JywnT3RpbGRlJzonXFxcXHhENScsJ291bWwnOidcXFxceEY2JywnT3VtbCc6J1xcXFx4RDYnLCdwYXJhJzonXFxcXHhCNicsJ3BsdXNtbic6J1xcXFx4QjEnLCdwb3VuZCc6J1xcXFx4QTMnLCdxdW90JzonXFxcIicsJ1FVT1QnOidcXFwiJywncmFxdW8nOidcXFxceEJCJywncmVnJzonXFxcXHhBRScsJ1JFRyc6J1xcXFx4QUUnLCdzZWN0JzonXFxcXHhBNycsJ3NoeSc6J1xcXFx4QUQnLCdzdXAxJzonXFxcXHhCOScsJ3N1cDInOidcXFxceEIyJywnc3VwMyc6J1xcXFx4QjMnLCdzemxpZyc6J1xcXFx4REYnLCd0aG9ybic6J1xcXFx4RkUnLCdUSE9STic6J1xcXFx4REUnLCd0aW1lcyc6J1xcXFx4RDcnLCd1YWN1dGUnOidcXFxceEZBJywnVWFjdXRlJzonXFxcXHhEQScsJ3VjaXJjJzonXFxcXHhGQicsJ1VjaXJjJzonXFxcXHhEQicsJ3VncmF2ZSc6J1xcXFx4RjknLCdVZ3JhdmUnOidcXFxceEQ5JywndW1sJzonXFxcXHhBOCcsJ3V1bWwnOidcXFxceEZDJywnVXVtbCc6J1xcXFx4REMnLCd5YWN1dGUnOidcXFxceEZEJywnWWFjdXRlJzonXFxcXHhERCcsJ3llbic6J1xcXFx4QTUnLCd5dW1sJzonXFxcXHhGRid9O1xcblxcdHZhciBkZWNvZGVNYXBOdW1lcmljID0geycwJzonXFxcXHVGRkZEJywnMTI4JzonXFxcXHUyMEFDJywnMTMwJzonXFxcXHUyMDFBJywnMTMxJzonXFxcXHUwMTkyJywnMTMyJzonXFxcXHUyMDFFJywnMTMzJzonXFxcXHUyMDI2JywnMTM0JzonXFxcXHUyMDIwJywnMTM1JzonXFxcXHUyMDIxJywnMTM2JzonXFxcXHUwMkM2JywnMTM3JzonXFxcXHUyMDMwJywnMTM4JzonXFxcXHUwMTYwJywnMTM5JzonXFxcXHUyMDM5JywnMTQwJzonXFxcXHUwMTUyJywnMTQyJzonXFxcXHUwMTdEJywnMTQ1JzonXFxcXHUyMDE4JywnMTQ2JzonXFxcXHUyMDE5JywnMTQ3JzonXFxcXHUyMDFDJywnMTQ4JzonXFxcXHUyMDFEJywnMTQ5JzonXFxcXHUyMDIyJywnMTUwJzonXFxcXHUyMDEzJywnMTUxJzonXFxcXHUyMDE0JywnMTUyJzonXFxcXHUwMkRDJywnMTUzJzonXFxcXHUyMTIyJywnMTU0JzonXFxcXHUwMTYxJywnMTU1JzonXFxcXHUyMDNBJywnMTU2JzonXFxcXHUwMTUzJywnMTU4JzonXFxcXHUwMTdFJywnMTU5JzonXFxcXHUwMTc4J307XFxuXFx0dmFyIGludmFsaWRSZWZlcmVuY2VDb2RlUG9pbnRzID0gWzEsMiwzLDQsNSw2LDcsOCwxMSwxMywxNCwxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCwyOSwzMCwzMSwxMjcsMTI4LDEyOSwxMzAsMTMxLDEzMiwxMzMsMTM0LDEzNSwxMzYsMTM3LDEzOCwxMzksMTQwLDE0MSwxNDIsMTQzLDE0NCwxNDUsMTQ2LDE0NywxNDgsMTQ5LDE1MCwxNTEsMTUyLDE1MywxNTQsMTU1LDE1NiwxNTcsMTU4LDE1OSw2NDk3Niw2NDk3Nyw2NDk3OCw2NDk3OSw2NDk4MCw2NDk4MSw2NDk4Miw2NDk4Myw2NDk4NCw2NDk4NSw2NDk4Niw2NDk4Nyw2NDk4OCw2NDk4OSw2NDk5MCw2NDk5MSw2NDk5Miw2NDk5Myw2NDk5NCw2NDk5NSw2NDk5Niw2NDk5Nyw2NDk5OCw2NDk5OSw2NTAwMCw2NTAwMSw2NTAwMiw2NTAwMyw2NTAwNCw2NTAwNSw2NTAwNiw2NTAwNyw2NTUzNCw2NTUzNSwxMzEwNzAsMTMxMDcxLDE5NjYwNiwxOTY2MDcsMjYyMTQyLDI2MjE0MywzMjc2NzgsMzI3Njc5LDM5MzIxNCwzOTMyMTUsNDU4NzUwLDQ1ODc1MSw1MjQyODYsNTI0Mjg3LDU4OTgyMiw1ODk4MjMsNjU1MzU4LDY1NTM1OSw3MjA4OTQsNzIwODk1LDc4NjQzMCw3ODY0MzEsODUxOTY2LDg1MTk2Nyw5MTc1MDIsOTE3NTAzLDk4MzAzOCw5ODMwMzksMTA0ODU3NCwxMDQ4NTc1LDExMTQxMTAsMTExNDExMV07XFxuXFxuXFx0LyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXFxuXFxuXFx0dmFyIHN0cmluZ0Zyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XFxuXFxuXFx0dmFyIG9iamVjdCA9IHt9O1xcblxcdHZhciBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdC5oYXNPd25Qcm9wZXJ0eTtcXG5cXHR2YXIgaGFzID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eU5hbWUpIHtcXG5cXHRcXHRyZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5TmFtZSk7XFxuXFx0fTtcXG5cXG5cXHR2YXIgY29udGFpbnMgPSBmdW5jdGlvbihhcnJheSwgdmFsdWUpIHtcXG5cXHRcXHR2YXIgaW5kZXggPSAtMTtcXG5cXHRcXHR2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xcblxcdFxcdHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuXFx0XFx0XFx0aWYgKGFycmF5W2luZGV4XSA9PSB2YWx1ZSkge1xcblxcdFxcdFxcdFxcdHJldHVybiB0cnVlO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdH07XFxuXFxuXFx0dmFyIG1lcmdlID0gZnVuY3Rpb24ob3B0aW9ucywgZGVmYXVsdHMpIHtcXG5cXHRcXHRpZiAoIW9wdGlvbnMpIHtcXG5cXHRcXHRcXHRyZXR1cm4gZGVmYXVsdHM7XFxuXFx0XFx0fVxcblxcdFxcdHZhciByZXN1bHQgPSB7fTtcXG5cXHRcXHR2YXIga2V5O1xcblxcdFxcdGZvciAoa2V5IGluIGRlZmF1bHRzKSB7XFxuXFx0XFx0XFx0Ly8gQSBgaGFzT3duUHJvcGVydHlgIGNoZWNrIGlzIG5vdCBuZWVkZWQgaGVyZSwgc2luY2Ugb25seSByZWNvZ25pemVkXFxuXFx0XFx0XFx0Ly8gb3B0aW9uIG5hbWVzIGFyZSB1c2VkIGFueXdheS4gQW55IG90aGVycyBhcmUgaWdub3JlZC5cXG5cXHRcXHRcXHRyZXN1bHRba2V5XSA9IGhhcyhvcHRpb25zLCBrZXkpID8gb3B0aW9uc1trZXldIDogZGVmYXVsdHNba2V5XTtcXG5cXHRcXHR9XFxuXFx0XFx0cmV0dXJuIHJlc3VsdDtcXG5cXHR9O1xcblxcblxcdC8vIE1vZGlmaWVkIHZlcnNpb24gb2YgYHVjczJlbmNvZGVgOyBzZWUgaHR0cHM6Ly9tdGhzLmJlL3B1bnljb2RlLlxcblxcdHZhciBjb2RlUG9pbnRUb1N5bWJvbCA9IGZ1bmN0aW9uKGNvZGVQb2ludCwgc3RyaWN0KSB7XFxuXFx0XFx0dmFyIG91dHB1dCA9ICcnO1xcblxcdFxcdGlmICgoY29kZVBvaW50ID49IDB4RDgwMCAmJiBjb2RlUG9pbnQgPD0gMHhERkZGKSB8fCBjb2RlUG9pbnQgPiAweDEwRkZGRikge1xcblxcdFxcdFxcdC8vIFNlZSBpc3N1ZSAjNDpcXG5cXHRcXHRcXHQvLyDigJxPdGhlcndpc2UsIGlmIHRoZSBudW1iZXIgaXMgaW4gdGhlIHJhbmdlIDB4RDgwMCB0byAweERGRkYgb3IgaXNcXG5cXHRcXHRcXHQvLyBncmVhdGVyIHRoYW4gMHgxMEZGRkYsIHRoZW4gdGhpcyBpcyBhIHBhcnNlIGVycm9yLiBSZXR1cm4gYSBVK0ZGRkRcXG5cXHRcXHRcXHQvLyBSRVBMQUNFTUVOVCBDSEFSQUNURVIu4oCdXFxuXFx0XFx0XFx0aWYgKHN0cmljdCkge1xcblxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugb3V0c2lkZSB0aGUgcGVybWlzc2libGUgVW5pY29kZSByYW5nZScpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRyZXR1cm4gJ1xcXFx1RkZGRCc7XFxuXFx0XFx0fVxcblxcdFxcdGlmIChoYXMoZGVjb2RlTWFwTnVtZXJpYywgY29kZVBvaW50KSkge1xcblxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRwYXJzZUVycm9yKCdkaXNhbGxvd2VkIGNoYXJhY3RlciByZWZlcmVuY2UnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGRlY29kZU1hcE51bWVyaWNbY29kZVBvaW50XTtcXG5cXHRcXHR9XFxuXFx0XFx0aWYgKHN0cmljdCAmJiBjb250YWlucyhpbnZhbGlkUmVmZXJlbmNlQ29kZVBvaW50cywgY29kZVBvaW50KSkge1xcblxcdFxcdFxcdHBhcnNlRXJyb3IoJ2Rpc2FsbG93ZWQgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAoY29kZVBvaW50ID4gMHhGRkZGKSB7XFxuXFx0XFx0XFx0Y29kZVBvaW50IC09IDB4MTAwMDA7XFxuXFx0XFx0XFx0b3V0cHV0ICs9IHN0cmluZ0Zyb21DaGFyQ29kZShjb2RlUG9pbnQgPj4+IDEwICYgMHgzRkYgfCAweEQ4MDApO1xcblxcdFxcdFxcdGNvZGVQb2ludCA9IDB4REMwMCB8IGNvZGVQb2ludCAmIDB4M0ZGO1xcblxcdFxcdH1cXG5cXHRcXHRvdXRwdXQgKz0gc3RyaW5nRnJvbUNoYXJDb2RlKGNvZGVQb2ludCk7XFxuXFx0XFx0cmV0dXJuIG91dHB1dDtcXG5cXHR9O1xcblxcblxcdHZhciBoZXhFc2NhcGUgPSBmdW5jdGlvbihjb2RlUG9pbnQpIHtcXG5cXHRcXHRyZXR1cm4gJyYjeCcgKyBjb2RlUG9pbnQudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCkgKyAnOyc7XFxuXFx0fTtcXG5cXG5cXHR2YXIgZGVjRXNjYXBlID0gZnVuY3Rpb24oY29kZVBvaW50KSB7XFxuXFx0XFx0cmV0dXJuICcmIycgKyBjb2RlUG9pbnQgKyAnOyc7XFxuXFx0fTtcXG5cXG5cXHR2YXIgcGFyc2VFcnJvciA9IGZ1bmN0aW9uKG1lc3NhZ2UpIHtcXG5cXHRcXHR0aHJvdyBFcnJvcignUGFyc2UgZXJyb3I6ICcgKyBtZXNzYWdlKTtcXG5cXHR9O1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBlbmNvZGUgPSBmdW5jdGlvbihzdHJpbmcsIG9wdGlvbnMpIHtcXG5cXHRcXHRvcHRpb25zID0gbWVyZ2Uob3B0aW9ucywgZW5jb2RlLm9wdGlvbnMpO1xcblxcdFxcdHZhciBzdHJpY3QgPSBvcHRpb25zLnN0cmljdDtcXG5cXHRcXHRpZiAoc3RyaWN0ICYmIHJlZ2V4SW52YWxpZFJhd0NvZGVQb2ludC50ZXN0KHN0cmluZykpIHtcXG5cXHRcXHRcXHRwYXJzZUVycm9yKCdmb3JiaWRkZW4gY29kZSBwb2ludCcpO1xcblxcdFxcdH1cXG5cXHRcXHR2YXIgZW5jb2RlRXZlcnl0aGluZyA9IG9wdGlvbnMuZW5jb2RlRXZlcnl0aGluZztcXG5cXHRcXHR2YXIgdXNlTmFtZWRSZWZlcmVuY2VzID0gb3B0aW9ucy51c2VOYW1lZFJlZmVyZW5jZXM7XFxuXFx0XFx0dmFyIGFsbG93VW5zYWZlU3ltYm9scyA9IG9wdGlvbnMuYWxsb3dVbnNhZmVTeW1ib2xzO1xcblxcdFxcdHZhciBlc2NhcGVDb2RlUG9pbnQgPSBvcHRpb25zLmRlY2ltYWwgPyBkZWNFc2NhcGUgOiBoZXhFc2NhcGU7XFxuXFxuXFx0XFx0dmFyIGVzY2FwZUJtcFN5bWJvbCA9IGZ1bmN0aW9uKHN5bWJvbCkge1xcblxcdFxcdFxcdHJldHVybiBlc2NhcGVDb2RlUG9pbnQoc3ltYm9sLmNoYXJDb2RlQXQoMCkpO1xcblxcdFxcdH07XFxuXFxuXFx0XFx0aWYgKGVuY29kZUV2ZXJ5dGhpbmcpIHtcXG5cXHRcXHRcXHQvLyBFbmNvZGUgQVNDSUkgc3ltYm9scy5cXG5cXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEFzY2lpV2hpdGVsaXN0LCBmdW5jdGlvbihzeW1ib2wpIHtcXG5cXHRcXHRcXHRcXHQvLyBVc2UgbmFtZWQgcmVmZXJlbmNlcyBpZiByZXF1ZXN0ZWQgJiBwb3NzaWJsZS5cXG5cXHRcXHRcXHRcXHRpZiAodXNlTmFtZWRSZWZlcmVuY2VzICYmIGhhcyhlbmNvZGVNYXAsIHN5bWJvbCkpIHtcXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJyYnICsgZW5jb2RlTWFwW3N5bWJvbF0gKyAnOyc7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdHJldHVybiBlc2NhcGVCbXBTeW1ib2woc3ltYm9sKTtcXG5cXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHQvLyBTaG9ydGVuIGEgZmV3IGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZVxcblxcdFxcdFxcdC8vIGlzIHdpdGhpbiB0aGUgQVNDSUkgcmFuZ2UuXFxuXFx0XFx0XFx0aWYgKHVzZU5hbWVkUmVmZXJlbmNlcykge1xcblxcdFxcdFxcdFxcdHN0cmluZyA9IHN0cmluZ1xcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mZ3Q7XFxcXHUyMEQyL2csICcmbnZndDsnKVxcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mbHQ7XFxcXHUyMEQyL2csICcmbnZsdDsnKVxcblxcdFxcdFxcdFxcdFxcdC5yZXBsYWNlKC8mI3g2NjsmI3g2QTsvZywgJyZmamxpZzsnKTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gRW5jb2RlIG5vbi1BU0NJSSBzeW1ib2xzLlxcblxcdFxcdFxcdGlmICh1c2VOYW1lZFJlZmVyZW5jZXMpIHtcXG5cXHRcXHRcXHRcXHQvLyBFbmNvZGUgbm9uLUFTQ0lJIHN5bWJvbHMgdGhhdCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIG5hbWVkIHJlZmVyZW5jZS5cXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVuY29kZU5vbkFzY2lpLCBmdW5jdGlvbihzdHJpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHQvLyBOb3RlOiB0aGVyZSBpcyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoZW5jb2RlTWFwLCBzdHJpbmcpYCBoZXJlLlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiAnJicgKyBlbmNvZGVNYXBbc3RyaW5nXSArICc7JztcXG5cXHRcXHRcXHRcXHR9KTtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0Ly8gTm90ZTogYW55IHJlbWFpbmluZyBub24tQVNDSUkgc3ltYm9scyBhcmUgaGFuZGxlZCBvdXRzaWRlIG9mIHRoZSBgaWZgLlxcblxcdFxcdH0gZWxzZSBpZiAodXNlTmFtZWRSZWZlcmVuY2VzKSB7XFxuXFx0XFx0XFx0Ly8gQXBwbHkgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGA8PlxcXCInJmAgdXNpbmcgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMuXFxuXFx0XFx0XFx0aWYgKCFhbGxvd1Vuc2FmZVN5bWJvbHMpIHtcXG5cXHRcXHRcXHRcXHRzdHJpbmcgPSBzdHJpbmcucmVwbGFjZShyZWdleEVzY2FwZSwgZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnOyAvLyBubyBuZWVkIHRvIGNoZWNrIGBoYXMoKWAgaGVyZVxcblxcdFxcdFxcdFxcdH0pO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBTaG9ydGVuIGVzY2FwZXMgdGhhdCByZXByZXNlbnQgdHdvIHN5bWJvbHMsIG9mIHdoaWNoIGF0IGxlYXN0IG9uZSBpc1xcblxcdFxcdFxcdC8vIGA8PlxcXCInJmAuXFxuXFx0XFx0XFx0c3RyaW5nID0gc3RyaW5nXFxuXFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZndDtcXFxcdTIwRDIvZywgJyZudmd0OycpXFxuXFx0XFx0XFx0XFx0LnJlcGxhY2UoLyZsdDtcXFxcdTIwRDIvZywgJyZudmx0OycpO1xcblxcdFxcdFxcdC8vIEVuY29kZSBub24tQVNDSUkgc3ltYm9scyB0aGF0IGNhbiBiZSByZXBsYWNlZCB3aXRoIGEgbmFtZWQgcmVmZXJlbmNlLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RW5jb2RlTm9uQXNjaWksIGZ1bmN0aW9uKHN0cmluZykge1xcblxcdFxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlbmNvZGVNYXAsIHN0cmluZylgIGhlcmUuXFxuXFx0XFx0XFx0XFx0cmV0dXJuICcmJyArIGVuY29kZU1hcFtzdHJpbmddICsgJzsnO1xcblxcdFxcdFxcdH0pO1xcblxcdFxcdH0gZWxzZSBpZiAoIWFsbG93VW5zYWZlU3ltYm9scykge1xcblxcdFxcdFxcdC8vIEVuY29kZSBgPD5cXFwiJyZgIHVzaW5nIGhleGFkZWNpbWFsIGVzY2FwZXMsIG5vdyB0aGF0IHRoZXnigJlyZSBub3QgaGFuZGxlZFxcblxcdFxcdFxcdC8vIHVzaW5nIG5hbWVkIGNoYXJhY3RlciByZWZlcmVuY2VzLlxcblxcdFxcdFxcdHN0cmluZyA9IHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBlc2NhcGVCbXBTeW1ib2wpO1xcblxcdFxcdH1cXG5cXHRcXHRyZXR1cm4gc3RyaW5nXFxuXFx0XFx0XFx0Ly8gRW5jb2RlIGFzdHJhbCBzeW1ib2xzLlxcblxcdFxcdFxcdC5yZXBsYWNlKHJlZ2V4QXN0cmFsU3ltYm9scywgZnVuY3Rpb24oJDApIHtcXG5cXHRcXHRcXHRcXHQvLyBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvamF2YXNjcmlwdC1lbmNvZGluZyNzdXJyb2dhdGUtZm9ybXVsYWVcXG5cXHRcXHRcXHRcXHR2YXIgaGlnaCA9ICQwLmNoYXJDb2RlQXQoMCk7XFxuXFx0XFx0XFx0XFx0dmFyIGxvdyA9ICQwLmNoYXJDb2RlQXQoMSk7XFxuXFx0XFx0XFx0XFx0dmFyIGNvZGVQb2ludCA9IChoaWdoIC0gMHhEODAwKSAqIDB4NDAwICsgbG93IC0gMHhEQzAwICsgMHgxMDAwMDtcXG5cXHRcXHRcXHRcXHRyZXR1cm4gZXNjYXBlQ29kZVBvaW50KGNvZGVQb2ludCk7XFxuXFx0XFx0XFx0fSlcXG5cXHRcXHRcXHQvLyBFbmNvZGUgYW55IHJlbWFpbmluZyBCTVAgc3ltYm9scyB0aGF0IGFyZSBub3QgcHJpbnRhYmxlIEFTQ0lJIHN5bWJvbHNcXG5cXHRcXHRcXHQvLyB1c2luZyBhIGhleGFkZWNpbWFsIGVzY2FwZS5cXG5cXHRcXHRcXHQucmVwbGFjZShyZWdleEJtcFdoaXRlbGlzdCwgZXNjYXBlQm1wU3ltYm9sKTtcXG5cXHR9O1xcblxcdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxcblxcdGVuY29kZS5vcHRpb25zID0ge1xcblxcdFxcdCdhbGxvd1Vuc2FmZVN5bWJvbHMnOiBmYWxzZSxcXG5cXHRcXHQnZW5jb2RlRXZlcnl0aGluZyc6IGZhbHNlLFxcblxcdFxcdCdzdHJpY3QnOiBmYWxzZSxcXG5cXHRcXHQndXNlTmFtZWRSZWZlcmVuY2VzJzogZmFsc2UsXFxuXFx0XFx0J2RlY2ltYWwnIDogZmFsc2VcXG5cXHR9O1xcblxcblxcdHZhciBkZWNvZGUgPSBmdW5jdGlvbihodG1sLCBvcHRpb25zKSB7XFxuXFx0XFx0b3B0aW9ucyA9IG1lcmdlKG9wdGlvbnMsIGRlY29kZS5vcHRpb25zKTtcXG5cXHRcXHR2YXIgc3RyaWN0ID0gb3B0aW9ucy5zdHJpY3Q7XFxuXFx0XFx0aWYgKHN0cmljdCAmJiByZWdleEludmFsaWRFbnRpdHkudGVzdChodG1sKSkge1xcblxcdFxcdFxcdHBhcnNlRXJyb3IoJ21hbGZvcm1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlJyk7XFxuXFx0XFx0fVxcblxcdFxcdHJldHVybiBodG1sLnJlcGxhY2UocmVnZXhEZWNvZGUsIGZ1bmN0aW9uKCQwLCAkMSwgJDIsICQzLCAkNCwgJDUsICQ2LCAkNykge1xcblxcdFxcdFxcdHZhciBjb2RlUG9pbnQ7XFxuXFx0XFx0XFx0dmFyIHNlbWljb2xvbjtcXG5cXHRcXHRcXHR2YXIgZGVjRGlnaXRzO1xcblxcdFxcdFxcdHZhciBoZXhEaWdpdHM7XFxuXFx0XFx0XFx0dmFyIHJlZmVyZW5jZTtcXG5cXHRcXHRcXHR2YXIgbmV4dDtcXG5cXHRcXHRcXHRpZiAoJDEpIHtcXG5cXHRcXHRcXHRcXHQvLyBEZWNvZGUgZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmIzExOTU1ODtgLlxcblxcdFxcdFxcdFxcdGRlY0RpZ2l0cyA9ICQxO1xcblxcdFxcdFxcdFxcdHNlbWljb2xvbiA9ICQyO1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNvZGVQb2ludCA9IHBhcnNlSW50KGRlY0RpZ2l0cywgMTApO1xcblxcdFxcdFxcdFxcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkMykge1xcblxcdFxcdFxcdFxcdC8vIERlY29kZSBoZXhhZGVjaW1hbCBlc2NhcGVzLCBlLmcuIGAmI3gxRDMwNjtgLlxcblxcdFxcdFxcdFxcdGhleERpZ2l0cyA9ICQzO1xcblxcdFxcdFxcdFxcdHNlbWljb2xvbiA9ICQ0O1xcblxcdFxcdFxcdFxcdGlmIChzdHJpY3QgJiYgIXNlbWljb2xvbikge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2NoYXJhY3RlciByZWZlcmVuY2Ugd2FzIG5vdCB0ZXJtaW5hdGVkIGJ5IGEgc2VtaWNvbG9uJyk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdFxcdGNvZGVQb2ludCA9IHBhcnNlSW50KGhleERpZ2l0cywgMTYpO1xcblxcdFxcdFxcdFxcdHJldHVybiBjb2RlUG9pbnRUb1N5bWJvbChjb2RlUG9pbnQsIHN0cmljdCk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdFxcdGlmICgkNSkge1xcblxcdFxcdFxcdFxcdC8vIERlY29kZSBuYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlcyB3aXRoIHRyYWlsaW5nIGA7YCwgZS5nLiBgJmNvcHk7YC5cXG5cXHRcXHRcXHRcXHRyZWZlcmVuY2UgPSAkNTtcXG5cXHRcXHRcXHRcXHRpZiAoaGFzKGRlY29kZU1hcCwgcmVmZXJlbmNlKSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiBkZWNvZGVNYXBbcmVmZXJlbmNlXTtcXG5cXHRcXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdFxcdC8vIEFtYmlndW91cyBhbXBlcnNhbmQuIGh0dHBzOi8vbXRocy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kc1xcblxcdFxcdFxcdFxcdFxcdGlmIChzdHJpY3QpIHtcXG5cXHRcXHRcXHRcXHRcXHRcXHRwYXJzZUVycm9yKFxcblxcdFxcdFxcdFxcdFxcdFxcdFxcdCduYW1lZCBjaGFyYWN0ZXIgcmVmZXJlbmNlIHdhcyBub3QgdGVybWluYXRlZCBieSBhIHNlbWljb2xvbidcXG5cXHRcXHRcXHRcXHRcXHRcXHQpO1xcblxcdFxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRcXHRyZXR1cm4gJDA7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHQvLyBJZiB3ZeKAmXJlIHN0aWxsIGhlcmUsIGl04oCZcyBhIGxlZ2FjeSByZWZlcmVuY2UgZm9yIHN1cmUuIE5vIG5lZWQgZm9yIGFuXFxuXFx0XFx0XFx0Ly8gZXh0cmEgYGlmYCBjaGVjay5cXG5cXHRcXHRcXHQvLyBEZWNvZGUgbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZXMgd2l0aG91dCB0cmFpbGluZyBgO2AsIGUuZy4gYCZhbXBgXFxuXFx0XFx0XFx0Ly8gVGhpcyBpcyBvbmx5IGEgcGFyc2UgZXJyb3IgaWYgaXQgZ2V0cyBjb252ZXJ0ZWQgdG8gYCZgLCBvciBpZiBpdCBpc1xcblxcdFxcdFxcdC8vIGZvbGxvd2VkIGJ5IGA9YCBpbiBhbiBhdHRyaWJ1dGUgY29udGV4dC5cXG5cXHRcXHRcXHRyZWZlcmVuY2UgPSAkNjtcXG5cXHRcXHRcXHRuZXh0ID0gJDc7XFxuXFx0XFx0XFx0aWYgKG5leHQgJiYgb3B0aW9ucy5pc0F0dHJpYnV0ZVZhbHVlKSB7XFxuXFx0XFx0XFx0XFx0aWYgKHN0cmljdCAmJiBuZXh0ID09ICc9Jykge1xcblxcdFxcdFxcdFxcdFxcdHBhcnNlRXJyb3IoJ2AmYCBkaWQgbm90IHN0YXJ0IGEgY2hhcmFjdGVyIHJlZmVyZW5jZScpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHRyZXR1cm4gJDA7XFxuXFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRpZiAoc3RyaWN0KSB7XFxuXFx0XFx0XFx0XFx0XFx0cGFyc2VFcnJvcihcXG5cXHRcXHRcXHRcXHRcXHRcXHQnbmFtZWQgY2hhcmFjdGVyIHJlZmVyZW5jZSB3YXMgbm90IHRlcm1pbmF0ZWQgYnkgYSBzZW1pY29sb24nXFxuXFx0XFx0XFx0XFx0XFx0KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0Ly8gTm90ZTogdGhlcmUgaXMgbm8gbmVlZCB0byBjaGVjayBgaGFzKGRlY29kZU1hcExlZ2FjeSwgcmVmZXJlbmNlKWAuXFxuXFx0XFx0XFx0XFx0cmV0dXJuIGRlY29kZU1hcExlZ2FjeVtyZWZlcmVuY2VdICsgKG5leHQgfHwgJycpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcdC8vIEV4cG9zZSBkZWZhdWx0IG9wdGlvbnMgKHNvIHRoZXkgY2FuIGJlIG92ZXJyaWRkZW4gZ2xvYmFsbHkpLlxcblxcdGRlY29kZS5vcHRpb25zID0ge1xcblxcdFxcdCdpc0F0dHJpYnV0ZVZhbHVlJzogZmFsc2UsXFxuXFx0XFx0J3N0cmljdCc6IGZhbHNlXFxuXFx0fTtcXG5cXG5cXHR2YXIgZXNjYXBlID0gZnVuY3Rpb24oc3RyaW5nKSB7XFxuXFx0XFx0cmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlZ2V4RXNjYXBlLCBmdW5jdGlvbigkMCkge1xcblxcdFxcdFxcdC8vIE5vdGU6IHRoZXJlIGlzIG5vIG5lZWQgdG8gY2hlY2sgYGhhcyhlc2NhcGVNYXAsICQwKWAgaGVyZS5cXG5cXHRcXHRcXHRyZXR1cm4gZXNjYXBlTWFwWyQwXTtcXG5cXHRcXHR9KTtcXG5cXHR9O1xcblxcblxcdC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xcblxcblxcdHZhciBoZSA9IHtcXG5cXHRcXHQndmVyc2lvbic6ICcxLjEuMScsXFxuXFx0XFx0J2VuY29kZSc6IGVuY29kZSxcXG5cXHRcXHQnZGVjb2RlJzogZGVjb2RlLFxcblxcdFxcdCdlc2NhcGUnOiBlc2NhcGUsXFxuXFx0XFx0J3VuZXNjYXBlJzogZGVjb2RlXFxuXFx0fTtcXG5cXG5cXHQvLyBTb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnNcXG5cXHQvLyBsaWtlIHRoZSBmb2xsb3dpbmc6XFxuXFx0aWYgKFxcblxcdFxcdGZhbHNlXFxuXFx0KSB7XFxuXFx0XFx0ZGVmaW5lKGZ1bmN0aW9uKCkge1xcblxcdFxcdFxcdHJldHVybiBoZTtcXG5cXHRcXHR9KTtcXG5cXHR9XFx0ZWxzZSBpZiAoZnJlZUV4cG9ydHMgJiYgIWZyZWVFeHBvcnRzLm5vZGVUeXBlKSB7XFxuXFx0XFx0aWYgKGZyZWVNb2R1bGUpIHsgLy8gaW4gTm9kZS5qcywgaW8uanMsIG9yIFJpbmdvSlMgdjAuOC4wK1xcblxcdFxcdFxcdGZyZWVNb2R1bGUuZXhwb3J0cyA9IGhlO1xcblxcdFxcdH0gZWxzZSB7IC8vIGluIE5hcndoYWwgb3IgUmluZ29KUyB2MC43LjAtXFxuXFx0XFx0XFx0Zm9yICh2YXIga2V5IGluIGhlKSB7XFxuXFx0XFx0XFx0XFx0aGFzKGhlLCBrZXkpICYmIChmcmVlRXhwb3J0c1trZXldID0gaGVba2V5XSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9IGVsc2UgeyAvLyBpbiBSaGlubyBvciBhIHdlYiBicm93c2VyXFxuXFx0XFx0cm9vdC5oZSA9IGhlO1xcblxcdH1cXG5cXG59KHRoaXMpKTtcXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSw0OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuZXhwb3J0cy5yZWFkID0gZnVuY3Rpb24gKGJ1ZmZlciwgb2Zmc2V0LCBpc0xFLCBtTGVuLCBuQnl0ZXMpIHtcXG4gIHZhciBlLCBtXFxuICB2YXIgZUxlbiA9IG5CeXRlcyAqIDggLSBtTGVuIC0gMVxcbiAgdmFyIGVNYXggPSAoMSA8PCBlTGVuKSAtIDFcXG4gIHZhciBlQmlhcyA9IGVNYXggPj4gMVxcbiAgdmFyIG5CaXRzID0gLTdcXG4gIHZhciBpID0gaXNMRSA/IChuQnl0ZXMgLSAxKSA6IDBcXG4gIHZhciBkID0gaXNMRSA/IC0xIDogMVxcbiAgdmFyIHMgPSBidWZmZXJbb2Zmc2V0ICsgaV1cXG5cXG4gIGkgKz0gZFxcblxcbiAgZSA9IHMgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcXG4gIHMgPj49ICgtbkJpdHMpXFxuICBuQml0cyArPSBlTGVuXFxuICBmb3IgKDsgbkJpdHMgPiAwOyBlID0gZSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxcblxcbiAgbSA9IGUgJiAoKDEgPDwgKC1uQml0cykpIC0gMSlcXG4gIGUgPj49ICgtbkJpdHMpXFxuICBuQml0cyArPSBtTGVuXFxuICBmb3IgKDsgbkJpdHMgPiAwOyBtID0gbSAqIDI1NiArIGJ1ZmZlcltvZmZzZXQgKyBpXSwgaSArPSBkLCBuQml0cyAtPSA4KSB7fVxcblxcbiAgaWYgKGUgPT09IDApIHtcXG4gICAgZSA9IDEgLSBlQmlhc1xcbiAgfSBlbHNlIGlmIChlID09PSBlTWF4KSB7XFxuICAgIHJldHVybiBtID8gTmFOIDogKChzID8gLTEgOiAxKSAqIEluZmluaXR5KVxcbiAgfSBlbHNlIHtcXG4gICAgbSA9IG0gKyBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICBlID0gZSAtIGVCaWFzXFxuICB9XFxuICByZXR1cm4gKHMgPyAtMSA6IDEpICogbSAqIE1hdGgucG93KDIsIGUgLSBtTGVuKVxcbn1cXG5cXG5leHBvcnRzLndyaXRlID0gZnVuY3Rpb24gKGJ1ZmZlciwgdmFsdWUsIG9mZnNldCwgaXNMRSwgbUxlbiwgbkJ5dGVzKSB7XFxuICB2YXIgZSwgbSwgY1xcbiAgdmFyIGVMZW4gPSBuQnl0ZXMgKiA4IC0gbUxlbiAtIDFcXG4gIHZhciBlTWF4ID0gKDEgPDwgZUxlbikgLSAxXFxuICB2YXIgZUJpYXMgPSBlTWF4ID4+IDFcXG4gIHZhciBydCA9IChtTGVuID09PSAyMyA/IE1hdGgucG93KDIsIC0yNCkgLSBNYXRoLnBvdygyLCAtNzcpIDogMClcXG4gIHZhciBpID0gaXNMRSA/IDAgOiAobkJ5dGVzIC0gMSlcXG4gIHZhciBkID0gaXNMRSA/IDEgOiAtMVxcbiAgdmFyIHMgPSB2YWx1ZSA8IDAgfHwgKHZhbHVlID09PSAwICYmIDEgLyB2YWx1ZSA8IDApID8gMSA6IDBcXG5cXG4gIHZhbHVlID0gTWF0aC5hYnModmFsdWUpXFxuXFxuICBpZiAoaXNOYU4odmFsdWUpIHx8IHZhbHVlID09PSBJbmZpbml0eSkge1xcbiAgICBtID0gaXNOYU4odmFsdWUpID8gMSA6IDBcXG4gICAgZSA9IGVNYXhcXG4gIH0gZWxzZSB7XFxuICAgIGUgPSBNYXRoLmZsb29yKE1hdGgubG9nKHZhbHVlKSAvIE1hdGguTE4yKVxcbiAgICBpZiAodmFsdWUgKiAoYyA9IE1hdGgucG93KDIsIC1lKSkgPCAxKSB7XFxuICAgICAgZS0tXFxuICAgICAgYyAqPSAyXFxuICAgIH1cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgdmFsdWUgKz0gcnQgLyBjXFxuICAgIH0gZWxzZSB7XFxuICAgICAgdmFsdWUgKz0gcnQgKiBNYXRoLnBvdygyLCAxIC0gZUJpYXMpXFxuICAgIH1cXG4gICAgaWYgKHZhbHVlICogYyA+PSAyKSB7XFxuICAgICAgZSsrXFxuICAgICAgYyAvPSAyXFxuICAgIH1cXG5cXG4gICAgaWYgKGUgKyBlQmlhcyA+PSBlTWF4KSB7XFxuICAgICAgbSA9IDBcXG4gICAgICBlID0gZU1heFxcbiAgICB9IGVsc2UgaWYgKGUgKyBlQmlhcyA+PSAxKSB7XFxuICAgICAgbSA9ICh2YWx1ZSAqIGMgLSAxKSAqIE1hdGgucG93KDIsIG1MZW4pXFxuICAgICAgZSA9IGUgKyBlQmlhc1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG0gPSB2YWx1ZSAqIE1hdGgucG93KDIsIGVCaWFzIC0gMSkgKiBNYXRoLnBvdygyLCBtTGVuKVxcbiAgICAgIGUgPSAwXFxuICAgIH1cXG4gIH1cXG5cXG4gIGZvciAoOyBtTGVuID49IDg7IGJ1ZmZlcltvZmZzZXQgKyBpXSA9IG0gJiAweGZmLCBpICs9IGQsIG0gLz0gMjU2LCBtTGVuIC09IDgpIHt9XFxuXFxuICBlID0gKGUgPDwgbUxlbikgfCBtXFxuICBlTGVuICs9IG1MZW5cXG4gIGZvciAoOyBlTGVuID4gMDsgYnVmZmVyW29mZnNldCArIGldID0gZSAmIDB4ZmYsIGkgKz0gZCwgZSAvPSAyNTYsIGVMZW4gLT0gOCkge31cXG5cXG4gIGJ1ZmZlcltvZmZzZXQgKyBpIC0gZF0gfD0gcyAqIDEyOFxcbn1cXG5cXG59LHt9XSw1MDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XFxuICAvLyBpbXBsZW1lbnRhdGlvbiBmcm9tIHN0YW5kYXJkIG5vZGUuanMgJ3V0aWwnIG1vZHVsZVxcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcXG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcXG4gICAgY3Rvci5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ3Rvci5wcm90b3R5cGUsIHtcXG4gICAgICBjb25zdHJ1Y3Rvcjoge1xcbiAgICAgICAgdmFsdWU6IGN0b3IsXFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlLFxcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgICAgfVxcbiAgICB9KTtcXG4gIH07XFxufSBlbHNlIHtcXG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXFxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcikge1xcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fVxcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlXFxuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcXG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yXFxuICB9XFxufVxcblxcbn0se31dLDUxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vKiFcXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXFxuICpcXG4gKiBAYXV0aG9yICAgRmVyb3NzIEFib3VraGFkaWplaCA8ZmVyb3NzQGZlcm9zcy5vcmc+IDxodHRwOi8vZmVyb3NzLm9yZz5cXG4gKiBAbGljZW5zZSAgTUlUXFxuICovXFxuXFxuLy8gVGhlIF9pc0J1ZmZlciBjaGVjayBpcyBmb3IgU2FmYXJpIDUtNyBzdXBwb3J0LCBiZWNhdXNlIGl0J3MgbWlzc2luZ1xcbi8vIE9iamVjdC5wcm90b3R5cGUuY29uc3RydWN0b3IuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHlcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcXG4gIHJldHVybiBvYmogIT0gbnVsbCAmJiAoaXNCdWZmZXIob2JqKSB8fCBpc1Nsb3dCdWZmZXIob2JqKSB8fCAhIW9iai5faXNCdWZmZXIpXFxufVxcblxcbmZ1bmN0aW9uIGlzQnVmZmVyIChvYmopIHtcXG4gIHJldHVybiAhIW9iai5jb25zdHJ1Y3RvciAmJiB0eXBlb2Ygb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyID09PSAnZnVuY3Rpb24nICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopXFxufVxcblxcbi8vIEZvciBOb2RlIHYwLjEwIHN1cHBvcnQuIFJlbW92ZSB0aGlzIGV2ZW50dWFsbHkuXFxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcXG4gIHJldHVybiB0eXBlb2Ygb2JqLnJlYWRGbG9hdExFID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBvYmouc2xpY2UgPT09ICdmdW5jdGlvbicgJiYgaXNCdWZmZXIob2JqLnNsaWNlKDAsIDApKVxcbn1cXG5cXG59LHt9XSw1MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxudmFyIHRvU3RyaW5nID0ge30udG9TdHJpbmc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChhcnIpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKGFycikgPT0gJ1tvYmplY3QgQXJyYXldJztcXG59O1xcblxcbn0se31dLDUzOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKHByb2Nlc3Mpe1xcbnZhciBwYXRoID0gcmVxdWlyZSgncGF0aCcpO1xcbnZhciBmcyA9IHJlcXVpcmUoJ2ZzJyk7XFxudmFyIF8wNzc3ID0gcGFyc2VJbnQoJzA3NzcnLCA4KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IG1rZGlyUC5ta2RpcnAgPSBta2RpclAubWtkaXJQID0gbWtkaXJQO1xcblxcbmZ1bmN0aW9uIG1rZGlyUCAocCwgb3B0cywgZiwgbWFkZSkge1xcbiAgICBpZiAodHlwZW9mIG9wdHMgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIGYgPSBvcHRzO1xcbiAgICAgICAgb3B0cyA9IHt9O1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKCFvcHRzIHx8IHR5cGVvZiBvcHRzICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgb3B0cyA9IHsgbW9kZTogb3B0cyB9O1xcbiAgICB9XFxuICAgIFxcbiAgICB2YXIgbW9kZSA9IG9wdHMubW9kZTtcXG4gICAgdmFyIHhmcyA9IG9wdHMuZnMgfHwgZnM7XFxuICAgIFxcbiAgICBpZiAobW9kZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICBtb2RlID0gXzA3NzcgJiAofnByb2Nlc3MudW1hc2soKSk7XFxuICAgIH1cXG4gICAgaWYgKCFtYWRlKSBtYWRlID0gbnVsbDtcXG4gICAgXFxuICAgIHZhciBjYiA9IGYgfHwgZnVuY3Rpb24gKCkge307XFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuICAgIFxcbiAgICB4ZnMubWtkaXIocCwgbW9kZSwgZnVuY3Rpb24gKGVyKSB7XFxuICAgICAgICBpZiAoIWVyKSB7XFxuICAgICAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgICAgICAgICByZXR1cm4gY2IobnVsbCwgbWFkZSk7XFxuICAgICAgICB9XFxuICAgICAgICBzd2l0Y2ggKGVyLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnOlxcbiAgICAgICAgICAgICAgICBta2RpclAocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBmdW5jdGlvbiAoZXIsIG1hZGUpIHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChlcikgY2IoZXIsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBta2RpclAocCwgb3B0cywgY2IsIG1hZGUpO1xcbiAgICAgICAgICAgICAgICB9KTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgeGZzLnN0YXQocCwgZnVuY3Rpb24gKGVyMiwgc3RhdCkge1xcbiAgICAgICAgICAgICAgICAgICAgLy8gaWYgdGhlIHN0YXQgZmFpbHMsIHRoZW4gdGhhdCdzIHN1cGVyIHdlaXJkLlxcbiAgICAgICAgICAgICAgICAgICAgLy8gbGV0IHRoZSBvcmlnaW5hbCBlcnJvciBiZSB0aGUgZmFpbHVyZSByZWFzb24uXFxuICAgICAgICAgICAgICAgICAgICBpZiAoZXIyIHx8ICFzdGF0LmlzRGlyZWN0b3J5KCkpIGNiKGVyLCBtYWRlKVxcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBjYihudWxsLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgICAgIGJyZWFrO1xcbiAgICAgICAgfVxcbiAgICB9KTtcXG59XFxuXFxubWtkaXJQLnN5bmMgPSBmdW5jdGlvbiBzeW5jIChwLCBvcHRzLCBtYWRlKSB7XFxuICAgIGlmICghb3B0cyB8fCB0eXBlb2Ygb3B0cyAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIG9wdHMgPSB7IG1vZGU6IG9wdHMgfTtcXG4gICAgfVxcbiAgICBcXG4gICAgdmFyIG1vZGUgPSBvcHRzLm1vZGU7XFxuICAgIHZhciB4ZnMgPSBvcHRzLmZzIHx8IGZzO1xcbiAgICBcXG4gICAgaWYgKG1vZGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgICAgbW9kZSA9IF8wNzc3ICYgKH5wcm9jZXNzLnVtYXNrKCkpO1xcbiAgICB9XFxuICAgIGlmICghbWFkZSkgbWFkZSA9IG51bGw7XFxuXFxuICAgIHAgPSBwYXRoLnJlc29sdmUocCk7XFxuXFxuICAgIHRyeSB7XFxuICAgICAgICB4ZnMubWtkaXJTeW5jKHAsIG1vZGUpO1xcbiAgICAgICAgbWFkZSA9IG1hZGUgfHwgcDtcXG4gICAgfVxcbiAgICBjYXRjaCAoZXJyMCkge1xcbiAgICAgICAgc3dpdGNoIChlcnIwLmNvZGUpIHtcXG4gICAgICAgICAgICBjYXNlICdFTk9FTlQnIDpcXG4gICAgICAgICAgICAgICAgbWFkZSA9IHN5bmMocGF0aC5kaXJuYW1lKHApLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgc3luYyhwLCBvcHRzLCBtYWRlKTtcXG4gICAgICAgICAgICAgICAgYnJlYWs7XFxuXFxuICAgICAgICAgICAgLy8gSW4gdGhlIGNhc2Ugb2YgYW55IG90aGVyIGVycm9yLCBqdXN0IHNlZSBpZiB0aGVyZSdzIGEgZGlyXFxuICAgICAgICAgICAgLy8gdGhlcmUgYWxyZWFkeS4gIElmIHNvLCB0aGVuIGhvb3JheSEgIElmIG5vdCwgdGhlbiBzb21ldGhpbmdcXG4gICAgICAgICAgICAvLyBpcyBib3JrZWQuXFxuICAgICAgICAgICAgZGVmYXVsdDpcXG4gICAgICAgICAgICAgICAgdmFyIHN0YXQ7XFxuICAgICAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgICAgICBzdGF0ID0geGZzLnN0YXRTeW5jKHApO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnIxKSB7XFxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIGlmICghc3RhdC5pc0RpcmVjdG9yeSgpKSB0aHJvdyBlcnIwO1xcbiAgICAgICAgICAgICAgICBicmVhaztcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gbWFkZTtcXG59O1xcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpKVxcbn0se1xcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImZzXFxcIjo0MCxcXFwicGF0aFxcXCI6NDB9XSw1NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuLyoqXFxuICogSGVscGVycy5cXG4gKi9cXG5cXG52YXIgcyA9IDEwMDA7XFxudmFyIG0gPSBzICogNjA7XFxudmFyIGggPSBtICogNjA7XFxudmFyIGQgPSBoICogMjQ7XFxudmFyIHkgPSBkICogMzY1LjI1O1xcblxcbi8qKlxcbiAqIFBhcnNlIG9yIGZvcm1hdCB0aGUgZ2l2ZW4gYHZhbGAuXFxuICpcXG4gKiBPcHRpb25zOlxcbiAqXFxuICogIC0gYGxvbmdgIHZlcmJvc2UgZm9ybWF0dGluZyBbZmFsc2VdXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ3xOdW1iZXJ9IHZhbFxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc11cXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcXG4gKiBAcmV0dXJuIHtTdHJpbmd8TnVtYmVyfVxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih2YWwsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgdmFyIHR5cGUgPSB0eXBlb2YgdmFsO1xcbiAgaWYgKHR5cGUgPT09ICdzdHJpbmcnICYmIHZhbC5sZW5ndGggPiAwKSB7XFxuICAgIHJldHVybiBwYXJzZSh2YWwpO1xcbiAgfSBlbHNlIGlmICh0eXBlID09PSAnbnVtYmVyJyAmJiBpc05hTih2YWwpID09PSBmYWxzZSkge1xcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcXG4gIH1cXG4gIHRocm93IG5ldyBFcnJvcihcXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXFxuICAgICAgSlNPTi5zdHJpbmdpZnkodmFsKVxcbiAgKTtcXG59O1xcblxcbi8qKlxcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHJcXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gcGFyc2Uoc3RyKSB7XFxuICBzdHIgPSBTdHJpbmcoc3RyKTtcXG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIHZhciBtYXRjaCA9IC9eKCg/OlxcXFxkKyk/XFxcXC4/XFxcXGQrKSAqKG1pbGxpc2Vjb25kcz98bXNlY3M/fG1zfHNlY29uZHM/fHNlY3M/fHN8bWludXRlcz98bWlucz98bXxob3Vycz98aHJzP3xofGRheXM/fGR8eWVhcnM/fHlycz98eSk/JC9pLmV4ZWMoXFxuICAgIHN0clxcbiAgKTtcXG4gIGlmICghbWF0Y2gpIHtcXG4gICAgcmV0dXJuO1xcbiAgfVxcbiAgdmFyIG4gPSBwYXJzZUZsb2F0KG1hdGNoWzFdKTtcXG4gIHZhciB0eXBlID0gKG1hdGNoWzJdIHx8ICdtcycpLnRvTG93ZXJDYXNlKCk7XFxuICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgY2FzZSAneWVhcnMnOlxcbiAgICBjYXNlICd5ZWFyJzpcXG4gICAgY2FzZSAneXJzJzpcXG4gICAgY2FzZSAneXInOlxcbiAgICBjYXNlICd5JzpcXG4gICAgICByZXR1cm4gbiAqIHk7XFxuICAgIGNhc2UgJ2RheXMnOlxcbiAgICBjYXNlICdkYXknOlxcbiAgICBjYXNlICdkJzpcXG4gICAgICByZXR1cm4gbiAqIGQ7XFxuICAgIGNhc2UgJ2hvdXJzJzpcXG4gICAgY2FzZSAnaG91cic6XFxuICAgIGNhc2UgJ2hycyc6XFxuICAgIGNhc2UgJ2hyJzpcXG4gICAgY2FzZSAnaCc6XFxuICAgICAgcmV0dXJuIG4gKiBoO1xcbiAgICBjYXNlICdtaW51dGVzJzpcXG4gICAgY2FzZSAnbWludXRlJzpcXG4gICAgY2FzZSAnbWlucyc6XFxuICAgIGNhc2UgJ21pbic6XFxuICAgIGNhc2UgJ20nOlxcbiAgICAgIHJldHVybiBuICogbTtcXG4gICAgY2FzZSAnc2Vjb25kcyc6XFxuICAgIGNhc2UgJ3NlY29uZCc6XFxuICAgIGNhc2UgJ3NlY3MnOlxcbiAgICBjYXNlICdzZWMnOlxcbiAgICBjYXNlICdzJzpcXG4gICAgICByZXR1cm4gbiAqIHM7XFxuICAgIGNhc2UgJ21pbGxpc2Vjb25kcyc6XFxuICAgIGNhc2UgJ21pbGxpc2Vjb25kJzpcXG4gICAgY2FzZSAnbXNlY3MnOlxcbiAgICBjYXNlICdtc2VjJzpcXG4gICAgY2FzZSAnbXMnOlxcbiAgICAgIHJldHVybiBuO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XFxuICB9XFxufVxcblxcbi8qKlxcbiAqIFNob3J0IGZvcm1hdCBmb3IgYG1zYC5cXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xcbiAqIEByZXR1cm4ge1N0cmluZ31cXG4gKiBAYXBpIHByaXZhdGVcXG4gKi9cXG5cXG5mdW5jdGlvbiBmbXRTaG9ydChtcykge1xcbiAgaWYgKG1zID49IGQpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBkKSArICdkJztcXG4gIH1cXG4gIGlmIChtcyA+PSBoKSB7XFxuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gaCkgKyAnaCc7XFxuICB9XFxuICBpZiAobXMgPj0gbSkge1xcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIG0pICsgJ20nO1xcbiAgfVxcbiAgaWYgKG1zID49IHMpIHtcXG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBzKSArICdzJztcXG4gIH1cXG4gIHJldHVybiBtcyArICdtcyc7XFxufVxcblxcbi8qKlxcbiAqIExvbmcgZm9ybWF0IGZvciBgbXNgLlxcbiAqXFxuICogQHBhcmFtIHtOdW1iZXJ9IG1zXFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqIEBhcGkgcHJpdmF0ZVxcbiAqL1xcblxcbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcXG4gIHJldHVybiBwbHVyYWwobXMsIGQsICdkYXknKSB8fFxcbiAgICBwbHVyYWwobXMsIGgsICdob3VyJykgfHxcXG4gICAgcGx1cmFsKG1zLCBtLCAnbWludXRlJykgfHxcXG4gICAgcGx1cmFsKG1zLCBzLCAnc2Vjb25kJykgfHxcXG4gICAgbXMgKyAnIG1zJztcXG59XFxuXFxuLyoqXFxuICogUGx1cmFsaXphdGlvbiBoZWxwZXIuXFxuICovXFxuXFxuZnVuY3Rpb24gcGx1cmFsKG1zLCBuLCBuYW1lKSB7XFxuICBpZiAobXMgPCBuKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG4gIGlmIChtcyA8IG4gKiAxLjUpIHtcXG4gICAgcmV0dXJuIE1hdGguZmxvb3IobXMgLyBuKSArICcgJyArIG5hbWU7XFxuICB9XFxuICByZXR1cm4gTWF0aC5jZWlsKG1zIC8gbikgKyAnICcgKyBuYW1lICsgJ3MnO1xcbn1cXG5cXG59LHt9XSw1NTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzKXtcXG4ndXNlIHN0cmljdCc7XFxuXFxuaWYgKCFwcm9jZXNzLnZlcnNpb24gfHxcXG4gICAgcHJvY2Vzcy52ZXJzaW9uLmluZGV4T2YoJ3YwLicpID09PSAwIHx8XFxuICAgIHByb2Nlc3MudmVyc2lvbi5pbmRleE9mKCd2MS4nKSA9PT0gMCAmJiBwcm9jZXNzLnZlcnNpb24uaW5kZXhPZigndjEuOC4nKSAhPT0gMCkge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBuZXh0VGljaztcXG59IGVsc2Uge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBwcm9jZXNzLm5leHRUaWNrO1xcbn1cXG5cXG5mdW5jdGlvbiBuZXh0VGljayhmbiwgYXJnMSwgYXJnMiwgYXJnMykge1xcbiAgaWYgKHR5cGVvZiBmbiAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcXFwiY2FsbGJhY2tcXFwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xcbiAgfVxcbiAgdmFyIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XFxuICB2YXIgYXJncywgaTtcXG4gIHN3aXRjaCAobGVuKSB7XFxuICBjYXNlIDA6XFxuICBjYXNlIDE6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZuKTtcXG4gIGNhc2UgMjpcXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrT25lKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSk7XFxuICAgIH0pO1xcbiAgY2FzZSAzOlxcbiAgICByZXR1cm4gcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiBhZnRlclRpY2tUd28oKSB7XFxuICAgICAgZm4uY2FsbChudWxsLCBhcmcxLCBhcmcyKTtcXG4gICAgfSk7XFxuICBjYXNlIDQ6XFxuICAgIHJldHVybiBwcm9jZXNzLm5leHRUaWNrKGZ1bmN0aW9uIGFmdGVyVGlja1RocmVlKCkge1xcbiAgICAgIGZuLmNhbGwobnVsbCwgYXJnMSwgYXJnMiwgYXJnMyk7XFxuICAgIH0pO1xcbiAgZGVmYXVsdDpcXG4gICAgYXJncyA9IG5ldyBBcnJheShsZW4gLSAxKTtcXG4gICAgaSA9IDA7XFxuICAgIHdoaWxlIChpIDwgYXJncy5sZW5ndGgpIHtcXG4gICAgICBhcmdzW2krK10gPSBhcmd1bWVudHNbaV07XFxuICAgIH1cXG4gICAgcmV0dXJuIHByb2Nlc3MubmV4dFRpY2soZnVuY3Rpb24gYWZ0ZXJUaWNrKCkge1xcbiAgICAgIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xcbiAgICB9KTtcXG4gIH1cXG59XFxuXFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJykpXFxufSx7XFxcIl9wcm9jZXNzXFxcIjo1Nn1dLDU2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XFxuXFxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXFxuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXFxuXFxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XFxudmFyIGNhY2hlZENsZWFyVGltZW91dDtcXG5cXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcXG59XFxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XFxufVxcbihmdW5jdGlvbiAoKSB7XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XFxuICAgICAgICB9XFxuICAgIH0gY2F0Y2ggKGUpIHtcXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcXG4gICAgICAgIH1cXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcXG4gICAgfVxcbn0gKCkpXFxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcXG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcXG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfVxcbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcXG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcXG4gICAgfSBjYXRjaChlKXtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xcbiAgICAgICAgfSBjYXRjaChlKXtcXG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcblxcbn1cXG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XFxuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXFxuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XFxuICAgIH1cXG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcXG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xcbiAgICB9IGNhdGNoIChlKXtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xcbiAgICAgICAgfSBjYXRjaCAoZSl7XFxuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXFxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuXFxuXFxufVxcbnZhciBxdWV1ZSA9IFtdO1xcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xcbnZhciBjdXJyZW50UXVldWU7XFxudmFyIHF1ZXVlSW5kZXggPSAtMTtcXG5cXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XFxuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICB9XFxuICAgIGRyYWluaW5nID0gZmFsc2U7XFxuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XFxuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xcbiAgICB9XFxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcXG4gICAgICAgIGRyYWluUXVldWUoKTtcXG4gICAgfVxcbn1cXG5cXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xcbiAgICBpZiAoZHJhaW5pbmcpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgfVxcbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcXG4gICAgZHJhaW5pbmcgPSB0cnVlO1xcblxcbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xcbiAgICB3aGlsZShsZW4pIHtcXG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xcbiAgICAgICAgcXVldWUgPSBbXTtcXG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcXG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XFxuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XFxuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XFxuICAgIH1cXG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcXG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcXG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xcbn1cXG5cXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XFxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcXG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcXG4gICAgfVxcbn07XFxuXFxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xcbiAgICB0aGlzLmZ1biA9IGZ1bjtcXG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xcbn1cXG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XFxuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xcbn07XFxucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcXG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xcbnByb2Nlc3MuZW52ID0ge307XFxucHJvY2Vzcy5hcmd2ID0gW107XFxucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXFxucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xcblxcbmZ1bmN0aW9uIG5vb3AoKSB7fVxcblxcbnByb2Nlc3Mub24gPSBub29wO1xcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3Mub25jZSA9IG5vb3A7XFxucHJvY2Vzcy5vZmYgPSBub29wO1xcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcXG5wcm9jZXNzLmVtaXQgPSBub29wO1xcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcXG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xcblxcbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cXG5cXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5cXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XFxuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XFxufTtcXG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xcblxcbn0se31dLDU3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL19zdHJlYW1fZHVwbGV4LmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fZHVwbGV4LmpzXFxcIjo1OH1dLDU4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIGR1cGxleCBzdHJlYW0gaXMganVzdCBhIHN0cmVhbSB0aGF0IGlzIGJvdGggcmVhZGFibGUgYW5kIHdyaXRhYmxlLlxcbi8vIFNpbmNlIEpTIGRvZXNuJ3QgaGF2ZSBtdWx0aXBsZSBwcm90b3R5cGFsIGluaGVyaXRhbmNlLCB0aGlzIGNsYXNzXFxuLy8gcHJvdG90eXBhbGx5IGluaGVyaXRzIGZyb20gUmVhZGFibGUsIGFuZCB0aGVuIHBhcmFzaXRpY2FsbHkgZnJvbVxcbi8vIFdyaXRhYmxlLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIG9iamVjdEtleXMgPSBPYmplY3Qua2V5cyB8fCBmdW5jdGlvbiAob2JqKSB7XFxuICB2YXIga2V5cyA9IFtdO1xcbiAgZm9yICh2YXIga2V5IGluIG9iaikge1xcbiAgICBrZXlzLnB1c2goa2V5KTtcXG4gIH1yZXR1cm4ga2V5cztcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gRHVwbGV4O1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG52YXIgUmVhZGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fcmVhZGFibGUnKTtcXG52YXIgV3JpdGFibGUgPSByZXF1aXJlKCcuL19zdHJlYW1fd3JpdGFibGUnKTtcXG5cXG51dGlsLmluaGVyaXRzKER1cGxleCwgUmVhZGFibGUpO1xcblxcbnZhciBrZXlzID0gb2JqZWN0S2V5cyhXcml0YWJsZS5wcm90b3R5cGUpO1xcbmZvciAodmFyIHYgPSAwOyB2IDwga2V5cy5sZW5ndGg7IHYrKykge1xcbiAgdmFyIG1ldGhvZCA9IGtleXNbdl07XFxuICBpZiAoIUR1cGxleC5wcm90b3R5cGVbbWV0aG9kXSkgRHVwbGV4LnByb3RvdHlwZVttZXRob2RdID0gV3JpdGFibGUucHJvdG90eXBlW21ldGhvZF07XFxufVxcblxcbmZ1bmN0aW9uIER1cGxleChvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgRHVwbGV4KSkgcmV0dXJuIG5ldyBEdXBsZXgob3B0aW9ucyk7XFxuXFxuICBSZWFkYWJsZS5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcbiAgV3JpdGFibGUuY2FsbCh0aGlzLCBvcHRpb25zKTtcXG5cXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucmVhZGFibGUgPT09IGZhbHNlKSB0aGlzLnJlYWRhYmxlID0gZmFsc2U7XFxuXFxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLndyaXRhYmxlID09PSBmYWxzZSkgdGhpcy53cml0YWJsZSA9IGZhbHNlO1xcblxcbiAgdGhpcy5hbGxvd0hhbGZPcGVuID0gdHJ1ZTtcXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuYWxsb3dIYWxmT3BlbiA9PT0gZmFsc2UpIHRoaXMuYWxsb3dIYWxmT3BlbiA9IGZhbHNlO1xcblxcbiAgdGhpcy5vbmNlKCdlbmQnLCBvbmVuZCk7XFxufVxcblxcbi8vIHRoZSBuby1oYWxmLW9wZW4gZW5mb3JjZXJcXG5mdW5jdGlvbiBvbmVuZCgpIHtcXG4gIC8vIGlmIHdlIGFsbG93IGhhbGYtb3BlbiBzdGF0ZSwgb3IgaWYgdGhlIHdyaXRhYmxlIHNpZGUgZW5kZWQsXFxuICAvLyB0aGVuIHdlJ3JlIG9rLlxcbiAgaWYgKHRoaXMuYWxsb3dIYWxmT3BlbiB8fCB0aGlzLl93cml0YWJsZVN0YXRlLmVuZGVkKSByZXR1cm47XFxuXFxuICAvLyBubyBtb3JlIGRhdGEgY2FuIGJlIHdyaXR0ZW4uXFxuICAvLyBCdXQgYWxsb3cgbW9yZSB3cml0ZXMgdG8gaGFwcGVuIGluIHRoaXMgdGljay5cXG4gIHByb2Nlc3NOZXh0VGljayhvbkVuZE5ULCB0aGlzKTtcXG59XFxuXFxuZnVuY3Rpb24gb25FbmROVChzZWxmKSB7XFxuICBzZWxmLmVuZCgpO1xcbn1cXG5cXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoRHVwbGV4LnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkIHx8IHRoaXMuX3dyaXRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCkge1xcbiAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgJiYgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQ7XFxuICB9LFxcbiAgc2V0OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgLy8gd2UgaWdub3JlIHRoZSB2YWx1ZSBpZiB0aGUgc3RyZWFtXFxuICAgIC8vIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZCB5ZXRcXG4gICAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUgPT09IHVuZGVmaW5lZCB8fCB0aGlzLl93cml0YWJsZVN0YXRlID09PSB1bmRlZmluZWQpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcXG4gIH1cXG59KTtcXG5cXG5EdXBsZXgucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcXG4gIHRoaXMucHVzaChudWxsKTtcXG4gIHRoaXMuZW5kKCk7XFxuXFxuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVycik7XFxufTtcXG5cXG5mdW5jdGlvbiBmb3JFYWNoKHhzLCBmKSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBmKHhzW2ldLCBpKTtcXG4gIH1cXG59XFxufSx7XFxcIi4vX3N0cmVhbV9yZWFkYWJsZVxcXCI6NjAsXFxcIi4vX3N0cmVhbV93cml0YWJsZVxcXCI6NjIsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImluaGVyaXRzXFxcIjo1MCxcXFwicHJvY2Vzcy1uZXh0aWNrLWFyZ3NcXFwiOjU1fV0sNTk6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbi8vIGEgcGFzc3Rocm91Z2ggc3RyZWFtLlxcbi8vIGJhc2ljYWxseSBqdXN0IHRoZSBtb3N0IG1pbmltYWwgc29ydCBvZiBUcmFuc2Zvcm0gc3RyZWFtLlxcbi8vIEV2ZXJ5IHdyaXR0ZW4gY2h1bmsgZ2V0cyBvdXRwdXQgYXMtaXMuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbm1vZHVsZS5leHBvcnRzID0gUGFzc1Rocm91Z2g7XFxuXFxudmFyIFRyYW5zZm9ybSA9IHJlcXVpcmUoJy4vX3N0cmVhbV90cmFuc2Zvcm0nKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhQYXNzVGhyb3VnaCwgVHJhbnNmb3JtKTtcXG5cXG5mdW5jdGlvbiBQYXNzVGhyb3VnaChvcHRpb25zKSB7XFxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUGFzc1Rocm91Z2gpKSByZXR1cm4gbmV3IFBhc3NUaHJvdWdoKG9wdGlvbnMpO1xcblxcbiAgVHJhbnNmb3JtLmNhbGwodGhpcywgb3B0aW9ucyk7XFxufVxcblxcblBhc3NUaHJvdWdoLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGNiKG51bGwsIGNodW5rKTtcXG59O1xcbn0se1xcXCIuL19zdHJlYW1fdHJhbnNmb3JtXFxcIjo2MSxcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwfV0sNjA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbihmdW5jdGlvbiAocHJvY2VzcyxnbG9iYWwpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbm1vZHVsZS5leHBvcnRzID0gUmVhZGFibGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgaXNBcnJheSA9IHJlcXVpcmUoJ2lzYXJyYXknKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBEdXBsZXg7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuUmVhZGFibGUuUmVhZGFibGVTdGF0ZSA9IFJlYWRhYmxlU3RhdGU7XFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRUUgPSByZXF1aXJlKCdldmVudHMnKS5FdmVudEVtaXR0ZXI7XFxuXFxudmFyIEVFbGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uIChlbWl0dGVyLCB0eXBlKSB7XFxuICByZXR1cm4gZW1pdHRlci5saXN0ZW5lcnModHlwZSkubGVuZ3RoO1xcbn07XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgU3RyZWFtID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbScpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8vIFRPRE8oYm1ldXJlcik6IENoYW5nZSB0aGlzIGJhY2sgdG8gY29uc3Qgb25jZSBob2xlIGNoZWNrcyBhcmVcXG4vLyBwcm9wZXJseSBvcHRpbWl6ZWQgYXdheSBlYXJseSBpbiBJZ25pdGlvbitUdXJib0Zhbi5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcXG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XFxufVxcbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XFxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcXG59XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgdXRpbCA9IHJlcXVpcmUoJ2NvcmUtdXRpbC1pcycpO1xcbnV0aWwuaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIGRlYnVnVXRpbCA9IHJlcXVpcmUoJ3V0aWwnKTtcXG52YXIgZGVidWcgPSB2b2lkIDA7XFxuaWYgKGRlYnVnVXRpbCAmJiBkZWJ1Z1V0aWwuZGVidWdsb2cpIHtcXG4gIGRlYnVnID0gZGVidWdVdGlsLmRlYnVnbG9nKCdzdHJlYW0nKTtcXG59IGVsc2Uge1xcbiAgZGVidWcgPSBmdW5jdGlvbiAoKSB7fTtcXG59XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIEJ1ZmZlckxpc3QgPSByZXF1aXJlKCcuL2ludGVybmFsL3N0cmVhbXMvQnVmZmVyTGlzdCcpO1xcbnZhciBkZXN0cm95SW1wbCA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95Jyk7XFxudmFyIFN0cmluZ0RlY29kZXI7XFxuXFxudXRpbC5pbmhlcml0cyhSZWFkYWJsZSwgU3RyZWFtKTtcXG5cXG52YXIga1Byb3h5RXZlbnRzID0gWydlcnJvcicsICdjbG9zZScsICdkZXN0cm95JywgJ3BhdXNlJywgJ3Jlc3VtZSddO1xcblxcbmZ1bmN0aW9uIHByZXBlbmRMaXN0ZW5lcihlbWl0dGVyLCBldmVudCwgZm4pIHtcXG4gIC8vIFNhZGx5IHRoaXMgaXMgbm90IGNhY2hlYWJsZSBhcyBzb21lIGxpYnJhcmllcyBidW5kbGUgdGhlaXIgb3duXFxuICAvLyBldmVudCBlbWl0dGVyIGltcGxlbWVudGF0aW9uIHdpdGggdGhlbS5cXG4gIGlmICh0eXBlb2YgZW1pdHRlci5wcmVwZW5kTGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgcmV0dXJuIGVtaXR0ZXIucHJlcGVuZExpc3RlbmVyKGV2ZW50LCBmbik7XFxuICB9IGVsc2Uge1xcbiAgICAvLyBUaGlzIGlzIGEgaGFjayB0byBtYWtlIHN1cmUgdGhhdCBvdXIgZXJyb3IgaGFuZGxlciBpcyBhdHRhY2hlZCBiZWZvcmUgYW55XFxuICAgIC8vIHVzZXJsYW5kIG9uZXMuICBORVZFUiBETyBUSElTLiBUaGlzIGlzIGhlcmUgb25seSBiZWNhdXNlIHRoaXMgY29kZSBuZWVkc1xcbiAgICAvLyB0byBjb250aW51ZSB0byB3b3JrIHdpdGggb2xkZXIgdmVyc2lvbnMgb2YgTm9kZS5qcyB0aGF0IGRvIG5vdCBpbmNsdWRlXFxuICAgIC8vIHRoZSBwcmVwZW5kTGlzdGVuZXIoKSBtZXRob2QuIFRoZSBnb2FsIGlzIHRvIGV2ZW50dWFsbHkgcmVtb3ZlIHRoaXMgaGFjay5cXG4gICAgaWYgKCFlbWl0dGVyLl9ldmVudHMgfHwgIWVtaXR0ZXIuX2V2ZW50c1tldmVudF0pIGVtaXR0ZXIub24oZXZlbnQsIGZuKTtlbHNlIGlmIChpc0FycmF5KGVtaXR0ZXIuX2V2ZW50c1tldmVudF0pKSBlbWl0dGVyLl9ldmVudHNbZXZlbnRdLnVuc2hpZnQoZm4pO2Vsc2UgZW1pdHRlci5fZXZlbnRzW2V2ZW50XSA9IFtmbiwgZW1pdHRlci5fZXZlbnRzW2V2ZW50XV07XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIFJlYWRhYmxlU3RhdGUob3B0aW9ucywgc3RyZWFtKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAvLyBvYmplY3Qgc3RyZWFtIGZsYWcuIFVzZWQgdG8gbWFrZSByZWFkKG4pIGlnbm9yZSBuIGFuZCB0b1xcbiAgLy8gbWFrZSBhbGwgdGhlIGJ1ZmZlciBtZXJnaW5nIGFuZCBsZW5ndGggY2hlY2tzIGdvIGF3YXlcXG4gIHRoaXMub2JqZWN0TW9kZSA9ICEhb3B0aW9ucy5vYmplY3RNb2RlO1xcblxcbiAgaWYgKHN0cmVhbSBpbnN0YW5jZW9mIER1cGxleCkgdGhpcy5vYmplY3RNb2RlID0gdGhpcy5vYmplY3RNb2RlIHx8ICEhb3B0aW9ucy5yZWFkYWJsZU9iamVjdE1vZGU7XFxuXFxuICAvLyB0aGUgcG9pbnQgYXQgd2hpY2ggaXQgc3RvcHMgY2FsbGluZyBfcmVhZCgpIHRvIGZpbGwgdGhlIGJ1ZmZlclxcbiAgLy8gTm90ZTogMCBpcyBhIHZhbGlkIHZhbHVlLCBtZWFucyBcXFwiZG9uJ3QgY2FsbCBfcmVhZCBwcmVlbXB0aXZlbHkgZXZlclxcXCJcXG4gIHZhciBod20gPSBvcHRpb25zLmhpZ2hXYXRlck1hcms7XFxuICB2YXIgZGVmYXVsdEh3bSA9IHRoaXMub2JqZWN0TW9kZSA/IDE2IDogMTYgKiAxMDI0O1xcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gaHdtIHx8IGh3bSA9PT0gMCA/IGh3bSA6IGRlZmF1bHRId207XFxuXFxuICAvLyBjYXN0IHRvIGludHMuXFxuICB0aGlzLmhpZ2hXYXRlck1hcmsgPSBNYXRoLmZsb29yKHRoaXMuaGlnaFdhdGVyTWFyayk7XFxuXFxuICAvLyBBIGxpbmtlZCBsaXN0IGlzIHVzZWQgdG8gc3RvcmUgZGF0YSBjaHVua3MgaW5zdGVhZCBvZiBhbiBhcnJheSBiZWNhdXNlIHRoZVxcbiAgLy8gbGlua2VkIGxpc3QgY2FuIHJlbW92ZSBlbGVtZW50cyBmcm9tIHRoZSBiZWdpbm5pbmcgZmFzdGVyIHRoYW5cXG4gIC8vIGFycmF5LnNoaWZ0KClcXG4gIHRoaXMuYnVmZmVyID0gbmV3IEJ1ZmZlckxpc3QoKTtcXG4gIHRoaXMubGVuZ3RoID0gMDtcXG4gIHRoaXMucGlwZXMgPSBudWxsO1xcbiAgdGhpcy5waXBlc0NvdW50ID0gMDtcXG4gIHRoaXMuZmxvd2luZyA9IG51bGw7XFxuICB0aGlzLmVuZGVkID0gZmFsc2U7XFxuICB0aGlzLmVuZEVtaXR0ZWQgPSBmYWxzZTtcXG4gIHRoaXMucmVhZGluZyA9IGZhbHNlO1xcblxcbiAgLy8gYSBmbGFnIHRvIGJlIGFibGUgdG8gdGVsbCBpZiB0aGUgZXZlbnQgJ3JlYWRhYmxlJy8nZGF0YScgaXMgZW1pdHRlZFxcbiAgLy8gaW1tZWRpYXRlbHksIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2VcXG4gIC8vIGFueSBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHJlYWQgY2FsbC5cXG4gIHRoaXMuc3luYyA9IHRydWU7XFxuXFxuICAvLyB3aGVuZXZlciB3ZSByZXR1cm4gbnVsbCwgdGhlbiB3ZSBzZXQgYSBmbGFnIHRvIHNheVxcbiAgLy8gdGhhdCB3ZSdyZSBhd2FpdGluZyBhICdyZWFkYWJsZScgZXZlbnQgZW1pc3Npb24uXFxuICB0aGlzLm5lZWRSZWFkYWJsZSA9IGZhbHNlO1xcbiAgdGhpcy5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG4gIHRoaXMucmVhZGFibGVMaXN0ZW5pbmcgPSBmYWxzZTtcXG4gIHRoaXMucmVzdW1lU2NoZWR1bGVkID0gZmFsc2U7XFxuXFxuICAvLyBoYXMgaXQgYmVlbiBkZXN0cm95ZWRcXG4gIHRoaXMuZGVzdHJveWVkID0gZmFsc2U7XFxuXFxuICAvLyBDcnlwdG8gaXMga2luZCBvZiBvbGQgYW5kIGNydXN0eS4gIEhpc3RvcmljYWxseSwgaXRzIGRlZmF1bHQgc3RyaW5nXFxuICAvLyBlbmNvZGluZyBpcyAnYmluYXJ5JyBzbyB3ZSBoYXZlIHRvIG1ha2UgdGhpcyBjb25maWd1cmFibGUuXFxuICAvLyBFdmVyeXRoaW5nIGVsc2UgaW4gdGhlIHVuaXZlcnNlIHVzZXMgJ3V0ZjgnLCB0aG91Z2guXFxuICB0aGlzLmRlZmF1bHRFbmNvZGluZyA9IG9wdGlvbnMuZGVmYXVsdEVuY29kaW5nIHx8ICd1dGY4JztcXG5cXG4gIC8vIHRoZSBudW1iZXIgb2Ygd3JpdGVycyB0aGF0IGFyZSBhd2FpdGluZyBhIGRyYWluIGV2ZW50IGluIC5waXBlKClzXFxuICB0aGlzLmF3YWl0RHJhaW4gPSAwO1xcblxcbiAgLy8gaWYgdHJ1ZSwgYSBtYXliZVJlYWRNb3JlIGhhcyBiZWVuIHNjaGVkdWxlZFxcbiAgdGhpcy5yZWFkaW5nTW9yZSA9IGZhbHNlO1xcblxcbiAgdGhpcy5kZWNvZGVyID0gbnVsbDtcXG4gIHRoaXMuZW5jb2RpbmcgPSBudWxsO1xcbiAgaWYgKG9wdGlvbnMuZW5jb2RpbmcpIHtcXG4gICAgaWYgKCFTdHJpbmdEZWNvZGVyKSBTdHJpbmdEZWNvZGVyID0gcmVxdWlyZSgnc3RyaW5nX2RlY29kZXIvJykuU3RyaW5nRGVjb2RlcjtcXG4gICAgdGhpcy5kZWNvZGVyID0gbmV3IFN0cmluZ0RlY29kZXIob3B0aW9ucy5lbmNvZGluZyk7XFxuICAgIHRoaXMuZW5jb2RpbmcgPSBvcHRpb25zLmVuY29kaW5nO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBSZWFkYWJsZShvcHRpb25zKSB7XFxuICBEdXBsZXggPSBEdXBsZXggfHwgcmVxdWlyZSgnLi9fc3RyZWFtX2R1cGxleCcpO1xcblxcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFJlYWRhYmxlKSkgcmV0dXJuIG5ldyBSZWFkYWJsZShvcHRpb25zKTtcXG5cXG4gIHRoaXMuX3JlYWRhYmxlU3RhdGUgPSBuZXcgUmVhZGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeVxcbiAgdGhpcy5yZWFkYWJsZSA9IHRydWU7XFxuXFxuICBpZiAob3B0aW9ucykge1xcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMucmVhZCA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fcmVhZCA9IG9wdGlvbnMucmVhZDtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmRlc3Ryb3kgPT09ICdmdW5jdGlvbicpIHRoaXMuX2Rlc3Ryb3kgPSBvcHRpb25zLmRlc3Ryb3k7XFxuICB9XFxuXFxuICBTdHJlYW0uY2FsbCh0aGlzKTtcXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlYWRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxcbiAgICBpZiAoIXRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcXG4gIH1cXG59KTtcXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XFxuUmVhZGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XFxuUmVhZGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcXG4gIHRoaXMucHVzaChudWxsKTtcXG4gIGNiKGVycik7XFxufTtcXG5cXG4vLyBNYW51YWxseSBzaG92ZSBzb21ldGhpbmcgaW50byB0aGUgcmVhZCgpIGJ1ZmZlci5cXG4vLyBUaGlzIHJldHVybnMgdHJ1ZSBpZiB0aGUgaGlnaFdhdGVyTWFyayBoYXMgbm90IGJlZW4gaGl0IHlldCxcXG4vLyBzaW1pbGFyIHRvIGhvdyBXcml0YWJsZS53cml0ZSgpIHJldHVybnMgdHJ1ZSBpZiB5b3Ugc2hvdWxkXFxuLy8gd3JpdGUoKSBzb21lIG1vcmUuXFxuUmVhZGFibGUucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIHNraXBDaHVua0NoZWNrO1xcblxcbiAgaWYgKCFzdGF0ZS5vYmplY3RNb2RlKSB7XFxuICAgIGlmICh0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyB8fCBzdGF0ZS5kZWZhdWx0RW5jb2Rpbmc7XFxuICAgICAgaWYgKGVuY29kaW5nICE9PSBzdGF0ZS5lbmNvZGluZykge1xcbiAgICAgICAgY2h1bmsgPSBCdWZmZXIuZnJvbShjaHVuaywgZW5jb2RpbmcpO1xcbiAgICAgICAgZW5jb2RpbmcgPSAnJztcXG4gICAgICB9XFxuICAgICAgc2tpcENodW5rQ2hlY2sgPSB0cnVlO1xcbiAgICB9XFxuICB9IGVsc2Uge1xcbiAgICBza2lwQ2h1bmtDaGVjayA9IHRydWU7XFxuICB9XFxuXFxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgZW5jb2RpbmcsIGZhbHNlLCBza2lwQ2h1bmtDaGVjayk7XFxufTtcXG5cXG4vLyBVbnNoaWZ0IHNob3VsZCAqYWx3YXlzKiBiZSBzb21ldGhpbmcgZGlyZWN0bHkgb3V0IG9mIHJlYWQoKVxcblJlYWRhYmxlLnByb3RvdHlwZS51bnNoaWZ0ID0gZnVuY3Rpb24gKGNodW5rKSB7XFxuICByZXR1cm4gcmVhZGFibGVBZGRDaHVuayh0aGlzLCBjaHVuaywgbnVsbCwgdHJ1ZSwgZmFsc2UpO1xcbn07XFxuXFxuZnVuY3Rpb24gcmVhZGFibGVBZGRDaHVuayhzdHJlYW0sIGNodW5rLCBlbmNvZGluZywgYWRkVG9Gcm9udCwgc2tpcENodW5rQ2hlY2spIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fcmVhZGFibGVTdGF0ZTtcXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gZmFsc2U7XFxuICAgIG9uRW9mQ2h1bmsoc3RyZWFtLCBzdGF0ZSk7XFxuICB9IGVsc2Uge1xcbiAgICB2YXIgZXI7XFxuICAgIGlmICghc2tpcENodW5rQ2hlY2spIGVyID0gY2h1bmtJbnZhbGlkKHN0YXRlLCBjaHVuayk7XFxuICAgIGlmIChlcikge1xcbiAgICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gICAgfSBlbHNlIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rICYmIGNodW5rLmxlbmd0aCA+IDApIHtcXG4gICAgICBpZiAodHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiAhc3RhdGUub2JqZWN0TW9kZSAmJiBPYmplY3QuZ2V0UHJvdG90eXBlT2YoY2h1bmspICE9PSBCdWZmZXIucHJvdG90eXBlKSB7XFxuICAgICAgICBjaHVuayA9IF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAoYWRkVG9Gcm9udCkge1xcbiAgICAgICAgaWYgKHN0YXRlLmVuZEVtaXR0ZWQpIHN0cmVhbS5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignc3RyZWFtLnVuc2hpZnQoKSBhZnRlciBlbmQgZXZlbnQnKSk7ZWxzZSBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgdHJ1ZSk7XFxuICAgICAgfSBlbHNlIGlmIChzdGF0ZS5lbmRlZCkge1xcbiAgICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgbmV3IEVycm9yKCdzdHJlYW0ucHVzaCgpIGFmdGVyIEVPRicpKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgc3RhdGUucmVhZGluZyA9IGZhbHNlO1xcbiAgICAgICAgaWYgKHN0YXRlLmRlY29kZXIgJiYgIWVuY29kaW5nKSB7XFxuICAgICAgICAgIGNodW5rID0gc3RhdGUuZGVjb2Rlci53cml0ZShjaHVuayk7XFxuICAgICAgICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlIHx8IGNodW5rLmxlbmd0aCAhPT0gMCkgYWRkQ2h1bmsoc3RyZWFtLCBzdGF0ZSwgY2h1bmssIGZhbHNlKTtlbHNlIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBhZGRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgZmFsc2UpO1xcbiAgICAgICAgfVxcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmICghYWRkVG9Gcm9udCkge1xcbiAgICAgIHN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIG5lZWRNb3JlRGF0YShzdGF0ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGFkZENodW5rKHN0cmVhbSwgc3RhdGUsIGNodW5rLCBhZGRUb0Zyb250KSB7XFxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiBzdGF0ZS5sZW5ndGggPT09IDAgJiYgIXN0YXRlLnN5bmMpIHtcXG4gICAgc3RyZWFtLmVtaXQoJ2RhdGEnLCBjaHVuayk7XFxuICAgIHN0cmVhbS5yZWFkKDApO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gdXBkYXRlIHRoZSBidWZmZXIgaW5mby5cXG4gICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcbiAgICBpZiAoYWRkVG9Gcm9udCkgc3RhdGUuYnVmZmVyLnVuc2hpZnQoY2h1bmspO2Vsc2Ugc3RhdGUuYnVmZmVyLnB1c2goY2h1bmspO1xcblxcbiAgICBpZiAoc3RhdGUubmVlZFJlYWRhYmxlKSBlbWl0UmVhZGFibGUoc3RyZWFtKTtcXG4gIH1cXG4gIG1heWJlUmVhZE1vcmUoc3RyZWFtLCBzdGF0ZSk7XFxufVxcblxcbmZ1bmN0aW9uIGNodW5rSW52YWxpZChzdGF0ZSwgY2h1bmspIHtcXG4gIHZhciBlcjtcXG4gIGlmICghX2lzVWludDhBcnJheShjaHVuaykgJiYgdHlwZW9mIGNodW5rICE9PSAnc3RyaW5nJyAmJiBjaHVuayAhPT0gdW5kZWZpbmVkICYmICFzdGF0ZS5vYmplY3RNb2RlKSB7XFxuICAgIGVyID0gbmV3IFR5cGVFcnJvcignSW52YWxpZCBub24tc3RyaW5nL2J1ZmZlciBjaHVuaycpO1xcbiAgfVxcbiAgcmV0dXJuIGVyO1xcbn1cXG5cXG4vLyBpZiBpdCdzIHBhc3QgdGhlIGhpZ2ggd2F0ZXIgbWFyaywgd2UgY2FuIHB1c2ggaW4gc29tZSBtb3JlLlxcbi8vIEFsc28sIGlmIHdlIGhhdmUgbm8gZGF0YSB5ZXQsIHdlIGNhbiBzdGFuZCBzb21lXFxuLy8gbW9yZSBieXRlcy4gIFRoaXMgaXMgdG8gd29yayBhcm91bmQgY2FzZXMgd2hlcmUgaHdtPTAsXFxuLy8gc3VjaCBhcyB0aGUgcmVwbC4gIEFsc28sIGlmIHRoZSBwdXNoKCkgdHJpZ2dlcmVkIGFcXG4vLyByZWFkYWJsZSBldmVudCwgYW5kIHRoZSB1c2VyIGNhbGxlZCByZWFkKGxhcmdlTnVtYmVyKSBzdWNoIHRoYXRcXG4vLyBuZWVkUmVhZGFibGUgd2FzIHNldCwgdGhlbiB3ZSBvdWdodCB0byBwdXNoIG1vcmUsIHNvIHRoYXQgYW5vdGhlclxcbi8vICdyZWFkYWJsZScgZXZlbnQgd2lsbCBiZSB0cmlnZ2VyZWQuXFxuZnVuY3Rpb24gbmVlZE1vcmVEYXRhKHN0YXRlKSB7XFxuICByZXR1cm4gIXN0YXRlLmVuZGVkICYmIChzdGF0ZS5uZWVkUmVhZGFibGUgfHwgc3RhdGUubGVuZ3RoIDwgc3RhdGUuaGlnaFdhdGVyTWFyayB8fCBzdGF0ZS5sZW5ndGggPT09IDApO1xcbn1cXG5cXG5SZWFkYWJsZS5wcm90b3R5cGUuaXNQYXVzZWQgPSBmdW5jdGlvbiAoKSB7XFxuICByZXR1cm4gdGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nID09PSBmYWxzZTtcXG59O1xcblxcbi8vIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxcblJlYWRhYmxlLnByb3RvdHlwZS5zZXRFbmNvZGluZyA9IGZ1bmN0aW9uIChlbmMpIHtcXG4gIGlmICghU3RyaW5nRGVjb2RlcikgU3RyaW5nRGVjb2RlciA9IHJlcXVpcmUoJ3N0cmluZ19kZWNvZGVyLycpLlN0cmluZ0RlY29kZXI7XFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlY29kZXIgPSBuZXcgU3RyaW5nRGVjb2RlcihlbmMpO1xcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmNvZGluZyA9IGVuYztcXG4gIHJldHVybiB0aGlzO1xcbn07XFxuXFxuLy8gRG9uJ3QgcmFpc2UgdGhlIGh3bSA+IDhNQlxcbnZhciBNQVhfSFdNID0gMHg4MDAwMDA7XFxuZnVuY3Rpb24gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobikge1xcbiAgaWYgKG4gPj0gTUFYX0hXTSkge1xcbiAgICBuID0gTUFYX0hXTTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIEdldCB0aGUgbmV4dCBoaWdoZXN0IHBvd2VyIG9mIDIgdG8gcHJldmVudCBpbmNyZWFzaW5nIGh3bSBleGNlc3NpdmVseSBpblxcbiAgICAvLyB0aW55IGFtb3VudHNcXG4gICAgbi0tO1xcbiAgICBuIHw9IG4gPj4+IDE7XFxuICAgIG4gfD0gbiA+Pj4gMjtcXG4gICAgbiB8PSBuID4+PiA0O1xcbiAgICBuIHw9IG4gPj4+IDg7XFxuICAgIG4gfD0gbiA+Pj4gMTY7XFxuICAgIG4rKztcXG4gIH1cXG4gIHJldHVybiBuO1xcbn1cXG5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gaG93TXVjaFRvUmVhZChuLCBzdGF0ZSkge1xcbiAgaWYgKG4gPD0gMCB8fCBzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUuZW5kZWQpIHJldHVybiAwO1xcbiAgaWYgKHN0YXRlLm9iamVjdE1vZGUpIHJldHVybiAxO1xcbiAgaWYgKG4gIT09IG4pIHtcXG4gICAgLy8gT25seSBmbG93IG9uZSBidWZmZXIgYXQgYSB0aW1lXFxuICAgIGlmIChzdGF0ZS5mbG93aW5nICYmIHN0YXRlLmxlbmd0aCkgcmV0dXJuIHN0YXRlLmJ1ZmZlci5oZWFkLmRhdGEubGVuZ3RoO2Vsc2UgcmV0dXJuIHN0YXRlLmxlbmd0aDtcXG4gIH1cXG4gIC8vIElmIHdlJ3JlIGFza2luZyBmb3IgbW9yZSB0aGFuIHRoZSBjdXJyZW50IGh3bSwgdGhlbiByYWlzZSB0aGUgaHdtLlxcbiAgaWYgKG4gPiBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSBzdGF0ZS5oaWdoV2F0ZXJNYXJrID0gY29tcHV0ZU5ld0hpZ2hXYXRlck1hcmsobik7XFxuICBpZiAobiA8PSBzdGF0ZS5sZW5ndGgpIHJldHVybiBuO1xcbiAgLy8gRG9uJ3QgaGF2ZSBlbm91Z2hcXG4gIGlmICghc3RhdGUuZW5kZWQpIHtcXG4gICAgc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgcmV0dXJuIDA7XFxuICB9XFxuICByZXR1cm4gc3RhdGUubGVuZ3RoO1xcbn1cXG5cXG4vLyB5b3UgY2FuIG92ZXJyaWRlIGVpdGhlciB0aGlzIG1ldGhvZCwgb3IgdGhlIGFzeW5jIF9yZWFkKG4pIGJlbG93LlxcblJlYWRhYmxlLnByb3RvdHlwZS5yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIGRlYnVnKCdyZWFkJywgbik7XFxuICBuID0gcGFyc2VJbnQobiwgMTApO1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIHZhciBuT3JpZyA9IG47XFxuXFxuICBpZiAobiAhPT0gMCkgc3RhdGUuZW1pdHRlZFJlYWRhYmxlID0gZmFsc2U7XFxuXFxuICAvLyBpZiB3ZSdyZSBkb2luZyByZWFkKDApIHRvIHRyaWdnZXIgYSByZWFkYWJsZSBldmVudCwgYnV0IHdlXFxuICAvLyBhbHJlYWR5IGhhdmUgYSBidW5jaCBvZiBkYXRhIGluIHRoZSBidWZmZXIsIHRoZW4ganVzdCB0cmlnZ2VyXFxuICAvLyB0aGUgJ3JlYWRhYmxlJyBldmVudCBhbmQgbW92ZSBvbi5cXG4gIGlmIChuID09PSAwICYmIHN0YXRlLm5lZWRSZWFkYWJsZSAmJiAoc3RhdGUubGVuZ3RoID49IHN0YXRlLmhpZ2hXYXRlck1hcmsgfHwgc3RhdGUuZW5kZWQpKSB7XFxuICAgIGRlYnVnKCdyZWFkOiBlbWl0UmVhZGFibGUnLCBzdGF0ZS5sZW5ndGgsIHN0YXRlLmVuZGVkKTtcXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5lbmRlZCkgZW5kUmVhZGFibGUodGhpcyk7ZWxzZSBlbWl0UmVhZGFibGUodGhpcyk7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgbiA9IGhvd011Y2hUb1JlYWQobiwgc3RhdGUpO1xcblxcbiAgLy8gaWYgd2UndmUgZW5kZWQsIGFuZCB3ZSdyZSBub3cgY2xlYXIsIHRoZW4gZmluaXNoIGl0IHVwLlxcbiAgaWYgKG4gPT09IDAgJiYgc3RhdGUuZW5kZWQpIHtcXG4gICAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCkgZW5kUmVhZGFibGUodGhpcyk7XFxuICAgIHJldHVybiBudWxsO1xcbiAgfVxcblxcbiAgLy8gQWxsIHRoZSBhY3R1YWwgY2h1bmsgZ2VuZXJhdGlvbiBsb2dpYyBuZWVkcyB0byBiZVxcbiAgLy8gKmJlbG93KiB0aGUgY2FsbCB0byBfcmVhZC4gIFRoZSByZWFzb24gaXMgdGhhdCBpbiBjZXJ0YWluXFxuICAvLyBzeW50aGV0aWMgc3RyZWFtIGNhc2VzLCBzdWNoIGFzIHBhc3N0aHJvdWdoIHN0cmVhbXMsIF9yZWFkXFxuICAvLyBtYXkgYmUgYSBjb21wbGV0ZWx5IHN5bmNocm9ub3VzIG9wZXJhdGlvbiB3aGljaCBtYXkgY2hhbmdlXFxuICAvLyB0aGUgc3RhdGUgb2YgdGhlIHJlYWQgYnVmZmVyLCBwcm92aWRpbmcgZW5vdWdoIGRhdGEgd2hlblxcbiAgLy8gYmVmb3JlIHRoZXJlIHdhcyAqbm90KiBlbm91Z2guXFxuICAvL1xcbiAgLy8gU28sIHRoZSBzdGVwcyBhcmU6XFxuICAvLyAxLiBGaWd1cmUgb3V0IHdoYXQgdGhlIHN0YXRlIG9mIHRoaW5ncyB3aWxsIGJlIGFmdGVyIHdlIGRvXFxuICAvLyBhIHJlYWQgZnJvbSB0aGUgYnVmZmVyLlxcbiAgLy9cXG4gIC8vIDIuIElmIHRoYXQgcmVzdWx0aW5nIHN0YXRlIHdpbGwgdHJpZ2dlciBhIF9yZWFkLCB0aGVuIGNhbGwgX3JlYWQuXFxuICAvLyBOb3RlIHRoYXQgdGhpcyBtYXkgYmUgYXN5bmNocm9ub3VzLCBvciBzeW5jaHJvbm91cy4gIFllcywgaXQgaXNcXG4gIC8vIGRlZXBseSB1Z2x5IHRvIHdyaXRlIEFQSXMgdGhpcyB3YXksIGJ1dCB0aGF0IHN0aWxsIGRvZXNuJ3QgbWVhblxcbiAgLy8gdGhhdCB0aGUgUmVhZGFibGUgY2xhc3Mgc2hvdWxkIGJlaGF2ZSBpbXByb3Blcmx5LCBhcyBzdHJlYW1zIGFyZVxcbiAgLy8gZGVzaWduZWQgdG8gYmUgc3luYy9hc3luYyBhZ25vc3RpYy5cXG4gIC8vIFRha2Ugbm90ZSBpZiB0aGUgX3JlYWQgY2FsbCBpcyBzeW5jIG9yIGFzeW5jIChpZSwgaWYgdGhlIHJlYWQgY2FsbFxcbiAgLy8gaGFzIHJldHVybmVkIHlldCksIHNvIHRoYXQgd2Uga25vdyB3aGV0aGVyIG9yIG5vdCBpdCdzIHNhZmUgdG8gZW1pdFxcbiAgLy8gJ3JlYWRhYmxlJyBldGMuXFxuICAvL1xcbiAgLy8gMy4gQWN0dWFsbHkgcHVsbCB0aGUgcmVxdWVzdGVkIGNodW5rcyBvdXQgb2YgdGhlIGJ1ZmZlciBhbmQgcmV0dXJuLlxcblxcbiAgLy8gaWYgd2UgbmVlZCBhIHJlYWRhYmxlIGV2ZW50LCB0aGVuIHdlIG5lZWQgdG8gZG8gc29tZSByZWFkaW5nLlxcbiAgdmFyIGRvUmVhZCA9IHN0YXRlLm5lZWRSZWFkYWJsZTtcXG4gIGRlYnVnKCduZWVkIHJlYWRhYmxlJywgZG9SZWFkKTtcXG5cXG4gIC8vIGlmIHdlIGN1cnJlbnRseSBoYXZlIGxlc3MgdGhhbiB0aGUgaGlnaFdhdGVyTWFyaywgdGhlbiBhbHNvIHJlYWQgc29tZVxcbiAgaWYgKHN0YXRlLmxlbmd0aCA9PT0gMCB8fCBzdGF0ZS5sZW5ndGggLSBuIDwgc3RhdGUuaGlnaFdhdGVyTWFyaykge1xcbiAgICBkb1JlYWQgPSB0cnVlO1xcbiAgICBkZWJ1ZygnbGVuZ3RoIGxlc3MgdGhhbiB3YXRlcm1hcmsnLCBkb1JlYWQpO1xcbiAgfVxcblxcbiAgLy8gaG93ZXZlciwgaWYgd2UndmUgZW5kZWQsIHRoZW4gdGhlcmUncyBubyBwb2ludCwgYW5kIGlmIHdlJ3JlIGFscmVhZHlcXG4gIC8vIHJlYWRpbmcsIHRoZW4gaXQncyB1bm5lY2Vzc2FyeS5cXG4gIGlmIChzdGF0ZS5lbmRlZCB8fCBzdGF0ZS5yZWFkaW5nKSB7XFxuICAgIGRvUmVhZCA9IGZhbHNlO1xcbiAgICBkZWJ1ZygncmVhZGluZyBvciBlbmRlZCcsIGRvUmVhZCk7XFxuICB9IGVsc2UgaWYgKGRvUmVhZCkge1xcbiAgICBkZWJ1ZygnZG8gcmVhZCcpO1xcbiAgICBzdGF0ZS5yZWFkaW5nID0gdHJ1ZTtcXG4gICAgc3RhdGUuc3luYyA9IHRydWU7XFxuICAgIC8vIGlmIHRoZSBsZW5ndGggaXMgY3VycmVudGx5IHplcm8sIHRoZW4gd2UgKm5lZWQqIGEgcmVhZGFibGUgZXZlbnQuXFxuICAgIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIC8vIGNhbGwgaW50ZXJuYWwgcmVhZCBtZXRob2RcXG4gICAgdGhpcy5fcmVhZChzdGF0ZS5oaWdoV2F0ZXJNYXJrKTtcXG4gICAgc3RhdGUuc3luYyA9IGZhbHNlO1xcbiAgICAvLyBJZiBfcmVhZCBwdXNoZWQgZGF0YSBzeW5jaHJvbm91c2x5LCB0aGVuIGByZWFkaW5nYCB3aWxsIGJlIGZhbHNlLFxcbiAgICAvLyBhbmQgd2UgbmVlZCB0byByZS1ldmFsdWF0ZSBob3cgbXVjaCBkYXRhIHdlIGNhbiByZXR1cm4gdG8gdGhlIHVzZXIuXFxuICAgIGlmICghc3RhdGUucmVhZGluZykgbiA9IGhvd011Y2hUb1JlYWQobk9yaWcsIHN0YXRlKTtcXG4gIH1cXG5cXG4gIHZhciByZXQ7XFxuICBpZiAobiA+IDApIHJldCA9IGZyb21MaXN0KG4sIHN0YXRlKTtlbHNlIHJldCA9IG51bGw7XFxuXFxuICBpZiAocmV0ID09PSBudWxsKSB7XFxuICAgIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIG4gPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgc3RhdGUubGVuZ3RoIC09IG47XFxuICB9XFxuXFxuICBpZiAoc3RhdGUubGVuZ3RoID09PSAwKSB7XFxuICAgIC8vIElmIHdlIGhhdmUgbm90aGluZyBpbiB0aGUgYnVmZmVyLCB0aGVuIHdlIHdhbnQgdG8ga25vd1xcbiAgICAvLyBhcyBzb29uIGFzIHdlICpkbyogZ2V0IHNvbWV0aGluZyBpbnRvIHRoZSBidWZmZXIuXFxuICAgIGlmICghc3RhdGUuZW5kZWQpIHN0YXRlLm5lZWRSZWFkYWJsZSA9IHRydWU7XFxuXFxuICAgIC8vIElmIHdlIHRyaWVkIHRvIHJlYWQoKSBwYXN0IHRoZSBFT0YsIHRoZW4gZW1pdCBlbmQgb24gdGhlIG5leHQgdGljay5cXG4gICAgaWYgKG5PcmlnICE9PSBuICYmIHN0YXRlLmVuZGVkKSBlbmRSZWFkYWJsZSh0aGlzKTtcXG4gIH1cXG5cXG4gIGlmIChyZXQgIT09IG51bGwpIHRoaXMuZW1pdCgnZGF0YScsIHJldCk7XFxuXFxuICByZXR1cm4gcmV0O1xcbn07XFxuXFxuZnVuY3Rpb24gb25Fb2ZDaHVuayhzdHJlYW0sIHN0YXRlKSB7XFxuICBpZiAoc3RhdGUuZW5kZWQpIHJldHVybjtcXG4gIGlmIChzdGF0ZS5kZWNvZGVyKSB7XFxuICAgIHZhciBjaHVuayA9IHN0YXRlLmRlY29kZXIuZW5kKCk7XFxuICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHtcXG4gICAgICBzdGF0ZS5idWZmZXIucHVzaChjaHVuayk7XFxuICAgICAgc3RhdGUubGVuZ3RoICs9IHN0YXRlLm9iamVjdE1vZGUgPyAxIDogY2h1bmsubGVuZ3RoO1xcbiAgICB9XFxuICB9XFxuICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuXFxuICAvLyBlbWl0ICdyZWFkYWJsZScgbm93IHRvIG1ha2Ugc3VyZSBpdCBnZXRzIHBpY2tlZCB1cC5cXG4gIGVtaXRSZWFkYWJsZShzdHJlYW0pO1xcbn1cXG5cXG4vLyBEb24ndCBlbWl0IHJlYWRhYmxlIHJpZ2h0IGF3YXkgaW4gc3luYyBtb2RlLCBiZWNhdXNlIHRoaXMgY2FuIHRyaWdnZXJcXG4vLyBhbm90aGVyIHJlYWQoKSBjYWxsID0+IHN0YWNrIG92ZXJmbG93LiAgVGhpcyB3YXksIGl0IG1pZ2h0IHRyaWdnZXJcXG4vLyBhIG5leHRUaWNrIHJlY3Vyc2lvbiB3YXJuaW5nLCBidXQgdGhhdCdzIG5vdCBzbyBiYWQuXFxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlKHN0cmVhbSkge1xcbiAgdmFyIHN0YXRlID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgc3RhdGUubmVlZFJlYWRhYmxlID0gZmFsc2U7XFxuICBpZiAoIXN0YXRlLmVtaXR0ZWRSZWFkYWJsZSkge1xcbiAgICBkZWJ1ZygnZW1pdFJlYWRhYmxlJywgc3RhdGUuZmxvd2luZyk7XFxuICAgIHN0YXRlLmVtaXR0ZWRSZWFkYWJsZSA9IHRydWU7XFxuICAgIGlmIChzdGF0ZS5zeW5jKSBwcm9jZXNzTmV4dFRpY2soZW1pdFJlYWRhYmxlXywgc3RyZWFtKTtlbHNlIGVtaXRSZWFkYWJsZV8oc3RyZWFtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW1pdFJlYWRhYmxlXyhzdHJlYW0pIHtcXG4gIGRlYnVnKCdlbWl0IHJlYWRhYmxlJyk7XFxuICBzdHJlYW0uZW1pdCgncmVhZGFibGUnKTtcXG4gIGZsb3coc3RyZWFtKTtcXG59XFxuXFxuLy8gYXQgdGhpcyBwb2ludCwgdGhlIHVzZXIgaGFzIHByZXN1bWFibHkgc2VlbiB0aGUgJ3JlYWRhYmxlJyBldmVudCxcXG4vLyBhbmQgY2FsbGVkIHJlYWQoKSB0byBjb25zdW1lIHNvbWUgZGF0YS4gIHRoYXQgbWF5IGhhdmUgdHJpZ2dlcmVkXFxuLy8gaW4gdHVybiBhbm90aGVyIF9yZWFkKG4pIGNhbGwsIGluIHdoaWNoIGNhc2UgcmVhZGluZyA9IHRydWUgaWZcXG4vLyBpdCdzIGluIHByb2dyZXNzLlxcbi8vIEhvd2V2ZXIsIGlmIHdlJ3JlIG5vdCBlbmRlZCwgb3IgcmVhZGluZywgYW5kIHRoZSBsZW5ndGggPCBod20sXFxuLy8gdGhlbiBnbyBhaGVhZCBhbmQgdHJ5IHRvIHJlYWQgc29tZSBtb3JlIHByZWVtcHRpdmVseS5cXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVhZGluZ01vcmUpIHtcXG4gICAgc3RhdGUucmVhZGluZ01vcmUgPSB0cnVlO1xcbiAgICBwcm9jZXNzTmV4dFRpY2sobWF5YmVSZWFkTW9yZV8sIHN0cmVhbSwgc3RhdGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBtYXliZVJlYWRNb3JlXyhzdHJlYW0sIHN0YXRlKSB7XFxuICB2YXIgbGVuID0gc3RhdGUubGVuZ3RoO1xcbiAgd2hpbGUgKCFzdGF0ZS5yZWFkaW5nICYmICFzdGF0ZS5mbG93aW5nICYmICFzdGF0ZS5lbmRlZCAmJiBzdGF0ZS5sZW5ndGggPCBzdGF0ZS5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIGRlYnVnKCdtYXliZVJlYWRNb3JlIHJlYWQgMCcpO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gICAgaWYgKGxlbiA9PT0gc3RhdGUubGVuZ3RoKVxcbiAgICAgIC8vIGRpZG4ndCBnZXQgYW55IGRhdGEsIHN0b3Agc3Bpbm5pbmcuXFxuICAgICAgYnJlYWs7ZWxzZSBsZW4gPSBzdGF0ZS5sZW5ndGg7XFxuICB9XFxuICBzdGF0ZS5yZWFkaW5nTW9yZSA9IGZhbHNlO1xcbn1cXG5cXG4vLyBhYnN0cmFjdCBtZXRob2QuICB0byBiZSBvdmVycmlkZGVuIGluIHNwZWNpZmljIGltcGxlbWVudGF0aW9uIGNsYXNzZXMuXFxuLy8gY2FsbCBjYihlciwgZGF0YSkgd2hlcmUgZGF0YSBpcyA8PSBuIGluIGxlbmd0aC5cXG4vLyBmb3IgdmlydHVhbCAobm9uLXN0cmluZywgbm9uLWJ1ZmZlcikgc3RyZWFtcywgXFxcImxlbmd0aFxcXCIgaXMgc29tZXdoYXRcXG4vLyBhcmJpdHJhcnksIGFuZCBwZXJoYXBzIG5vdCB2ZXJ5IG1lYW5pbmdmdWwuXFxuUmVhZGFibGUucHJvdG90eXBlLl9yZWFkID0gZnVuY3Rpb24gKG4pIHtcXG4gIHRoaXMuZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ19yZWFkKCkgaXMgbm90IGltcGxlbWVudGVkJykpO1xcbn07XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnBpcGUgPSBmdW5jdGlvbiAoZGVzdCwgcGlwZU9wdHMpIHtcXG4gIHZhciBzcmMgPSB0aGlzO1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG5cXG4gIHN3aXRjaCAoc3RhdGUucGlwZXNDb3VudCkge1xcbiAgICBjYXNlIDA6XFxuICAgICAgc3RhdGUucGlwZXMgPSBkZXN0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlIDE6XFxuICAgICAgc3RhdGUucGlwZXMgPSBbc3RhdGUucGlwZXMsIGRlc3RdO1xcbiAgICAgIGJyZWFrO1xcbiAgICBkZWZhdWx0OlxcbiAgICAgIHN0YXRlLnBpcGVzLnB1c2goZGVzdCk7XFxuICAgICAgYnJlYWs7XFxuICB9XFxuICBzdGF0ZS5waXBlc0NvdW50ICs9IDE7XFxuICBkZWJ1ZygncGlwZSBjb3VudD0lZCBvcHRzPSVqJywgc3RhdGUucGlwZXNDb3VudCwgcGlwZU9wdHMpO1xcblxcbiAgdmFyIGRvRW5kID0gKCFwaXBlT3B0cyB8fCBwaXBlT3B0cy5lbmQgIT09IGZhbHNlKSAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZG91dCAmJiBkZXN0ICE9PSBwcm9jZXNzLnN0ZGVycjtcXG5cXG4gIHZhciBlbmRGbiA9IGRvRW5kID8gb25lbmQgOiB1bnBpcGU7XFxuICBpZiAoc3RhdGUuZW5kRW1pdHRlZCkgcHJvY2Vzc05leHRUaWNrKGVuZEZuKTtlbHNlIHNyYy5vbmNlKCdlbmQnLCBlbmRGbik7XFxuXFxuICBkZXN0Lm9uKCd1bnBpcGUnLCBvbnVucGlwZSk7XFxuICBmdW5jdGlvbiBvbnVucGlwZShyZWFkYWJsZSwgdW5waXBlSW5mbykge1xcbiAgICBkZWJ1Zygnb251bnBpcGUnKTtcXG4gICAgaWYgKHJlYWRhYmxlID09PSBzcmMpIHtcXG4gICAgICBpZiAodW5waXBlSW5mbyAmJiB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPT09IGZhbHNlKSB7XFxuICAgICAgICB1bnBpcGVJbmZvLmhhc1VucGlwZWQgPSB0cnVlO1xcbiAgICAgICAgY2xlYW51cCgpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgZnVuY3Rpb24gb25lbmQoKSB7XFxuICAgIGRlYnVnKCdvbmVuZCcpO1xcbiAgICBkZXN0LmVuZCgpO1xcbiAgfVxcblxcbiAgLy8gd2hlbiB0aGUgZGVzdCBkcmFpbnMsIGl0IHJlZHVjZXMgdGhlIGF3YWl0RHJhaW4gY291bnRlclxcbiAgLy8gb24gdGhlIHNvdXJjZS4gIFRoaXMgd291bGQgYmUgbW9yZSBlbGVnYW50IHdpdGggYSAub25jZSgpXFxuICAvLyBoYW5kbGVyIGluIGZsb3coKSwgYnV0IGFkZGluZyBhbmQgcmVtb3ZpbmcgcmVwZWF0ZWRseSBpc1xcbiAgLy8gdG9vIHNsb3cuXFxuICB2YXIgb25kcmFpbiA9IHBpcGVPbkRyYWluKHNyYyk7XFxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgdmFyIGNsZWFuZWRVcCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gY2xlYW51cCgpIHtcXG4gICAgZGVidWcoJ2NsZWFudXAnKTtcXG4gICAgLy8gY2xlYW51cCBldmVudCBoYW5kbGVycyBvbmNlIHRoZSBwaXBlIGlzIGJyb2tlblxcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIG9uY2xvc2UpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Vycm9yJywgb25lcnJvcik7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZScsIG9udW5waXBlKTtcXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNyYy5yZW1vdmVMaXN0ZW5lcignZW5kJywgdW5waXBlKTtcXG4gICAgc3JjLnJlbW92ZUxpc3RlbmVyKCdkYXRhJywgb25kYXRhKTtcXG5cXG4gICAgY2xlYW5lZFVwID0gdHJ1ZTtcXG5cXG4gICAgLy8gaWYgdGhlIHJlYWRlciBpcyB3YWl0aW5nIGZvciBhIGRyYWluIGV2ZW50IGZyb20gdGhpc1xcbiAgICAvLyBzcGVjaWZpYyB3cml0ZXIsIHRoZW4gaXQgd291bGQgY2F1c2UgaXQgdG8gbmV2ZXIgc3RhcnRcXG4gICAgLy8gZmxvd2luZyBhZ2Fpbi5cXG4gICAgLy8gU28sIGlmIHRoaXMgaXMgYXdhaXRpbmcgYSBkcmFpbiwgdGhlbiB3ZSBqdXN0IGNhbGwgaXQgbm93LlxcbiAgICAvLyBJZiB3ZSBkb24ndCBrbm93LCB0aGVuIGFzc3VtZSB0aGF0IHdlIGFyZSB3YWl0aW5nIGZvciBvbmUuXFxuICAgIGlmIChzdGF0ZS5hd2FpdERyYWluICYmICghZGVzdC5fd3JpdGFibGVTdGF0ZSB8fCBkZXN0Ll93cml0YWJsZVN0YXRlLm5lZWREcmFpbikpIG9uZHJhaW4oKTtcXG4gIH1cXG5cXG4gIC8vIElmIHRoZSB1c2VyIHB1c2hlcyBtb3JlIGRhdGEgd2hpbGUgd2UncmUgd3JpdGluZyB0byBkZXN0IHRoZW4gd2UnbGwgZW5kIHVwXFxuICAvLyBpbiBvbmRhdGEgYWdhaW4uIEhvd2V2ZXIsIHdlIG9ubHkgd2FudCB0byBpbmNyZWFzZSBhd2FpdERyYWluIG9uY2UgYmVjYXVzZVxcbiAgLy8gZGVzdCB3aWxsIG9ubHkgZW1pdCBvbmUgJ2RyYWluJyBldmVudCBmb3IgdGhlIG11bHRpcGxlIHdyaXRlcy5cXG4gIC8vID0+IEludHJvZHVjZSBhIGd1YXJkIG9uIGluY3JlYXNpbmcgYXdhaXREcmFpbi5cXG4gIHZhciBpbmNyZWFzZWRBd2FpdERyYWluID0gZmFsc2U7XFxuICBzcmMub24oJ2RhdGEnLCBvbmRhdGEpO1xcbiAgZnVuY3Rpb24gb25kYXRhKGNodW5rKSB7XFxuICAgIGRlYnVnKCdvbmRhdGEnKTtcXG4gICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IGZhbHNlO1xcbiAgICB2YXIgcmV0ID0gZGVzdC53cml0ZShjaHVuayk7XFxuICAgIGlmIChmYWxzZSA9PT0gcmV0ICYmICFpbmNyZWFzZWRBd2FpdERyYWluKSB7XFxuICAgICAgLy8gSWYgdGhlIHVzZXIgdW5waXBlZCBkdXJpbmcgYGRlc3Qud3JpdGUoKWAsIGl0IGlzIHBvc3NpYmxlXFxuICAgICAgLy8gdG8gZ2V0IHN0dWNrIGluIGEgcGVybWFuZW50bHkgcGF1c2VkIHN0YXRlIGlmIHRoYXQgd3JpdGVcXG4gICAgICAvLyBhbHNvIHJldHVybmVkIGZhbHNlLlxcbiAgICAgIC8vID0+IENoZWNrIHdoZXRoZXIgYGRlc3RgIGlzIHN0aWxsIGEgcGlwaW5nIGRlc3RpbmF0aW9uLlxcbiAgICAgIGlmICgoc3RhdGUucGlwZXNDb3VudCA9PT0gMSAmJiBzdGF0ZS5waXBlcyA9PT0gZGVzdCB8fCBzdGF0ZS5waXBlc0NvdW50ID4gMSAmJiBpbmRleE9mKHN0YXRlLnBpcGVzLCBkZXN0KSAhPT0gLTEpICYmICFjbGVhbmVkVXApIHtcXG4gICAgICAgIGRlYnVnKCdmYWxzZSB3cml0ZSByZXNwb25zZSwgcGF1c2UnLCBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbik7XFxuICAgICAgICBzcmMuX3JlYWRhYmxlU3RhdGUuYXdhaXREcmFpbisrO1xcbiAgICAgICAgaW5jcmVhc2VkQXdhaXREcmFpbiA9IHRydWU7XFxuICAgICAgfVxcbiAgICAgIHNyYy5wYXVzZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBpZiB0aGUgZGVzdCBoYXMgYW4gZXJyb3IsIHRoZW4gc3RvcCBwaXBpbmcgaW50byBpdC5cXG4gIC8vIGhvd2V2ZXIsIGRvbid0IHN1cHByZXNzIHRoZSB0aHJvd2luZyBiZWhhdmlvciBmb3IgdGhpcy5cXG4gIGZ1bmN0aW9uIG9uZXJyb3IoZXIpIHtcXG4gICAgZGVidWcoJ29uZXJyb3InLCBlcik7XFxuICAgIHVucGlwZSgpO1xcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIG9uZXJyb3IpO1xcbiAgICBpZiAoRUVsaXN0ZW5lckNvdW50KGRlc3QsICdlcnJvcicpID09PSAwKSBkZXN0LmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBzdXJlIG91ciBlcnJvciBoYW5kbGVyIGlzIGF0dGFjaGVkIGJlZm9yZSB1c2VybGFuZCBvbmVzLlxcbiAgcHJlcGVuZExpc3RlbmVyKGRlc3QsICdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgLy8gQm90aCBjbG9zZSBhbmQgZmluaXNoIHNob3VsZCB0cmlnZ2VyIHVucGlwZSwgYnV0IG9ubHkgb25jZS5cXG4gIGZ1bmN0aW9uIG9uY2xvc2UoKSB7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2ZpbmlzaCcsIG9uZmluaXNoKTtcXG4gICAgdW5waXBlKCk7XFxuICB9XFxuICBkZXN0Lm9uY2UoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICBmdW5jdGlvbiBvbmZpbmlzaCgpIHtcXG4gICAgZGVidWcoJ29uZmluaXNoJyk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuICAgIHVucGlwZSgpO1xcbiAgfVxcbiAgZGVzdC5vbmNlKCdmaW5pc2gnLCBvbmZpbmlzaCk7XFxuXFxuICBmdW5jdGlvbiB1bnBpcGUoKSB7XFxuICAgIGRlYnVnKCd1bnBpcGUnKTtcXG4gICAgc3JjLnVucGlwZShkZXN0KTtcXG4gIH1cXG5cXG4gIC8vIHRlbGwgdGhlIGRlc3QgdGhhdCBpdCdzIGJlaW5nIHBpcGVkIHRvXFxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzcmMpO1xcblxcbiAgLy8gc3RhcnQgdGhlIGZsb3cgaWYgaXQgaGFzbid0IGJlZW4gc3RhcnRlZCBhbHJlYWR5LlxcbiAgaWYgKCFzdGF0ZS5mbG93aW5nKSB7XFxuICAgIGRlYnVnKCdwaXBlIHJlc3VtZScpO1xcbiAgICBzcmMucmVzdW1lKCk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVzdDtcXG59O1xcblxcbmZ1bmN0aW9uIHBpcGVPbkRyYWluKHNyYykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIHN0YXRlID0gc3JjLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBkZWJ1ZygncGlwZU9uRHJhaW4nLCBzdGF0ZS5hd2FpdERyYWluKTtcXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4pIHN0YXRlLmF3YWl0RHJhaW4tLTtcXG4gICAgaWYgKHN0YXRlLmF3YWl0RHJhaW4gPT09IDAgJiYgRUVsaXN0ZW5lckNvdW50KHNyYywgJ2RhdGEnKSkge1xcbiAgICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICAgIGZsb3coc3JjKTtcXG4gICAgfVxcbiAgfTtcXG59XFxuXFxuUmVhZGFibGUucHJvdG90eXBlLnVucGlwZSA9IGZ1bmN0aW9uIChkZXN0KSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIHVucGlwZUluZm8gPSB7IGhhc1VucGlwZWQ6IGZhbHNlIH07XFxuXFxuICAvLyBpZiB3ZSdyZSBub3QgcGlwaW5nIGFueXdoZXJlLCB0aGVuIGRvIG5vdGhpbmcuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMCkgcmV0dXJuIHRoaXM7XFxuXFxuICAvLyBqdXN0IG9uZSBkZXN0aW5hdGlvbi4gIG1vc3QgY29tbW9uIGNhc2UuXFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkge1xcbiAgICAvLyBwYXNzZWQgaW4gb25lLCBidXQgaXQncyBub3QgdGhlIHJpZ2h0IG9uZS5cXG4gICAgaWYgKGRlc3QgJiYgZGVzdCAhPT0gc3RhdGUucGlwZXMpIHJldHVybiB0aGlzO1xcblxcbiAgICBpZiAoIWRlc3QpIGRlc3QgPSBzdGF0ZS5waXBlcztcXG5cXG4gICAgLy8gZ290IGEgbWF0Y2guXFxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG4gICAgaWYgKGRlc3QpIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XFxuICAgIHJldHVybiB0aGlzO1xcbiAgfVxcblxcbiAgLy8gc2xvdyBjYXNlLiBtdWx0aXBsZSBwaXBlIGRlc3RpbmF0aW9ucy5cXG5cXG4gIGlmICghZGVzdCkge1xcbiAgICAvLyByZW1vdmUgYWxsLlxcbiAgICB2YXIgZGVzdHMgPSBzdGF0ZS5waXBlcztcXG4gICAgdmFyIGxlbiA9IHN0YXRlLnBpcGVzQ291bnQ7XFxuICAgIHN0YXRlLnBpcGVzID0gbnVsbDtcXG4gICAgc3RhdGUucGlwZXNDb3VudCA9IDA7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSBmYWxzZTtcXG5cXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xcbiAgICAgIGRlc3RzW2ldLmVtaXQoJ3VucGlwZScsIHRoaXMsIHVucGlwZUluZm8pO1xcbiAgICB9cmV0dXJuIHRoaXM7XFxuICB9XFxuXFxuICAvLyB0cnkgdG8gZmluZCB0aGUgcmlnaHQgb25lLlxcbiAgdmFyIGluZGV4ID0gaW5kZXhPZihzdGF0ZS5waXBlcywgZGVzdCk7XFxuICBpZiAoaW5kZXggPT09IC0xKSByZXR1cm4gdGhpcztcXG5cXG4gIHN0YXRlLnBpcGVzLnNwbGljZShpbmRleCwgMSk7XFxuICBzdGF0ZS5waXBlc0NvdW50IC09IDE7XFxuICBpZiAoc3RhdGUucGlwZXNDb3VudCA9PT0gMSkgc3RhdGUucGlwZXMgPSBzdGF0ZS5waXBlc1swXTtcXG5cXG4gIGRlc3QuZW1pdCgndW5waXBlJywgdGhpcywgdW5waXBlSW5mbyk7XFxuXFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbi8vIHNldCB1cCBkYXRhIGV2ZW50cyBpZiB0aGV5IGFyZSBhc2tlZCBmb3JcXG4vLyBFbnN1cmUgcmVhZGFibGUgbGlzdGVuZXJzIGV2ZW50dWFsbHkgZ2V0IHNvbWV0aGluZ1xcblJlYWRhYmxlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uIChldiwgZm4pIHtcXG4gIHZhciByZXMgPSBTdHJlYW0ucHJvdG90eXBlLm9uLmNhbGwodGhpcywgZXYsIGZuKTtcXG5cXG4gIGlmIChldiA9PT0gJ2RhdGEnKSB7XFxuICAgIC8vIFN0YXJ0IGZsb3dpbmcgb24gbmV4dCB0aWNrIGlmIHN0cmVhbSBpc24ndCBleHBsaWNpdGx5IHBhdXNlZFxcbiAgICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZS5mbG93aW5nICE9PSBmYWxzZSkgdGhpcy5yZXN1bWUoKTtcXG4gIH0gZWxzZSBpZiAoZXYgPT09ICdyZWFkYWJsZScpIHtcXG4gICAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gICAgaWYgKCFzdGF0ZS5lbmRFbWl0dGVkICYmICFzdGF0ZS5yZWFkYWJsZUxpc3RlbmluZykge1xcbiAgICAgIHN0YXRlLnJlYWRhYmxlTGlzdGVuaW5nID0gc3RhdGUubmVlZFJlYWRhYmxlID0gdHJ1ZTtcXG4gICAgICBzdGF0ZS5lbWl0dGVkUmVhZGFibGUgPSBmYWxzZTtcXG4gICAgICBpZiAoIXN0YXRlLnJlYWRpbmcpIHtcXG4gICAgICAgIHByb2Nlc3NOZXh0VGljayhuUmVhZGluZ05leHRUaWNrLCB0aGlzKTtcXG4gICAgICB9IGVsc2UgaWYgKHN0YXRlLmxlbmd0aCkge1xcbiAgICAgICAgZW1pdFJlYWRhYmxlKHRoaXMpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIHJlcztcXG59O1xcblJlYWRhYmxlLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IFJlYWRhYmxlLnByb3RvdHlwZS5vbjtcXG5cXG5mdW5jdGlvbiBuUmVhZGluZ05leHRUaWNrKHNlbGYpIHtcXG4gIGRlYnVnKCdyZWFkYWJsZSBuZXh0dGljayByZWFkIDAnKTtcXG4gIHNlbGYucmVhZCgwKTtcXG59XFxuXFxuLy8gcGF1c2UoKSBhbmQgcmVzdW1lKCkgYXJlIHJlbW5hbnRzIG9mIHRoZSBsZWdhY3kgcmVhZGFibGUgc3RyZWFtIEFQSVxcbi8vIElmIHRoZSB1c2VyIHVzZXMgdGhlbSwgdGhlbiBzd2l0Y2ggaW50byBvbGQgbW9kZS5cXG5SZWFkYWJsZS5wcm90b3R5cGUucmVzdW1lID0gZnVuY3Rpb24gKCkge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fcmVhZGFibGVTdGF0ZTtcXG4gIGlmICghc3RhdGUuZmxvd2luZykge1xcbiAgICBkZWJ1ZygncmVzdW1lJyk7XFxuICAgIHN0YXRlLmZsb3dpbmcgPSB0cnVlO1xcbiAgICByZXN1bWUodGhpcywgc3RhdGUpO1xcbiAgfVxcbiAgcmV0dXJuIHRoaXM7XFxufTtcXG5cXG5mdW5jdGlvbiByZXN1bWUoc3RyZWFtLCBzdGF0ZSkge1xcbiAgaWYgKCFzdGF0ZS5yZXN1bWVTY2hlZHVsZWQpIHtcXG4gICAgc3RhdGUucmVzdW1lU2NoZWR1bGVkID0gdHJ1ZTtcXG4gICAgcHJvY2Vzc05leHRUaWNrKHJlc3VtZV8sIHN0cmVhbSwgc3RhdGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiByZXN1bWVfKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucmVhZGluZykge1xcbiAgICBkZWJ1ZygncmVzdW1lIHJlYWQgMCcpO1xcbiAgICBzdHJlYW0ucmVhZCgwKTtcXG4gIH1cXG5cXG4gIHN0YXRlLnJlc3VtZVNjaGVkdWxlZCA9IGZhbHNlO1xcbiAgc3RhdGUuYXdhaXREcmFpbiA9IDA7XFxuICBzdHJlYW0uZW1pdCgncmVzdW1lJyk7XFxuICBmbG93KHN0cmVhbSk7XFxuICBpZiAoc3RhdGUuZmxvd2luZyAmJiAhc3RhdGUucmVhZGluZykgc3RyZWFtLnJlYWQoMCk7XFxufVxcblxcblJlYWRhYmxlLnByb3RvdHlwZS5wYXVzZSA9IGZ1bmN0aW9uICgpIHtcXG4gIGRlYnVnKCdjYWxsIHBhdXNlIGZsb3dpbmc9JWonLCB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpO1xcbiAgaWYgKGZhbHNlICE9PSB0aGlzLl9yZWFkYWJsZVN0YXRlLmZsb3dpbmcpIHtcXG4gICAgZGVidWcoJ3BhdXNlJyk7XFxuICAgIHRoaXMuX3JlYWRhYmxlU3RhdGUuZmxvd2luZyA9IGZhbHNlO1xcbiAgICB0aGlzLmVtaXQoJ3BhdXNlJyk7XFxuICB9XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIGZsb3coc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuICBkZWJ1ZygnZmxvdycsIHN0YXRlLmZsb3dpbmcpO1xcbiAgd2hpbGUgKHN0YXRlLmZsb3dpbmcgJiYgc3RyZWFtLnJlYWQoKSAhPT0gbnVsbCkge31cXG59XFxuXFxuLy8gd3JhcCBhbiBvbGQtc3R5bGUgc3RyZWFtIGFzIHRoZSBhc3luYyBkYXRhIHNvdXJjZS5cXG4vLyBUaGlzIGlzICpub3QqIHBhcnQgb2YgdGhlIHJlYWRhYmxlIHN0cmVhbSBpbnRlcmZhY2UuXFxuLy8gSXQgaXMgYW4gdWdseSB1bmZvcnR1bmF0ZSBtZXNzIG9mIGhpc3RvcnkuXFxuUmVhZGFibGUucHJvdG90eXBlLndyYXAgPSBmdW5jdGlvbiAoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgdmFyIHBhdXNlZCA9IGZhbHNlO1xcblxcbiAgdmFyIHNlbGYgPSB0aGlzO1xcbiAgc3RyZWFtLm9uKCdlbmQnLCBmdW5jdGlvbiAoKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIGVuZCcpO1xcbiAgICBpZiAoc3RhdGUuZGVjb2RlciAmJiAhc3RhdGUuZW5kZWQpIHtcXG4gICAgICB2YXIgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLmVuZCgpO1xcbiAgICAgIGlmIChjaHVuayAmJiBjaHVuay5sZW5ndGgpIHNlbGYucHVzaChjaHVuayk7XFxuICAgIH1cXG5cXG4gICAgc2VsZi5wdXNoKG51bGwpO1xcbiAgfSk7XFxuXFxuICBzdHJlYW0ub24oJ2RhdGEnLCBmdW5jdGlvbiAoY2h1bmspIHtcXG4gICAgZGVidWcoJ3dyYXBwZWQgZGF0YScpO1xcbiAgICBpZiAoc3RhdGUuZGVjb2RlcikgY2h1bmsgPSBzdGF0ZS5kZWNvZGVyLndyaXRlKGNodW5rKTtcXG5cXG4gICAgLy8gZG9uJ3Qgc2tpcCBvdmVyIGZhbHN5IHZhbHVlcyBpbiBvYmplY3RNb2RlXFxuICAgIGlmIChzdGF0ZS5vYmplY3RNb2RlICYmIChjaHVuayA9PT0gbnVsbCB8fCBjaHVuayA9PT0gdW5kZWZpbmVkKSkgcmV0dXJuO2Vsc2UgaWYgKCFzdGF0ZS5vYmplY3RNb2RlICYmICghY2h1bmsgfHwgIWNodW5rLmxlbmd0aCkpIHJldHVybjtcXG5cXG4gICAgdmFyIHJldCA9IHNlbGYucHVzaChjaHVuayk7XFxuICAgIGlmICghcmV0KSB7XFxuICAgICAgcGF1c2VkID0gdHJ1ZTtcXG4gICAgICBzdHJlYW0ucGF1c2UoKTtcXG4gICAgfVxcbiAgfSk7XFxuXFxuICAvLyBwcm94eSBhbGwgdGhlIG90aGVyIG1ldGhvZHMuXFxuICAvLyBpbXBvcnRhbnQgd2hlbiB3cmFwcGluZyBmaWx0ZXJzIGFuZCBkdXBsZXhlcy5cXG4gIGZvciAodmFyIGkgaW4gc3RyZWFtKSB7XFxuICAgIGlmICh0aGlzW2ldID09PSB1bmRlZmluZWQgJiYgdHlwZW9mIHN0cmVhbVtpXSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHRoaXNbaV0gPSBmdW5jdGlvbiAobWV0aG9kKSB7XFxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICByZXR1cm4gc3RyZWFtW21ldGhvZF0uYXBwbHkoc3RyZWFtLCBhcmd1bWVudHMpO1xcbiAgICAgICAgfTtcXG4gICAgICB9KGkpO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBwcm94eSBjZXJ0YWluIGltcG9ydGFudCBldmVudHMuXFxuICBmb3IgKHZhciBuID0gMDsgbiA8IGtQcm94eUV2ZW50cy5sZW5ndGg7IG4rKykge1xcbiAgICBzdHJlYW0ub24oa1Byb3h5RXZlbnRzW25dLCBzZWxmLmVtaXQuYmluZChzZWxmLCBrUHJveHlFdmVudHNbbl0pKTtcXG4gIH1cXG5cXG4gIC8vIHdoZW4gd2UgdHJ5IHRvIGNvbnN1bWUgc29tZSBtb3JlIGJ5dGVzLCBzaW1wbHkgdW5wYXVzZSB0aGVcXG4gIC8vIHVuZGVybHlpbmcgc3RyZWFtLlxcbiAgc2VsZi5fcmVhZCA9IGZ1bmN0aW9uIChuKSB7XFxuICAgIGRlYnVnKCd3cmFwcGVkIF9yZWFkJywgbik7XFxuICAgIGlmIChwYXVzZWQpIHtcXG4gICAgICBwYXVzZWQgPSBmYWxzZTtcXG4gICAgICBzdHJlYW0ucmVzdW1lKCk7XFxuICAgIH1cXG4gIH07XFxuXFxuICByZXR1cm4gc2VsZjtcXG59O1xcblxcbi8vIGV4cG9zZWQgZm9yIHRlc3RpbmcgcHVycG9zZXMgb25seS5cXG5SZWFkYWJsZS5fZnJvbUxpc3QgPSBmcm9tTGlzdDtcXG5cXG4vLyBQbHVjayBvZmYgbiBieXRlcyBmcm9tIGFuIGFycmF5IG9mIGJ1ZmZlcnMuXFxuLy8gTGVuZ3RoIGlzIHRoZSBjb21iaW5lZCBsZW5ndGhzIG9mIGFsbCB0aGUgYnVmZmVycyBpbiB0aGUgbGlzdC5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gZnJvbUxpc3Qobiwgc3RhdGUpIHtcXG4gIC8vIG5vdGhpbmcgYnVmZmVyZWRcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDApIHJldHVybiBudWxsO1xcblxcbiAgdmFyIHJldDtcXG4gIGlmIChzdGF0ZS5vYmplY3RNb2RlKSByZXQgPSBzdGF0ZS5idWZmZXIuc2hpZnQoKTtlbHNlIGlmICghbiB8fCBuID49IHN0YXRlLmxlbmd0aCkge1xcbiAgICAvLyByZWFkIGl0IGFsbCwgdHJ1bmNhdGUgdGhlIGxpc3RcXG4gICAgaWYgKHN0YXRlLmRlY29kZXIpIHJldCA9IHN0YXRlLmJ1ZmZlci5qb2luKCcnKTtlbHNlIGlmIChzdGF0ZS5idWZmZXIubGVuZ3RoID09PSAxKSByZXQgPSBzdGF0ZS5idWZmZXIuaGVhZC5kYXRhO2Vsc2UgcmV0ID0gc3RhdGUuYnVmZmVyLmNvbmNhdChzdGF0ZS5sZW5ndGgpO1xcbiAgICBzdGF0ZS5idWZmZXIuY2xlYXIoKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHJlYWQgcGFydCBvZiBsaXN0XFxuICAgIHJldCA9IGZyb21MaXN0UGFydGlhbChuLCBzdGF0ZS5idWZmZXIsIHN0YXRlLmRlY29kZXIpO1xcbiAgfVxcblxcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuLy8gRXh0cmFjdHMgb25seSBlbm91Z2ggYnVmZmVyZWQgZGF0YSB0byBzYXRpc2Z5IHRoZSBhbW91bnQgcmVxdWVzdGVkLlxcbi8vIFRoaXMgZnVuY3Rpb24gaXMgZGVzaWduZWQgdG8gYmUgaW5saW5hYmxlLCBzbyBwbGVhc2UgdGFrZSBjYXJlIHdoZW4gbWFraW5nXFxuLy8gY2hhbmdlcyB0byB0aGUgZnVuY3Rpb24gYm9keS5cXG5mdW5jdGlvbiBmcm9tTGlzdFBhcnRpYWwobiwgbGlzdCwgaGFzU3RyaW5ncykge1xcbiAgdmFyIHJldDtcXG4gIGlmIChuIDwgbGlzdC5oZWFkLmRhdGEubGVuZ3RoKSB7XFxuICAgIC8vIHNsaWNlIGlzIHRoZSBzYW1lIGZvciBidWZmZXJzIGFuZCBzdHJpbmdzXFxuICAgIHJldCA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKDAsIG4pO1xcbiAgICBsaXN0LmhlYWQuZGF0YSA9IGxpc3QuaGVhZC5kYXRhLnNsaWNlKG4pO1xcbiAgfSBlbHNlIGlmIChuID09PSBsaXN0LmhlYWQuZGF0YS5sZW5ndGgpIHtcXG4gICAgLy8gZmlyc3QgY2h1bmsgaXMgYSBwZXJmZWN0IG1hdGNoXFxuICAgIHJldCA9IGxpc3Quc2hpZnQoKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIHJlc3VsdCBzcGFucyBtb3JlIHRoYW4gb25lIGJ1ZmZlclxcbiAgICByZXQgPSBoYXNTdHJpbmdzID8gY29weUZyb21CdWZmZXJTdHJpbmcobiwgbGlzdCkgOiBjb3B5RnJvbUJ1ZmZlcihuLCBsaXN0KTtcXG4gIH1cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgY2hhcmFjdGVycyBmcm9tIHRoZSBsaXN0IG9mIGJ1ZmZlcmVkIGRhdGFcXG4vLyBjaHVua3MuXFxuLy8gVGhpcyBmdW5jdGlvbiBpcyBkZXNpZ25lZCB0byBiZSBpbmxpbmFibGUsIHNvIHBsZWFzZSB0YWtlIGNhcmUgd2hlbiBtYWtpbmdcXG4vLyBjaGFuZ2VzIHRvIHRoZSBmdW5jdGlvbiBib2R5LlxcbmZ1bmN0aW9uIGNvcHlGcm9tQnVmZmVyU3RyaW5nKG4sIGxpc3QpIHtcXG4gIHZhciBwID0gbGlzdC5oZWFkO1xcbiAgdmFyIGMgPSAxO1xcbiAgdmFyIHJldCA9IHAuZGF0YTtcXG4gIG4gLT0gcmV0Lmxlbmd0aDtcXG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgIHZhciBzdHIgPSBwLmRhdGE7XFxuICAgIHZhciBuYiA9IG4gPiBzdHIubGVuZ3RoID8gc3RyLmxlbmd0aCA6IG47XFxuICAgIGlmIChuYiA9PT0gc3RyLmxlbmd0aCkgcmV0ICs9IHN0cjtlbHNlIHJldCArPSBzdHIuc2xpY2UoMCwgbik7XFxuICAgIG4gLT0gbmI7XFxuICAgIGlmIChuID09PSAwKSB7XFxuICAgICAgaWYgKG5iID09PSBzdHIubGVuZ3RoKSB7XFxuICAgICAgICArK2M7XFxuICAgICAgICBpZiAocC5uZXh0KSBsaXN0LmhlYWQgPSBwLm5leHQ7ZWxzZSBsaXN0LmhlYWQgPSBsaXN0LnRhaWwgPSBudWxsO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBsaXN0LmhlYWQgPSBwO1xcbiAgICAgICAgcC5kYXRhID0gc3RyLnNsaWNlKG5iKTtcXG4gICAgICB9XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gICAgKytjO1xcbiAgfVxcbiAgbGlzdC5sZW5ndGggLT0gYztcXG4gIHJldHVybiByZXQ7XFxufVxcblxcbi8vIENvcGllcyBhIHNwZWNpZmllZCBhbW91bnQgb2YgYnl0ZXMgZnJvbSB0aGUgbGlzdCBvZiBidWZmZXJlZCBkYXRhIGNodW5rcy5cXG4vLyBUaGlzIGZ1bmN0aW9uIGlzIGRlc2lnbmVkIHRvIGJlIGlubGluYWJsZSwgc28gcGxlYXNlIHRha2UgY2FyZSB3aGVuIG1ha2luZ1xcbi8vIGNoYW5nZXMgdG8gdGhlIGZ1bmN0aW9uIGJvZHkuXFxuZnVuY3Rpb24gY29weUZyb21CdWZmZXIobiwgbGlzdCkge1xcbiAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuKTtcXG4gIHZhciBwID0gbGlzdC5oZWFkO1xcbiAgdmFyIGMgPSAxO1xcbiAgcC5kYXRhLmNvcHkocmV0KTtcXG4gIG4gLT0gcC5kYXRhLmxlbmd0aDtcXG4gIHdoaWxlIChwID0gcC5uZXh0KSB7XFxuICAgIHZhciBidWYgPSBwLmRhdGE7XFxuICAgIHZhciBuYiA9IG4gPiBidWYubGVuZ3RoID8gYnVmLmxlbmd0aCA6IG47XFxuICAgIGJ1Zi5jb3B5KHJldCwgcmV0Lmxlbmd0aCAtIG4sIDAsIG5iKTtcXG4gICAgbiAtPSBuYjtcXG4gICAgaWYgKG4gPT09IDApIHtcXG4gICAgICBpZiAobmIgPT09IGJ1Zi5sZW5ndGgpIHtcXG4gICAgICAgICsrYztcXG4gICAgICAgIGlmIChwLm5leHQpIGxpc3QuaGVhZCA9IHAubmV4dDtlbHNlIGxpc3QuaGVhZCA9IGxpc3QudGFpbCA9IG51bGw7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGxpc3QuaGVhZCA9IHA7XFxuICAgICAgICBwLmRhdGEgPSBidWYuc2xpY2UobmIpO1xcbiAgICAgIH1cXG4gICAgICBicmVhaztcXG4gICAgfVxcbiAgICArK2M7XFxuICB9XFxuICBsaXN0Lmxlbmd0aCAtPSBjO1xcbiAgcmV0dXJuIHJldDtcXG59XFxuXFxuZnVuY3Rpb24gZW5kUmVhZGFibGUoc3RyZWFtKSB7XFxuICB2YXIgc3RhdGUgPSBzdHJlYW0uX3JlYWRhYmxlU3RhdGU7XFxuXFxuICAvLyBJZiB3ZSBnZXQgaGVyZSBiZWZvcmUgY29uc3VtaW5nIGFsbCB0aGUgYnl0ZXMsIHRoZW4gdGhhdCBpcyBhXFxuICAvLyBidWcgaW4gbm9kZS4gIFNob3VsZCBuZXZlciBoYXBwZW4uXFxuICBpZiAoc3RhdGUubGVuZ3RoID4gMCkgdGhyb3cgbmV3IEVycm9yKCdcXFwiZW5kUmVhZGFibGUoKVxcXCIgY2FsbGVkIG9uIG5vbi1lbXB0eSBzdHJlYW0nKTtcXG5cXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCkge1xcbiAgICBzdGF0ZS5lbmRlZCA9IHRydWU7XFxuICAgIHByb2Nlc3NOZXh0VGljayhlbmRSZWFkYWJsZU5ULCBzdGF0ZSwgc3RyZWFtKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gZW5kUmVhZGFibGVOVChzdGF0ZSwgc3RyZWFtKSB7XFxuICAvLyBDaGVjayB0aGF0IHdlIGRpZG4ndCBnZXQgb25lIGxhc3QgdW5zaGlmdC5cXG4gIGlmICghc3RhdGUuZW5kRW1pdHRlZCAmJiBzdGF0ZS5sZW5ndGggPT09IDApIHtcXG4gICAgc3RhdGUuZW5kRW1pdHRlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5yZWFkYWJsZSA9IGZhbHNlO1xcbiAgICBzdHJlYW0uZW1pdCgnZW5kJyk7XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZvckVhY2goeHMsIGYpIHtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0geHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XFxuICAgIGYoeHNbaV0sIGkpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBpbmRleE9mKHhzLCB4KSB7XFxuICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICBpZiAoeHNbaV0gPT09IHgpIHJldHVybiBpO1xcbiAgfVxcbiAgcmV0dXJuIC0xO1xcbn1cXG59KS5jYWxsKHRoaXMscmVxdWlyZSgnX3Byb2Nlc3MnKSx0eXBlb2YgZ2xvYmFsICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHNlbGYgOiB0eXBlb2Ygd2luZG93ICE9PSBcXFwidW5kZWZpbmVkXFxcIiA/IHdpbmRvdyA6IHt9KVxcbn0se1xcXCIuL19zdHJlYW1fZHVwbGV4XFxcIjo1OCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL0J1ZmZlckxpc3RcXFwiOjYzLFxcXCIuL2ludGVybmFsL3N0cmVhbXMvZGVzdHJveVxcXCI6NjQsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW1cXFwiOjY1LFxcXCJfcHJvY2Vzc1xcXCI6NTYsXFxcImNvcmUtdXRpbC1pc1xcXCI6NDIsXFxcImV2ZW50c1xcXCI6NDcsXFxcImluaGVyaXRzXFxcIjo1MCxcXFwiaXNhcnJheVxcXCI6NTIsXFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NSxcXFwic2FmZS1idWZmZXJcXFwiOjcwLFxcXCJzdHJpbmdfZGVjb2Rlci9cXFwiOjcyLFxcXCJ1dGlsXFxcIjozOH1dLDYxOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4vLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cXG4vL1xcbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXFxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxcbi8vIFxcXCJTb2Z0d2FyZVxcXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXFxuLy8gZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGwgY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdFxcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxcbi8vXFxuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cXG4vL1xcbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcXFwiQVMgSVNcXFwiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXFxuLy8gT1IgSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRlxcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcXG4vLyBEQU1BR0VTIE9SIE9USEVSIExJQUJJTElUWSwgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIFRPUlQgT1JcXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXFxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cXG5cXG4vLyBhIHRyYW5zZm9ybSBzdHJlYW0gaXMgYSByZWFkYWJsZS93cml0YWJsZSBzdHJlYW0gd2hlcmUgeW91IGRvXFxuLy8gc29tZXRoaW5nIHdpdGggdGhlIGRhdGEuICBTb21ldGltZXMgaXQncyBjYWxsZWQgYSBcXFwiZmlsdGVyXFxcIixcXG4vLyBidXQgdGhhdCdzIG5vdCBhIGdyZWF0IG5hbWUgZm9yIGl0LCBzaW5jZSB0aGF0IGltcGxpZXMgYSB0aGluZyB3aGVyZVxcbi8vIHNvbWUgYml0cyBwYXNzIHRocm91Z2gsIGFuZCBvdGhlcnMgYXJlIHNpbXBseSBpZ25vcmVkLiAgKFRoYXQgd291bGRcXG4vLyBiZSBhIHZhbGlkIGV4YW1wbGUgb2YgYSB0cmFuc2Zvcm0sIG9mIGNvdXJzZS4pXFxuLy9cXG4vLyBXaGlsZSB0aGUgb3V0cHV0IGlzIGNhdXNhbGx5IHJlbGF0ZWQgdG8gdGhlIGlucHV0LCBpdCdzIG5vdCBhXFxuLy8gbmVjZXNzYXJpbHkgc3ltbWV0cmljIG9yIHN5bmNocm9ub3VzIHRyYW5zZm9ybWF0aW9uLiAgRm9yIGV4YW1wbGUsXFxuLy8gYSB6bGliIHN0cmVhbSBtaWdodCB0YWtlIG11bHRpcGxlIHBsYWluLXRleHQgd3JpdGVzKCksIGFuZCB0aGVuXFxuLy8gZW1pdCBhIHNpbmdsZSBjb21wcmVzc2VkIGNodW5rIHNvbWUgdGltZSBpbiB0aGUgZnV0dXJlLlxcbi8vXFxuLy8gSGVyZSdzIGhvdyB0aGlzIHdvcmtzOlxcbi8vXFxuLy8gVGhlIFRyYW5zZm9ybSBzdHJlYW0gaGFzIGFsbCB0aGUgYXNwZWN0cyBvZiB0aGUgcmVhZGFibGUgYW5kIHdyaXRhYmxlXFxuLy8gc3RyZWFtIGNsYXNzZXMuICBXaGVuIHlvdSB3cml0ZShjaHVuayksIHRoYXQgY2FsbHMgX3dyaXRlKGNodW5rLGNiKVxcbi8vIGludGVybmFsbHksIGFuZCByZXR1cm5zIGZhbHNlIGlmIHRoZXJlJ3MgYSBsb3Qgb2YgcGVuZGluZyB3cml0ZXNcXG4vLyBidWZmZXJlZCB1cC4gIFdoZW4geW91IGNhbGwgcmVhZCgpLCB0aGF0IGNhbGxzIF9yZWFkKG4pIHVudGlsXFxuLy8gdGhlcmUncyBlbm91Z2ggcGVuZGluZyByZWFkYWJsZSBkYXRhIGJ1ZmZlcmVkIHVwLlxcbi8vXFxuLy8gSW4gYSB0cmFuc2Zvcm0gc3RyZWFtLCB0aGUgd3JpdHRlbiBkYXRhIGlzIHBsYWNlZCBpbiBhIGJ1ZmZlci4gIFdoZW5cXG4vLyBfcmVhZChuKSBpcyBjYWxsZWQsIGl0IHRyYW5zZm9ybXMgdGhlIHF1ZXVlZCB1cCBkYXRhLCBjYWxsaW5nIHRoZVxcbi8vIGJ1ZmZlcmVkIF93cml0ZSBjYidzIGFzIGl0IGNvbnN1bWVzIGNodW5rcy4gIElmIGNvbnN1bWluZyBhIHNpbmdsZVxcbi8vIHdyaXR0ZW4gY2h1bmsgd291bGQgcmVzdWx0IGluIG11bHRpcGxlIG91dHB1dCBjaHVua3MsIHRoZW4gdGhlIGZpcnN0XFxuLy8gb3V0cHV0dGVkIGJpdCBjYWxscyB0aGUgcmVhZGNiLCBhbmQgc3Vic2VxdWVudCBjaHVua3MganVzdCBnbyBpbnRvXFxuLy8gdGhlIHJlYWQgYnVmZmVyLCBhbmQgd2lsbCBjYXVzZSBpdCB0byBlbWl0ICdyZWFkYWJsZScgaWYgbmVjZXNzYXJ5Llxcbi8vXFxuLy8gVGhpcyB3YXksIGJhY2stcHJlc3N1cmUgaXMgYWN0dWFsbHkgZGV0ZXJtaW5lZCBieSB0aGUgcmVhZGluZyBzaWRlLFxcbi8vIHNpbmNlIF9yZWFkIGhhcyB0byBiZSBjYWxsZWQgdG8gc3RhcnQgcHJvY2Vzc2luZyBhIG5ldyBjaHVuay4gIEhvd2V2ZXIsXFxuLy8gYSBwYXRob2xvZ2ljYWwgaW5mbGF0ZSB0eXBlIG9mIHRyYW5zZm9ybSBjYW4gY2F1c2UgZXhjZXNzaXZlIGJ1ZmZlcmluZ1xcbi8vIGhlcmUuICBGb3IgZXhhbXBsZSwgaW1hZ2luZSBhIHN0cmVhbSB3aGVyZSBldmVyeSBieXRlIG9mIGlucHV0IGlzXFxuLy8gaW50ZXJwcmV0ZWQgYXMgYW4gaW50ZWdlciBmcm9tIDAtMjU1LCBhbmQgdGhlbiByZXN1bHRzIGluIHRoYXQgbWFueVxcbi8vIGJ5dGVzIG9mIG91dHB1dC4gIFdyaXRpbmcgdGhlIDQgYnl0ZXMge2ZmLGZmLGZmLGZmfSB3b3VsZCByZXN1bHQgaW5cXG4vLyAxa2Igb2YgZGF0YSBiZWluZyBvdXRwdXQuICBJbiB0aGlzIGNhc2UsIHlvdSBjb3VsZCB3cml0ZSBhIHZlcnkgc21hbGxcXG4vLyBhbW91bnQgb2YgaW5wdXQsIGFuZCBlbmQgdXAgd2l0aCBhIHZlcnkgbGFyZ2UgYW1vdW50IG9mIG91dHB1dC4gIEluXFxuLy8gc3VjaCBhIHBhdGhvbG9naWNhbCBpbmZsYXRpbmcgbWVjaGFuaXNtLCB0aGVyZSdkIGJlIG5vIHdheSB0byB0ZWxsXFxuLy8gdGhlIHN5c3RlbSB0byBzdG9wIGRvaW5nIHRoZSB0cmFuc2Zvcm0uICBBIHNpbmdsZSA0TUIgd3JpdGUgY291bGRcXG4vLyBjYXVzZSB0aGUgc3lzdGVtIHRvIHJ1biBvdXQgb2YgbWVtb3J5Llxcbi8vXFxuLy8gSG93ZXZlciwgZXZlbiBpbiBzdWNoIGEgcGF0aG9sb2dpY2FsIGNhc2UsIG9ubHkgYSBzaW5nbGUgd3JpdHRlbiBjaHVua1xcbi8vIHdvdWxkIGJlIGNvbnN1bWVkLCBhbmQgdGhlbiB0aGUgcmVzdCB3b3VsZCB3YWl0ICh1bi10cmFuc2Zvcm1lZCkgdW50aWxcXG4vLyB0aGUgcmVzdWx0cyBvZiB0aGUgcHJldmlvdXMgdHJhbnNmb3JtZWQgY2h1bmsgd2VyZSBjb25zdW1lZC5cXG5cXG4ndXNlIHN0cmljdCc7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBUcmFuc2Zvcm07XFxuXFxudmFyIER1cGxleCA9IHJlcXVpcmUoJy4vX3N0cmVhbV9kdXBsZXgnKTtcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciB1dGlsID0gcmVxdWlyZSgnY29yZS11dGlsLWlzJyk7XFxudXRpbC5pbmhlcml0cyA9IHJlcXVpcmUoJ2luaGVyaXRzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudXRpbC5pbmhlcml0cyhUcmFuc2Zvcm0sIER1cGxleCk7XFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtU3RhdGUoc3RyZWFtKSB7XFxuICB0aGlzLmFmdGVyVHJhbnNmb3JtID0gZnVuY3Rpb24gKGVyLCBkYXRhKSB7XFxuICAgIHJldHVybiBhZnRlclRyYW5zZm9ybShzdHJlYW0sIGVyLCBkYXRhKTtcXG4gIH07XFxuXFxuICB0aGlzLm5lZWRUcmFuc2Zvcm0gPSBmYWxzZTtcXG4gIHRoaXMudHJhbnNmb3JtaW5nID0gZmFsc2U7XFxuICB0aGlzLndyaXRlY2IgPSBudWxsO1xcbiAgdGhpcy53cml0ZWNodW5rID0gbnVsbDtcXG4gIHRoaXMud3JpdGVlbmNvZGluZyA9IG51bGw7XFxufVxcblxcbmZ1bmN0aW9uIGFmdGVyVHJhbnNmb3JtKHN0cmVhbSwgZXIsIGRhdGEpIHtcXG4gIHZhciB0cyA9IHN0cmVhbS5fdHJhbnNmb3JtU3RhdGU7XFxuICB0cy50cmFuc2Zvcm1pbmcgPSBmYWxzZTtcXG5cXG4gIHZhciBjYiA9IHRzLndyaXRlY2I7XFxuXFxuICBpZiAoIWNiKSB7XFxuICAgIHJldHVybiBzdHJlYW0uZW1pdCgnZXJyb3InLCBuZXcgRXJyb3IoJ3dyaXRlIGNhbGxiYWNrIGNhbGxlZCBtdWx0aXBsZSB0aW1lcycpKTtcXG4gIH1cXG5cXG4gIHRzLndyaXRlY2h1bmsgPSBudWxsO1xcbiAgdHMud3JpdGVjYiA9IG51bGw7XFxuXFxuICBpZiAoZGF0YSAhPT0gbnVsbCAmJiBkYXRhICE9PSB1bmRlZmluZWQpIHN0cmVhbS5wdXNoKGRhdGEpO1xcblxcbiAgY2IoZXIpO1xcblxcbiAgdmFyIHJzID0gc3RyZWFtLl9yZWFkYWJsZVN0YXRlO1xcbiAgcnMucmVhZGluZyA9IGZhbHNlO1xcbiAgaWYgKHJzLm5lZWRSZWFkYWJsZSB8fCBycy5sZW5ndGggPCBycy5oaWdoV2F0ZXJNYXJrKSB7XFxuICAgIHN0cmVhbS5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59XFxuXFxuZnVuY3Rpb24gVHJhbnNmb3JtKG9wdGlvbnMpIHtcXG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBUcmFuc2Zvcm0pKSByZXR1cm4gbmV3IFRyYW5zZm9ybShvcHRpb25zKTtcXG5cXG4gIER1cGxleC5jYWxsKHRoaXMsIG9wdGlvbnMpO1xcblxcbiAgdGhpcy5fdHJhbnNmb3JtU3RhdGUgPSBuZXcgVHJhbnNmb3JtU3RhdGUodGhpcyk7XFxuXFxuICB2YXIgc3RyZWFtID0gdGhpcztcXG5cXG4gIC8vIHN0YXJ0IG91dCBhc2tpbmcgZm9yIGEgcmVhZGFibGUgZXZlbnQgb25jZSBkYXRhIGlzIHRyYW5zZm9ybWVkLlxcbiAgdGhpcy5fcmVhZGFibGVTdGF0ZS5uZWVkUmVhZGFibGUgPSB0cnVlO1xcblxcbiAgLy8gd2UgaGF2ZSBpbXBsZW1lbnRlZCB0aGUgX3JlYWQgbWV0aG9kLCBhbmQgZG9uZSB0aGUgb3RoZXIgdGhpbmdzXFxuICAvLyB0aGF0IFJlYWRhYmxlIHdhbnRzIGJlZm9yZSB0aGUgZmlyc3QgX3JlYWQgY2FsbCwgc28gdW5zZXQgdGhlXFxuICAvLyBzeW5jIGd1YXJkIGZsYWcuXFxuICB0aGlzLl9yZWFkYWJsZVN0YXRlLnN5bmMgPSBmYWxzZTtcXG5cXG4gIGlmIChvcHRpb25zKSB7XFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy50cmFuc2Zvcm0gPT09ICdmdW5jdGlvbicpIHRoaXMuX3RyYW5zZm9ybSA9IG9wdGlvbnMudHJhbnNmb3JtO1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZmx1c2ggPT09ICdmdW5jdGlvbicpIHRoaXMuX2ZsdXNoID0gb3B0aW9ucy5mbHVzaDtcXG4gIH1cXG5cXG4gIC8vIFdoZW4gdGhlIHdyaXRhYmxlIHNpZGUgZmluaXNoZXMsIHRoZW4gZmx1c2ggb3V0IGFueXRoaW5nIHJlbWFpbmluZy5cXG4gIHRoaXMub25jZSgncHJlZmluaXNoJywgZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodHlwZW9mIHRoaXMuX2ZsdXNoID09PSAnZnVuY3Rpb24nKSB0aGlzLl9mbHVzaChmdW5jdGlvbiAoZXIsIGRhdGEpIHtcXG4gICAgICBkb25lKHN0cmVhbSwgZXIsIGRhdGEpO1xcbiAgICB9KTtlbHNlIGRvbmUoc3RyZWFtKTtcXG4gIH0pO1xcbn1cXG5cXG5UcmFuc2Zvcm0ucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nKSB7XFxuICB0aGlzLl90cmFuc2Zvcm1TdGF0ZS5uZWVkVHJhbnNmb3JtID0gZmFsc2U7XFxuICByZXR1cm4gRHVwbGV4LnByb3RvdHlwZS5wdXNoLmNhbGwodGhpcywgY2h1bmssIGVuY29kaW5nKTtcXG59O1xcblxcbi8vIFRoaXMgaXMgdGhlIHBhcnQgd2hlcmUgeW91IGRvIHN0dWZmIVxcbi8vIG92ZXJyaWRlIHRoaXMgZnVuY3Rpb24gaW4gaW1wbGVtZW50YXRpb24gY2xhc3Nlcy5cXG4vLyAnY2h1bmsnIGlzIGFuIGlucHV0IGNodW5rLlxcbi8vXFxuLy8gQ2FsbCBgcHVzaChuZXdDaHVuaylgIHRvIHBhc3MgYWxvbmcgdHJhbnNmb3JtZWQgb3V0cHV0XFxuLy8gdG8gdGhlIHJlYWRhYmxlIHNpZGUuICBZb3UgbWF5IGNhbGwgJ3B1c2gnIHplcm8gb3IgbW9yZSB0aW1lcy5cXG4vL1xcbi8vIENhbGwgYGNiKGVycilgIHdoZW4geW91IGFyZSBkb25lIHdpdGggdGhpcyBjaHVuay4gIElmIHlvdSBwYXNzXFxuLy8gYW4gZXJyb3IsIHRoZW4gdGhhdCdsbCBwdXQgdGhlIGh1cnQgb24gdGhlIHdob2xlIG9wZXJhdGlvbi4gIElmIHlvdVxcbi8vIG5ldmVyIGNhbGwgY2IoKSwgdGhlbiB5b3UnbGwgbmV2ZXIgZ2V0IGFub3RoZXIgY2h1bmsuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fdHJhbnNmb3JtID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHRocm93IG5ldyBFcnJvcignX3RyYW5zZm9ybSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpO1xcbn07XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fd3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuICB0cy53cml0ZWNiID0gY2I7XFxuICB0cy53cml0ZWNodW5rID0gY2h1bms7XFxuICB0cy53cml0ZWVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICBpZiAoIXRzLnRyYW5zZm9ybWluZykge1xcbiAgICB2YXIgcnMgPSB0aGlzLl9yZWFkYWJsZVN0YXRlO1xcbiAgICBpZiAodHMubmVlZFRyYW5zZm9ybSB8fCBycy5uZWVkUmVhZGFibGUgfHwgcnMubGVuZ3RoIDwgcnMuaGlnaFdhdGVyTWFyaykgdGhpcy5fcmVhZChycy5oaWdoV2F0ZXJNYXJrKTtcXG4gIH1cXG59O1xcblxcbi8vIERvZXNuJ3QgbWF0dGVyIHdoYXQgdGhlIGFyZ3MgYXJlIGhlcmUuXFxuLy8gX3RyYW5zZm9ybSBkb2VzIGFsbCB0aGUgd29yay5cXG4vLyBUaGF0IHdlIGdvdCBoZXJlIG1lYW5zIHRoYXQgdGhlIHJlYWRhYmxlIHNpZGUgd2FudHMgbW9yZSBkYXRhLlxcblRyYW5zZm9ybS5wcm90b3R5cGUuX3JlYWQgPSBmdW5jdGlvbiAobikge1xcbiAgdmFyIHRzID0gdGhpcy5fdHJhbnNmb3JtU3RhdGU7XFxuXFxuICBpZiAodHMud3JpdGVjaHVuayAhPT0gbnVsbCAmJiB0cy53cml0ZWNiICYmICF0cy50cmFuc2Zvcm1pbmcpIHtcXG4gICAgdHMudHJhbnNmb3JtaW5nID0gdHJ1ZTtcXG4gICAgdGhpcy5fdHJhbnNmb3JtKHRzLndyaXRlY2h1bmssIHRzLndyaXRlZW5jb2RpbmcsIHRzLmFmdGVyVHJhbnNmb3JtKTtcXG4gIH0gZWxzZSB7XFxuICAgIC8vIG1hcmsgdGhhdCB3ZSBuZWVkIGEgdHJhbnNmb3JtLCBzbyB0aGF0IGFueSBkYXRhIHRoYXQgY29tZXMgaW5cXG4gICAgLy8gd2lsbCBnZXQgcHJvY2Vzc2VkLCBub3cgdGhhdCB3ZSd2ZSBhc2tlZCBmb3IgaXQuXFxuICAgIHRzLm5lZWRUcmFuc2Zvcm0gPSB0cnVlO1xcbiAgfVxcbn07XFxuXFxuVHJhbnNmb3JtLnByb3RvdHlwZS5fZGVzdHJveSA9IGZ1bmN0aW9uIChlcnIsIGNiKSB7XFxuICB2YXIgX3RoaXMgPSB0aGlzO1xcblxcbiAgRHVwbGV4LnByb3RvdHlwZS5fZGVzdHJveS5jYWxsKHRoaXMsIGVyciwgZnVuY3Rpb24gKGVycjIpIHtcXG4gICAgY2IoZXJyMik7XFxuICAgIF90aGlzLmVtaXQoJ2Nsb3NlJyk7XFxuICB9KTtcXG59O1xcblxcbmZ1bmN0aW9uIGRvbmUoc3RyZWFtLCBlciwgZGF0YSkge1xcbiAgaWYgKGVyKSByZXR1cm4gc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcblxcbiAgaWYgKGRhdGEgIT09IG51bGwgJiYgZGF0YSAhPT0gdW5kZWZpbmVkKSBzdHJlYW0ucHVzaChkYXRhKTtcXG5cXG4gIC8vIGlmIHRoZXJlJ3Mgbm90aGluZyBpbiB0aGUgd3JpdGUgYnVmZmVyLCB0aGVuIHRoYXQgbWVhbnNcXG4gIC8vIHRoYXQgbm90aGluZyBtb3JlIHdpbGwgZXZlciBiZSBwcm92aWRlZFxcbiAgdmFyIHdzID0gc3RyZWFtLl93cml0YWJsZVN0YXRlO1xcbiAgdmFyIHRzID0gc3RyZWFtLl90cmFuc2Zvcm1TdGF0ZTtcXG5cXG4gIGlmICh3cy5sZW5ndGgpIHRocm93IG5ldyBFcnJvcignQ2FsbGluZyB0cmFuc2Zvcm0gZG9uZSB3aGVuIHdzLmxlbmd0aCAhPSAwJyk7XFxuXFxuICBpZiAodHMudHJhbnNmb3JtaW5nKSB0aHJvdyBuZXcgRXJyb3IoJ0NhbGxpbmcgdHJhbnNmb3JtIGRvbmUgd2hlbiBzdGlsbCB0cmFuc2Zvcm1pbmcnKTtcXG5cXG4gIHJldHVybiBzdHJlYW0ucHVzaChudWxsKTtcXG59XFxufSx7XFxcIi4vX3N0cmVhbV9kdXBsZXhcXFwiOjU4LFxcXCJjb3JlLXV0aWwtaXNcXFwiOjQyLFxcXCJpbmhlcml0c1xcXCI6NTB9XSw2MjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxuLy8gQSBiaXQgc2ltcGxlciB0aGFuIHJlYWRhYmxlIHN0cmVhbXMuXFxuLy8gSW1wbGVtZW50IGFuIGFzeW5jIC5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYiksIGFuZCBpdCdsbCBoYW5kbGUgYWxsXFxuLy8gdGhlIGRyYWluIGV2ZW50IGVtaXNzaW9uIGFuZCBidWZmZXJpbmcuXFxuXFxuJ3VzZSBzdHJpY3QnO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxuXFxudmFyIHByb2Nlc3NOZXh0VGljayA9IHJlcXVpcmUoJ3Byb2Nlc3MtbmV4dGljay1hcmdzJyk7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBXcml0YWJsZTtcXG5cXG4vKiA8cmVwbGFjZW1lbnQ+ICovXFxuZnVuY3Rpb24gV3JpdGVSZXEoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdGhpcy5jaHVuayA9IGNodW5rO1xcbiAgdGhpcy5lbmNvZGluZyA9IGVuY29kaW5nO1xcbiAgdGhpcy5jYWxsYmFjayA9IGNiO1xcbiAgdGhpcy5uZXh0ID0gbnVsbDtcXG59XFxuXFxuLy8gSXQgc2VlbXMgYSBsaW5rZWQgbGlzdCBidXQgaXQgaXMgbm90XFxuLy8gdGhlcmUgd2lsbCBiZSBvbmx5IDIgb2YgdGhlc2UgZm9yIGVhY2ggc3RyZWFtXFxuZnVuY3Rpb24gQ29ya2VkUmVxdWVzdChzdGF0ZSkge1xcbiAgdmFyIF90aGlzID0gdGhpcztcXG5cXG4gIHRoaXMubmV4dCA9IG51bGw7XFxuICB0aGlzLmVudHJ5ID0gbnVsbDtcXG4gIHRoaXMuZmluaXNoID0gZnVuY3Rpb24gKCkge1xcbiAgICBvbkNvcmtlZEZpbmlzaChfdGhpcywgc3RhdGUpO1xcbiAgfTtcXG59XFxuLyogPC9yZXBsYWNlbWVudD4gKi9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBhc3luY1dyaXRlID0gIXByb2Nlc3MuYnJvd3NlciAmJiBbJ3YwLjEwJywgJ3YwLjkuJ10uaW5kZXhPZihwcm9jZXNzLnZlcnNpb24uc2xpY2UoMCwgNSkpID4gLTEgPyBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzTmV4dFRpY2s7XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxuLyo8cmVwbGFjZW1lbnQ+Ki9cXG52YXIgRHVwbGV4O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbldyaXRhYmxlLldyaXRhYmxlU3RhdGUgPSBXcml0YWJsZVN0YXRlO1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIHV0aWwgPSByZXF1aXJlKCdjb3JlLXV0aWwtaXMnKTtcXG51dGlsLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBpbnRlcm5hbFV0aWwgPSB7XFxuICBkZXByZWNhdGU6IHJlcXVpcmUoJ3V0aWwtZGVwcmVjYXRlJylcXG59O1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8qPHJlcGxhY2VtZW50PiovXFxudmFyIFN0cmVhbSA9IHJlcXVpcmUoJy4vaW50ZXJuYWwvc3RyZWFtcy9zdHJlYW0nKTtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG52YXIgT3VyVWludDhBcnJheSA9IGdsb2JhbC5VaW50OEFycmF5IHx8IGZ1bmN0aW9uICgpIHt9O1xcbmZ1bmN0aW9uIF91aW50OEFycmF5VG9CdWZmZXIoY2h1bmspIHtcXG4gIHJldHVybiBCdWZmZXIuZnJvbShjaHVuayk7XFxufVxcbmZ1bmN0aW9uIF9pc1VpbnQ4QXJyYXkob2JqKSB7XFxuICByZXR1cm4gQnVmZmVyLmlzQnVmZmVyKG9iaikgfHwgb2JqIGluc3RhbmNlb2YgT3VyVWludDhBcnJheTtcXG59XFxuLyo8L3JlcGxhY2VtZW50PiovXFxuXFxudmFyIGRlc3Ryb3lJbXBsID0gcmVxdWlyZSgnLi9pbnRlcm5hbC9zdHJlYW1zL2Rlc3Ryb3knKTtcXG5cXG51dGlsLmluaGVyaXRzKFdyaXRhYmxlLCBTdHJlYW0pO1xcblxcbmZ1bmN0aW9uIG5vcCgpIHt9XFxuXFxuZnVuY3Rpb24gV3JpdGFibGVTdGF0ZShvcHRpb25zLCBzdHJlYW0pIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG5cXG4gIC8vIG9iamVjdCBzdHJlYW0gZmxhZyB0byBpbmRpY2F0ZSB3aGV0aGVyIG9yIG5vdCB0aGlzIHN0cmVhbVxcbiAgLy8gY29udGFpbnMgYnVmZmVycyBvciBvYmplY3RzLlxcbiAgdGhpcy5vYmplY3RNb2RlID0gISFvcHRpb25zLm9iamVjdE1vZGU7XFxuXFxuICBpZiAoc3RyZWFtIGluc3RhbmNlb2YgRHVwbGV4KSB0aGlzLm9iamVjdE1vZGUgPSB0aGlzLm9iamVjdE1vZGUgfHwgISFvcHRpb25zLndyaXRhYmxlT2JqZWN0TW9kZTtcXG5cXG4gIC8vIHRoZSBwb2ludCBhdCB3aGljaCB3cml0ZSgpIHN0YXJ0cyByZXR1cm5pbmcgZmFsc2VcXG4gIC8vIE5vdGU6IDAgaXMgYSB2YWxpZCB2YWx1ZSwgbWVhbnMgdGhhdCB3ZSBhbHdheXMgcmV0dXJuIGZhbHNlIGlmXFxuICAvLyB0aGUgZW50aXJlIGJ1ZmZlciBpcyBub3QgZmx1c2hlZCBpbW1lZGlhdGVseSBvbiB3cml0ZSgpXFxuICB2YXIgaHdtID0gb3B0aW9ucy5oaWdoV2F0ZXJNYXJrO1xcbiAgdmFyIGRlZmF1bHRId20gPSB0aGlzLm9iamVjdE1vZGUgPyAxNiA6IDE2ICogMTAyNDtcXG4gIHRoaXMuaGlnaFdhdGVyTWFyayA9IGh3bSB8fCBod20gPT09IDAgPyBod20gOiBkZWZhdWx0SHdtO1xcblxcbiAgLy8gY2FzdCB0byBpbnRzLlxcbiAgdGhpcy5oaWdoV2F0ZXJNYXJrID0gTWF0aC5mbG9vcih0aGlzLmhpZ2hXYXRlck1hcmspO1xcblxcbiAgLy8gaWYgX2ZpbmFsIGhhcyBiZWVuIGNhbGxlZFxcbiAgdGhpcy5maW5hbENhbGxlZCA9IGZhbHNlO1xcblxcbiAgLy8gZHJhaW4gZXZlbnQgZmxhZy5cXG4gIHRoaXMubmVlZERyYWluID0gZmFsc2U7XFxuICAvLyBhdCB0aGUgc3RhcnQgb2YgY2FsbGluZyBlbmQoKVxcbiAgdGhpcy5lbmRpbmcgPSBmYWxzZTtcXG4gIC8vIHdoZW4gZW5kKCkgaGFzIGJlZW4gY2FsbGVkLCBhbmQgcmV0dXJuZWRcXG4gIHRoaXMuZW5kZWQgPSBmYWxzZTtcXG4gIC8vIHdoZW4gJ2ZpbmlzaCcgaXMgZW1pdHRlZFxcbiAgdGhpcy5maW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gaGFzIGl0IGJlZW4gZGVzdHJveWVkXFxuICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xcblxcbiAgLy8gc2hvdWxkIHdlIGRlY29kZSBzdHJpbmdzIGludG8gYnVmZmVycyBiZWZvcmUgcGFzc2luZyB0byBfd3JpdGU/XFxuICAvLyB0aGlzIGlzIGhlcmUgc28gdGhhdCBzb21lIG5vZGUtY29yZSBzdHJlYW1zIGNhbiBvcHRpbWl6ZSBzdHJpbmdcXG4gIC8vIGhhbmRsaW5nIGF0IGEgbG93ZXIgbGV2ZWwuXFxuICB2YXIgbm9EZWNvZGUgPSBvcHRpb25zLmRlY29kZVN0cmluZ3MgPT09IGZhbHNlO1xcbiAgdGhpcy5kZWNvZGVTdHJpbmdzID0gIW5vRGVjb2RlO1xcblxcbiAgLy8gQ3J5cHRvIGlzIGtpbmQgb2Ygb2xkIGFuZCBjcnVzdHkuICBIaXN0b3JpY2FsbHksIGl0cyBkZWZhdWx0IHN0cmluZ1xcbiAgLy8gZW5jb2RpbmcgaXMgJ2JpbmFyeScgc28gd2UgaGF2ZSB0byBtYWtlIHRoaXMgY29uZmlndXJhYmxlLlxcbiAgLy8gRXZlcnl0aGluZyBlbHNlIGluIHRoZSB1bml2ZXJzZSB1c2VzICd1dGY4JywgdGhvdWdoLlxcbiAgdGhpcy5kZWZhdWx0RW5jb2RpbmcgPSBvcHRpb25zLmRlZmF1bHRFbmNvZGluZyB8fCAndXRmOCc7XFxuXFxuICAvLyBub3QgYW4gYWN0dWFsIGJ1ZmZlciB3ZSBrZWVwIHRyYWNrIG9mLCBidXQgYSBtZWFzdXJlbWVudFxcbiAgLy8gb2YgaG93IG11Y2ggd2UncmUgd2FpdGluZyB0byBnZXQgcHVzaGVkIHRvIHNvbWUgdW5kZXJseWluZ1xcbiAgLy8gc29ja2V0IG9yIGZpbGUuXFxuICB0aGlzLmxlbmd0aCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gc2VlIHdoZW4gd2UncmUgaW4gdGhlIG1pZGRsZSBvZiBhIHdyaXRlLlxcbiAgdGhpcy53cml0aW5nID0gZmFsc2U7XFxuXFxuICAvLyB3aGVuIHRydWUgYWxsIHdyaXRlcyB3aWxsIGJlIGJ1ZmZlcmVkIHVudGlsIC51bmNvcmsoKSBjYWxsXFxuICB0aGlzLmNvcmtlZCA9IDA7XFxuXFxuICAvLyBhIGZsYWcgdG8gYmUgYWJsZSB0byB0ZWxsIGlmIHRoZSBvbndyaXRlIGNiIGlzIGNhbGxlZCBpbW1lZGlhdGVseSxcXG4gIC8vIG9yIG9uIGEgbGF0ZXIgdGljay4gIFdlIHNldCB0aGlzIHRvIHRydWUgYXQgZmlyc3QsIGJlY2F1c2UgYW55XFxuICAvLyBhY3Rpb25zIHRoYXQgc2hvdWxkbid0IGhhcHBlbiB1bnRpbCBcXFwibGF0ZXJcXFwiIHNob3VsZCBnZW5lcmFsbHkgYWxzb1xcbiAgLy8gbm90IGhhcHBlbiBiZWZvcmUgdGhlIGZpcnN0IHdyaXRlIGNhbGwuXFxuICB0aGlzLnN5bmMgPSB0cnVlO1xcblxcbiAgLy8gYSBmbGFnIHRvIGtub3cgaWYgd2UncmUgcHJvY2Vzc2luZyBwcmV2aW91c2x5IGJ1ZmZlcmVkIGl0ZW1zLCB3aGljaFxcbiAgLy8gbWF5IGNhbGwgdGhlIF93cml0ZSgpIGNhbGxiYWNrIGluIHRoZSBzYW1lIHRpY2ssIHNvIHRoYXQgd2UgZG9uJ3RcXG4gIC8vIGVuZCB1cCBpbiBhbiBvdmVybGFwcGVkIG9ud3JpdGUgc2l0dWF0aW9uLlxcbiAgdGhpcy5idWZmZXJQcm9jZXNzaW5nID0gZmFsc2U7XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCdzIHBhc3NlZCB0byBfd3JpdGUoY2h1bmssY2IpXFxuICB0aGlzLm9ud3JpdGUgPSBmdW5jdGlvbiAoZXIpIHtcXG4gICAgb253cml0ZShzdHJlYW0sIGVyKTtcXG4gIH07XFxuXFxuICAvLyB0aGUgY2FsbGJhY2sgdGhhdCB0aGUgdXNlciBzdXBwbGllcyB0byB3cml0ZShjaHVuayxlbmNvZGluZyxjYilcXG4gIHRoaXMud3JpdGVjYiA9IG51bGw7XFxuXFxuICAvLyB0aGUgYW1vdW50IHRoYXQgaXMgYmVpbmcgd3JpdHRlbiB3aGVuIF93cml0ZSBpcyBjYWxsZWQuXFxuICB0aGlzLndyaXRlbGVuID0gMDtcXG5cXG4gIHRoaXMuYnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gIHRoaXMubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuXFxuICAvLyBudW1iZXIgb2YgcGVuZGluZyB1c2VyLXN1cHBsaWVkIHdyaXRlIGNhbGxiYWNrc1xcbiAgLy8gdGhpcyBtdXN0IGJlIDAgYmVmb3JlICdmaW5pc2gnIGNhbiBiZSBlbWl0dGVkXFxuICB0aGlzLnBlbmRpbmdjYiA9IDA7XFxuXFxuICAvLyBlbWl0IHByZWZpbmlzaCBpZiB0aGUgb25seSB0aGluZyB3ZSdyZSB3YWl0aW5nIGZvciBpcyBfd3JpdGUgY2JzXFxuICAvLyBUaGlzIGlzIHJlbGV2YW50IGZvciBzeW5jaHJvbm91cyBUcmFuc2Zvcm0gc3RyZWFtc1xcbiAgdGhpcy5wcmVmaW5pc2hlZCA9IGZhbHNlO1xcblxcbiAgLy8gVHJ1ZSBpZiB0aGUgZXJyb3Igd2FzIGFscmVhZHkgZW1pdHRlZCBhbmQgc2hvdWxkIG5vdCBiZSB0aHJvd24gYWdhaW5cXG4gIHRoaXMuZXJyb3JFbWl0dGVkID0gZmFsc2U7XFxuXFxuICAvLyBjb3VudCBidWZmZXJlZCByZXF1ZXN0c1xcbiAgdGhpcy5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XFxuXFxuICAvLyBhbGxvY2F0ZSB0aGUgZmlyc3QgQ29ya2VkUmVxdWVzdCwgdGhlcmUgaXMgYWx3YXlzXFxuICAvLyBvbmUgYWxsb2NhdGVkIGFuZCBmcmVlIHRvIHVzZSwgYW5kIHdlIG1haW50YWluIGF0IG1vc3QgdHdvXFxuICB0aGlzLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHRoaXMpO1xcbn1cXG5cXG5Xcml0YWJsZVN0YXRlLnByb3RvdHlwZS5nZXRCdWZmZXIgPSBmdW5jdGlvbiBnZXRCdWZmZXIoKSB7XFxuICB2YXIgY3VycmVudCA9IHRoaXMuYnVmZmVyZWRSZXF1ZXN0O1xcbiAgdmFyIG91dCA9IFtdO1xcbiAgd2hpbGUgKGN1cnJlbnQpIHtcXG4gICAgb3V0LnB1c2goY3VycmVudCk7XFxuICAgIGN1cnJlbnQgPSBjdXJyZW50Lm5leHQ7XFxuICB9XFxuICByZXR1cm4gb3V0O1xcbn07XFxuXFxuKGZ1bmN0aW9uICgpIHtcXG4gIHRyeSB7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShXcml0YWJsZVN0YXRlLnByb3RvdHlwZSwgJ2J1ZmZlcicsIHtcXG4gICAgICBnZXQ6IGludGVybmFsVXRpbC5kZXByZWNhdGUoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0QnVmZmVyKCk7XFxuICAgICAgfSwgJ193cml0YWJsZVN0YXRlLmJ1ZmZlciBpcyBkZXByZWNhdGVkLiBVc2UgX3dyaXRhYmxlU3RhdGUuZ2V0QnVmZmVyICcgKyAnaW5zdGVhZC4nLCAnREVQMDAwMycpXFxuICAgIH0pO1xcbiAgfSBjYXRjaCAoXykge31cXG59KSgpO1xcblxcbi8vIFRlc3QgX3dyaXRhYmxlU3RhdGUgZm9yIGluaGVyaXRhbmNlIHRvIGFjY291bnQgZm9yIER1cGxleCBzdHJlYW1zLFxcbi8vIHdob3NlIHByb3RvdHlwZSBjaGFpbiBvbmx5IHBvaW50cyB0byBSZWFkYWJsZS5cXG52YXIgcmVhbEhhc0luc3RhbmNlO1xcbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5oYXNJbnN0YW5jZSAmJiB0eXBlb2YgRnVuY3Rpb24ucHJvdG90eXBlW1N5bWJvbC5oYXNJbnN0YW5jZV0gPT09ICdmdW5jdGlvbicpIHtcXG4gIHJlYWxIYXNJbnN0YW5jZSA9IEZ1bmN0aW9uLnByb3RvdHlwZVtTeW1ib2wuaGFzSW5zdGFuY2VdO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLCBTeW1ib2wuaGFzSW5zdGFuY2UsIHtcXG4gICAgdmFsdWU6IGZ1bmN0aW9uIChvYmplY3QpIHtcXG4gICAgICBpZiAocmVhbEhhc0luc3RhbmNlLmNhbGwodGhpcywgb2JqZWN0KSkgcmV0dXJuIHRydWU7XFxuXFxuICAgICAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3QuX3dyaXRhYmxlU3RhdGUgaW5zdGFuY2VvZiBXcml0YWJsZVN0YXRlO1xcbiAgICB9XFxuICB9KTtcXG59IGVsc2Uge1xcbiAgcmVhbEhhc0luc3RhbmNlID0gZnVuY3Rpb24gKG9iamVjdCkge1xcbiAgICByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgdGhpcztcXG4gIH07XFxufVxcblxcbmZ1bmN0aW9uIFdyaXRhYmxlKG9wdGlvbnMpIHtcXG4gIER1cGxleCA9IER1cGxleCB8fCByZXF1aXJlKCcuL19zdHJlYW1fZHVwbGV4Jyk7XFxuXFxuICAvLyBXcml0YWJsZSBjdG9yIGlzIGFwcGxpZWQgdG8gRHVwbGV4ZXMsIHRvby5cXG4gIC8vIGByZWFsSGFzSW5zdGFuY2VgIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIHVzaW5nIHBsYWluIGBpbnN0YW5jZW9mYFxcbiAgLy8gd291bGQgcmV0dXJuIGZhbHNlLCBhcyBubyBgX3dyaXRhYmxlU3RhdGVgIHByb3BlcnR5IGlzIGF0dGFjaGVkLlxcblxcbiAgLy8gVHJ5aW5nIHRvIHVzZSB0aGUgY3VzdG9tIGBpbnN0YW5jZW9mYCBmb3IgV3JpdGFibGUgaGVyZSB3aWxsIGFsc28gYnJlYWsgdGhlXFxuICAvLyBOb2RlLmpzIExhenlUcmFuc2Zvcm0gaW1wbGVtZW50YXRpb24sIHdoaWNoIGhhcyBhIG5vbi10cml2aWFsIGdldHRlciBmb3JcXG4gIC8vIGBfd3JpdGFibGVTdGF0ZWAgdGhhdCB3b3VsZCBsZWFkIHRvIGluZmluaXRlIHJlY3Vyc2lvbi5cXG4gIGlmICghcmVhbEhhc0luc3RhbmNlLmNhbGwoV3JpdGFibGUsIHRoaXMpICYmICEodGhpcyBpbnN0YW5jZW9mIER1cGxleCkpIHtcXG4gICAgcmV0dXJuIG5ldyBXcml0YWJsZShvcHRpb25zKTtcXG4gIH1cXG5cXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUgPSBuZXcgV3JpdGFibGVTdGF0ZShvcHRpb25zLCB0aGlzKTtcXG5cXG4gIC8vIGxlZ2FjeS5cXG4gIHRoaXMud3JpdGFibGUgPSB0cnVlO1xcblxcbiAgaWYgKG9wdGlvbnMpIHtcXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLndyaXRlID09PSAnZnVuY3Rpb24nKSB0aGlzLl93cml0ZSA9IG9wdGlvbnMud3JpdGU7XFxuXFxuICAgIGlmICh0eXBlb2Ygb3B0aW9ucy53cml0ZXYgPT09ICdmdW5jdGlvbicpIHRoaXMuX3dyaXRldiA9IG9wdGlvbnMud3JpdGV2O1xcblxcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgdGhpcy5fZGVzdHJveSA9IG9wdGlvbnMuZGVzdHJveTtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbmFsID09PSAnZnVuY3Rpb24nKSB0aGlzLl9maW5hbCA9IG9wdGlvbnMuZmluYWw7XFxuICB9XFxuXFxuICBTdHJlYW0uY2FsbCh0aGlzKTtcXG59XFxuXFxuLy8gT3RoZXJ3aXNlIHBlb3BsZSBjYW4gcGlwZSBXcml0YWJsZSBzdHJlYW1zLCB3aGljaCBpcyBqdXN0IHdyb25nLlxcbldyaXRhYmxlLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24gKCkge1xcbiAgdGhpcy5lbWl0KCdlcnJvcicsIG5ldyBFcnJvcignQ2Fubm90IHBpcGUsIG5vdCByZWFkYWJsZScpKTtcXG59O1xcblxcbmZ1bmN0aW9uIHdyaXRlQWZ0ZXJFbmQoc3RyZWFtLCBjYikge1xcbiAgdmFyIGVyID0gbmV3IEVycm9yKCd3cml0ZSBhZnRlciBlbmQnKTtcXG4gIC8vIFRPRE86IGRlZmVyIGVycm9yIGV2ZW50cyBjb25zaXN0ZW50bHkgZXZlcnl3aGVyZSwgbm90IGp1c3QgdGhlIGNiXFxuICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICBwcm9jZXNzTmV4dFRpY2soY2IsIGVyKTtcXG59XFxuXFxuLy8gQ2hlY2tzIHRoYXQgYSB1c2VyLXN1cHBsaWVkIGNodW5rIGlzIHZhbGlkLCBlc3BlY2lhbGx5IGZvciB0aGUgcGFydGljdWxhclxcbi8vIG1vZGUgdGhlIHN0cmVhbSBpcyBpbi4gQ3VycmVudGx5IHRoaXMgbWVhbnMgdGhhdCBgbnVsbGAgaXMgbmV2ZXIgYWNjZXB0ZWRcXG4vLyBhbmQgdW5kZWZpbmVkL25vbi1zdHJpbmcgdmFsdWVzIGFyZSBvbmx5IGFsbG93ZWQgaW4gb2JqZWN0IG1vZGUuXFxuZnVuY3Rpb24gdmFsaWRDaHVuayhzdHJlYW0sIHN0YXRlLCBjaHVuaywgY2IpIHtcXG4gIHZhciB2YWxpZCA9IHRydWU7XFxuICB2YXIgZXIgPSBmYWxzZTtcXG5cXG4gIGlmIChjaHVuayA9PT0gbnVsbCkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ01heSBub3Qgd3JpdGUgbnVsbCB2YWx1ZXMgdG8gc3RyZWFtJyk7XFxuICB9IGVsc2UgaWYgKHR5cGVvZiBjaHVuayAhPT0gJ3N0cmluZycgJiYgY2h1bmsgIT09IHVuZGVmaW5lZCAmJiAhc3RhdGUub2JqZWN0TW9kZSkge1xcbiAgICBlciA9IG5ldyBUeXBlRXJyb3IoJ0ludmFsaWQgbm9uLXN0cmluZy9idWZmZXIgY2h1bmsnKTtcXG4gIH1cXG4gIGlmIChlcikge1xcbiAgICBzdHJlYW0uZW1pdCgnZXJyb3InLCBlcik7XFxuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xcbiAgICB2YWxpZCA9IGZhbHNlO1xcbiAgfVxcbiAgcmV0dXJuIHZhbGlkO1xcbn1cXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoY2h1bmssIGVuY29kaW5nLCBjYikge1xcbiAgdmFyIHN0YXRlID0gdGhpcy5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciByZXQgPSBmYWxzZTtcXG4gIHZhciBpc0J1ZiA9IF9pc1VpbnQ4QXJyYXkoY2h1bmspICYmICFzdGF0ZS5vYmplY3RNb2RlO1xcblxcbiAgaWYgKGlzQnVmICYmICFCdWZmZXIuaXNCdWZmZXIoY2h1bmspKSB7XFxuICAgIGNodW5rID0gX3VpbnQ4QXJyYXlUb0J1ZmZlcihjaHVuayk7XFxuICB9XFxuXFxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gZW5jb2Rpbmc7XFxuICAgIGVuY29kaW5nID0gbnVsbDtcXG4gIH1cXG5cXG4gIGlmIChpc0J1ZikgZW5jb2RpbmcgPSAnYnVmZmVyJztlbHNlIGlmICghZW5jb2RpbmcpIGVuY29kaW5nID0gc3RhdGUuZGVmYXVsdEVuY29kaW5nO1xcblxcbiAgaWYgKHR5cGVvZiBjYiAhPT0gJ2Z1bmN0aW9uJykgY2IgPSBub3A7XFxuXFxuICBpZiAoc3RhdGUuZW5kZWQpIHdyaXRlQWZ0ZXJFbmQodGhpcywgY2IpO2Vsc2UgaWYgKGlzQnVmIHx8IHZhbGlkQ2h1bmsodGhpcywgc3RhdGUsIGNodW5rLCBjYikpIHtcXG4gICAgc3RhdGUucGVuZGluZ2NiKys7XFxuICAgIHJldCA9IHdyaXRlT3JCdWZmZXIodGhpcywgc3RhdGUsIGlzQnVmLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuY29yayA9IGZ1bmN0aW9uICgpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBzdGF0ZS5jb3JrZWQrKztcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS51bmNvcmsgPSBmdW5jdGlvbiAoKSB7XFxuICB2YXIgc3RhdGUgPSB0aGlzLl93cml0YWJsZVN0YXRlO1xcblxcbiAgaWYgKHN0YXRlLmNvcmtlZCkge1xcbiAgICBzdGF0ZS5jb3JrZWQtLTtcXG5cXG4gICAgaWYgKCFzdGF0ZS53cml0aW5nICYmICFzdGF0ZS5jb3JrZWQgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS5idWZmZXJQcm9jZXNzaW5nICYmIHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdCkgY2xlYXJCdWZmZXIodGhpcywgc3RhdGUpO1xcbiAgfVxcbn07XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLnNldERlZmF1bHRFbmNvZGluZyA9IGZ1bmN0aW9uIHNldERlZmF1bHRFbmNvZGluZyhlbmNvZGluZykge1xcbiAgLy8gbm9kZTo6UGFyc2VFbmNvZGluZygpIHJlcXVpcmVzIGxvd2VyIGNhc2UuXFxuICBpZiAodHlwZW9mIGVuY29kaW5nID09PSAnc3RyaW5nJykgZW5jb2RpbmcgPSBlbmNvZGluZy50b0xvd2VyQ2FzZSgpO1xcbiAgaWYgKCEoWydoZXgnLCAndXRmOCcsICd1dGYtOCcsICdhc2NpaScsICdiaW5hcnknLCAnYmFzZTY0JywgJ3VjczInLCAndWNzLTInLCAndXRmMTZsZScsICd1dGYtMTZsZScsICdyYXcnXS5pbmRleE9mKChlbmNvZGluZyArICcnKS50b0xvd2VyQ2FzZSgpKSA+IC0xKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignVW5rbm93biBlbmNvZGluZzogJyArIGVuY29kaW5nKTtcXG4gIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVmYXVsdEVuY29kaW5nID0gZW5jb2Rpbmc7XFxuICByZXR1cm4gdGhpcztcXG59O1xcblxcbmZ1bmN0aW9uIGRlY29kZUNodW5rKHN0YXRlLCBjaHVuaywgZW5jb2RpbmcpIHtcXG4gIGlmICghc3RhdGUub2JqZWN0TW9kZSAmJiBzdGF0ZS5kZWNvZGVTdHJpbmdzICE9PSBmYWxzZSAmJiB0eXBlb2YgY2h1bmsgPT09ICdzdHJpbmcnKSB7XFxuICAgIGNodW5rID0gQnVmZmVyLmZyb20oY2h1bmssIGVuY29kaW5nKTtcXG4gIH1cXG4gIHJldHVybiBjaHVuaztcXG59XFxuXFxuLy8gaWYgd2UncmUgYWxyZWFkeSB3cml0aW5nIHNvbWV0aGluZywgdGhlbiBqdXN0IHB1dCB0aGlzXFxuLy8gaW4gdGhlIHF1ZXVlLCBhbmQgd2FpdCBvdXIgdHVybi4gIE90aGVyd2lzZSwgY2FsbCBfd3JpdGVcXG4vLyBJZiB3ZSByZXR1cm4gZmFsc2UsIHRoZW4gd2UgbmVlZCBhIGRyYWluIGV2ZW50LCBzbyBzZXQgdGhhdCBmbGFnLlxcbmZ1bmN0aW9uIHdyaXRlT3JCdWZmZXIoc3RyZWFtLCBzdGF0ZSwgaXNCdWYsIGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIGlmICghaXNCdWYpIHtcXG4gICAgdmFyIG5ld0NodW5rID0gZGVjb2RlQ2h1bmsoc3RhdGUsIGNodW5rLCBlbmNvZGluZyk7XFxuICAgIGlmIChjaHVuayAhPT0gbmV3Q2h1bmspIHtcXG4gICAgICBpc0J1ZiA9IHRydWU7XFxuICAgICAgZW5jb2RpbmcgPSAnYnVmZmVyJztcXG4gICAgICBjaHVuayA9IG5ld0NodW5rO1xcbiAgICB9XFxuICB9XFxuICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XFxuXFxuICBzdGF0ZS5sZW5ndGggKz0gbGVuO1xcblxcbiAgdmFyIHJldCA9IHN0YXRlLmxlbmd0aCA8IHN0YXRlLmhpZ2hXYXRlck1hcms7XFxuICAvLyB3ZSBtdXN0IGVuc3VyZSB0aGF0IHByZXZpb3VzIG5lZWREcmFpbiB3aWxsIG5vdCBiZSByZXNldCB0byBmYWxzZS5cXG4gIGlmICghcmV0KSBzdGF0ZS5uZWVkRHJhaW4gPSB0cnVlO1xcblxcbiAgaWYgKHN0YXRlLndyaXRpbmcgfHwgc3RhdGUuY29ya2VkKSB7XFxuICAgIHZhciBsYXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IHtcXG4gICAgICBjaHVuazogY2h1bmssXFxuICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxcbiAgICAgIGlzQnVmOiBpc0J1ZixcXG4gICAgICBjYWxsYmFjazogY2IsXFxuICAgICAgbmV4dDogbnVsbFxcbiAgICB9O1xcbiAgICBpZiAobGFzdCkge1xcbiAgICAgIGxhc3QubmV4dCA9IHN0YXRlLmxhc3RCdWZmZXJlZFJlcXVlc3Q7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RhdGUuYnVmZmVyZWRSZXF1ZXN0ID0gc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdDtcXG4gICAgfVxcbiAgICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCArPSAxO1xcbiAgfSBlbHNlIHtcXG4gICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcXG4gIH1cXG5cXG4gIHJldHVybiByZXQ7XFxufVxcblxcbmZ1bmN0aW9uIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgd3JpdGV2LCBsZW4sIGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHN0YXRlLndyaXRlbGVuID0gbGVuO1xcbiAgc3RhdGUud3JpdGVjYiA9IGNiO1xcbiAgc3RhdGUud3JpdGluZyA9IHRydWU7XFxuICBzdGF0ZS5zeW5jID0gdHJ1ZTtcXG4gIGlmICh3cml0ZXYpIHN0cmVhbS5fd3JpdGV2KGNodW5rLCBzdGF0ZS5vbndyaXRlKTtlbHNlIHN0cmVhbS5fd3JpdGUoY2h1bmssIGVuY29kaW5nLCBzdGF0ZS5vbndyaXRlKTtcXG4gIHN0YXRlLnN5bmMgPSBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gb253cml0ZUVycm9yKHN0cmVhbSwgc3RhdGUsIHN5bmMsIGVyLCBjYikge1xcbiAgLS1zdGF0ZS5wZW5kaW5nY2I7XFxuXFxuICBpZiAoc3luYykge1xcbiAgICAvLyBkZWZlciB0aGUgY2FsbGJhY2sgaWYgd2UgYXJlIGJlaW5nIGNhbGxlZCBzeW5jaHJvbm91c2x5XFxuICAgIC8vIHRvIGF2b2lkIHBpbGluZyB1cCB0aGluZ3Mgb24gdGhlIHN0YWNrXFxuICAgIHByb2Nlc3NOZXh0VGljayhjYiwgZXIpO1xcbiAgICAvLyB0aGlzIGNhbiBlbWl0IGZpbmlzaCwgYW5kIGl0IHdpbGwgYWx3YXlzIGhhcHBlblxcbiAgICAvLyBhZnRlciBlcnJvclxcbiAgICBwcm9jZXNzTmV4dFRpY2soZmluaXNoTWF5YmUsIHN0cmVhbSwgc3RhdGUpO1xcbiAgICBzdHJlYW0uX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkID0gdHJ1ZTtcXG4gICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXIpO1xcbiAgfSBlbHNlIHtcXG4gICAgLy8gdGhlIGNhbGxlciBleHBlY3QgdGhpcyB0byBoYXBwZW4gYmVmb3JlIGlmXFxuICAgIC8vIGl0IGlzIGFzeW5jXFxuICAgIGNiKGVyKTtcXG4gICAgc3RyZWFtLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5lbWl0KCdlcnJvcicsIGVyKTtcXG4gICAgLy8gdGhpcyBjYW4gZW1pdCBmaW5pc2gsIGJ1dCBmaW5pc2ggbXVzdFxcbiAgICAvLyBhbHdheXMgZm9sbG93IGVycm9yXFxuICAgIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpIHtcXG4gIHN0YXRlLndyaXRpbmcgPSBmYWxzZTtcXG4gIHN0YXRlLndyaXRlY2IgPSBudWxsO1xcbiAgc3RhdGUubGVuZ3RoIC09IHN0YXRlLndyaXRlbGVuO1xcbiAgc3RhdGUud3JpdGVsZW4gPSAwO1xcbn1cXG5cXG5mdW5jdGlvbiBvbndyaXRlKHN0cmVhbSwgZXIpIHtcXG4gIHZhciBzdGF0ZSA9IHN0cmVhbS5fd3JpdGFibGVTdGF0ZTtcXG4gIHZhciBzeW5jID0gc3RhdGUuc3luYztcXG4gIHZhciBjYiA9IHN0YXRlLndyaXRlY2I7XFxuXFxuICBvbndyaXRlU3RhdGVVcGRhdGUoc3RhdGUpO1xcblxcbiAgaWYgKGVyKSBvbndyaXRlRXJyb3Ioc3RyZWFtLCBzdGF0ZSwgc3luYywgZXIsIGNiKTtlbHNlIHtcXG4gICAgLy8gQ2hlY2sgaWYgd2UncmUgYWN0dWFsbHkgcmVhZHkgdG8gZmluaXNoLCBidXQgZG9uJ3QgZW1pdCB5ZXRcXG4gICAgdmFyIGZpbmlzaGVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuXFxuICAgIGlmICghZmluaXNoZWQgJiYgIXN0YXRlLmNvcmtlZCAmJiAhc3RhdGUuYnVmZmVyUHJvY2Vzc2luZyAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QpIHtcXG4gICAgICBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKTtcXG4gICAgfVxcblxcbiAgICBpZiAoc3luYykge1xcbiAgICAgIC8qPHJlcGxhY2VtZW50PiovXFxuICAgICAgYXN5bmNXcml0ZShhZnRlcldyaXRlLCBzdHJlYW0sIHN0YXRlLCBmaW5pc2hlZCwgY2IpO1xcbiAgICAgIC8qPC9yZXBsYWNlbWVudD4qL1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIGFmdGVyV3JpdGUoc3RyZWFtLCBzdGF0ZSwgZmluaXNoZWQsIGNiKTtcXG4gICAgfVxcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBhZnRlcldyaXRlKHN0cmVhbSwgc3RhdGUsIGZpbmlzaGVkLCBjYikge1xcbiAgaWYgKCFmaW5pc2hlZCkgb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpO1xcbiAgc3RhdGUucGVuZGluZ2NiLS07XFxuICBjYigpO1xcbiAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxufVxcblxcbi8vIE11c3QgZm9yY2UgY2FsbGJhY2sgdG8gYmUgY2FsbGVkIG9uIG5leHRUaWNrLCBzbyB0aGF0IHdlIGRvbid0XFxuLy8gZW1pdCAnZHJhaW4nIGJlZm9yZSB0aGUgd3JpdGUoKSBjb25zdW1lciBnZXRzIHRoZSAnZmFsc2UnIHJldHVyblxcbi8vIHZhbHVlLCBhbmQgaGFzIGEgY2hhbmNlIHRvIGF0dGFjaCBhICdkcmFpbicgbGlzdGVuZXIuXFxuZnVuY3Rpb24gb253cml0ZURyYWluKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmIChzdGF0ZS5sZW5ndGggPT09IDAgJiYgc3RhdGUubmVlZERyYWluKSB7XFxuICAgIHN0YXRlLm5lZWREcmFpbiA9IGZhbHNlO1xcbiAgICBzdHJlYW0uZW1pdCgnZHJhaW4nKTtcXG4gIH1cXG59XFxuXFxuLy8gaWYgdGhlcmUncyBzb21ldGhpbmcgaW4gdGhlIGJ1ZmZlciB3YWl0aW5nLCB0aGVuIHByb2Nlc3MgaXRcXG5mdW5jdGlvbiBjbGVhckJ1ZmZlcihzdHJlYW0sIHN0YXRlKSB7XFxuICBzdGF0ZS5idWZmZXJQcm9jZXNzaW5nID0gdHJ1ZTtcXG4gIHZhciBlbnRyeSA9IHN0YXRlLmJ1ZmZlcmVkUmVxdWVzdDtcXG5cXG4gIGlmIChzdHJlYW0uX3dyaXRldiAmJiBlbnRyeSAmJiBlbnRyeS5uZXh0KSB7XFxuICAgIC8vIEZhc3QgY2FzZSwgd3JpdGUgZXZlcnl0aGluZyB1c2luZyBfd3JpdGV2KClcXG4gICAgdmFyIGwgPSBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudDtcXG4gICAgdmFyIGJ1ZmZlciA9IG5ldyBBcnJheShsKTtcXG4gICAgdmFyIGhvbGRlciA9IHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZTtcXG4gICAgaG9sZGVyLmVudHJ5ID0gZW50cnk7XFxuXFxuICAgIHZhciBjb3VudCA9IDA7XFxuICAgIHZhciBhbGxCdWZmZXJzID0gdHJ1ZTtcXG4gICAgd2hpbGUgKGVudHJ5KSB7XFxuICAgICAgYnVmZmVyW2NvdW50XSA9IGVudHJ5O1xcbiAgICAgIGlmICghZW50cnkuaXNCdWYpIGFsbEJ1ZmZlcnMgPSBmYWxzZTtcXG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XFxuICAgICAgY291bnQgKz0gMTtcXG4gICAgfVxcbiAgICBidWZmZXIuYWxsQnVmZmVycyA9IGFsbEJ1ZmZlcnM7XFxuXFxuICAgIGRvV3JpdGUoc3RyZWFtLCBzdGF0ZSwgdHJ1ZSwgc3RhdGUubGVuZ3RoLCBidWZmZXIsICcnLCBob2xkZXIuZmluaXNoKTtcXG5cXG4gICAgLy8gZG9Xcml0ZSBpcyBhbG1vc3QgYWx3YXlzIGFzeW5jLCBkZWZlciB0aGVzZSB0byBzYXZlIGEgYml0IG9mIHRpbWVcXG4gICAgLy8gYXMgdGhlIGhvdCBwYXRoIGVuZHMgd2l0aCBkb1dyaXRlXFxuICAgIHN0YXRlLnBlbmRpbmdjYisrO1xcbiAgICBzdGF0ZS5sYXN0QnVmZmVyZWRSZXF1ZXN0ID0gbnVsbDtcXG4gICAgaWYgKGhvbGRlci5uZXh0KSB7XFxuICAgICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gaG9sZGVyLm5leHQ7XFxuICAgICAgaG9sZGVyLm5leHQgPSBudWxsO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHN0YXRlLmNvcmtlZFJlcXVlc3RzRnJlZSA9IG5ldyBDb3JrZWRSZXF1ZXN0KHN0YXRlKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gU2xvdyBjYXNlLCB3cml0ZSBjaHVua3Mgb25lLWJ5LW9uZVxcbiAgICB3aGlsZSAoZW50cnkpIHtcXG4gICAgICB2YXIgY2h1bmsgPSBlbnRyeS5jaHVuaztcXG4gICAgICB2YXIgZW5jb2RpbmcgPSBlbnRyeS5lbmNvZGluZztcXG4gICAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcXG4gICAgICB2YXIgbGVuID0gc3RhdGUub2JqZWN0TW9kZSA/IDEgOiBjaHVuay5sZW5ndGg7XFxuXFxuICAgICAgZG9Xcml0ZShzdHJlYW0sIHN0YXRlLCBmYWxzZSwgbGVuLCBjaHVuaywgZW5jb2RpbmcsIGNiKTtcXG4gICAgICBlbnRyeSA9IGVudHJ5Lm5leHQ7XFxuICAgICAgLy8gaWYgd2UgZGlkbid0IGNhbGwgdGhlIG9ud3JpdGUgaW1tZWRpYXRlbHksIHRoZW5cXG4gICAgICAvLyBpdCBtZWFucyB0aGF0IHdlIG5lZWQgdG8gd2FpdCB1bnRpbCBpdCBkb2VzLlxcbiAgICAgIC8vIGFsc28sIHRoYXQgbWVhbnMgdGhhdCB0aGUgY2h1bmsgYW5kIGNiIGFyZSBjdXJyZW50bHlcXG4gICAgICAvLyBiZWluZyBwcm9jZXNzZWQsIHNvIG1vdmUgdGhlIGJ1ZmZlciBjb3VudGVyIHBhc3QgdGhlbS5cXG4gICAgICBpZiAoc3RhdGUud3JpdGluZykge1xcbiAgICAgICAgYnJlYWs7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmIChlbnRyeSA9PT0gbnVsbCkgc3RhdGUubGFzdEJ1ZmZlcmVkUmVxdWVzdCA9IG51bGw7XFxuICB9XFxuXFxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3RDb3VudCA9IDA7XFxuICBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPSBlbnRyeTtcXG4gIHN0YXRlLmJ1ZmZlclByb2Nlc3NpbmcgPSBmYWxzZTtcXG59XFxuXFxuV3JpdGFibGUucHJvdG90eXBlLl93cml0ZSA9IGZ1bmN0aW9uIChjaHVuaywgZW5jb2RpbmcsIGNiKSB7XFxuICBjYihuZXcgRXJyb3IoJ193cml0ZSgpIGlzIG5vdCBpbXBsZW1lbnRlZCcpKTtcXG59O1xcblxcbldyaXRhYmxlLnByb3RvdHlwZS5fd3JpdGV2ID0gbnVsbDtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuZW5kID0gZnVuY3Rpb24gKGNodW5rLCBlbmNvZGluZywgY2IpIHtcXG4gIHZhciBzdGF0ZSA9IHRoaXMuX3dyaXRhYmxlU3RhdGU7XFxuXFxuICBpZiAodHlwZW9mIGNodW5rID09PSAnZnVuY3Rpb24nKSB7XFxuICAgIGNiID0gY2h1bms7XFxuICAgIGNodW5rID0gbnVsbDtcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgY2IgPSBlbmNvZGluZztcXG4gICAgZW5jb2RpbmcgPSBudWxsO1xcbiAgfVxcblxcbiAgaWYgKGNodW5rICE9PSBudWxsICYmIGNodW5rICE9PSB1bmRlZmluZWQpIHRoaXMud3JpdGUoY2h1bmssIGVuY29kaW5nKTtcXG5cXG4gIC8vIC5lbmQoKSBmdWxseSB1bmNvcmtzXFxuICBpZiAoc3RhdGUuY29ya2VkKSB7XFxuICAgIHN0YXRlLmNvcmtlZCA9IDE7XFxuICAgIHRoaXMudW5jb3JrKCk7XFxuICB9XFxuXFxuICAvLyBpZ25vcmUgdW5uZWNlc3NhcnkgZW5kKCkgY2FsbHMuXFxuICBpZiAoIXN0YXRlLmVuZGluZyAmJiAhc3RhdGUuZmluaXNoZWQpIGVuZFdyaXRhYmxlKHRoaXMsIHN0YXRlLCBjYik7XFxufTtcXG5cXG5mdW5jdGlvbiBuZWVkRmluaXNoKHN0YXRlKSB7XFxuICByZXR1cm4gc3RhdGUuZW5kaW5nICYmIHN0YXRlLmxlbmd0aCA9PT0gMCAmJiBzdGF0ZS5idWZmZXJlZFJlcXVlc3QgPT09IG51bGwgJiYgIXN0YXRlLmZpbmlzaGVkICYmICFzdGF0ZS53cml0aW5nO1xcbn1cXG5mdW5jdGlvbiBjYWxsRmluYWwoc3RyZWFtLCBzdGF0ZSkge1xcbiAgc3RyZWFtLl9maW5hbChmdW5jdGlvbiAoZXJyKSB7XFxuICAgIHN0YXRlLnBlbmRpbmdjYi0tO1xcbiAgICBpZiAoZXJyKSB7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2Vycm9yJywgZXJyKTtcXG4gICAgfVxcbiAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XFxuICAgIHN0cmVhbS5lbWl0KCdwcmVmaW5pc2gnKTtcXG4gICAgZmluaXNoTWF5YmUoc3RyZWFtLCBzdGF0ZSk7XFxuICB9KTtcXG59XFxuZnVuY3Rpb24gcHJlZmluaXNoKHN0cmVhbSwgc3RhdGUpIHtcXG4gIGlmICghc3RhdGUucHJlZmluaXNoZWQgJiYgIXN0YXRlLmZpbmFsQ2FsbGVkKSB7XFxuICAgIGlmICh0eXBlb2Ygc3RyZWFtLl9maW5hbCA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgIHN0YXRlLnBlbmRpbmdjYisrO1xcbiAgICAgIHN0YXRlLmZpbmFsQ2FsbGVkID0gdHJ1ZTtcXG4gICAgICBwcm9jZXNzTmV4dFRpY2soY2FsbEZpbmFsLCBzdHJlYW0sIHN0YXRlKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdGF0ZS5wcmVmaW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ3ByZWZpbmlzaCcpO1xcbiAgICB9XFxuICB9XFxufVxcblxcbmZ1bmN0aW9uIGZpbmlzaE1heWJlKHN0cmVhbSwgc3RhdGUpIHtcXG4gIHZhciBuZWVkID0gbmVlZEZpbmlzaChzdGF0ZSk7XFxuICBpZiAobmVlZCkge1xcbiAgICBwcmVmaW5pc2goc3RyZWFtLCBzdGF0ZSk7XFxuICAgIGlmIChzdGF0ZS5wZW5kaW5nY2IgPT09IDApIHtcXG4gICAgICBzdGF0ZS5maW5pc2hlZCA9IHRydWU7XFxuICAgICAgc3RyZWFtLmVtaXQoJ2ZpbmlzaCcpO1xcbiAgICB9XFxuICB9XFxuICByZXR1cm4gbmVlZDtcXG59XFxuXFxuZnVuY3Rpb24gZW5kV3JpdGFibGUoc3RyZWFtLCBzdGF0ZSwgY2IpIHtcXG4gIHN0YXRlLmVuZGluZyA9IHRydWU7XFxuICBmaW5pc2hNYXliZShzdHJlYW0sIHN0YXRlKTtcXG4gIGlmIChjYikge1xcbiAgICBpZiAoc3RhdGUuZmluaXNoZWQpIHByb2Nlc3NOZXh0VGljayhjYik7ZWxzZSBzdHJlYW0ub25jZSgnZmluaXNoJywgY2IpO1xcbiAgfVxcbiAgc3RhdGUuZW5kZWQgPSB0cnVlO1xcbiAgc3RyZWFtLndyaXRhYmxlID0gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIG9uQ29ya2VkRmluaXNoKGNvcmtSZXEsIHN0YXRlLCBlcnIpIHtcXG4gIHZhciBlbnRyeSA9IGNvcmtSZXEuZW50cnk7XFxuICBjb3JrUmVxLmVudHJ5ID0gbnVsbDtcXG4gIHdoaWxlIChlbnRyeSkge1xcbiAgICB2YXIgY2IgPSBlbnRyeS5jYWxsYmFjaztcXG4gICAgc3RhdGUucGVuZGluZ2NiLS07XFxuICAgIGNiKGVycik7XFxuICAgIGVudHJ5ID0gZW50cnkubmV4dDtcXG4gIH1cXG4gIGlmIChzdGF0ZS5jb3JrZWRSZXF1ZXN0c0ZyZWUpIHtcXG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlLm5leHQgPSBjb3JrUmVxO1xcbiAgfSBlbHNlIHtcXG4gICAgc3RhdGUuY29ya2VkUmVxdWVzdHNGcmVlID0gY29ya1JlcTtcXG4gIH1cXG59XFxuXFxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFdyaXRhYmxlLnByb3RvdHlwZSwgJ2Rlc3Ryb3llZCcsIHtcXG4gIGdldDogZnVuY3Rpb24gKCkge1xcbiAgICBpZiAodGhpcy5fd3JpdGFibGVTdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XFxuICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHJldHVybiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcXG4gIH0sXFxuICBzZXQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAvLyB3ZSBpZ25vcmUgdGhlIHZhbHVlIGlmIHRoZSBzdHJlYW1cXG4gICAgLy8gaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkIHlldFxcbiAgICBpZiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgdGhlIHVzZXIgaXMgZXhwbGljaXRseVxcbiAgICAvLyBtYW5hZ2luZyBkZXN0cm95ZWRcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB2YWx1ZTtcXG4gIH1cXG59KTtcXG5cXG5Xcml0YWJsZS5wcm90b3R5cGUuZGVzdHJveSA9IGRlc3Ryb3lJbXBsLmRlc3Ryb3k7XFxuV3JpdGFibGUucHJvdG90eXBlLl91bmRlc3Ryb3kgPSBkZXN0cm95SW1wbC51bmRlc3Ryb3k7XFxuV3JpdGFibGUucHJvdG90eXBlLl9kZXN0cm95ID0gZnVuY3Rpb24gKGVyciwgY2IpIHtcXG4gIHRoaXMuZW5kKCk7XFxuICBjYihlcnIpO1xcbn07XFxufSkuY2FsbCh0aGlzLHJlcXVpcmUoJ19wcm9jZXNzJyksdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHtcXFwiLi9fc3RyZWFtX2R1cGxleFxcXCI6NTgsXFxcIi4vaW50ZXJuYWwvc3RyZWFtcy9kZXN0cm95XFxcIjo2NCxcXFwiLi9pbnRlcm5hbC9zdHJlYW1zL3N0cmVhbVxcXCI6NjUsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiY29yZS11dGlsLWlzXFxcIjo0MixcXFwiaW5oZXJpdHNcXFwiOjUwLFxcXCJwcm9jZXNzLW5leHRpY2stYXJnc1xcXCI6NTUsXFxcInNhZmUtYnVmZmVyXFxcIjo3MCxcXFwidXRpbC1kZXByZWNhdGVcXFwiOjczfV0sNjM6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbmZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHsgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHsgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXFxcIik7IH0gfVxcblxcbnZhciBCdWZmZXIgPSByZXF1aXJlKCdzYWZlLWJ1ZmZlcicpLkJ1ZmZlcjtcXG4vKjwvcmVwbGFjZW1lbnQ+Ki9cXG5cXG5mdW5jdGlvbiBjb3B5QnVmZmVyKHNyYywgdGFyZ2V0LCBvZmZzZXQpIHtcXG4gIHNyYy5jb3B5KHRhcmdldCwgb2Zmc2V0KTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoKSB7XFxuICBmdW5jdGlvbiBCdWZmZXJMaXN0KCkge1xcbiAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQnVmZmVyTGlzdCk7XFxuXFxuICAgIHRoaXMuaGVhZCA9IG51bGw7XFxuICAgIHRoaXMudGFpbCA9IG51bGw7XFxuICAgIHRoaXMubGVuZ3RoID0gMDtcXG4gIH1cXG5cXG4gIEJ1ZmZlckxpc3QucHJvdG90eXBlLnB1c2ggPSBmdW5jdGlvbiBwdXNoKHYpIHtcXG4gICAgdmFyIGVudHJ5ID0geyBkYXRhOiB2LCBuZXh0OiBudWxsIH07XFxuICAgIGlmICh0aGlzLmxlbmd0aCA+IDApIHRoaXMudGFpbC5uZXh0ID0gZW50cnk7ZWxzZSB0aGlzLmhlYWQgPSBlbnRyeTtcXG4gICAgdGhpcy50YWlsID0gZW50cnk7XFxuICAgICsrdGhpcy5sZW5ndGg7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUudW5zaGlmdCA9IGZ1bmN0aW9uIHVuc2hpZnQodikge1xcbiAgICB2YXIgZW50cnkgPSB7IGRhdGE6IHYsIG5leHQ6IHRoaXMuaGVhZCB9O1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHRoaXMudGFpbCA9IGVudHJ5O1xcbiAgICB0aGlzLmhlYWQgPSBlbnRyeTtcXG4gICAgKyt0aGlzLmxlbmd0aDtcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uIHNoaWZ0KCkge1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybjtcXG4gICAgdmFyIHJldCA9IHRoaXMuaGVhZC5kYXRhO1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHRoaXMuaGVhZCA9IHRoaXMudGFpbCA9IG51bGw7ZWxzZSB0aGlzLmhlYWQgPSB0aGlzLmhlYWQubmV4dDtcXG4gICAgLS10aGlzLmxlbmd0aDtcXG4gICAgcmV0dXJuIHJldDtcXG4gIH07XFxuXFxuICBCdWZmZXJMaXN0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyKCkge1xcbiAgICB0aGlzLmhlYWQgPSB0aGlzLnRhaWwgPSBudWxsO1xcbiAgICB0aGlzLmxlbmd0aCA9IDA7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuam9pbiA9IGZ1bmN0aW9uIGpvaW4ocykge1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHJldHVybiAnJztcXG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XFxuICAgIHZhciByZXQgPSAnJyArIHAuZGF0YTtcXG4gICAgd2hpbGUgKHAgPSBwLm5leHQpIHtcXG4gICAgICByZXQgKz0gcyArIHAuZGF0YTtcXG4gICAgfXJldHVybiByZXQ7XFxuICB9O1xcblxcbiAgQnVmZmVyTGlzdC5wcm90b3R5cGUuY29uY2F0ID0gZnVuY3Rpb24gY29uY2F0KG4pIHtcXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAwKSByZXR1cm4gQnVmZmVyLmFsbG9jKDApO1xcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEpIHJldHVybiB0aGlzLmhlYWQuZGF0YTtcXG4gICAgdmFyIHJldCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShuID4+PiAwKTtcXG4gICAgdmFyIHAgPSB0aGlzLmhlYWQ7XFxuICAgIHZhciBpID0gMDtcXG4gICAgd2hpbGUgKHApIHtcXG4gICAgICBjb3B5QnVmZmVyKHAuZGF0YSwgcmV0LCBpKTtcXG4gICAgICBpICs9IHAuZGF0YS5sZW5ndGg7XFxuICAgICAgcCA9IHAubmV4dDtcXG4gICAgfVxcbiAgICByZXR1cm4gcmV0O1xcbiAgfTtcXG5cXG4gIHJldHVybiBCdWZmZXJMaXN0O1xcbn0oKTtcXG59LHtcXFwic2FmZS1idWZmZXJcXFwiOjcwfV0sNjQ6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG4vKjxyZXBsYWNlbWVudD4qL1xcblxcbnZhciBwcm9jZXNzTmV4dFRpY2sgPSByZXF1aXJlKCdwcm9jZXNzLW5leHRpY2stYXJncycpO1xcbi8qPC9yZXBsYWNlbWVudD4qL1xcblxcbi8vIHVuZG9jdW1lbnRlZCBjYigpIEFQSSwgbmVlZGVkIGZvciBjb3JlLCBub3QgZm9yIHB1YmxpYyBBUElcXG5mdW5jdGlvbiBkZXN0cm95KGVyciwgY2IpIHtcXG4gIHZhciBfdGhpcyA9IHRoaXM7XFxuXFxuICB2YXIgcmVhZGFibGVEZXN0cm95ZWQgPSB0aGlzLl9yZWFkYWJsZVN0YXRlICYmIHRoaXMuX3JlYWRhYmxlU3RhdGUuZGVzdHJveWVkO1xcbiAgdmFyIHdyaXRhYmxlRGVzdHJveWVkID0gdGhpcy5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLl93cml0YWJsZVN0YXRlLmRlc3Ryb3llZDtcXG5cXG4gIGlmIChyZWFkYWJsZURlc3Ryb3llZCB8fCB3cml0YWJsZURlc3Ryb3llZCkge1xcbiAgICBpZiAoY2IpIHtcXG4gICAgICBjYihlcnIpO1xcbiAgICB9IGVsc2UgaWYgKGVyciAmJiAoIXRoaXMuX3dyaXRhYmxlU3RhdGUgfHwgIXRoaXMuX3dyaXRhYmxlU3RhdGUuZXJyb3JFbWl0dGVkKSkge1xcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgdGhpcywgZXJyKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxuICB9XFxuXFxuICAvLyB3ZSBzZXQgZGVzdHJveWVkIHRvIHRydWUgYmVmb3JlIGZpcmluZyBlcnJvciBjYWxsYmFja3MgaW4gb3JkZXJcXG4gIC8vIHRvIG1ha2UgaXQgcmUtZW50cmFuY2Ugc2FmZSBpbiBjYXNlIGRlc3Ryb3koKSBpcyBjYWxsZWQgd2l0aGluIGNhbGxiYWNrc1xcblxcbiAgaWYgKHRoaXMuX3JlYWRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgLy8gaWYgdGhpcyBpcyBhIGR1cGxleCBzdHJlYW0gbWFyayB0aGUgd3JpdGFibGUgcGFydCBhcyBkZXN0cm95ZWQgYXMgd2VsbFxcbiAgaWYgKHRoaXMuX3dyaXRhYmxlU3RhdGUpIHtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xcbiAgfVxcblxcbiAgdGhpcy5fZGVzdHJveShlcnIgfHwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xcbiAgICBpZiAoIWNiICYmIGVycikge1xcbiAgICAgIHByb2Nlc3NOZXh0VGljayhlbWl0RXJyb3JOVCwgX3RoaXMsIGVycik7XFxuICAgICAgaWYgKF90aGlzLl93cml0YWJsZVN0YXRlKSB7XFxuICAgICAgICBfdGhpcy5fd3JpdGFibGVTdGF0ZS5lcnJvckVtaXR0ZWQgPSB0cnVlO1xcbiAgICAgIH1cXG4gICAgfSBlbHNlIGlmIChjYikge1xcbiAgICAgIGNiKGVycik7XFxuICAgIH1cXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiB1bmRlc3Ryb3koKSB7XFxuICBpZiAodGhpcy5fcmVhZGFibGVTdGF0ZSkge1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmRlc3Ryb3llZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLnJlYWRpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5fcmVhZGFibGVTdGF0ZS5lbmRlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl9yZWFkYWJsZVN0YXRlLmVuZEVtaXR0ZWQgPSBmYWxzZTtcXG4gIH1cXG5cXG4gIGlmICh0aGlzLl93cml0YWJsZVN0YXRlKSB7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZGVzdHJveWVkID0gZmFsc2U7XFxuICAgIHRoaXMuX3dyaXRhYmxlU3RhdGUuZW5kZWQgPSBmYWxzZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5lbmRpbmcgPSBmYWxzZTtcXG4gICAgdGhpcy5fd3JpdGFibGVTdGF0ZS5maW5pc2hlZCA9IGZhbHNlO1xcbiAgICB0aGlzLl93cml0YWJsZVN0YXRlLmVycm9yRW1pdHRlZCA9IGZhbHNlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBlbWl0RXJyb3JOVChzZWxmLCBlcnIpIHtcXG4gIHNlbGYuZW1pdCgnZXJyb3InLCBlcnIpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIGRlc3Ryb3k6IGRlc3Ryb3ksXFxuICB1bmRlc3Ryb3k6IHVuZGVzdHJveVxcbn07XFxufSx7XFxcInByb2Nlc3MtbmV4dGljay1hcmdzXFxcIjo1NX1dLDY1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG5cXG59LHtcXFwiZXZlbnRzXFxcIjo0N31dLDY2OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5QYXNzVGhyb3VnaFxcblxcbn0se1xcXCIuL3JlYWRhYmxlXFxcIjo2N31dLDY3OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzJyk7XFxuZXhwb3J0cy5TdHJlYW0gPSBleHBvcnRzO1xcbmV4cG9ydHMuUmVhZGFibGUgPSBleHBvcnRzO1xcbmV4cG9ydHMuV3JpdGFibGUgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XFxuZXhwb3J0cy5EdXBsZXggPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX2R1cGxleC5qcycpO1xcbmV4cG9ydHMuVHJhbnNmb3JtID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanMnKTtcXG5leHBvcnRzLlBhc3NUaHJvdWdoID0gcmVxdWlyZSgnLi9saWIvX3N0cmVhbV9wYXNzdGhyb3VnaC5qcycpO1xcblxcbn0se1xcXCIuL2xpYi9fc3RyZWFtX2R1cGxleC5qc1xcXCI6NTgsXFxcIi4vbGliL19zdHJlYW1fcGFzc3Rocm91Z2guanNcXFwiOjU5LFxcXCIuL2xpYi9fc3RyZWFtX3JlYWRhYmxlLmpzXFxcIjo2MCxcXFwiLi9saWIvX3N0cmVhbV90cmFuc2Zvcm0uanNcXFwiOjYxLFxcXCIuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzXFxcIjo2Mn1dLDY4OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vcmVhZGFibGUnKS5UcmFuc2Zvcm1cXG5cXG59LHtcXFwiLi9yZWFkYWJsZVxcXCI6Njd9XSw2OTpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxubW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9fc3RyZWFtX3dyaXRhYmxlLmpzJyk7XFxuXFxufSx7XFxcIi4vbGliL19zdHJlYW1fd3JpdGFibGUuanNcXFwiOjYyfV0sNzA6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8qIGVzbGludC1kaXNhYmxlIG5vZGUvbm8tZGVwcmVjYXRlZC1hcGkgKi9cXG52YXIgYnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJylcXG52YXIgQnVmZmVyID0gYnVmZmVyLkJ1ZmZlclxcblxcbi8vIGFsdGVybmF0aXZlIHRvIHVzaW5nIE9iamVjdC5rZXlzIGZvciBvbGQgYnJvd3NlcnNcXG5mdW5jdGlvbiBjb3B5UHJvcHMgKHNyYywgZHN0KSB7XFxuICBmb3IgKHZhciBrZXkgaW4gc3JjKSB7XFxuICAgIGRzdFtrZXldID0gc3JjW2tleV1cXG4gIH1cXG59XFxuaWYgKEJ1ZmZlci5mcm9tICYmIEJ1ZmZlci5hbGxvYyAmJiBCdWZmZXIuYWxsb2NVbnNhZmUgJiYgQnVmZmVyLmFsbG9jVW5zYWZlU2xvdykge1xcbiAgbW9kdWxlLmV4cG9ydHMgPSBidWZmZXJcXG59IGVsc2Uge1xcbiAgLy8gQ29weSBwcm9wZXJ0aWVzIGZyb20gcmVxdWlyZSgnYnVmZmVyJylcXG4gIGNvcHlQcm9wcyhidWZmZXIsIGV4cG9ydHMpXFxuICBleHBvcnRzLkJ1ZmZlciA9IFNhZmVCdWZmZXJcXG59XFxuXFxuZnVuY3Rpb24gU2FmZUJ1ZmZlciAoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpIHtcXG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcbi8vIENvcHkgc3RhdGljIG1ldGhvZHMgZnJvbSBCdWZmZXJcXG5jb3B5UHJvcHMoQnVmZmVyLCBTYWZlQnVmZmVyKVxcblxcblNhZmVCdWZmZXIuZnJvbSA9IGZ1bmN0aW9uIChhcmcsIGVuY29kaW5nT3JPZmZzZXQsIGxlbmd0aCkge1xcbiAgaWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3Qgbm90IGJlIGEgbnVtYmVyJylcXG4gIH1cXG4gIHJldHVybiBCdWZmZXIoYXJnLCBlbmNvZGluZ09yT2Zmc2V0LCBsZW5ndGgpXFxufVxcblxcblNhZmVCdWZmZXIuYWxsb2MgPSBmdW5jdGlvbiAoc2l6ZSwgZmlsbCwgZW5jb2RpbmcpIHtcXG4gIGlmICh0eXBlb2Ygc2l6ZSAhPT0gJ251bWJlcicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnQgbXVzdCBiZSBhIG51bWJlcicpXFxuICB9XFxuICB2YXIgYnVmID0gQnVmZmVyKHNpemUpXFxuICBpZiAoZmlsbCAhPT0gdW5kZWZpbmVkKSB7XFxuICAgIGlmICh0eXBlb2YgZW5jb2RpbmcgPT09ICdzdHJpbmcnKSB7XFxuICAgICAgYnVmLmZpbGwoZmlsbCwgZW5jb2RpbmcpXFxuICAgIH0gZWxzZSB7XFxuICAgICAgYnVmLmZpbGwoZmlsbClcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgYnVmLmZpbGwoMClcXG4gIH1cXG4gIHJldHVybiBidWZcXG59XFxuXFxuU2FmZUJ1ZmZlci5hbGxvY1Vuc2FmZSA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgcmV0dXJuIEJ1ZmZlcihzaXplKVxcbn1cXG5cXG5TYWZlQnVmZmVyLmFsbG9jVW5zYWZlU2xvdyA9IGZ1bmN0aW9uIChzaXplKSB7XFxuICBpZiAodHlwZW9mIHNpemUgIT09ICdudW1iZXInKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50IG11c3QgYmUgYSBudW1iZXInKVxcbiAgfVxcbiAgcmV0dXJuIGJ1ZmZlci5TbG93QnVmZmVyKHNpemUpXFxufVxcblxcbn0se1xcXCJidWZmZXJcXFwiOjQxfV0sNzE6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxcbi8vXFxuLy8gUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGFcXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXFxuLy8gXFxcIlNvZnR3YXJlXFxcIiksIHRvIGRlYWwgaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZ1xcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XFxuLy8gcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpcyBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlXFxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XFxuLy9cXG4vLyBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZFxcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxcbi8vXFxuLy8gVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFxcXCJBUyBJU1xcXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1NcXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXFxuLy8gTUVSQ0hBTlRBQklMSVRZLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTlxcbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxcbi8vIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLCBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEVcXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxcblxcbm1vZHVsZS5leHBvcnRzID0gU3RyZWFtO1xcblxcbnZhciBFRSA9IHJlcXVpcmUoJ2V2ZW50cycpLkV2ZW50RW1pdHRlcjtcXG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xcblxcbmluaGVyaXRzKFN0cmVhbSwgRUUpO1xcblN0cmVhbS5SZWFkYWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qcycpO1xcblN0cmVhbS5Xcml0YWJsZSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS93cml0YWJsZS5qcycpO1xcblN0cmVhbS5EdXBsZXggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4LmpzJyk7XFxuU3RyZWFtLlRyYW5zZm9ybSA9IHJlcXVpcmUoJ3JlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanMnKTtcXG5TdHJlYW0uUGFzc1Rocm91Z2ggPSByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vcGFzc3Rocm91Z2guanMnKTtcXG5cXG4vLyBCYWNrd2FyZHMtY29tcGF0IHdpdGggbm9kZSAwLjQueFxcblN0cmVhbS5TdHJlYW0gPSBTdHJlYW07XFxuXFxuXFxuXFxuLy8gb2xkLXN0eWxlIHN0cmVhbXMuICBOb3RlIHRoYXQgdGhlIHBpcGUgbWV0aG9kICh0aGUgb25seSByZWxldmFudFxcbi8vIHBhcnQgb2YgdGhpcyBjbGFzcykgaXMgb3ZlcnJpZGRlbiBpbiB0aGUgUmVhZGFibGUgY2xhc3MuXFxuXFxuZnVuY3Rpb24gU3RyZWFtKCkge1xcbiAgRUUuY2FsbCh0aGlzKTtcXG59XFxuXFxuU3RyZWFtLnByb3RvdHlwZS5waXBlID0gZnVuY3Rpb24oZGVzdCwgb3B0aW9ucykge1xcbiAgdmFyIHNvdXJjZSA9IHRoaXM7XFxuXFxuICBmdW5jdGlvbiBvbmRhdGEoY2h1bmspIHtcXG4gICAgaWYgKGRlc3Qud3JpdGFibGUpIHtcXG4gICAgICBpZiAoZmFsc2UgPT09IGRlc3Qud3JpdGUoY2h1bmspICYmIHNvdXJjZS5wYXVzZSkge1xcbiAgICAgICAgc291cmNlLnBhdXNlKCk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2RhdGEnLCBvbmRhdGEpO1xcblxcbiAgZnVuY3Rpb24gb25kcmFpbigpIHtcXG4gICAgaWYgKHNvdXJjZS5yZWFkYWJsZSAmJiBzb3VyY2UucmVzdW1lKSB7XFxuICAgICAgc291cmNlLnJlc3VtZSgpO1xcbiAgICB9XFxuICB9XFxuXFxuICBkZXN0Lm9uKCdkcmFpbicsIG9uZHJhaW4pO1xcblxcbiAgLy8gSWYgdGhlICdlbmQnIG9wdGlvbiBpcyBub3Qgc3VwcGxpZWQsIGRlc3QuZW5kKCkgd2lsbCBiZSBjYWxsZWQgd2hlblxcbiAgLy8gc291cmNlIGdldHMgdGhlICdlbmQnIG9yICdjbG9zZScgZXZlbnRzLiAgT25seSBkZXN0LmVuZCgpIG9uY2UuXFxuICBpZiAoIWRlc3QuX2lzU3RkaW8gJiYgKCFvcHRpb25zIHx8IG9wdGlvbnMuZW5kICE9PSBmYWxzZSkpIHtcXG4gICAgc291cmNlLm9uKCdlbmQnLCBvbmVuZCk7XFxuICAgIHNvdXJjZS5vbignY2xvc2UnLCBvbmNsb3NlKTtcXG4gIH1cXG5cXG4gIHZhciBkaWRPbkVuZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gb25lbmQoKSB7XFxuICAgIGlmIChkaWRPbkVuZCkgcmV0dXJuO1xcbiAgICBkaWRPbkVuZCA9IHRydWU7XFxuXFxuICAgIGRlc3QuZW5kKCk7XFxuICB9XFxuXFxuXFxuICBmdW5jdGlvbiBvbmNsb3NlKCkge1xcbiAgICBpZiAoZGlkT25FbmQpIHJldHVybjtcXG4gICAgZGlkT25FbmQgPSB0cnVlO1xcblxcbiAgICBpZiAodHlwZW9mIGRlc3QuZGVzdHJveSA9PT0gJ2Z1bmN0aW9uJykgZGVzdC5kZXN0cm95KCk7XFxuICB9XFxuXFxuICAvLyBkb24ndCBsZWF2ZSBkYW5nbGluZyBwaXBlcyB3aGVuIHRoZXJlIGFyZSBlcnJvcnMuXFxuICBmdW5jdGlvbiBvbmVycm9yKGVyKSB7XFxuICAgIGNsZWFudXAoKTtcXG4gICAgaWYgKEVFLmxpc3RlbmVyQ291bnQodGhpcywgJ2Vycm9yJykgPT09IDApIHtcXG4gICAgICB0aHJvdyBlcjsgLy8gVW5oYW5kbGVkIHN0cmVhbSBlcnJvciBpbiBwaXBlLlxcbiAgICB9XFxuICB9XFxuXFxuICBzb3VyY2Uub24oJ2Vycm9yJywgb25lcnJvcik7XFxuICBkZXN0Lm9uKCdlcnJvcicsIG9uZXJyb3IpO1xcblxcbiAgLy8gcmVtb3ZlIGFsbCB0aGUgZXZlbnQgbGlzdGVuZXJzIHRoYXQgd2VyZSBhZGRlZC5cXG4gIGZ1bmN0aW9uIGNsZWFudXAoKSB7XFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZGF0YScsIG9uZGF0YSk7XFxuICAgIGRlc3QucmVtb3ZlTGlzdGVuZXIoJ2RyYWluJywgb25kcmFpbik7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZW5kJywgb25lbmQpO1xcbiAgICBzb3VyY2UucmVtb3ZlTGlzdGVuZXIoJ2Nsb3NlJywgb25jbG9zZSk7XFxuXFxuICAgIHNvdXJjZS5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG4gICAgZGVzdC5yZW1vdmVMaXN0ZW5lcignZXJyb3InLCBvbmVycm9yKTtcXG5cXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdlbmQnLCBjbGVhbnVwKTtcXG4gICAgc291cmNlLnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xcblxcbiAgICBkZXN0LnJlbW92ZUxpc3RlbmVyKCdjbG9zZScsIGNsZWFudXApO1xcbiAgfVxcblxcbiAgc291cmNlLm9uKCdlbmQnLCBjbGVhbnVwKTtcXG4gIHNvdXJjZS5vbignY2xvc2UnLCBjbGVhbnVwKTtcXG5cXG4gIGRlc3Qub24oJ2Nsb3NlJywgY2xlYW51cCk7XFxuXFxuICBkZXN0LmVtaXQoJ3BpcGUnLCBzb3VyY2UpO1xcblxcbiAgLy8gQWxsb3cgZm9yIHVuaXgtbGlrZSB1c2FnZTogQS5waXBlKEIpLnBpcGUoQylcXG4gIHJldHVybiBkZXN0O1xcbn07XFxuXFxufSx7XFxcImV2ZW50c1xcXCI6NDcsXFxcImluaGVyaXRzXFxcIjo1MCxcXFwicmVhZGFibGUtc3RyZWFtL2R1cGxleC5qc1xcXCI6NTcsXFxcInJlYWRhYmxlLXN0cmVhbS9wYXNzdGhyb3VnaC5qc1xcXCI6NjYsXFxcInJlYWRhYmxlLXN0cmVhbS9yZWFkYWJsZS5qc1xcXCI6NjcsXFxcInJlYWRhYmxlLXN0cmVhbS90cmFuc2Zvcm0uanNcXFwiOjY4LFxcXCJyZWFkYWJsZS1zdHJlYW0vd3JpdGFibGUuanNcXFwiOjY5fV0sNzI6W2Z1bmN0aW9uKHJlcXVpcmUsbW9kdWxlLGV4cG9ydHMpe1xcbid1c2Ugc3RyaWN0JztcXG5cXG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XFxuXFxudmFyIGlzRW5jb2RpbmcgPSBCdWZmZXIuaXNFbmNvZGluZyB8fCBmdW5jdGlvbiAoZW5jb2RpbmcpIHtcXG4gIGVuY29kaW5nID0gJycgKyBlbmNvZGluZztcXG4gIHN3aXRjaCAoZW5jb2RpbmcgJiYgZW5jb2RpbmcudG9Mb3dlckNhc2UoKSkge1xcbiAgICBjYXNlICdoZXgnOmNhc2UgJ3V0ZjgnOmNhc2UgJ3V0Zi04JzpjYXNlICdhc2NpaSc6Y2FzZSAnYmluYXJ5JzpjYXNlICdiYXNlNjQnOmNhc2UgJ3VjczInOmNhc2UgJ3Vjcy0yJzpjYXNlICd1dGYxNmxlJzpjYXNlICd1dGYtMTZsZSc6Y2FzZSAncmF3JzpcXG4gICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgZGVmYXVsdDpcXG4gICAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxufTtcXG5cXG5mdW5jdGlvbiBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKSB7XFxuICBpZiAoIWVuYykgcmV0dXJuICd1dGY4JztcXG4gIHZhciByZXRyaWVkO1xcbiAgd2hpbGUgKHRydWUpIHtcXG4gICAgc3dpdGNoIChlbmMpIHtcXG4gICAgICBjYXNlICd1dGY4JzpcXG4gICAgICBjYXNlICd1dGYtOCc6XFxuICAgICAgICByZXR1cm4gJ3V0ZjgnO1xcbiAgICAgIGNhc2UgJ3VjczInOlxcbiAgICAgIGNhc2UgJ3Vjcy0yJzpcXG4gICAgICBjYXNlICd1dGYxNmxlJzpcXG4gICAgICBjYXNlICd1dGYtMTZsZSc6XFxuICAgICAgICByZXR1cm4gJ3V0ZjE2bGUnO1xcbiAgICAgIGNhc2UgJ2xhdGluMSc6XFxuICAgICAgY2FzZSAnYmluYXJ5JzpcXG4gICAgICAgIHJldHVybiAnbGF0aW4xJztcXG4gICAgICBjYXNlICdiYXNlNjQnOlxcbiAgICAgIGNhc2UgJ2FzY2lpJzpcXG4gICAgICBjYXNlICdoZXgnOlxcbiAgICAgICAgcmV0dXJuIGVuYztcXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgaWYgKHJldHJpZWQpIHJldHVybjsgLy8gdW5kZWZpbmVkXFxuICAgICAgICBlbmMgPSAoJycgKyBlbmMpLnRvTG93ZXJDYXNlKCk7XFxuICAgICAgICByZXRyaWVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgfVxcbn07XFxuXFxuLy8gRG8gbm90IGNhY2hlIGBCdWZmZXIuaXNFbmNvZGluZ2Agd2hlbiBjaGVja2luZyBlbmNvZGluZyBuYW1lcyBhcyBzb21lXFxuLy8gbW9kdWxlcyBtb25rZXktcGF0Y2ggaXQgdG8gc3VwcG9ydCBhZGRpdGlvbmFsIGVuY29kaW5nc1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZUVuY29kaW5nKGVuYykge1xcbiAgdmFyIG5lbmMgPSBfbm9ybWFsaXplRW5jb2RpbmcoZW5jKTtcXG4gIGlmICh0eXBlb2YgbmVuYyAhPT0gJ3N0cmluZycgJiYgKEJ1ZmZlci5pc0VuY29kaW5nID09PSBpc0VuY29kaW5nIHx8ICFpc0VuY29kaW5nKGVuYykpKSB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZW5jb2Rpbmc6ICcgKyBlbmMpO1xcbiAgcmV0dXJuIG5lbmMgfHwgZW5jO1xcbn1cXG5cXG4vLyBTdHJpbmdEZWNvZGVyIHByb3ZpZGVzIGFuIGludGVyZmFjZSBmb3IgZWZmaWNpZW50bHkgc3BsaXR0aW5nIGEgc2VyaWVzIG9mXFxuLy8gYnVmZmVycyBpbnRvIGEgc2VyaWVzIG9mIEpTIHN0cmluZ3Mgd2l0aG91dCBicmVha2luZyBhcGFydCBtdWx0aS1ieXRlXFxuLy8gY2hhcmFjdGVycy5cXG5leHBvcnRzLlN0cmluZ0RlY29kZXIgPSBTdHJpbmdEZWNvZGVyO1xcbmZ1bmN0aW9uIFN0cmluZ0RlY29kZXIoZW5jb2RpbmcpIHtcXG4gIHRoaXMuZW5jb2RpbmcgPSBub3JtYWxpemVFbmNvZGluZyhlbmNvZGluZyk7XFxuICB2YXIgbmI7XFxuICBzd2l0Y2ggKHRoaXMuZW5jb2RpbmcpIHtcXG4gICAgY2FzZSAndXRmMTZsZSc6XFxuICAgICAgdGhpcy50ZXh0ID0gdXRmMTZUZXh0O1xcbiAgICAgIHRoaXMuZW5kID0gdXRmMTZFbmQ7XFxuICAgICAgbmIgPSA0O1xcbiAgICAgIGJyZWFrO1xcbiAgICBjYXNlICd1dGY4JzpcXG4gICAgICB0aGlzLmZpbGxMYXN0ID0gdXRmOEZpbGxMYXN0O1xcbiAgICAgIG5iID0gNDtcXG4gICAgICBicmVhaztcXG4gICAgY2FzZSAnYmFzZTY0JzpcXG4gICAgICB0aGlzLnRleHQgPSBiYXNlNjRUZXh0O1xcbiAgICAgIHRoaXMuZW5kID0gYmFzZTY0RW5kO1xcbiAgICAgIG5iID0gMztcXG4gICAgICBicmVhaztcXG4gICAgZGVmYXVsdDpcXG4gICAgICB0aGlzLndyaXRlID0gc2ltcGxlV3JpdGU7XFxuICAgICAgdGhpcy5lbmQgPSBzaW1wbGVFbmQ7XFxuICAgICAgcmV0dXJuO1xcbiAgfVxcbiAgdGhpcy5sYXN0TmVlZCA9IDA7XFxuICB0aGlzLmxhc3RUb3RhbCA9IDA7XFxuICB0aGlzLmxhc3RDaGFyID0gQnVmZmVyLmFsbG9jVW5zYWZlKG5iKTtcXG59XFxuXFxuU3RyaW5nRGVjb2Rlci5wcm90b3R5cGUud3JpdGUgPSBmdW5jdGlvbiAoYnVmKSB7XFxuICBpZiAoYnVmLmxlbmd0aCA9PT0gMCkgcmV0dXJuICcnO1xcbiAgdmFyIHI7XFxuICB2YXIgaTtcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSB7XFxuICAgIHIgPSB0aGlzLmZpbGxMYXN0KGJ1Zik7XFxuICAgIGlmIChyID09PSB1bmRlZmluZWQpIHJldHVybiAnJztcXG4gICAgaSA9IHRoaXMubGFzdE5lZWQ7XFxuICAgIHRoaXMubGFzdE5lZWQgPSAwO1xcbiAgfSBlbHNlIHtcXG4gICAgaSA9IDA7XFxuICB9XFxuICBpZiAoaSA8IGJ1Zi5sZW5ndGgpIHJldHVybiByID8gciArIHRoaXMudGV4dChidWYsIGkpIDogdGhpcy50ZXh0KGJ1ZiwgaSk7XFxuICByZXR1cm4gciB8fCAnJztcXG59O1xcblxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmVuZCA9IHV0ZjhFbmQ7XFxuXFxuLy8gUmV0dXJucyBvbmx5IGNvbXBsZXRlIGNoYXJhY3RlcnMgaW4gYSBCdWZmZXJcXG5TdHJpbmdEZWNvZGVyLnByb3RvdHlwZS50ZXh0ID0gdXRmOFRleHQ7XFxuXFxuLy8gQXR0ZW1wdHMgdG8gY29tcGxldGUgYSBwYXJ0aWFsIG5vbi1VVEYtOCBjaGFyYWN0ZXIgdXNpbmcgYnl0ZXMgZnJvbSBhIEJ1ZmZlclxcblN0cmluZ0RlY29kZXIucHJvdG90eXBlLmZpbGxMYXN0ID0gZnVuY3Rpb24gKGJ1Zikge1xcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIHRoaXMubGFzdE5lZWQpO1xcbiAgICByZXR1cm4gdGhpcy5sYXN0Q2hhci50b1N0cmluZyh0aGlzLmVuY29kaW5nLCAwLCB0aGlzLmxhc3RUb3RhbCk7XFxuICB9XFxuICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQsIDAsIGJ1Zi5sZW5ndGgpO1xcbiAgdGhpcy5sYXN0TmVlZCAtPSBidWYubGVuZ3RoO1xcbn07XFxuXFxuLy8gQ2hlY2tzIHRoZSB0eXBlIG9mIGEgVVRGLTggYnl0ZSwgd2hldGhlciBpdCdzIEFTQ0lJLCBhIGxlYWRpbmcgYnl0ZSwgb3IgYVxcbi8vIGNvbnRpbnVhdGlvbiBieXRlLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0J5dGUoYnl0ZSkge1xcbiAgaWYgKGJ5dGUgPD0gMHg3RikgcmV0dXJuIDA7ZWxzZSBpZiAoYnl0ZSA+PiA1ID09PSAweDA2KSByZXR1cm4gMjtlbHNlIGlmIChieXRlID4+IDQgPT09IDB4MEUpIHJldHVybiAzO2Vsc2UgaWYgKGJ5dGUgPj4gMyA9PT0gMHgxRSkgcmV0dXJuIDQ7XFxuICByZXR1cm4gLTE7XFxufVxcblxcbi8vIENoZWNrcyBhdCBtb3N0IDMgYnl0ZXMgYXQgdGhlIGVuZCBvZiBhIEJ1ZmZlciBpbiBvcmRlciB0byBkZXRlY3QgYW5cXG4vLyBpbmNvbXBsZXRlIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyLiBUaGUgdG90YWwgbnVtYmVyIG9mIGJ5dGVzICgyLCAzLCBvciA0KVxcbi8vIG5lZWRlZCB0byBjb21wbGV0ZSB0aGUgVVRGLTggY2hhcmFjdGVyIChpZiBhcHBsaWNhYmxlKSBhcmUgcmV0dXJuZWQuXFxuZnVuY3Rpb24gdXRmOENoZWNrSW5jb21wbGV0ZShzZWxmLCBidWYsIGkpIHtcXG4gIHZhciBqID0gYnVmLmxlbmd0aCAtIDE7XFxuICBpZiAoaiA8IGkpIHJldHVybiAwO1xcbiAgdmFyIG5iID0gdXRmOENoZWNrQnl0ZShidWZbal0pO1xcbiAgaWYgKG5iID49IDApIHtcXG4gICAgaWYgKG5iID4gMCkgc2VsZi5sYXN0TmVlZCA9IG5iIC0gMTtcXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgaWYgKC0taiA8IGkpIHJldHVybiAwO1xcbiAgbmIgPSB1dGY4Q2hlY2tCeXRlKGJ1ZltqXSk7XFxuICBpZiAobmIgPj0gMCkge1xcbiAgICBpZiAobmIgPiAwKSBzZWxmLmxhc3ROZWVkID0gbmIgLSAyO1xcbiAgICByZXR1cm4gbmI7XFxuICB9XFxuICBpZiAoLS1qIDwgaSkgcmV0dXJuIDA7XFxuICBuYiA9IHV0ZjhDaGVja0J5dGUoYnVmW2pdKTtcXG4gIGlmIChuYiA+PSAwKSB7XFxuICAgIGlmIChuYiA+IDApIHtcXG4gICAgICBpZiAobmIgPT09IDIpIG5iID0gMDtlbHNlIHNlbGYubGFzdE5lZWQgPSBuYiAtIDM7XFxuICAgIH1cXG4gICAgcmV0dXJuIG5iO1xcbiAgfVxcbiAgcmV0dXJuIDA7XFxufVxcblxcbi8vIFZhbGlkYXRlcyBhcyBtYW55IGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBtdWx0aS1ieXRlIFVURi04IGNoYXJhY3RlciBhc1xcbi8vIG5lZWRlZCBvciBhcmUgYXZhaWxhYmxlLiBJZiB3ZSBzZWUgYSBub24tY29udGludWF0aW9uIGJ5dGUgd2hlcmUgd2UgZXhwZWN0XFxuLy8gb25lLCB3ZSBcXFwicmVwbGFjZVxcXCIgdGhlIHZhbGlkYXRlZCBjb250aW51YXRpb24gYnl0ZXMgd2UndmUgc2VlbiBzbyBmYXIgd2l0aFxcbi8vIFVURi04IHJlcGxhY2VtZW50IGNoYXJhY3RlcnMgKCdcXFxcdWZmZmQnKSwgdG8gbWF0Y2ggdjgncyBVVEYtOCBkZWNvZGluZ1xcbi8vIGJlaGF2aW9yLiBUaGUgY29udGludWF0aW9uIGJ5dGUgY2hlY2sgaXMgaW5jbHVkZWQgdGhyZWUgdGltZXMgaW4gdGhlIGNhc2VcXG4vLyB3aGVyZSBhbGwgb2YgdGhlIGNvbnRpbnVhdGlvbiBieXRlcyBmb3IgYSBjaGFyYWN0ZXIgZXhpc3QgaW4gdGhlIHNhbWUgYnVmZmVyLlxcbi8vIEl0IGlzIGFsc28gZG9uZSB0aGlzIHdheSBhcyBhIHNsaWdodCBwZXJmb3JtYW5jZSBpbmNyZWFzZSBpbnN0ZWFkIG9mIHVzaW5nIGFcXG4vLyBsb29wLlxcbmZ1bmN0aW9uIHV0ZjhDaGVja0V4dHJhQnl0ZXMoc2VsZiwgYnVmLCBwKSB7XFxuICBpZiAoKGJ1ZlswXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgIHNlbGYubGFzdE5lZWQgPSAwO1xcbiAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHApO1xcbiAgfVxcbiAgaWYgKHNlbGYubGFzdE5lZWQgPiAxICYmIGJ1Zi5sZW5ndGggPiAxKSB7XFxuICAgIGlmICgoYnVmWzFdICYgMHhDMCkgIT09IDB4ODApIHtcXG4gICAgICBzZWxmLmxhc3ROZWVkID0gMTtcXG4gICAgICByZXR1cm4gJ1xcXFx1ZmZmZCcucmVwZWF0KHAgKyAxKTtcXG4gICAgfVxcbiAgICBpZiAoc2VsZi5sYXN0TmVlZCA+IDIgJiYgYnVmLmxlbmd0aCA+IDIpIHtcXG4gICAgICBpZiAoKGJ1ZlsyXSAmIDB4QzApICE9PSAweDgwKSB7XFxuICAgICAgICBzZWxmLmxhc3ROZWVkID0gMjtcXG4gICAgICAgIHJldHVybiAnXFxcXHVmZmZkJy5yZXBlYXQocCArIDIpO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vLyBBdHRlbXB0cyB0byBjb21wbGV0ZSBhIG11bHRpLWJ5dGUgVVRGLTggY2hhcmFjdGVyIHVzaW5nIGJ5dGVzIGZyb20gYSBCdWZmZXIuXFxuZnVuY3Rpb24gdXRmOEZpbGxMYXN0KGJ1Zikge1xcbiAgdmFyIHAgPSB0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQ7XFxuICB2YXIgciA9IHV0ZjhDaGVja0V4dHJhQnl0ZXModGhpcywgYnVmLCBwKTtcXG4gIGlmIChyICE9PSB1bmRlZmluZWQpIHJldHVybiByO1xcbiAgaWYgKHRoaXMubGFzdE5lZWQgPD0gYnVmLmxlbmd0aCkge1xcbiAgICBidWYuY29weSh0aGlzLmxhc3RDaGFyLCBwLCAwLCB0aGlzLmxhc3ROZWVkKTtcXG4gICAgcmV0dXJuIHRoaXMubGFzdENoYXIudG9TdHJpbmcodGhpcy5lbmNvZGluZywgMCwgdGhpcy5sYXN0VG90YWwpO1xcbiAgfVxcbiAgYnVmLmNvcHkodGhpcy5sYXN0Q2hhciwgcCwgMCwgYnVmLmxlbmd0aCk7XFxuICB0aGlzLmxhc3ROZWVkIC09IGJ1Zi5sZW5ndGg7XFxufVxcblxcbi8vIFJldHVybnMgYWxsIGNvbXBsZXRlIFVURi04IGNoYXJhY3RlcnMgaW4gYSBCdWZmZXIuIElmIHRoZSBCdWZmZXIgZW5kZWQgb24gYVxcbi8vIHBhcnRpYWwgY2hhcmFjdGVyLCB0aGUgY2hhcmFjdGVyJ3MgYnl0ZXMgYXJlIGJ1ZmZlcmVkIHVudGlsIHRoZSByZXF1aXJlZFxcbi8vIG51bWJlciBvZiBieXRlcyBhcmUgYXZhaWxhYmxlLlxcbmZ1bmN0aW9uIHV0ZjhUZXh0KGJ1ZiwgaSkge1xcbiAgdmFyIHRvdGFsID0gdXRmOENoZWNrSW5jb21wbGV0ZSh0aGlzLCBidWYsIGkpO1xcbiAgaWYgKCF0aGlzLmxhc3ROZWVkKSByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSk7XFxuICB0aGlzLmxhc3RUb3RhbCA9IHRvdGFsO1xcbiAgdmFyIGVuZCA9IGJ1Zi5sZW5ndGggLSAodG90YWwgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIGJ1Zi5jb3B5KHRoaXMubGFzdENoYXIsIDAsIGVuZCk7XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCd1dGY4JywgaSwgZW5kKTtcXG59XFxuXFxuLy8gRm9yIFVURi04LCBhIHJlcGxhY2VtZW50IGNoYXJhY3RlciBmb3IgZWFjaCBidWZmZXJlZCBieXRlIG9mIGEgKHBhcnRpYWwpXFxuLy8gY2hhcmFjdGVyIG5lZWRzIHRvIGJlIGFkZGVkIHRvIHRoZSBvdXRwdXQuXFxuZnVuY3Rpb24gdXRmOEVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArICdcXFxcdWZmZmQnLnJlcGVhdCh0aGlzLmxhc3RUb3RhbCAtIHRoaXMubGFzdE5lZWQpO1xcbiAgcmV0dXJuIHI7XFxufVxcblxcbi8vIFVURi0xNkxFIHR5cGljYWxseSBuZWVkcyB0d28gYnl0ZXMgcGVyIGNoYXJhY3RlciwgYnV0IGV2ZW4gaWYgd2UgaGF2ZSBhbiBldmVuXFxuLy8gbnVtYmVyIG9mIGJ5dGVzIGF2YWlsYWJsZSwgd2UgbmVlZCB0byBjaGVjayBpZiB3ZSBlbmQgb24gYSBsZWFkaW5nL2hpZ2hcXG4vLyBzdXJyb2dhdGUuIEluIHRoYXQgY2FzZSwgd2UgbmVlZCB0byB3YWl0IGZvciB0aGUgbmV4dCB0d28gYnl0ZXMgaW4gb3JkZXIgdG9cXG4vLyBkZWNvZGUgdGhlIGxhc3QgY2hhcmFjdGVyIHByb3Blcmx5LlxcbmZ1bmN0aW9uIHV0ZjE2VGV4dChidWYsIGkpIHtcXG4gIGlmICgoYnVmLmxlbmd0aCAtIGkpICUgMiA9PT0gMCkge1xcbiAgICB2YXIgciA9IGJ1Zi50b1N0cmluZygndXRmMTZsZScsIGkpO1xcbiAgICBpZiAocikge1xcbiAgICAgIHZhciBjID0gci5jaGFyQ29kZUF0KHIubGVuZ3RoIC0gMSk7XFxuICAgICAgaWYgKGMgPj0gMHhEODAwICYmIGMgPD0gMHhEQkZGKSB7XFxuICAgICAgICB0aGlzLmxhc3ROZWVkID0gMjtcXG4gICAgICAgIHRoaXMubGFzdFRvdGFsID0gNDtcXG4gICAgICAgIHRoaXMubGFzdENoYXJbMF0gPSBidWZbYnVmLmxlbmd0aCAtIDJdO1xcbiAgICAgICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICAgICAgICByZXR1cm4gci5zbGljZSgwLCAtMSk7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiByO1xcbiAgfVxcbiAgdGhpcy5sYXN0TmVlZCA9IDE7XFxuICB0aGlzLmxhc3RUb3RhbCA9IDI7XFxuICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAxXTtcXG4gIHJldHVybiBidWYudG9TdHJpbmcoJ3V0ZjE2bGUnLCBpLCBidWYubGVuZ3RoIC0gMSk7XFxufVxcblxcbi8vIEZvciBVVEYtMTZMRSB3ZSBkbyBub3QgZXhwbGljaXRseSBhcHBlbmQgc3BlY2lhbCByZXBsYWNlbWVudCBjaGFyYWN0ZXJzIGlmIHdlXFxuLy8gZW5kIG9uIGEgcGFydGlhbCBjaGFyYWN0ZXIsIHdlIHNpbXBseSBsZXQgdjggaGFuZGxlIHRoYXQuXFxuZnVuY3Rpb24gdXRmMTZFbmQoYnVmKSB7XFxuICB2YXIgciA9IGJ1ZiAmJiBidWYubGVuZ3RoID8gdGhpcy53cml0ZShidWYpIDogJyc7XFxuICBpZiAodGhpcy5sYXN0TmVlZCkge1xcbiAgICB2YXIgZW5kID0gdGhpcy5sYXN0VG90YWwgLSB0aGlzLmxhc3ROZWVkO1xcbiAgICByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ3V0ZjE2bGUnLCAwLCBlbmQpO1xcbiAgfVxcbiAgcmV0dXJuIHI7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NFRleHQoYnVmLCBpKSB7XFxuICB2YXIgbiA9IChidWYubGVuZ3RoIC0gaSkgJSAzO1xcbiAgaWYgKG4gPT09IDApIHJldHVybiBidWYudG9TdHJpbmcoJ2Jhc2U2NCcsIGkpO1xcbiAgdGhpcy5sYXN0TmVlZCA9IDMgLSBuO1xcbiAgdGhpcy5sYXN0VG90YWwgPSAzO1xcbiAgaWYgKG4gPT09IDEpIHtcXG4gICAgdGhpcy5sYXN0Q2hhclswXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLmxhc3RDaGFyWzBdID0gYnVmW2J1Zi5sZW5ndGggLSAyXTtcXG4gICAgdGhpcy5sYXN0Q2hhclsxXSA9IGJ1ZltidWYubGVuZ3RoIC0gMV07XFxuICB9XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKCdiYXNlNjQnLCBpLCBidWYubGVuZ3RoIC0gbik7XFxufVxcblxcbmZ1bmN0aW9uIGJhc2U2NEVuZChidWYpIHtcXG4gIHZhciByID0gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG4gIGlmICh0aGlzLmxhc3ROZWVkKSByZXR1cm4gciArIHRoaXMubGFzdENoYXIudG9TdHJpbmcoJ2Jhc2U2NCcsIDAsIDMgLSB0aGlzLmxhc3ROZWVkKTtcXG4gIHJldHVybiByO1xcbn1cXG5cXG4vLyBQYXNzIGJ5dGVzIG9uIHRocm91Z2ggZm9yIHNpbmdsZS1ieXRlIGVuY29kaW5ncyAoZS5nLiBhc2NpaSwgbGF0aW4xLCBoZXgpXFxuZnVuY3Rpb24gc2ltcGxlV3JpdGUoYnVmKSB7XFxuICByZXR1cm4gYnVmLnRvU3RyaW5nKHRoaXMuZW5jb2RpbmcpO1xcbn1cXG5cXG5mdW5jdGlvbiBzaW1wbGVFbmQoYnVmKSB7XFxuICByZXR1cm4gYnVmICYmIGJ1Zi5sZW5ndGggPyB0aGlzLndyaXRlKGJ1ZikgOiAnJztcXG59XFxufSx7XFxcInNhZmUtYnVmZmVyXFxcIjo3MH1dLDczOltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG4oZnVuY3Rpb24gKGdsb2JhbCl7XFxuXFxuLyoqXFxuICogTW9kdWxlIGV4cG9ydHMuXFxuICovXFxuXFxubW9kdWxlLmV4cG9ydHMgPSBkZXByZWNhdGU7XFxuXFxuLyoqXFxuICogTWFyayB0aGF0IGEgbWV0aG9kIHNob3VsZCBub3QgYmUgdXNlZC5cXG4gKiBSZXR1cm5zIGEgbW9kaWZpZWQgZnVuY3Rpb24gd2hpY2ggd2FybnMgb25jZSBieSBkZWZhdWx0LlxcbiAqXFxuICogSWYgYGxvY2FsU3RvcmFnZS5ub0RlcHJlY2F0aW9uID0gdHJ1ZWAgaXMgc2V0LCB0aGVuIGl0IGlzIGEgbm8tb3AuXFxuICpcXG4gKiBJZiBgbG9jYWxTdG9yYWdlLnRocm93RGVwcmVjYXRpb24gPSB0cnVlYCBpcyBzZXQsIHRoZW4gZGVwcmVjYXRlZCBmdW5jdGlvbnNcXG4gKiB3aWxsIHRocm93IGFuIEVycm9yIHdoZW4gaW52b2tlZC5cXG4gKlxcbiAqIElmIGBsb2NhbFN0b3JhZ2UudHJhY2VEZXByZWNhdGlvbiA9IHRydWVgIGlzIHNldCwgdGhlbiBkZXByZWNhdGVkIGZ1bmN0aW9uc1xcbiAqIHdpbGwgaW52b2tlIGBjb25zb2xlLnRyYWNlKClgIGluc3RlYWQgb2YgYGNvbnNvbGUuZXJyb3IoKWAuXFxuICpcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmbiAtIHRoZSBmdW5jdGlvbiB0byBkZXByZWNhdGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gbXNnIC0gdGhlIHN0cmluZyB0byBwcmludCB0byB0aGUgY29uc29sZSB3aGVuIGBmbmAgaXMgaW52b2tlZFxcbiAqIEByZXR1cm5zIHtGdW5jdGlvbn0gYSBuZXcgXFxcImRlcHJlY2F0ZWRcXFwiIHZlcnNpb24gb2YgYGZuYFxcbiAqIEBhcGkgcHVibGljXFxuICovXFxuXFxuZnVuY3Rpb24gZGVwcmVjYXRlIChmbiwgbXNnKSB7XFxuICBpZiAoY29uZmlnKCdub0RlcHJlY2F0aW9uJykpIHtcXG4gICAgcmV0dXJuIGZuO1xcbiAgfVxcblxcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xcbiAgZnVuY3Rpb24gZGVwcmVjYXRlZCgpIHtcXG4gICAgaWYgKCF3YXJuZWQpIHtcXG4gICAgICBpZiAoY29uZmlnKCd0aHJvd0RlcHJlY2F0aW9uJykpIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcbiAgICAgIH0gZWxzZSBpZiAoY29uZmlnKCd0cmFjZURlcHJlY2F0aW9uJykpIHtcXG4gICAgICAgIGNvbnNvbGUudHJhY2UobXNnKTtcXG4gICAgICB9IGVsc2Uge1xcbiAgICAgICAgY29uc29sZS53YXJuKG1zZyk7XFxuICAgICAgfVxcbiAgICAgIHdhcm5lZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIGZuLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XFxuICB9XFxuXFxuICByZXR1cm4gZGVwcmVjYXRlZDtcXG59XFxuXFxuLyoqXFxuICogQ2hlY2tzIGBsb2NhbFN0b3JhZ2VgIGZvciBib29sZWFuIHZhbHVlcyBmb3IgdGhlIGdpdmVuIGBuYW1lYC5cXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXFxuICogQHJldHVybnMge0Jvb2xlYW59XFxuICogQGFwaSBwcml2YXRlXFxuICovXFxuXFxuZnVuY3Rpb24gY29uZmlnIChuYW1lKSB7XFxuICAvLyBhY2Nlc3NpbmcgZ2xvYmFsLmxvY2FsU3RvcmFnZSBjYW4gdHJpZ2dlciBhIERPTUV4Y2VwdGlvbiBpbiBzYW5kYm94ZWQgaWZyYW1lc1xcbiAgdHJ5IHtcXG4gICAgaWYgKCFnbG9iYWwubG9jYWxTdG9yYWdlKSByZXR1cm4gZmFsc2U7XFxuICB9IGNhdGNoIChfKSB7XFxuICAgIHJldHVybiBmYWxzZTtcXG4gIH1cXG4gIHZhciB2YWwgPSBnbG9iYWwubG9jYWxTdG9yYWdlW25hbWVdO1xcbiAgaWYgKG51bGwgPT0gdmFsKSByZXR1cm4gZmFsc2U7XFxuICByZXR1cm4gU3RyaW5nKHZhbCkudG9Mb3dlckNhc2UoKSA9PT0gJ3RydWUnO1xcbn1cXG5cXG59KS5jYWxsKHRoaXMsdHlwZW9mIGdsb2JhbCAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyBzZWxmIDogdHlwZW9mIHdpbmRvdyAhPT0gXFxcInVuZGVmaW5lZFxcXCIgPyB3aW5kb3cgOiB7fSlcXG59LHt9XSw3NDpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuYXJndW1lbnRzWzRdWzUwXVswXS5hcHBseShleHBvcnRzLGFyZ3VtZW50cylcXG59LHtcXFwiZHVwXFxcIjo1MH1dLDc1OltmdW5jdGlvbihyZXF1aXJlLG1vZHVsZSxleHBvcnRzKXtcXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGlzQnVmZmVyKGFyZykge1xcbiAgcmV0dXJuIGFyZyAmJiB0eXBlb2YgYXJnID09PSAnb2JqZWN0J1xcbiAgICAmJiB0eXBlb2YgYXJnLmNvcHkgPT09ICdmdW5jdGlvbidcXG4gICAgJiYgdHlwZW9mIGFyZy5maWxsID09PSAnZnVuY3Rpb24nXFxuICAgICYmIHR5cGVvZiBhcmcucmVhZFVJbnQ4ID09PSAnZnVuY3Rpb24nO1xcbn1cXG59LHt9XSw3NjpbZnVuY3Rpb24ocmVxdWlyZSxtb2R1bGUsZXhwb3J0cyl7XFxuKGZ1bmN0aW9uIChwcm9jZXNzLGdsb2JhbCl7XFxuLy8gQ29weXJpZ2h0IEpveWVudCwgSW5jLiBhbmQgb3RoZXIgTm9kZSBjb250cmlidXRvcnMuXFxuLy9cXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxcbi8vIGNvcHkgb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGVcXG4vLyBcXFwiU29mdHdhcmVcXFwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXFxuLy8gd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHMgdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLFxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcXG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcXG4vLyBmb2xsb3dpbmcgY29uZGl0aW9uczpcXG4vL1xcbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXFxuLy8gaW4gYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXFxuLy9cXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXFxcIkFTIElTXFxcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTU1xcbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0ZcXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXFxuLy8gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sXFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXFxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxcbi8vIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEUgU09GVFdBUkUuXFxuXFxudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkaiVdL2c7XFxuZXhwb3J0cy5mb3JtYXQgPSBmdW5jdGlvbihmKSB7XFxuICBpZiAoIWlzU3RyaW5nKGYpKSB7XFxuICAgIHZhciBvYmplY3RzID0gW107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgb2JqZWN0cy5wdXNoKGluc3BlY3QoYXJndW1lbnRzW2ldKSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIG9iamVjdHMuam9pbignICcpO1xcbiAgfVxcblxcbiAgdmFyIGkgPSAxO1xcbiAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XFxuICB2YXIgc3RyID0gU3RyaW5nKGYpLnJlcGxhY2UoZm9ybWF0UmVnRXhwLCBmdW5jdGlvbih4KSB7XFxuICAgIGlmICh4ID09PSAnJSUnKSByZXR1cm4gJyUnO1xcbiAgICBpZiAoaSA+PSBsZW4pIHJldHVybiB4O1xcbiAgICBzd2l0Y2ggKHgpIHtcXG4gICAgICBjYXNlICclcyc6IHJldHVybiBTdHJpbmcoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICclZCc6IHJldHVybiBOdW1iZXIoYXJnc1tpKytdKTtcXG4gICAgICBjYXNlICclaic6XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnc1tpKytdKTtcXG4gICAgICAgIH0gY2F0Y2ggKF8pIHtcXG4gICAgICAgICAgcmV0dXJuICdbQ2lyY3VsYXJdJztcXG4gICAgICAgIH1cXG4gICAgICBkZWZhdWx0OlxcbiAgICAgICAgcmV0dXJuIHg7XFxuICAgIH1cXG4gIH0pO1xcbiAgZm9yICh2YXIgeCA9IGFyZ3NbaV07IGkgPCBsZW47IHggPSBhcmdzWysraV0pIHtcXG4gICAgaWYgKGlzTnVsbCh4KSB8fCAhaXNPYmplY3QoeCkpIHtcXG4gICAgICBzdHIgKz0gJyAnICsgeDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBzdHIgKz0gJyAnICsgaW5zcGVjdCh4KTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIHN0cjtcXG59O1xcblxcblxcbi8vIE1hcmsgdGhhdCBhIG1ldGhvZCBzaG91bGQgbm90IGJlIHVzZWQuXFxuLy8gUmV0dXJucyBhIG1vZGlmaWVkIGZ1bmN0aW9uIHdoaWNoIHdhcm5zIG9uY2UgYnkgZGVmYXVsdC5cXG4vLyBJZiAtLW5vLWRlcHJlY2F0aW9uIGlzIHNldCwgdGhlbiBpdCBpcyBhIG5vLW9wLlxcbmV4cG9ydHMuZGVwcmVjYXRlID0gZnVuY3Rpb24oZm4sIG1zZykge1xcbiAgLy8gQWxsb3cgZm9yIGRlcHJlY2F0aW5nIHRoaW5ncyBpbiB0aGUgcHJvY2VzcyBvZiBzdGFydGluZyB1cC5cXG4gIGlmIChpc1VuZGVmaW5lZChnbG9iYWwucHJvY2VzcykpIHtcXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xcbiAgICAgIHJldHVybiBleHBvcnRzLmRlcHJlY2F0ZShmbiwgbXNnKS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xcbiAgICB9O1xcbiAgfVxcblxcbiAgaWYgKHByb2Nlc3Mubm9EZXByZWNhdGlvbiA9PT0gdHJ1ZSkge1xcbiAgICByZXR1cm4gZm47XFxuICB9XFxuXFxuICB2YXIgd2FybmVkID0gZmFsc2U7XFxuICBmdW5jdGlvbiBkZXByZWNhdGVkKCkge1xcbiAgICBpZiAoIXdhcm5lZCkge1xcbiAgICAgIGlmIChwcm9jZXNzLnRocm93RGVwcmVjYXRpb24pIHtcXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihtc2cpO1xcbiAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy50cmFjZURlcHJlY2F0aW9uKSB7XFxuICAgICAgICBjb25zb2xlLnRyYWNlKG1zZyk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIGNvbnNvbGUuZXJyb3IobXNnKTtcXG4gICAgICB9XFxuICAgICAgd2FybmVkID0gdHJ1ZTtcXG4gICAgfVxcbiAgICByZXR1cm4gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG4gIH1cXG5cXG4gIHJldHVybiBkZXByZWNhdGVkO1xcbn07XFxuXFxuXFxudmFyIGRlYnVncyA9IHt9O1xcbnZhciBkZWJ1Z0Vudmlyb247XFxuZXhwb3J0cy5kZWJ1Z2xvZyA9IGZ1bmN0aW9uKHNldCkge1xcbiAgaWYgKGlzVW5kZWZpbmVkKGRlYnVnRW52aXJvbikpXFxuICAgIGRlYnVnRW52aXJvbiA9IHByb2Nlc3MuZW52Lk5PREVfREVCVUcgfHwgJyc7XFxuICBzZXQgPSBzZXQudG9VcHBlckNhc2UoKTtcXG4gIGlmICghZGVidWdzW3NldF0pIHtcXG4gICAgaWYgKG5ldyBSZWdFeHAoJ1xcXFxcXFxcYicgKyBzZXQgKyAnXFxcXFxcXFxiJywgJ2knKS50ZXN0KGRlYnVnRW52aXJvbikpIHtcXG4gICAgICB2YXIgcGlkID0gcHJvY2Vzcy5waWQ7XFxuICAgICAgZGVidWdzW3NldF0gPSBmdW5jdGlvbigpIHtcXG4gICAgICAgIHZhciBtc2cgPSBleHBvcnRzLmZvcm1hdC5hcHBseShleHBvcnRzLCBhcmd1bWVudHMpO1xcbiAgICAgICAgY29uc29sZS5lcnJvcignJXMgJWQ6ICVzJywgc2V0LCBwaWQsIG1zZyk7XFxuICAgICAgfTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBkZWJ1Z3Nbc2V0XSA9IGZ1bmN0aW9uKCkge307XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBkZWJ1Z3Nbc2V0XTtcXG59O1xcblxcblxcbi8qKlxcbiAqIEVjaG9zIHRoZSB2YWx1ZSBvZiBhIHZhbHVlLiBUcnlzIHRvIHByaW50IHRoZSB2YWx1ZSBvdXRcXG4gKiBpbiB0aGUgYmVzdCB3YXkgcG9zc2libGUgZ2l2ZW4gdGhlIGRpZmZlcmVudCB0eXBlcy5cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogVGhlIG9iamVjdCB0byBwcmludCBvdXQuXFxuICogQHBhcmFtIHtPYmplY3R9IG9wdHMgT3B0aW9uYWwgb3B0aW9ucyBvYmplY3QgdGhhdCBhbHRlcnMgdGhlIG91dHB1dC5cXG4gKi9cXG4vKiBsZWdhY3k6IG9iaiwgc2hvd0hpZGRlbiwgZGVwdGgsIGNvbG9ycyovXFxuZnVuY3Rpb24gaW5zcGVjdChvYmosIG9wdHMpIHtcXG4gIC8vIGRlZmF1bHQgb3B0aW9uc1xcbiAgdmFyIGN0eCA9IHtcXG4gICAgc2VlbjogW10sXFxuICAgIHN0eWxpemU6IHN0eWxpemVOb0NvbG9yXFxuICB9O1xcbiAgLy8gbGVnYWN5Li4uXFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSAzKSBjdHguZGVwdGggPSBhcmd1bWVudHNbMl07XFxuICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSBjdHguY29sb3JzID0gYXJndW1lbnRzWzNdO1xcbiAgaWYgKGlzQm9vbGVhbihvcHRzKSkge1xcbiAgICAvLyBsZWdhY3kuLi5cXG4gICAgY3R4LnNob3dIaWRkZW4gPSBvcHRzO1xcbiAgfSBlbHNlIGlmIChvcHRzKSB7XFxuICAgIC8vIGdvdCBhbiBcXFwib3B0aW9uc1xcXCIgb2JqZWN0XFxuICAgIGV4cG9ydHMuX2V4dGVuZChjdHgsIG9wdHMpO1xcbiAgfVxcbiAgLy8gc2V0IGRlZmF1bHQgb3B0aW9uc1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5zaG93SGlkZGVuKSkgY3R4LnNob3dIaWRkZW4gPSBmYWxzZTtcXG4gIGlmIChpc1VuZGVmaW5lZChjdHguZGVwdGgpKSBjdHguZGVwdGggPSAyO1xcbiAgaWYgKGlzVW5kZWZpbmVkKGN0eC5jb2xvcnMpKSBjdHguY29sb3JzID0gZmFsc2U7XFxuICBpZiAoaXNVbmRlZmluZWQoY3R4LmN1c3RvbUluc3BlY3QpKSBjdHguY3VzdG9tSW5zcGVjdCA9IHRydWU7XFxuICBpZiAoY3R4LmNvbG9ycykgY3R4LnN0eWxpemUgPSBzdHlsaXplV2l0aENvbG9yO1xcbiAgcmV0dXJuIGZvcm1hdFZhbHVlKGN0eCwgb2JqLCBjdHguZGVwdGgpO1xcbn1cXG5leHBvcnRzLmluc3BlY3QgPSBpbnNwZWN0O1xcblxcblxcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQU5TSV9lc2NhcGVfY29kZSNncmFwaGljc1xcbmluc3BlY3QuY29sb3JzID0ge1xcbiAgJ2JvbGQnIDogWzEsIDIyXSxcXG4gICdpdGFsaWMnIDogWzMsIDIzXSxcXG4gICd1bmRlcmxpbmUnIDogWzQsIDI0XSxcXG4gICdpbnZlcnNlJyA6IFs3LCAyN10sXFxuICAnd2hpdGUnIDogWzM3LCAzOV0sXFxuICAnZ3JleScgOiBbOTAsIDM5XSxcXG4gICdibGFjaycgOiBbMzAsIDM5XSxcXG4gICdibHVlJyA6IFszNCwgMzldLFxcbiAgJ2N5YW4nIDogWzM2LCAzOV0sXFxuICAnZ3JlZW4nIDogWzMyLCAzOV0sXFxuICAnbWFnZW50YScgOiBbMzUsIDM5XSxcXG4gICdyZWQnIDogWzMxLCAzOV0sXFxuICAneWVsbG93JyA6IFszMywgMzldXFxufTtcXG5cXG4vLyBEb24ndCB1c2UgJ2JsdWUnIG5vdCB2aXNpYmxlIG9uIGNtZC5leGVcXG5pbnNwZWN0LnN0eWxlcyA9IHtcXG4gICdzcGVjaWFsJzogJ2N5YW4nLFxcbiAgJ251bWJlcic6ICd5ZWxsb3cnLFxcbiAgJ2Jvb2xlYW4nOiAneWVsbG93JyxcXG4gICd1bmRlZmluZWQnOiAnZ3JleScsXFxuICAnbnVsbCc6ICdib2xkJyxcXG4gICdzdHJpbmcnOiAnZ3JlZW4nLFxcbiAgJ2RhdGUnOiAnbWFnZW50YScsXFxuICAvLyBcXFwibmFtZVxcXCI6IGludGVudGlvbmFsbHkgbm90IHN0eWxpbmdcXG4gICdyZWdleHAnOiAncmVkJ1xcbn07XFxuXFxuXFxuZnVuY3Rpb24gc3R5bGl6ZVdpdGhDb2xvcihzdHIsIHN0eWxlVHlwZSkge1xcbiAgdmFyIHN0eWxlID0gaW5zcGVjdC5zdHlsZXNbc3R5bGVUeXBlXTtcXG5cXG4gIGlmIChzdHlsZSkge1xcbiAgICByZXR1cm4gJ1xcXFx1MDAxYlsnICsgaW5zcGVjdC5jb2xvcnNbc3R5bGVdWzBdICsgJ20nICsgc3RyICtcXG4gICAgICAgICAgICdcXFxcdTAwMWJbJyArIGluc3BlY3QuY29sb3JzW3N0eWxlXVsxXSArICdtJztcXG4gIH0gZWxzZSB7XFxuICAgIHJldHVybiBzdHI7XFxuICB9XFxufVxcblxcblxcbmZ1bmN0aW9uIHN0eWxpemVOb0NvbG9yKHN0ciwgc3R5bGVUeXBlKSB7XFxuICByZXR1cm4gc3RyO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiBhcnJheVRvSGFzaChhcnJheSkge1xcbiAgdmFyIGhhc2ggPSB7fTtcXG5cXG4gIGFycmF5LmZvckVhY2goZnVuY3Rpb24odmFsLCBpZHgpIHtcXG4gICAgaGFzaFt2YWxdID0gdHJ1ZTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGhhc2g7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFZhbHVlKGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcykge1xcbiAgLy8gUHJvdmlkZSBhIGhvb2sgZm9yIHVzZXItc3BlY2lmaWVkIGluc3BlY3QgZnVuY3Rpb25zLlxcbiAgLy8gQ2hlY2sgdGhhdCB2YWx1ZSBpcyBhbiBvYmplY3Qgd2l0aCBhbiBpbnNwZWN0IGZ1bmN0aW9uIG9uIGl0XFxuICBpZiAoY3R4LmN1c3RvbUluc3BlY3QgJiZcXG4gICAgICB2YWx1ZSAmJlxcbiAgICAgIGlzRnVuY3Rpb24odmFsdWUuaW5zcGVjdCkgJiZcXG4gICAgICAvLyBGaWx0ZXIgb3V0IHRoZSB1dGlsIG1vZHVsZSwgaXQncyBpbnNwZWN0IGZ1bmN0aW9uIGlzIHNwZWNpYWxcXG4gICAgICB2YWx1ZS5pbnNwZWN0ICE9PSBleHBvcnRzLmluc3BlY3QgJiZcXG4gICAgICAvLyBBbHNvIGZpbHRlciBvdXQgYW55IHByb3RvdHlwZSBvYmplY3RzIHVzaW5nIHRoZSBjaXJjdWxhciBjaGVjay5cXG4gICAgICAhKHZhbHVlLmNvbnN0cnVjdG9yICYmIHZhbHVlLmNvbnN0cnVjdG9yLnByb3RvdHlwZSA9PT0gdmFsdWUpKSB7XFxuICAgIHZhciByZXQgPSB2YWx1ZS5pbnNwZWN0KHJlY3Vyc2VUaW1lcywgY3R4KTtcXG4gICAgaWYgKCFpc1N0cmluZyhyZXQpKSB7XFxuICAgICAgcmV0ID0gZm9ybWF0VmFsdWUoY3R4LCByZXQsIHJlY3Vyc2VUaW1lcyk7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJldDtcXG4gIH1cXG5cXG4gIC8vIFByaW1pdGl2ZSB0eXBlcyBjYW5ub3QgaGF2ZSBwcm9wZXJ0aWVzXFxuICB2YXIgcHJpbWl0aXZlID0gZm9ybWF0UHJpbWl0aXZlKGN0eCwgdmFsdWUpO1xcbiAgaWYgKHByaW1pdGl2ZSkge1xcbiAgICByZXR1cm4gcHJpbWl0aXZlO1xcbiAgfVxcblxcbiAgLy8gTG9vayB1cCB0aGUga2V5cyBvZiB0aGUgb2JqZWN0LlxcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyh2YWx1ZSk7XFxuICB2YXIgdmlzaWJsZUtleXMgPSBhcnJheVRvSGFzaChrZXlzKTtcXG5cXG4gIGlmIChjdHguc2hvd0hpZGRlbikge1xcbiAgICBrZXlzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXModmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gSUUgZG9lc24ndCBtYWtlIGVycm9yIGZpZWxkcyBub24tZW51bWVyYWJsZVxcbiAgLy8gaHR0cDovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L2llL2R3dzUyc2J0KHY9dnMuOTQpLmFzcHhcXG4gIGlmIChpc0Vycm9yKHZhbHVlKVxcbiAgICAgICYmIChrZXlzLmluZGV4T2YoJ21lc3NhZ2UnKSA+PSAwIHx8IGtleXMuaW5kZXhPZignZGVzY3JpcHRpb24nKSA+PSAwKSkge1xcbiAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgfVxcblxcbiAgLy8gU29tZSB0eXBlIG9mIG9iamVjdCB3aXRob3V0IHByb3BlcnRpZXMgY2FuIGJlIHNob3J0Y3V0dGVkLlxcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwKSB7XFxuICAgIGlmIChpc0Z1bmN0aW9uKHZhbHVlKSkge1xcbiAgICAgIHZhciBuYW1lID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbRnVuY3Rpb24nICsgbmFtZSArICddJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNSZWdFeHAodmFsdWUpKSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSksICdyZWdleHAnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNEYXRlKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShEYXRlLnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKSwgJ2RhdGUnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNFcnJvcih2YWx1ZSkpIHtcXG4gICAgICByZXR1cm4gZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgYmFzZSA9ICcnLCBhcnJheSA9IGZhbHNlLCBicmFjZXMgPSBbJ3snLCAnfSddO1xcblxcbiAgLy8gTWFrZSBBcnJheSBzYXkgdGhhdCB0aGV5IGFyZSBBcnJheVxcbiAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgIGFycmF5ID0gdHJ1ZTtcXG4gICAgYnJhY2VzID0gWydbJywgJ10nXTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZnVuY3Rpb25zIHNheSB0aGF0IHRoZXkgYXJlIGZ1bmN0aW9uc1xcbiAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XFxuICAgIHZhciBuID0gdmFsdWUubmFtZSA/ICc6ICcgKyB2YWx1ZS5uYW1lIDogJyc7XFxuICAgIGJhc2UgPSAnIFtGdW5jdGlvbicgKyBuICsgJ10nO1xcbiAgfVxcblxcbiAgLy8gTWFrZSBSZWdFeHBzIHNheSB0aGF0IHRoZXkgYXJlIFJlZ0V4cHNcXG4gIGlmIChpc1JlZ0V4cCh2YWx1ZSkpIHtcXG4gICAgYmFzZSA9ICcgJyArIFJlZ0V4cC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XFxuICB9XFxuXFxuICAvLyBNYWtlIGRhdGVzIHdpdGggcHJvcGVydGllcyBmaXJzdCBzYXkgdGhlIGRhdGVcXG4gIGlmIChpc0RhdGUodmFsdWUpKSB7XFxuICAgIGJhc2UgPSAnICcgKyBEYXRlLnByb3RvdHlwZS50b1VUQ1N0cmluZy5jYWxsKHZhbHVlKTtcXG4gIH1cXG5cXG4gIC8vIE1ha2UgZXJyb3Igd2l0aCBtZXNzYWdlIGZpcnN0IHNheSB0aGUgZXJyb3JcXG4gIGlmIChpc0Vycm9yKHZhbHVlKSkge1xcbiAgICBiYXNlID0gJyAnICsgZm9ybWF0RXJyb3IodmFsdWUpO1xcbiAgfVxcblxcbiAgaWYgKGtleXMubGVuZ3RoID09PSAwICYmICghYXJyYXkgfHwgdmFsdWUubGVuZ3RoID09IDApKSB7XFxuICAgIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgYnJhY2VzWzFdO1xcbiAgfVxcblxcbiAgaWYgKHJlY3Vyc2VUaW1lcyA8IDApIHtcXG4gICAgaWYgKGlzUmVnRXhwKHZhbHVlKSkge1xcbiAgICAgIHJldHVybiBjdHguc3R5bGl6ZShSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpLCAncmVnZXhwJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgcmV0dXJuIGN0eC5zdHlsaXplKCdbT2JqZWN0XScsICdzcGVjaWFsJyk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIGN0eC5zZWVuLnB1c2godmFsdWUpO1xcblxcbiAgdmFyIG91dHB1dDtcXG4gIGlmIChhcnJheSkge1xcbiAgICBvdXRwdXQgPSBmb3JtYXRBcnJheShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXlzKTtcXG4gIH0gZWxzZSB7XFxuICAgIG91dHB1dCA9IGtleXMubWFwKGZ1bmN0aW9uKGtleSkge1xcbiAgICAgIHJldHVybiBmb3JtYXRQcm9wZXJ0eShjdHgsIHZhbHVlLCByZWN1cnNlVGltZXMsIHZpc2libGVLZXlzLCBrZXksIGFycmF5KTtcXG4gICAgfSk7XFxuICB9XFxuXFxuICBjdHguc2Vlbi5wb3AoKTtcXG5cXG4gIHJldHVybiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcyk7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFByaW1pdGl2ZShjdHgsIHZhbHVlKSB7XFxuICBpZiAoaXNVbmRlZmluZWQodmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJ3VuZGVmaW5lZCcsICd1bmRlZmluZWQnKTtcXG4gIGlmIChpc1N0cmluZyh2YWx1ZSkpIHtcXG4gICAgdmFyIHNpbXBsZSA9ICdcXFxcJycgKyBKU09OLnN0cmluZ2lmeSh2YWx1ZSkucmVwbGFjZSgvXlxcXCJ8XFxcIiQvZywgJycpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoLycvZywgXFxcIlxcXFxcXFxcJ1xcXCIpXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLnJlcGxhY2UoL1xcXFxcXFxcXFxcIi9nLCAnXFxcIicpICsgJ1xcXFwnJztcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKHNpbXBsZSwgJ3N0cmluZycpO1xcbiAgfVxcbiAgaWYgKGlzTnVtYmVyKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCcnICsgdmFsdWUsICdudW1iZXInKTtcXG4gIGlmIChpc0Jvb2xlYW4odmFsdWUpKVxcbiAgICByZXR1cm4gY3R4LnN0eWxpemUoJycgKyB2YWx1ZSwgJ2Jvb2xlYW4nKTtcXG4gIC8vIEZvciBzb21lIHJlYXNvbiB0eXBlb2YgbnVsbCBpcyBcXFwib2JqZWN0XFxcIiwgc28gc3BlY2lhbCBjYXNlIGhlcmUuXFxuICBpZiAoaXNOdWxsKHZhbHVlKSlcXG4gICAgcmV0dXJuIGN0eC5zdHlsaXplKCdudWxsJywgJ251bGwnKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gZm9ybWF0RXJyb3IodmFsdWUpIHtcXG4gIHJldHVybiAnWycgKyBFcnJvci5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgKyAnXSc7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdEFycmF5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleXMpIHtcXG4gIHZhciBvdXRwdXQgPSBbXTtcXG4gIGZvciAodmFyIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgKytpKSB7XFxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eSh2YWx1ZSwgU3RyaW5nKGkpKSkge1xcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXFxuICAgICAgICAgIFN0cmluZyhpKSwgdHJ1ZSkpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG91dHB1dC5wdXNoKCcnKTtcXG4gICAgfVxcbiAgfVxcbiAga2V5cy5mb3JFYWNoKGZ1bmN0aW9uKGtleSkge1xcbiAgICBpZiAoIWtleS5tYXRjaCgvXlxcXFxkKyQvKSkge1xcbiAgICAgIG91dHB1dC5wdXNoKGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsXFxuICAgICAgICAgIGtleSwgdHJ1ZSkpO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiBvdXRwdXQ7XFxufVxcblxcblxcbmZ1bmN0aW9uIGZvcm1hdFByb3BlcnR5KGN0eCwgdmFsdWUsIHJlY3Vyc2VUaW1lcywgdmlzaWJsZUtleXMsIGtleSwgYXJyYXkpIHtcXG4gIHZhciBuYW1lLCBzdHIsIGRlc2M7XFxuICBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih2YWx1ZSwga2V5KSB8fCB7IHZhbHVlOiB2YWx1ZVtrZXldIH07XFxuICBpZiAoZGVzYy5nZXQpIHtcXG4gICAgaWYgKGRlc2Muc2V0KSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXIvU2V0dGVyXScsICdzcGVjaWFsJyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tHZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgaWYgKGRlc2Muc2V0KSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tTZXR0ZXJdJywgJ3NwZWNpYWwnKTtcXG4gICAgfVxcbiAgfVxcbiAgaWYgKCFoYXNPd25Qcm9wZXJ0eSh2aXNpYmxlS2V5cywga2V5KSkge1xcbiAgICBuYW1lID0gJ1snICsga2V5ICsgJ10nO1xcbiAgfVxcbiAgaWYgKCFzdHIpIHtcXG4gICAgaWYgKGN0eC5zZWVuLmluZGV4T2YoZGVzYy52YWx1ZSkgPCAwKSB7XFxuICAgICAgaWYgKGlzTnVsbChyZWN1cnNlVGltZXMpKSB7XFxuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIG51bGwpO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICBzdHIgPSBmb3JtYXRWYWx1ZShjdHgsIGRlc2MudmFsdWUsIHJlY3Vyc2VUaW1lcyAtIDEpO1xcbiAgICAgIH1cXG4gICAgICBpZiAoc3RyLmluZGV4T2YoJ1xcXFxuJykgPiAtMSkge1xcbiAgICAgICAgaWYgKGFycmF5KSB7XFxuICAgICAgICAgIHN0ciA9IHN0ci5zcGxpdCgnXFxcXG4nKS5tYXAoZnVuY3Rpb24obGluZSkge1xcbiAgICAgICAgICAgIHJldHVybiAnICAnICsgbGluZTtcXG4gICAgICAgICAgfSkuam9pbignXFxcXG4nKS5zdWJzdHIoMik7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICBzdHIgPSAnXFxcXG4nICsgc3RyLnNwbGl0KCdcXFxcbicpLm1hcChmdW5jdGlvbihsaW5lKSB7XFxuICAgICAgICAgICAgcmV0dXJuICcgICAnICsgbGluZTtcXG4gICAgICAgICAgfSkuam9pbignXFxcXG4nKTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH0gZWxzZSB7XFxuICAgICAgc3RyID0gY3R4LnN0eWxpemUoJ1tDaXJjdWxhcl0nLCAnc3BlY2lhbCcpO1xcbiAgICB9XFxuICB9XFxuICBpZiAoaXNVbmRlZmluZWQobmFtZSkpIHtcXG4gICAgaWYgKGFycmF5ICYmIGtleS5tYXRjaCgvXlxcXFxkKyQvKSkge1xcbiAgICAgIHJldHVybiBzdHI7XFxuICAgIH1cXG4gICAgbmFtZSA9IEpTT04uc3RyaW5naWZ5KCcnICsga2V5KTtcXG4gICAgaWYgKG5hbWUubWF0Y2goL15cXFwiKFthLXpBLVpfXVthLXpBLVpfMC05XSopXFxcIiQvKSkge1xcbiAgICAgIG5hbWUgPSBuYW1lLnN1YnN0cigxLCBuYW1lLmxlbmd0aCAtIDIpO1xcbiAgICAgIG5hbWUgPSBjdHguc3R5bGl6ZShuYW1lLCAnbmFtZScpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIG5hbWUgPSBuYW1lLnJlcGxhY2UoLycvZywgXFxcIlxcXFxcXFxcJ1xcXCIpXFxuICAgICAgICAgICAgICAgICAucmVwbGFjZSgvXFxcXFxcXFxcXFwiL2csICdcXFwiJylcXG4gICAgICAgICAgICAgICAgIC5yZXBsYWNlKC8oXlxcXCJ8XFxcIiQpL2csIFxcXCInXFxcIik7XFxuICAgICAgbmFtZSA9IGN0eC5zdHlsaXplKG5hbWUsICdzdHJpbmcnKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgcmV0dXJuIG5hbWUgKyAnOiAnICsgc3RyO1xcbn1cXG5cXG5cXG5mdW5jdGlvbiByZWR1Y2VUb1NpbmdsZVN0cmluZyhvdXRwdXQsIGJhc2UsIGJyYWNlcykge1xcbiAgdmFyIG51bUxpbmVzRXN0ID0gMDtcXG4gIHZhciBsZW5ndGggPSBvdXRwdXQucmVkdWNlKGZ1bmN0aW9uKHByZXYsIGN1cikge1xcbiAgICBudW1MaW5lc0VzdCsrO1xcbiAgICBpZiAoY3VyLmluZGV4T2YoJ1xcXFxuJykgPj0gMCkgbnVtTGluZXNFc3QrKztcXG4gICAgcmV0dXJuIHByZXYgKyBjdXIucmVwbGFjZSgvXFxcXHUwMDFiXFxcXFtcXFxcZFxcXFxkP20vZywgJycpLmxlbmd0aCArIDE7XFxuICB9LCAwKTtcXG5cXG4gIGlmIChsZW5ndGggPiA2MCkge1xcbiAgICByZXR1cm4gYnJhY2VzWzBdICtcXG4gICAgICAgICAgIChiYXNlID09PSAnJyA/ICcnIDogYmFzZSArICdcXFxcbiAnKSArXFxuICAgICAgICAgICAnICcgK1xcbiAgICAgICAgICAgb3V0cHV0LmpvaW4oJyxcXFxcbiAgJykgK1xcbiAgICAgICAgICAgJyAnICtcXG4gICAgICAgICAgIGJyYWNlc1sxXTtcXG4gIH1cXG5cXG4gIHJldHVybiBicmFjZXNbMF0gKyBiYXNlICsgJyAnICsgb3V0cHV0LmpvaW4oJywgJykgKyAnICcgKyBicmFjZXNbMV07XFxufVxcblxcblxcbi8vIE5PVEU6IFRoZXNlIHR5cGUgY2hlY2tpbmcgZnVuY3Rpb25zIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIGBpbnN0YW5jZW9mYFxcbi8vIGJlY2F1c2UgaXQgaXMgZnJhZ2lsZSBhbmQgY2FuIGJlIGVhc2lseSBmYWtlZCB3aXRoIGBPYmplY3QuY3JlYXRlKClgLlxcbmZ1bmN0aW9uIGlzQXJyYXkoYXIpIHtcXG4gIHJldHVybiBBcnJheS5pc0FycmF5KGFyKTtcXG59XFxuZXhwb3J0cy5pc0FycmF5ID0gaXNBcnJheTtcXG5cXG5mdW5jdGlvbiBpc0Jvb2xlYW4oYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nO1xcbn1cXG5leHBvcnRzLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcXG5cXG5mdW5jdGlvbiBpc051bGwoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsO1xcbn1cXG5leHBvcnRzLmlzTnVsbCA9IGlzTnVsbDtcXG5cXG5mdW5jdGlvbiBpc051bGxPclVuZGVmaW5lZChhcmcpIHtcXG4gIHJldHVybiBhcmcgPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc051bGxPclVuZGVmaW5lZCA9IGlzTnVsbE9yVW5kZWZpbmVkO1xcblxcbmZ1bmN0aW9uIGlzTnVtYmVyKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdudW1iZXInO1xcbn1cXG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XFxuXFxuZnVuY3Rpb24gaXNTdHJpbmcoYXJnKSB7XFxuICByZXR1cm4gdHlwZW9mIGFyZyA9PT0gJ3N0cmluZyc7XFxufVxcbmV4cG9ydHMuaXNTdHJpbmcgPSBpc1N0cmluZztcXG5cXG5mdW5jdGlvbiBpc1N5bWJvbChhcmcpIHtcXG4gIHJldHVybiB0eXBlb2YgYXJnID09PSAnc3ltYm9sJztcXG59XFxuZXhwb3J0cy5pc1N5bWJvbCA9IGlzU3ltYm9sO1xcblxcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKGFyZykge1xcbiAgcmV0dXJuIGFyZyA9PT0gdm9pZCAwO1xcbn1cXG5leHBvcnRzLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XFxuXFxuZnVuY3Rpb24gaXNSZWdFeHAocmUpIHtcXG4gIHJldHVybiBpc09iamVjdChyZSkgJiYgb2JqZWN0VG9TdHJpbmcocmUpID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59XFxuZXhwb3J0cy5pc1JlZ0V4cCA9IGlzUmVnRXhwO1xcblxcbmZ1bmN0aW9uIGlzT2JqZWN0KGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnICYmIGFyZyAhPT0gbnVsbDtcXG59XFxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xcblxcbmZ1bmN0aW9uIGlzRGF0ZShkKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZCkgJiYgb2JqZWN0VG9TdHJpbmcoZCkgPT09ICdbb2JqZWN0IERhdGVdJztcXG59XFxuZXhwb3J0cy5pc0RhdGUgPSBpc0RhdGU7XFxuXFxuZnVuY3Rpb24gaXNFcnJvcihlKSB7XFxuICByZXR1cm4gaXNPYmplY3QoZSkgJiZcXG4gICAgICAob2JqZWN0VG9TdHJpbmcoZSkgPT09ICdbb2JqZWN0IEVycm9yXScgfHwgZSBpbnN0YW5jZW9mIEVycm9yKTtcXG59XFxuZXhwb3J0cy5pc0Vycm9yID0gaXNFcnJvcjtcXG5cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGFyZykge1xcbiAgcmV0dXJuIHR5cGVvZiBhcmcgPT09ICdmdW5jdGlvbic7XFxufVxcbmV4cG9ydHMuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XFxuXFxuZnVuY3Rpb24gaXNQcmltaXRpdmUoYXJnKSB7XFxuICByZXR1cm4gYXJnID09PSBudWxsIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ2Jvb2xlYW4nIHx8XFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ251bWJlcicgfHxcXG4gICAgICAgICB0eXBlb2YgYXJnID09PSAnc3RyaW5nJyB8fFxcbiAgICAgICAgIHR5cGVvZiBhcmcgPT09ICdzeW1ib2wnIHx8ICAvLyBFUzYgc3ltYm9sXFxuICAgICAgICAgdHlwZW9mIGFyZyA9PT0gJ3VuZGVmaW5lZCc7XFxufVxcbmV4cG9ydHMuaXNQcmltaXRpdmUgPSBpc1ByaW1pdGl2ZTtcXG5cXG5leHBvcnRzLmlzQnVmZmVyID0gcmVxdWlyZSgnLi9zdXBwb3J0L2lzQnVmZmVyJyk7XFxuXFxuZnVuY3Rpb24gb2JqZWN0VG9TdHJpbmcobykge1xcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKTtcXG59XFxuXFxuXFxuZnVuY3Rpb24gcGFkKG4pIHtcXG4gIHJldHVybiBuIDwgMTAgPyAnMCcgKyBuLnRvU3RyaW5nKDEwKSA6IG4udG9TdHJpbmcoMTApO1xcbn1cXG5cXG5cXG52YXIgbW9udGhzID0gWydKYW4nLCAnRmViJywgJ01hcicsICdBcHInLCAnTWF5JywgJ0p1bicsICdKdWwnLCAnQXVnJywgJ1NlcCcsXFxuICAgICAgICAgICAgICAnT2N0JywgJ05vdicsICdEZWMnXTtcXG5cXG4vLyAyNiBGZWIgMTY6MTk6MzRcXG5mdW5jdGlvbiB0aW1lc3RhbXAoKSB7XFxuICB2YXIgZCA9IG5ldyBEYXRlKCk7XFxuICB2YXIgdGltZSA9IFtwYWQoZC5nZXRIb3VycygpKSxcXG4gICAgICAgICAgICAgIHBhZChkLmdldE1pbnV0ZXMoKSksXFxuICAgICAgICAgICAgICBwYWQoZC5nZXRTZWNvbmRzKCkpXS5qb2luKCc6Jyk7XFxuICByZXR1cm4gW2QuZ2V0RGF0ZSgpLCBtb250aHNbZC5nZXRNb250aCgpXSwgdGltZV0uam9pbignICcpO1xcbn1cXG5cXG5cXG4vLyBsb2cgaXMganVzdCBhIHRoaW4gd3JhcHBlciB0byBjb25zb2xlLmxvZyB0aGF0IHByZXBlbmRzIGEgdGltZXN0YW1wXFxuZXhwb3J0cy5sb2cgPSBmdW5jdGlvbigpIHtcXG4gIGNvbnNvbGUubG9nKCclcyAtICVzJywgdGltZXN0YW1wKCksIGV4cG9ydHMuZm9ybWF0LmFwcGx5KGV4cG9ydHMsIGFyZ3VtZW50cykpO1xcbn07XFxuXFxuXFxuLyoqXFxuICogSW5oZXJpdCB0aGUgcHJvdG90eXBlIG1ldGhvZHMgZnJvbSBvbmUgY29uc3RydWN0b3IgaW50byBhbm90aGVyLlxcbiAqXFxuICogVGhlIEZ1bmN0aW9uLnByb3RvdHlwZS5pbmhlcml0cyBmcm9tIGxhbmcuanMgcmV3cml0dGVuIGFzIGEgc3RhbmRhbG9uZVxcbiAqIGZ1bmN0aW9uIChub3Qgb24gRnVuY3Rpb24ucHJvdG90eXBlKS4gTk9URTogSWYgdGhpcyBmaWxlIGlzIHRvIGJlIGxvYWRlZFxcbiAqIGR1cmluZyBib290c3RyYXBwaW5nIHRoaXMgZnVuY3Rpb24gbmVlZHMgdG8gYmUgcmV3cml0dGVuIHVzaW5nIHNvbWUgbmF0aXZlXFxuICogZnVuY3Rpb25zIGFzIHByb3RvdHlwZSBzZXR1cCB1c2luZyBub3JtYWwgSmF2YVNjcmlwdCBkb2VzIG5vdCB3b3JrIGFzXFxuICogZXhwZWN0ZWQgZHVyaW5nIGJvb3RzdHJhcHBpbmcgKHNlZSBtaXJyb3IuanMgaW4gcjExNDkwMykuXFxuICpcXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBjdG9yIENvbnN0cnVjdG9yIGZ1bmN0aW9uIHdoaWNoIG5lZWRzIHRvIGluaGVyaXQgdGhlXFxuICogICAgIHByb3RvdHlwZS5cXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufSBzdXBlckN0b3IgQ29uc3RydWN0b3IgZnVuY3Rpb24gdG8gaW5oZXJpdCBwcm90b3R5cGUgZnJvbS5cXG4gKi9cXG5leHBvcnRzLmluaGVyaXRzID0gcmVxdWlyZSgnaW5oZXJpdHMnKTtcXG5cXG5leHBvcnRzLl9leHRlbmQgPSBmdW5jdGlvbihvcmlnaW4sIGFkZCkge1xcbiAgLy8gRG9uJ3QgZG8gYW55dGhpbmcgaWYgYWRkIGlzbid0IGFuIG9iamVjdFxcbiAgaWYgKCFhZGQgfHwgIWlzT2JqZWN0KGFkZCkpIHJldHVybiBvcmlnaW47XFxuXFxuICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGFkZCk7XFxuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSkge1xcbiAgICBvcmlnaW5ba2V5c1tpXV0gPSBhZGRba2V5c1tpXV07XFxuICB9XFxuICByZXR1cm4gb3JpZ2luO1xcbn07XFxuXFxuZnVuY3Rpb24gaGFzT3duUHJvcGVydHkob2JqLCBwcm9wKSB7XFxuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgcHJvcCk7XFxufVxcblxcbn0pLmNhbGwodGhpcyxyZXF1aXJlKCdfcHJvY2VzcycpLHR5cGVvZiBnbG9iYWwgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gZ2xvYmFsIDogdHlwZW9mIHNlbGYgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gc2VsZiA6IHR5cGVvZiB3aW5kb3cgIT09IFxcXCJ1bmRlZmluZWRcXFwiID8gd2luZG93IDoge30pXFxufSx7XFxcIi4vc3VwcG9ydC9pc0J1ZmZlclxcXCI6NzUsXFxcIl9wcm9jZXNzXFxcIjo1NixcXFwiaW5oZXJpdHNcXFwiOjc0fV19LHt9LFsxXSk7XFxuXCIiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihzcmMpIHtcblx0ZnVuY3Rpb24gbG9nKGVycm9yKSB7XG5cdFx0KHR5cGVvZiBjb25zb2xlICE9PSBcInVuZGVmaW5lZFwiKVxuXHRcdCYmIChjb25zb2xlLmVycm9yIHx8IGNvbnNvbGUubG9nKShcIltTY3JpcHQgTG9hZGVyXVwiLCBlcnJvcik7XG5cdH1cblxuXHQvLyBDaGVjayBmb3IgSUUgPTwgOFxuXHRmdW5jdGlvbiBpc0lFKCkge1xuXHRcdHJldHVybiB0eXBlb2YgYXR0YWNoRXZlbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGFkZEV2ZW50TGlzdGVuZXIgPT09IFwidW5kZWZpbmVkXCI7XG5cdH1cblxuXHR0cnkge1xuXHRcdGlmICh0eXBlb2YgZXhlY1NjcmlwdCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBpc0lFKCkpIHtcblx0XHRcdGV4ZWNTY3JpcHQoc3JjKTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBldmFsICE9PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRldmFsLmNhbGwobnVsbCwgc3JjKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bG9nKFwiRXZhbEVycm9yOiBObyBldmFsIGZ1bmN0aW9uIGF2YWlsYWJsZVwiKTtcblx0XHR9XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0bG9nKGVycm9yKTtcblx0fVxufVxuIiwicmVxdWlyZShcIiEhL1VzZXJzL21lZ2FuL3R1cmluZy9tb2QyL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvc2NyaXB0LWxvYWRlci9hZGRTY3JpcHQuanNcIikocmVxdWlyZShcIiEhL1VzZXJzL21lZ2FuL3R1cmluZy9tb2QyL2dhbWUtdGltZS9ub2RlX21vZHVsZXMvcmF3LWxvYWRlci9pbmRleC5qcyEvVXNlcnMvbWVnYW4vdHVyaW5nL21vZDIvZ2FtZS10aW1lL25vZGVfbW9kdWxlcy9tb2NoYS9tb2NoYS5qc1wiKSkiXSwic291cmNlUm9vdCI6IiJ9